{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Albumentations documentation","text":"<p>Albumentations is a fast and flexible image augmentation library. The library is widely used in industry, deep learning research, machine learning competitions, and open source projects. Albumentations is written in Python, and it is licensed under the MIT license. The source code is available at https://github.com/albumentations-team/albumentations.</p> <p>If you are new to image augmentation, start with articles in the \"Introduction to image augmentation\" section. They describe what image augmentation is, how it can boost deep neural networks' performance, and why you should use Albumentations.</p> <p>Articles in the \"Getting started with Albumentations\" section show how you can use the library for different computer vision tasks: image classification, semantic segmentation, instance segmentation, and object detection, keypoint detection.</p> <p>The \"Examples\" section contains Jupyter Notebooks that demonstrate how to use various features of Albumentations. Each notebook includes a link to Google Colab, where you can run the code by yourself.</p> <p>\"API Reference\" contains the description of Albumentations' methods and classes.</p>"},{"location":"#introduction-to-image-augmentation","title":"Introduction to image augmentation","text":"<ul> <li>What is image augmentation and how it can improve the performance of deep neural networks</li> <li>Why you need a dedicated library for image augmentation</li> <li>Why Albumentations</li> </ul>"},{"location":"#getting-started-with-albumentations","title":"Getting started with Albumentations","text":"<ul> <li>Installation</li> <li>Image augmentation for classification</li> <li>Mask augmentation for segmentation</li> <li>Bounding boxes augmentation for object detection</li> <li>Keypoints augmentation</li> <li>Simultaneous augmentation of multiple targets: masks, bounding boxes, keypoints</li> <li>A list of transforms and their supported targets</li> <li>Setting probabilities for transforms in an augmentation pipeline </li> </ul>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Defining a simple augmentation pipeline for image augmentation</li> <li>Working with non-8-bit images</li> <li>Using Albumentations to augment bounding boxes for object detection tasks</li> <li>How to use Albumentations for detection tasks if you need to keep all bounding boxes</li> <li>Using Albumentations for a semantic segmentation task</li> <li>Using Albumentations to augment keypoints</li> <li>Applying the same augmentation with the same parameters to multiple images, masks, bounding boxes, or keypoints</li> <li>Weather augmentations in Albumentations</li> <li>Example of applying XYMasking transform</li> <li>Example of applying MixUp transform</li> <li>Example of applying ChromaticAberration transform</li> <li>Example of applying Morphological transform</li> <li>Migrating from torchvision to Albumentations</li> <li>Debugging an augmentation pipeline with ReplayCompose</li> <li>How to save and load parameters of an augmentation pipeline</li> <li>Showcase. Cool augmentation examples on diverse set of images from various real-world tasks.</li> </ul>"},{"location":"#examples-of-how-to-use-albumentations-with-different-deep-learning-frameworks","title":"Examples of how to use Albumentations with different deep learning frameworks","text":"<ul> <li>PyTorch</li> <li>PyTorch and Albumentations for image classification</li> <li>PyTorch and Albumentations for semantic segmentation</li> <li>TensorFlow 2</li> <li>Using Albumentations with Tensorflow</li> </ul>"},{"location":"#external-resources","title":"External resources","text":"<ul> <li>Blog posts, podcasts, talks, and videos about Albumentations</li> <li>Books that mention Albumentations</li> <li>Online courses that cover Albumentations</li> </ul>"},{"location":"#other-topics","title":"Other topics","text":"<ul> <li>Frequently Asked Questions</li> <li>Release notes</li> <li>Contributing</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Full API Reference on a single page</li> <li>Index</li> <li>Core API (albumentations.core)</li> <li>Augmentations (albumentations.augmentations)</li> <li>PyTorch Helpers (albumentations.pytorch)</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing to Albumentations","text":"<p>Thank you for your interest in contributing to Albumentations! This guide is designed to make it easier for you to get involved and help us build a powerful, efficient, and easy-to-use image augmentation library.</p> <p>For small changes (e.g., bug fixes), feel free to submit a PR.</p> <p>For larger changes, consider creating an issue outlining your proposed change. You can also join us on Discord to discuss your idea with the community.</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":""},{"location":"CONTRIBUTING/#fork-and-clone-the-repository","title":"Fork and clone the repository","text":"<p>Start by forking the project repository to your GitHub account, then clone your fork to your local machine:</p> Bash<pre><code>git clone https://github.com/albumentations/albumentations.git\ncd albumentations\n</code></pre>"},{"location":"CONTRIBUTING/#create-a-virtual-environment","title":"Create a virtual environment","text":"<p>We recommend using a virtual environment to isolate project dependencies. Ensure you have Python 3.8 or higher installed on your machine, as it is the minimum supported version for Albumentations. To create and activate a virtual environment, run the following commands:</p>"},{"location":"CONTRIBUTING/#linux-macos","title":"Linux / macOS","text":"Bash<pre><code>python3 -m venv env\nsource env/bin/activate\n</code></pre>"},{"location":"CONTRIBUTING/#windows-cmdexe","title":"Windows cmd.exe","text":"Bash<pre><code>python -m venv env\nenv\\Scripts\\activate.bat\n</code></pre>"},{"location":"CONTRIBUTING/#windows-powershell","title":"Windows PowerShell","text":"Bash<pre><code>python -m venv env\nenv\\Scripts\\activate.ps1\n</code></pre>"},{"location":"CONTRIBUTING/#install-development-dependencies","title":"Install development dependencies","text":"<p>Install the project's dependencies by running:</p> Bash<pre><code>pip install -e .\n</code></pre> <p>Additionally, to ensure you have all the necessary tools for code formatting, linting, and additional development utilities, install the requirements from <code>requirements-dev.txt</code>:</p> Bash<pre><code>pip install -r requirements-dev.txt\n</code></pre>"},{"location":"CONTRIBUTING/#navigating-the-project","title":"Navigating the Project","text":"<ul> <li>The main source code is located in the <code>albumentations/</code> directory.</li> <li>Tests are located in the <code>tests/</code> directory. Every pull request should include tests for new features or bug fixes.</li> </ul>"},{"location":"CONTRIBUTING/#how-to-contribute","title":"How to Contribute","text":""},{"location":"CONTRIBUTING/#types-of-contributions","title":"Types of Contributions","text":"<ul> <li>Code Contributions: Whether it's fixing a bug, adding a new feature, or improving performance, your code contributions are valuable.</li> <li>Documentation: Help us improve the project's documentation for better usability and accessibility.</li> <li>Bug Reports and Feature Requests: Use GitHub Issues to report bugs, request features, or suggest improvements.</li> </ul>"},{"location":"CONTRIBUTING/#contribution-process","title":"Contribution Process","text":"<ol> <li>Find an issue to work on: Look for open issues or propose a new one. For newcomers, look for issues labeled \"good first issue.\"</li> <li>Fork the repository (if you haven't already).</li> <li>Create a new branch for your changes: <code>git checkout -b feature/my-new-feature</code>.</li> <li>Implement your changes: Write clean, readable, and well-documented code. Note that we do not use np.random module directly but call corresponding functions from the albumentations/random_utils.py module to ensure consistency and control over randomness.</li> <li>Add or update tests as necessary.</li> <li>Ensure all tests pass and your code adheres to the existing style guidelines.</li> <li>Submit a Pull Request (PR): Open a PR from your forked repository to the main Albumentations repository. Provide a clear description of the changes and any relevant issue numbers.</li> </ol>"},{"location":"CONTRIBUTING/#code-review-process","title":"Code Review Process","text":"<ul> <li>Once you submit a PR, the Albumentations maintainers will review your contribution.</li> <li>Engage in the review process if the maintainers have feedback or questions.</li> <li>Once your PR is approved, a maintainer will merge it into the main codebase.</li> </ul>"},{"location":"CONTRIBUTING/#coding-guidelines","title":"Coding Guidelines","text":""},{"location":"CONTRIBUTING/#using-pre-commit-hooks","title":"Using Pre-commit Hooks","text":"<p>To maintain code quality and consistency, we use pre-commit hooks. Follow these steps to set up pre-commit hooks in your local repository:</p> <p>Install pre-commit: If you haven't already, you need to install pre-commit on your machine. You can do this using pip:</p> Bash<pre><code>pip install pre-commit\n</code></pre> <p>Initialize pre-commit:</p> <p>Navigate to the root of your cloned repository and run:</p> Bash<pre><code>pre-commit install\n</code></pre> <p>This command sets up the pre-commit hooks based on the configurations found in <code>.pre-commit-config.yaml</code> at the root of the repository.</p> <p>Running pre-commit hooks:</p> <p>Pre-commit will automatically run the configured hooks on each commit. You can also manually run the hooks on all files in the repository with:</p> Bash<pre><code>pre-commit run --all-files\n</code></pre> <p>Ensure to fix any issues detected by the pre-commit hooks before submitting your pull request.</p>"},{"location":"CONTRIBUTING/#running-tests","title":"Running Tests","text":"<p>Before submitting your contributions, it's important to ensure that all tests pass. This helps maintain the stability and reliability of Albumentations. Here's how you can run the tests:</p> <p>Install test dependencies:</p> <p>If you haven't installed the development dependencies, make sure to do so. These dependencies include <code>pytest</code>, which is required to run the tests.</p> Bash<pre><code>pip install -e .\n</code></pre> Bash<pre><code>pip install -r requirements-dev.txt\n</code></pre> <p>Run the tests:</p> <p>With <code>pytest</code> installed, you can run all tests using the following command from the root of the repository:</p> Bash<pre><code>pytest\n</code></pre> <p>This will execute all the tests and display the results, indicating whether each test passed or failed.</p> <p>Tip: If you've made changes to a specific area of the library, you can run a subset of the tests related to your changes. This can save time and make it easier to debug issues. Use the <code>pytest</code> documentation to learn more about running specific tests.</p>"},{"location":"CONTRIBUTING/#ensuring-your-contribution-is-ready","title":"Ensuring Your Contribution is Ready","text":"<ul> <li>After setting up pre-commit hooks and ensuring all tests pass, your contribution is nearly ready for submission.</li> <li>Review your changes one last time, ensuring they meet the project's coding guidelines and documentation standards.</li> <li>If your changes affect how users interact with Albumentations, update the documentation accordingly.</li> </ul> <p>By following these guidelines, you help ensure that Albumentations remains a high-quality, reliable library. We appreciate your contributions and look forward to your pull request!</p>"},{"location":"CONTRIBUTING/#additional-resources","title":"Additional Resources","text":"<p>Albumentations Documentation</p>"},{"location":"CONTRIBUTING/#acknowledgements","title":"Acknowledgements","text":"<p>Your contributions are appreciated and recognized. Contributors who have significantly impacted the project will be mentioned in our documentation and releases.</p>"},{"location":"CONTRIBUTING/#contact-information","title":"Contact Information","text":"<p>For any questions or concerns about contributing, please reach out to the maintainers via GitHub Issues.</p>"},{"location":"benchmarking_results/","title":"Benchmarking results","text":""},{"location":"benchmarking_results/#benchmarking-results_1","title":"Benchmarking results","text":"<p>To run the benchmark yourself, follow the instructions in benchmark/README.md</p> <p>Results for running the benchmark on the first 2000 images from the ImageNet validation set using an AMD Ryzen Threadripper 3970X CPU. The table shows how many images per second can be processed on a single core; higher is better.</p> Library Version Python 3.10.13 (main, Sep 11 2023, 13:44:35) [GCC 11.2.0] albumentations 1.4.1 imgaug 0.4.0 torchvision 0.17.1+rocm5.7 numpy 1.26.4 opencv-python-headless 4.9.0.80 scikit-image 0.22.0 scipy 1.12.0 pillow 10.2.0 kornia 0.7.2 augly 1.0.0 albumentations1.4.0 torchvision0.17.1+rocm5.7 kornia0.7.2 augly1.0.0 imgaug0.4.0 HorizontalFlip 9843 \u00b1 2135 2436 \u00b1 29 1014 \u00b1 3 3663 \u00b1 18 4884 \u00b1 51 VerticalFlip 9898 \u00b1 18 2570 \u00b1 37 1024 \u00b1 4 5325 \u00b1 13 8683 \u00b1 5 Rotate 610 \u00b1 4 153 \u00b1 2 204 \u00b1 1 626 \u00b1 3 499 \u00b1 5 Affine 1705 \u00b1 67 159 \u00b1 1 200 \u00b1 1 - 663 \u00b1 24 Equalize 1061 \u00b1 14 337 \u00b1 1 77 \u00b1 1 - 845 \u00b1 33 RandomCrop64 203197 \u00b1 2105 15931 \u00b1 27 837 \u00b1 2 21858 \u00b1 362 5681 \u00b1 96 RandomResizedCrop 2998 \u00b1 30 1160 \u00b1 4 190 \u00b1 1 - - ShiftRGB 1400 \u00b1 3 - 435 \u00b1 1 - 1528 \u00b1 6 Resize 2581 \u00b1 3 1239 \u00b1 1 197 \u00b1 1 431 \u00b1 1 1728 \u00b1 1 RandomGamma 4556 \u00b1 3 230 \u00b1 1 205 \u00b1 1 - 2282 \u00b1 110 Grayscale 7234 \u00b1 4 1539 \u00b1 7 444 \u00b1 3 2606 \u00b1 2 918 \u00b1 42 ColorJitter 452 \u00b1 43 51 \u00b1 1 50 \u00b1 1 221 \u00b1 1 - RandomPerspective 465 \u00b1 1 121 \u00b1 1 115 \u00b1 1 - 433 \u00b1 16 GaussianBlur 2315 \u00b1 9 106 \u00b1 2 72 \u00b1 1 161 \u00b1 1 1213 \u00b1 3 MedianBlur 3711 \u00b1 2 - 2 \u00b1 1 - 566 \u00b1 3 MotionBlur 2763 \u00b1 25 - 101 \u00b1 4 - 508 \u00b1 2 Posterize 4238 \u00b1 51 2581 \u00b1 20 284 \u00b1 4 - 1893 \u00b1 9 JpegCompression 208 \u00b1 1 - - 692 \u00b1 4 435 \u00b1 1 GaussianNoise 64 \u00b1 9 - - 67 \u00b1 1 212 \u00b1 16 Elastic 129 \u00b1 1 3 \u00b1 1 1 \u00b1 1 - 128 \u00b1 1"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#installation","title":"Installation","text":"<ul> <li>I am receiving an error message <code>Failed building wheel for imagecodecs</code> when I am trying to install Albumentations. How can I fix the problem?</li> <li>I successfully installed the library, but when I am trying to import it I receive an error <code>ImportError: libXrender.so.1: cannot open shared object file: No such file or directory</code>.</li> </ul>"},{"location":"faq/#examples","title":"Examples","text":"<ul> <li>Why do you call <code>cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</code> in your examples?</li> </ul>"},{"location":"faq/#usage","title":"Usage","text":"<ul> <li>Frequently Asked Questions</li> <li>Installation</li> <li>Examples</li> <li>Usage</li> <li>Installation<ul> <li>I am receiving an error message <code>Failed building wheel for imagecodecs</code> when I am trying to install Albumentations. How can I fix the problem?</li> <li>I successfully installed the library, but when I am trying to import it I receive an error <code>ImportError: libXrender.so.1: cannot open shared object file: No such file or directory</code>.</li> </ul> </li> <li>Examples<ul> <li>Why do you call <code>cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</code> in your examples?</li> </ul> </li> <li>Usage<ul> <li>How can I find which augmentations were applied to the input data and which parameters they used?</li> <li>My computer vision pipeline works with a sequence of images. I want to apply the same augmentations with the same parameters to each image in the sequence. Can Albumentations do it?</li> <li>I want to augment 16-bit TIFF images. Can Albumentations work with them?</li> <li>Augmentations have a parameter named <code>p</code> that sets the probability of applying that augmentation, but they also have the <code>always_apply</code> parameter that can either be <code>True</code> or <code>False</code>. What is the difference between <code>p</code> and <code>always_apply</code>? Is <code>always_apply=True</code> equals to <code>p=1.0</code>?</li> <li>When I use augmentations with the <code>border_mode</code> parameter (such as <code>Rotate</code>) and set <code>border_mode</code> to <code>cv2.BORDER_REFLECT</code> or <code>cv2.BORDER_REFLECT_101</code> Albumentations mirrors regions of images and masks but doesn't mirror bounding boxes and keypoints. Is it a bug?</li> <li>I created annotations for bounding boxes using labeling service or labeling software. How can I use those annotations in Albumentations?</li> </ul> </li> </ul>"},{"location":"faq/#installation_1","title":"Installation","text":""},{"location":"faq/#i-am-receiving-an-error-message-failed-building-wheel-for-imagecodecs-when-i-am-trying-to-install-albumentations-how-can-i-fix-the-problem","title":"I am receiving an error message <code>Failed building wheel for imagecodecs</code> when I am trying to install Albumentations. How can I fix the problem?","text":"<p>Try to update <code>pip</code> by running the following command:</p> Bash<pre><code>python3 -m pip install --upgrade pip\n</code></pre>"},{"location":"faq/#i-successfully-installed-the-library-but-when-i-am-trying-to-import-it-i-receive-an-error-importerror-libxrenderso1-cannot-open-shared-object-file-no-such-file-or-directory","title":"I successfully installed the library, but when I am trying to import it I receive an error <code>ImportError: libXrender.so.1: cannot open shared object file: No such file or directory</code>.","text":"<p>Probably your system doesn't have <code>libXrender</code>. To install the <code>libXrender</code> package on Ubuntu or Debian run:</p> Bash<pre><code> sudo apt-get update\n sudo apt-get install libxrender1\n</code></pre> <p>To install the package on other operating systems, consult the documentation for the OS' package manager.</p>"},{"location":"faq/#examples_1","title":"Examples","text":""},{"location":"faq/#why-do-you-call-cv2cvtcolorimage-cv2color_bgr2rgb-in-your-examples","title":"Why do you call <code>cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</code> in your examples?","text":"<p>For historical reasons, OpenCV reads an image in BGR format (so color channels of the image have the following order: Blue, Green, Red). Albumentations uses the most common and popular RGB image format. So when using OpenCV, we need to convert the image format to RGB explicitly.</p>"},{"location":"faq/#usage_1","title":"Usage","text":""},{"location":"faq/#how-can-i-find-which-augmentations-were-applied-to-the-input-data-and-which-parameters-they-used","title":"How can I find which augmentations were applied to the input data and which parameters they used?","text":"<p>To save and inspect parameters of augmentations, you can replace Compose with ReplayCompose. ReplayCompose behaves just like regular Compose, but it also saves information about which augmentations were applied and which parameters were uses. Take a look at the example that shows how you can use ReplayCompose.</p>"},{"location":"faq/#my-computer-vision-pipeline-works-with-a-sequence-of-images-i-want-to-apply-the-same-augmentations-with-the-same-parameters-to-each-image-in-the-sequence-can-albumentations-do-it","title":"My computer vision pipeline works with a sequence of images. I want to apply the same augmentations with the same parameters to each image in the sequence. Can Albumentations do it?","text":"<p>Yes. You can define additional images, masks, bounding boxes, or keypoints through the <code>additional_targets</code> argument to <code>Compose</code>. You can then pass those additional targets to the augmentation pipeline, and Albumentations will augment them in the same way. See this example for more info.</p>"},{"location":"faq/#i-want-to-augment-16-bit-tiff-images-can-albumentations-work-with-them","title":"I want to augment 16-bit TIFF images. Can Albumentations work with them?","text":"<p>Yes. Albumentations can also work with non-8-bit images. See this example for more info.</p>"},{"location":"faq/#augmentations-have-a-parameter-named-p-that-sets-the-probability-of-applying-that-augmentation-but-they-also-have-the-always_apply-parameter-that-can-either-be-true-or-false-what-is-the-difference-between-p-and-always_apply-is-always_applytrue-equals-to-p10","title":"Augmentations have a parameter named <code>p</code> that sets the probability of applying that augmentation, but they also have the <code>always_apply</code> parameter that can either be <code>True</code> or <code>False</code>. What is the difference between <code>p</code> and <code>always_apply</code>? Is <code>always_apply=True</code> equals to <code>p=1.0</code>?","text":"<p>When <code>always_apply</code> is set to <code>True</code>, Albumentations will always apply that transform, even if <code>p</code> is set to a value less than <code>1.0</code>. However, <code>always_apply=True</code> doesn't equal to <code>p=1.0</code> because with <code>always_apply=True</code>, Albumentations will apply a transform even in a case when top-level containers are not applied.</p> <p>Let's look at an example when a container <code>Compose</code> contains one augmentation <code>Resize</code>:</p> Python<pre><code>transform = A.Compose([\n    A.Resize(height=256, width=256, p=1.0),\n], p=0.9)\n</code></pre> <p>If you set <code>p=1.0</code> for <code>Resize</code> and <code>p=0.9</code> for <code>Compose</code>, then <code>Resize</code> has a 90% chance to be applied, because there is a 90% chance for <code>Compose</code> to be applied and if <code>Compose</code> is applied, there is a 100% chance for <code>Resize</code> to be applied.</p> <p>But if you set <code>always_apply=True</code> for <code>Resize</code>, Albumentations will apply it with 100% probability even if Albumentations decides not to apply the parent container (<code>Compose</code> in the example):</p> Python<pre><code>transform = A.Compose([\n    A.Resize(height=256, width=256, always_apply=True),\n], p=0.9)\n</code></pre>"},{"location":"faq/#when-i-use-augmentations-with-the-border_mode-parameter-such-as-rotate-and-set-border_mode-to-cv2border_reflect-or-cv2border_reflect_101-albumentations-mirrors-regions-of-images-and-masks-but-doesnt-mirror-bounding-boxes-and-keypoints-is-it-a-bug","title":"When I use augmentations with the <code>border_mode</code> parameter (such as <code>Rotate</code>) and set <code>border_mode</code> to <code>cv2.BORDER_REFLECT</code> or <code>cv2.BORDER_REFLECT_101</code> Albumentations mirrors regions of images and masks but doesn't mirror bounding boxes and keypoints. Is it a bug?","text":"<p>Unfortunately, adding extra bounding boxes or keypoints to reflected regions of the image is not supported. You can change <code>border_mode</code> mode to <code>cv2.BORDER_CONSTANT</code> if this causes a significant impact on the training of your model.</p>"},{"location":"faq/#i-created-annotations-for-bounding-boxes-using-labeling-service-or-labeling-software-how-can-i-use-those-annotations-in-albumentations","title":"I created annotations for bounding boxes using labeling service or labeling software. How can I use those annotations in Albumentations?","text":"<p>You need to convert those annotations to one of the formats, supported by Albumentations. For the list of formats, please refer to this article. Consult the documentation of the labeling service to see how you can export annotations in those formats.</p>"},{"location":"frameworks_and_libraries/","title":"Frameworks and libraries that use Albumentations","text":""},{"location":"frameworks_and_libraries/#mmdetection","title":"MMDetection","text":"<p>https://github.com/open-mmlab/mmdetection</p> <p>MMDetection is an open source object detection toolbox based on PyTorch. It is a part of the OpenMMLab project.</p> <ul> <li>To install MMDetection with Albumentations follow the installation instructions.</li> <li>MMDetection has an example config with augmentations from Albumentations.</li> </ul>"},{"location":"frameworks_and_libraries/#yolov5","title":"YOLOv5","text":"<p>https://github.com/ultralytics/yolov5</p> <p>YOLOv5 \ud83d\ude80 is a family of object detection architectures and models pretrained on the COCO dataset, and represents Ultralytics open-source research into future vision AI methods, incorporating lessons learned and best practices evolved over thousands of hours of research and development.</p> <ul> <li>To use Albumentations along with YOLOv5 simply <code>pip install -U albumentations</code> and then update the augmentation pipeline as you see fit in the Albumentations class in <code>utils/augmentations.py</code>. An example is available in the YOLOv5 repository.</li> </ul>"},{"location":"frameworks_and_libraries/#other-frameworks-and-libraries","title":"Other frameworks and libraries","text":"<p>Other you can see find at GitHub</p>"},{"location":"release_notes/","title":"Release notes","text":""},{"location":"release_notes/#albumentations-143-release-notes","title":"Albumentations 1.4.3 Release Notes","text":"<ul> <li>Request</li> <li>Highlights</li> <li>New transform</li> <li>Minor improvements and bug fixes</li> </ul>"},{"location":"release_notes/#request","title":"Request","text":"<ol> <li>If you enjoy using the library as an individual developer or a company representative, please consider becoming a sponsor for the library. Every dollar helps.</li> <li>If you did not give our repo a \u2b50, it is only one mouse click</li> <li>If you have feature requests or proposals or encounter issues - submit your request to issues or ask in Discord server for Albumentations</li> </ol>"},{"location":"release_notes/#new-transform","title":"New transform","text":"<ul> <li>Added <code>Morphological</code> transform that modifies the structure of the image. Dilation expands the white (foreground) regions in a binary or grayscale image, while erosion shrinks them.</li> </ul>"},{"location":"release_notes/#minor-improvements-and-bug-fixes","title":"Minor improvements and bug fixes","text":"<ul> <li>Updated benchmark for uint8 images, processed on CPU. Added Kornia and Augly. LINK by @ternaus</li> <li>Bugfix in FDA transform by @ternaus</li> <li>Now RandomSizedCrop supports the same signature as analogous transform in torchvision by @zetyquickly</li> </ul>"},{"location":"release_notes/#albumentations-142-release-notes","title":"Albumentations 1.4.2 Release Notes","text":"<ul> <li>Request</li> <li>Highlights</li> <li>New transform</li> <li>New functionality</li> <li>Improvements and bug fixes</li> </ul>"},{"location":"release_notes/#request_1","title":"Request","text":"<ol> <li>If you enjoy using the library as an individual developer or as a representative of the company please consider becoming a sponsor for the library. Every dollar helps.</li> <li>If you did not give our repo a \u2b50, it is only one mouse click</li> <li>If you have feature requests or proposals or encounter issues - submit your request to issues or ask in Discord server for Albumentations</li> </ol>"},{"location":"release_notes/#new-transform_1","title":"New transform","text":"<p> Left: Original, Middle: Chromatic aberration (default args, mode=\"green_purple\"), Right:  Chromatic aberration (default args, mode=\"red_blue\")     (Image is from our internal mobile mapping dataset)   </p> <ul> <li>Added <code>ChromaticAbberation</code> transform that adds chromatic distortion to the image. Wiki by @mrsmrynk</li> </ul>"},{"location":"release_notes/#new-functionality","title":"New functionality","text":"<ul> <li>Return <code>mixing parameter</code> for <code>MixUp</code> transform by @Dipet. For more details Tutorial on MixUp</li> </ul>"},{"location":"release_notes/#improvements-and-bugfixes","title":"Improvements and Bugfixes","text":"<ul> <li>Do not throw deprecation warning when people do not use deprecated parameters in <code>AdvancedBlur</code> by @Aloqeely</li> <li>Updated <code>CONTRIBUTORS.md</code> for Windows users by @Aloqeely</li> <li>Fixed Docstring for <code>DownScale</code> transform by @ryoryon66</li> <li>Bugfix in <code>PadIfNeeded</code> serialization @ternaus</li> </ul>"},{"location":"release_notes/#albumentations-141-release-notes-4-march-2024","title":"Albumentations 1.4.1 Release Notes (4 March 2024)","text":"<ul> <li>Request</li> <li>Highlights</li> <li>New transform</li> <li>Improvements</li> <li>Bug fixes</li> </ul>"},{"location":"release_notes/#request_2","title":"Request","text":"<ol> <li>If you enjoy using the library as an individual developer or during the day job as a part of the company, please consider becoming a sponsor for the library. Every dollar helps.</li> <li>If you did not give our repo a \u2b50, it is only one mouse click</li> <li>If you have feature requests or proposals or encounter issues - submit your request to issues or our new initiative, - Discord server for albumentations</li> </ol>"},{"location":"release_notes/#new-transform_2","title":"New transform","text":"<ul> <li>Added <code>MixUp</code> transform: which linearly combines an input (image, mask, and class label) with another set from a predefined reference dataset. The mixing degree is controlled by a parameter \u03bb (lambda), sampled from a Beta distribution. This method is known for improving model generalization by promoting linear behavior between classes and smoothing decision boundaries.</li> </ul>"},{"location":"release_notes/#minor-changes-and-bug-fixes","title":"Minor changes and Bug Fixes","text":"<ul> <li>Moved from <code>isort</code>, <code>flake8</code>, <code>black</code> to <code>ruff</code></li> <li>Added extra checks for docstrings to match Google Style.</li> <li>Updated Who's using</li> <li>Removed quidda dependency, which addresses <code>opencv</code> library inconsistencies issues</li> <li>New, updated version of benchmark.</li> </ul>"},{"location":"release_notes/#albumentations-140-release-notes-17-february-2024","title":"Albumentations 1.4.0 Release Notes (17 February 2024)","text":"<ul> <li>Request</li> <li>Highlights</li> <li>New transform</li> <li>Backwards Incompatible Changes</li> <li>Improvements</li> <li>Bug fixes</li> </ul>"},{"location":"release_notes/#request_3","title":"Request","text":"<ol> <li>If you enjoy using the library as an individual developer or during the day job as a part of the company, please consider becoming a sponsor for the library. Every dollar helps.</li> <li>If you did not give our repo a \u2b50, it is [only one mouse click].(https://github.com/albumentations-team/albumentations)</li> <li>If you have feature requests, proposals, or encounter issues - submit your request to issues or, our new initiative, - Discord server for albumentations</li> </ol>"},{"location":"release_notes/#highlights","title":"Highlights","text":"<p>In this release, we mainly focused on the technical debt as its decrease allows faster iterations and bug fixes in the codebase. We added only one new transform, did not work on speeding up transforms, and other changes are minor.</p> <ol> <li>We are removing the dependency on the imgaug library. The library was one of our inspirations when we created Albumentations, but maintainers of imgaug ceased its support which caused inconsistencies in library versions. It was done in 2021, say commit https://github.com/albumentations-team/albumentations/commit/ba44effb0369ba5eae1e8eb4909105eac9709230 by @Dipet .</li> </ol> <p>But, somehow, we are cutting this dependency only in 2024.</p> <ol> <li>Added typing in all of the codebase. When we started the library, Python 2 was still widely used; hence, none of the original codebases had types specified for function arguments and return types. Since the end of the support for Python 2, we added types to the new or updated code, but only now have we covered all the codebase.</li> </ol>"},{"location":"release_notes/#new-transform_3","title":"New transform","text":"<ul> <li>Added <code>XYMasking</code> transform: applies masking strips to an image, either horizontally (X axis) or vertically (Y axis), simulating occlusions. This transform is helpful for training models to recognize images with varied visibility conditions. It's particularly effective for spectrogram images, allowing spectral and frequency masking to improve model robustness. As other dropout transforms CoarseDropout, MaskDropout, GridDropout it supports images, masks and keypoints as targets. (https://github.com/albumentations-team/albumentations/commit/004fabbf90794fbc21ee356e2dde6637b7fecbd4 by @ternaus )</li> </ul>"},{"location":"release_notes/#backward-incompatible-changes","title":"Backward Incompatible Changes","text":"<p>The deprecated code, including 15 transforms, was removed. Dependency on the imgaug library was removed.</p> <p>(https://github.com/albumentations-team/albumentations/commit/be6a217b207b3d7ebe792caabb438d660b45f2a5 by @ternaus )</p>"},{"location":"release_notes/#deleted-transforms","title":"Deleted Transforms","text":"<ol> <li><code>JpegCompression</code>. Use ImageCompression instead.</li> <li><code>RandomBrightness</code>. Use RandomBrigtnessContrast instead.</li> <li><code>RandomContrast</code>. Use RandomBrigtnessContrast instead.</li> <li><code>Cutout</code>. Use CoarseDropout instead.</li> <li><code>ToTensor</code>. Use ToTensorV2 instead.</li> <li><code>IAAAdditiveGaussianNoise</code>. Use GaussNoise instead.</li> <li><code>IAAAffine</code>. Use Affine instead.</li> <li>IAACropAndPad. Use CropAndPad instead.</li> <li><code>IAAEmboss</code>. Use Emboss instead.</li> <li><code>IAAFliplr</code>. Use HorizontalFlip instead.</li> <li><code>IAAFlipud</code>. Use VerticalFlip instead.</li> <li><code>IAAPerspective</code>. Use Perspective instead.</li> <li><code>IAAPiecewiseAffine</code>. Use PiecewiseAffine instead.</li> <li><code>IAASharpen</code>. Use Sharpen instead.</li> <li><code>IAASuperpixels</code>. Use Superpixels instead.</li> </ol>"},{"location":"release_notes/#other-deprecated-functionality","title":"Other deprecated functionality","text":"<ul> <li>Removed  <code>eps</code> parameter in RandomGamma</li> <li>Removed <code>lambda_transforms</code>in <code>serialization.from_dict</code> function.</li> </ul> <p>## Minor changes and Bug Fixes  * Added details Contributor's guide  * Added support for <code>matrix=None</code> case for Piecewise affine transform (https://github.com/albumentations-team/albumentations/commit/c70e664e060bfd7463c20674927aed217f72d437 @Dipet )  * Bugfix - Eliminated the possibility of the Perspective transform collapsing (https://github.com/albumentations-team/albumentations/commit/a919a772d763e0c62b674ca490a97c89e0b9c5a3 @alicangok )  * Fixes in docstrings (@domef, @aaronzs, @Dipet, @ternaus  )  * Added checks for python 3.12</p>"},{"location":"release_notes/#052-29-november-2020","title":"0.5.2 (29 November 2020)","text":""},{"location":"release_notes/#minor-changes","title":"Minor changes","text":"<ul> <li>ToTensorV2 now automatically expands grayscale images with the shape <code>[H, W]</code> to the shape <code>[H, W, 1]</code>. PR #604 by @Ingwar.</li> <li>CropNonEmptyMaskIfExists  now also works with multiple masks that are provided by the <code>masks</code> argument to the transform function. Previously this augmentation worked only with a single mask provided by the <code>mask</code> argument. PR #761.</li> </ul>"},{"location":"release_notes/#051-2-november-2020","title":"0.5.1 (2 November 2020)","text":""},{"location":"release_notes/#breaking-changes","title":"Breaking changes","text":"<ul> <li>API for <code>A.FDA</code> is changed to resemble API of <code>A.HistogramMatching</code>. Now, both transformations expect to receive a list of reference images, a function to read those image, and additional augmentation parameters. (#734)</li> <li><code>A.HistogramMatching</code> now uses<code>read_rgb_image</code> as a default <code>read_fn</code>. This function reads an image from the disk as an RGB NumPy array. Previously, the default <code>read_fn</code> was <code>cv2.imread</code> which read an image as a BGR NumPy array. (#734)</li> </ul>"},{"location":"release_notes/#new-transformations","title":"New transformations","text":"<ul> <li><code>A.Sequential</code> transform that can apply augmentations in a sequence. This transform is not intended to be a replacement for <code>A.Compose</code>. Instead, it should be used inside <code>A.Compose</code> the same way <code>A.OneOf</code> or <code>A.OneOrOther</code>. For instance, you can combine <code>A.OneOf</code> with <code>A.Sequential</code> to create an augmentation pipeline containing multiple sequences of augmentations and apply one randomly chosen sequence to input data. (#735)</li> </ul>"},{"location":"release_notes/#minor-changes_1","title":"Minor changes","text":"<ul> <li><code>A.ShiftScaleRotate</code> now has two additional optional parameters: <code>shift_limit_x</code> and <code>shift_limit_y</code>. If either of those parameters (or both of them) is set <code>A.ShiftScaleRotate</code> will use the set values to shift images on the respective axis. (#735)</li> <li><code>A.ToTensorV2</code> now supports an additional argument <code>transpose_mask</code> (<code>False</code> by default). If the argument is set to <code>True</code> and an input mask has 3 dimensions, <code>A.ToTensorV2</code> will transpose dimensions of a mask tensor in addition to transposing dimensions of an image tensor. (#735)</li> </ul>"},{"location":"release_notes/#bugfixes","title":"Bugfixes","text":"<ul> <li><code>A.FDA</code> now correctly uses coordinates of the center of an image. (#730)</li> <li>Fixed problems with grayscale images for <code>A.HistogramMatching</code>. (#734)</li> <li>Fixed a bug that led to an exception when <code>A.load()</code> was called to deserialize a pipeline that contained <code>A.ToTensor</code> or <code>A.ToTensorV2</code>, but those transforms were not imported in the code before the call. (#735)</li> </ul>"},{"location":"release_notes/#050-19-october-2020","title":"0.5.0 (19 October 2020)","text":""},{"location":"release_notes/#breaking-changes_1","title":"Breaking changes","text":"<ul> <li>Albumentations now explicitly checks that all inputs to augmentations are named arguments and raise an exception otherwise. So if an augmentation receives input like aug(image) instead of aug(image=image), Albumentations will raise an exception. (#560)</li> <li>Dropped support of Python 3.5 (#709)</li> <li>Keypoints and bboxes are checked for visibility after each transform (#566)</li> </ul>"},{"location":"release_notes/#new-transformations_1","title":"New transformations","text":"<ul> <li><code>A.FDA</code> transform for Fourier-based domain adaptation. (#685)</li> <li><code>A.HistogramMatching</code> transform that applies histogram matching. (#708)</li> <li><code>A.ColorJitter</code> transform that behaves similarly to <code>ColorJitter</code> from torchvision (though there are some minor differences due to different internal logic for working with HSV colorspace in Pillow, which is used in torchvision and OpenCV, which is used in Albumentations). (#705)</li> </ul>"},{"location":"release_notes/#minor-changes_2","title":"Minor changes","text":"<ul> <li><code>A.PadIfNeeded</code> now accepts additional <code>pad_width_divisor</code>, <code>pad_height_divisor</code> (<code>None</code> by default) to ensure image has width &amp; height that is dividable by given values. (#700)</li> <li>Added support to apply <code>A.CoarseDropout</code> to masks via <code>mask_fill_value</code>. (#699)</li> <li><code>A.GaussianBlur</code> now supports the sigma parameter that sets standard deviation for Gaussian kernel. (#674, #673) .</li> </ul>"},{"location":"release_notes/#bugfixes_1","title":"Bugfixes","text":"<ul> <li>Fixed bugs in <code>A.HueSaturationValue</code> for float dtype. (#696, #710)</li> <li>Fixed incorrect rounding error on bboxes in <code>YOLO</code> format. (#688)</li> </ul>"},{"location":"release_notes/#046-19-july-2020","title":"0.4.6 (19 July 2020)","text":""},{"location":"release_notes/#improvements","title":"Improvements","text":"<ul> <li>Change the ImgAug dependency version from \u201cimgaug&gt;=0.2.5,&lt;0.2.7\u201d to \u201cimgaug&gt;=0.4.0\". Now Albumentations won\u2019t downgrade your existing ImgAug installation to the old version. PR #658.</li> <li>Do not try to resize an image if it already has the required height and width. That eliminates the redundant call to the OpenCV function that requires additional copying of the input data. PR #639. <code>ReplayCompose</code> is now serializable. PR #623 by IlyaOvodov</li> <li>Documentation fixes and updates.</li> </ul>"},{"location":"release_notes/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fix a bug that causes some keypoints and bounding boxes to lie outside the visible part of the augmented image if an augmentation pipeline contained augmentations that increase the height and width of an image (such as <code>PadIfNeeded</code>). That happened because Albumentations checked which bounding boxes and keypoints lie outside the image only after applying all augmentations. Now Albumentations will check and remove keypoints and bounding boxes that lie outside the image after each augmentation. If, for some reason, you need the old behavior, pass <code>check_each_transform=False</code> in your <code>KeypointParams</code> or <code>BboxParams</code>. Issue #565 and PR #566.</li> <li>Fix a bug that causes an exception when Albumentations received images with the number of color channels that are even but are not multiples of 4 (such as 6, 10, etc.). PR #638.</li> <li>Fix the off-by-one error in applying steps for GridDistortion. Commit 9c225a9</li> <li>Fix bugs that prevent serialization of <code>ImageCompression</code> and <code>GaussNoise</code>. PR #569</li> <li>Fix a bug that causes errors with some values for <code>label_fields</code> in <code>BboxParams</code>. PR #504 by IlyaOvodov</li> <li>Fix a bug that prevents HueSaturationValue for working with grayscale images. PR #500.</li> </ul>"},{"location":"api_reference/","title":"Index","text":"<ul> <li>Full API Reference on a single page</li> <li>Core API (albumentations.core)<ul> <li>Composition API (albumentations.core.composition)</li> <li>Serialization API (albumentations.core.serialization)</li> <li>Transforms Interface (albumentations.core.transforms_interface)</li> <li>Helper functions for working with bounding boxes (albumentations.core.bbox_utils)</li> <li>Helper functions for working with keypoints (albumentations.core.keypoints_utils)</li> </ul> </li> <li>Augmentations (albumentations.augmentations)<ul> <li>Transforms (albumentations.augmentations.transforms)</li> <li>Functional transforms (albumentations.augmentations.functional)</li> </ul> </li> <li>PyTorch Helpers (albumentations.pytorch)<ul> <li>Transforms (albumentations.pytorch.transforms)</li> </ul> </li> </ul>"},{"location":"api_reference/full_reference/","title":"Full API Reference on a single page","text":""},{"location":"api_reference/full_reference/#pixel-level-transforms","title":"Pixel-level transforms","text":"<p>Here is a list of all available pixel-level transforms. You can apply a pixel-level transform to any target, and under the hood, the transform will change only the input image and return any other input targets such as masks, bounding boxes, or keypoints unchanged.</p> <ul> <li>AdvancedBlur</li> <li>Blur</li> <li>CLAHE</li> <li>ChannelDropout</li> <li>ChannelShuffle</li> <li>ChromaticAberration</li> <li>ColorJitter</li> <li>Defocus</li> <li>Downscale</li> <li>Emboss</li> <li>Equalize</li> <li>FDA</li> <li>FancyPCA</li> <li>FromFloat</li> <li>GaussNoise</li> <li>GaussianBlur</li> <li>GlassBlur</li> <li>HistogramMatching</li> <li>HueSaturationValue</li> <li>ISONoise</li> <li>ImageCompression</li> <li>InvertImg</li> <li>MedianBlur</li> <li>MotionBlur</li> <li>MultiplicativeNoise</li> <li>Normalize</li> <li>PixelDistributionAdaptation</li> <li>Posterize</li> <li>RGBShift</li> <li>RandomBrightnessContrast</li> <li>RandomFog</li> <li>RandomGamma</li> <li>RandomGravel</li> <li>RandomRain</li> <li>RandomShadow</li> <li>RandomSnow</li> <li>RandomSunFlare</li> <li>RandomToneCurve</li> <li>RingingOvershoot</li> <li>Sharpen</li> <li>Solarize</li> <li>Spatter</li> <li>Superpixels</li> <li>TemplateTransform</li> <li>ToFloat</li> <li>ToGray</li> <li>ToRGB</li> <li>ToSepia</li> <li>UnsharpMask</li> <li>ZoomBlur</li> </ul>"},{"location":"api_reference/full_reference/#spatial-level-transforms","title":"Spatial-level transforms","text":"<p>Here is a table with spatial-level transforms and targets they support. If you try to apply a spatial-level transform to an unsupported target, Albumentations will raise an error.</p> Transform Image Mask BBoxes Keypoints Global Label Affine \u2713 \u2713 \u2713 \u2713 BBoxSafeRandomCrop \u2713 \u2713 \u2713 CenterCrop \u2713 \u2713 \u2713 \u2713 CoarseDropout \u2713 \u2713 \u2713 Crop \u2713 \u2713 \u2713 \u2713 CropAndPad \u2713 \u2713 \u2713 \u2713 CropNonEmptyMaskIfExists \u2713 \u2713 \u2713 \u2713 ElasticTransform \u2713 \u2713 \u2713 Flip \u2713 \u2713 \u2713 \u2713 GridDistortion \u2713 \u2713 \u2713 GridDropout \u2713 \u2713 HorizontalFlip \u2713 \u2713 \u2713 \u2713 Lambda \u2713 \u2713 \u2713 \u2713 \u2713 LongestMaxSize \u2713 \u2713 \u2713 \u2713 MaskDropout \u2713 \u2713 MixUp \u2713 \u2713 \u2713 Morphological \u2713 \u2713 NoOp \u2713 \u2713 \u2713 \u2713 \u2713 OpticalDistortion \u2713 \u2713 \u2713 PadIfNeeded \u2713 \u2713 \u2713 \u2713 Perspective \u2713 \u2713 \u2713 \u2713 PiecewiseAffine \u2713 \u2713 \u2713 \u2713 PixelDropout \u2713 \u2713 RandomCrop \u2713 \u2713 \u2713 \u2713 RandomCropFromBorders \u2713 \u2713 \u2713 \u2713 RandomGridShuffle \u2713 \u2713 \u2713 RandomResizedCrop \u2713 \u2713 \u2713 \u2713 RandomRotate90 \u2713 \u2713 \u2713 \u2713 RandomScale \u2713 \u2713 \u2713 \u2713 RandomSizedBBoxSafeCrop \u2713 \u2713 \u2713 RandomSizedCrop \u2713 \u2713 \u2713 \u2713 Resize \u2713 \u2713 \u2713 \u2713 Rotate \u2713 \u2713 \u2713 \u2713 SafeRotate \u2713 \u2713 \u2713 \u2713 ShiftScaleRotate \u2713 \u2713 \u2713 \u2713 SmallestMaxSize \u2713 \u2713 \u2713 \u2713 Transpose \u2713 \u2713 \u2713 \u2713 VerticalFlip \u2713 \u2713 \u2713 \u2713 XYMasking \u2713 \u2713 \u2713"},{"location":"api_reference/full_reference/#albumentations.augmentations","title":"<code>augmentations</code>  <code>special</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.blur","title":"<code>blur</code>  <code>special</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms","title":"<code>transforms</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms.AdvancedBlur","title":"<code>class  AdvancedBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Blurs the input image using a Generalized Normal filter with randomly selected parameters.</p> <p>This transform also adds multiplicative noise to the generated kernel before convolution, affecting the image in a unique way that combines blurring and noise injection for enhanced data augmentation.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <code>ScaleIntType</code> <p>Maximum Gaussian kernel size for blurring the input image. Must be zero or odd and in range [0, inf). If set to 0, it will be computed from sigma as <code>round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1</code>. If a single value is provided, <code>blur_limit</code> will be in the range (0, blur_limit). Defaults to (3, 7).</p> <code>sigma_x_limit</code> <code>ScaleFloatType</code> <p>Gaussian kernel standard deviation for the X dimension. Must be in range [0, inf). If a single value is provided, <code>sigma_x_limit</code> will be in the range (0, sigma_limit). If set to 0, sigma will be computed as <code>sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8</code>. Defaults to (0.2, 1.0).</p> <code>sigma_y_limit</code> <code>ScaleFloatType</code> <p>Gaussian kernel standard deviation for the Y dimension. Must follow the same rules as <code>sigma_x_limit</code>. Defaults to (0.2, 1.0).</p> <code>rotate_limit</code> <code>ScaleIntType</code> <p>Range from which a random angle used to rotate the Gaussian kernel is picked. If limit is a single int, an angle is picked from (-rotate_limit, rotate_limit). Defaults to (-90, 90).</p> <code>beta_limit</code> <code>ScaleFloatType</code> <p>Distribution shape parameter. 1 represents the normal distribution. Values below 1.0 make distribution tails heavier than normal, and values above 1.0 make it lighter than normal. Defaults to (0.5, 8.0).</p> <code>noise_limit</code> <code>ScaleFloatType</code> <p>Multiplicative factor that controls the strength of kernel noise. Must be positive and preferably centered around 1.0. If a single value is provided, <code>noise_limit</code> will be in the range (0, noise_limit). Defaults to (0.75, 1.25).</p> <code>p</code> <code>float</code> <p>Probability of applying the transform. Defaults to 0.5.</p> <p>Reference</p> <p>\"Real-ESRGAN: Training Real-World Blind Super-Resolution with Pure Synthetic Data\", available at https://arxiv.org/abs/2107.10833</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class AdvancedBlur(ImageOnlyTransform):\n    \"\"\"Blurs the input image using a Generalized Normal filter with randomly selected parameters.\n\n    This transform also adds multiplicative noise to the generated kernel before convolution,\n    affecting the image in a unique way that combines blurring and noise injection for enhanced\n    data augmentation.\n\n    Args:\n        blur_limit (ScaleIntType, optional): Maximum Gaussian kernel size for blurring the input image.\n            Must be zero or odd and in range [0, inf). If set to 0, it will be computed from sigma\n            as `round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1`.\n            If a single value is provided, `blur_limit` will be in the range (0, blur_limit).\n            Defaults to (3, 7).\n        sigma_x_limit ScaleFloatType: Gaussian kernel standard deviation for the X dimension.\n            Must be in range [0, inf). If a single value is provided, `sigma_x_limit` will be in the range\n            (0, sigma_limit). If set to 0, sigma will be computed as `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.\n            Defaults to (0.2, 1.0).\n        sigma_y_limit ScaleFloatType: Gaussian kernel standard deviation for the Y dimension.\n            Must follow the same rules as `sigma_x_limit`.\n            Defaults to (0.2, 1.0).\n        rotate_limit (ScaleIntType, optional): Range from which a random angle used to rotate the Gaussian kernel\n            is picked. If limit is a single int, an angle is picked from (-rotate_limit, rotate_limit).\n            Defaults to (-90, 90).\n        beta_limit (ScaleFloatType, optional): Distribution shape parameter. 1 represents the normal distribution.\n            Values below 1.0 make distribution tails heavier than normal, and values above 1.0 make it\n            lighter than normal.\n            Defaults to (0.5, 8.0).\n        noise_limit (ScaleFloatType, optional): Multiplicative factor that controls the strength of kernel noise.\n            Must be positive and preferably centered around 1.0. If a single value is provided,\n            `noise_limit` will be in the range (0, noise_limit).\n            Defaults to (0.75, 1.25).\n        p (float, optional): Probability of applying the transform.\n            Defaults to 0.5.\n\n    Reference:\n        \"Real-ESRGAN: Training Real-World Blind Super-Resolution with Pure Synthetic Data\",\n        available at https://arxiv.org/abs/2107.10833\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BlurInitSchema):\n        sigma_x_limit: NonNegativeFloatRangeType = (0.2, 1.0)\n        sigma_y_limit: NonNegativeFloatRangeType = (0.2, 1.0)\n        beta_limit: NonNegativeFloatRangeType = (0.5, 8.0)\n        noise_limit: NonNegativeFloatRangeType = (0.75, 1.25)\n        rotate_limit: SymmetricRangeType = (-90, 90)\n\n        @field_validator(\"beta_limit\")\n        @classmethod\n        def check_beta_limit(cls, value: ScaleFloatType) -&gt; Tuple[float, float]:\n            result = to_tuple(value, low=0)\n            if not (result[0] &lt; 1.0 &lt; result[1]):\n                msg = \"beta_limit is expected to include 1.0.\"\n                raise ValueError(msg)\n            return result\n\n        @model_validator(mode=\"after\")\n        def validate_limits(self) -&gt; Self:\n            if (\n                isinstance(self.sigma_x_limit, (tuple, list))\n                and self.sigma_x_limit[0] == 0\n                and isinstance(self.sigma_y_limit, (tuple, list))\n                and self.sigma_y_limit[0] == 0\n            ):\n                msg = \"sigma_x_limit and sigma_y_limit minimum value cannot be both equal to 0.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = (3, 7),\n        sigma_x_limit: ScaleFloatType = (0.2, 1.0),\n        sigma_y_limit: ScaleFloatType = (0.2, 1.0),\n        sigmaX_limit: Optional[ScaleFloatType] = None,  # noqa: N803\n        sigmaY_limit: Optional[ScaleFloatType] = None,  # noqa: N803\n        rotate_limit: ScaleIntType = 90,\n        beta_limit: ScaleFloatType = (0.5, 8.0),\n        noise_limit: ScaleFloatType = (0.9, 1.1),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        if sigmaX_limit is not None:\n            warnings.warn(\"sigmaX_limit is deprecated; use sigma_x_limit instead.\", DeprecationWarning)\n            sigma_x_limit = sigmaX_limit\n\n        if sigmaY_limit is not None:\n            warnings.warn(\"sigmaY_limit is deprecated; use sigma_y_limit instead.\", DeprecationWarning)\n            sigma_y_limit = sigmaY_limit\n\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n        self.sigma_x_limit = cast(Tuple[float, float], sigma_x_limit)\n        self.sigma_y_limit = cast(Tuple[float, float], sigma_y_limit)\n        self.rotate_limit = cast(Tuple[int, int], rotate_limit)\n        self.beta_limit = cast(Tuple[float, float], beta_limit)\n        self.noise_limit = cast(Tuple[float, float], noise_limit)\n\n    def apply(self, img: np.ndarray, kernel: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return FMain.convolve(img, kernel=kernel)\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        ksize = random.randrange(self.blur_limit[0], self.blur_limit[1] + 1, 2)\n        sigma_x = random_utils.uniform(*self.sigma_x_limit)\n        sigma_y = random_utils.uniform(*self.sigma_y_limit)\n        angle = np.deg2rad(random.uniform(*self.rotate_limit))\n\n        # Split into 2 cases to avoid selection of narrow kernels (beta &gt; 1) too often.\n        beta = (\n            random.uniform(self.beta_limit[0], 1) if random.random() &lt; HALF else random.uniform(1, self.beta_limit[1])\n        )\n\n        noise_matrix = random_utils.uniform(self.noise_limit[0], self.noise_limit[1], size=[ksize, ksize])\n\n        # Generate mesh grid centered at zero.\n        ax = np.arange(-ksize // 2 + 1.0, ksize // 2 + 1.0)\n        # &gt; Shape (ksize, ksize, 2)\n        grid = np.stack(np.meshgrid(ax, ax), axis=-1)\n\n        # Calculate rotated sigma matrix\n        d_matrix = np.array([[sigma_x**2, 0], [0, sigma_y**2]])\n        u_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])\n        sigma_matrix = np.dot(u_matrix, np.dot(d_matrix, u_matrix.T))\n\n        inverse_sigma = np.linalg.inv(sigma_matrix)\n        # Described in \"Parameter Estimation For Multivariate Generalized Gaussian Distributions\"\n        kernel = np.exp(-0.5 * np.power(np.sum(np.dot(grid, inverse_sigma) * grid, 2), beta))\n        # Add noise\n        kernel *= noise_matrix\n\n        # Normalize kernel\n        kernel = kernel.astype(np.float32) / np.sum(kernel)\n        return {\"kernel\": kernel}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str, str, str]:\n        return (\n            \"blur_limit\",\n            \"sigma_x_limit\",\n            \"sigma_y_limit\",\n            \"rotate_limit\",\n            \"beta_limit\",\n            \"noise_limit\",\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms.Blur","title":"<code>class  Blur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Blur the input image using a random-sized kernel.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <p>maximum kernel size for blurring the input image. Should be in range [3, inf). Default: (3, 7).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class Blur(ImageOnlyTransform):\n    \"\"\"Blur the input image using a random-sized kernel.\n\n    Args:\n        blur_limit: maximum kernel size for blurring the input image.\n            Should be in range [3, inf). Default: (3, 7).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BlurInitSchema):\n        pass\n\n    def __init__(self, blur_limit: ScaleIntType = 7, always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply, p)\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n\n    def apply(self, img: np.ndarray, kernel: int = 3, **params: Any) -&gt; np.ndarray:\n        return F.blur(img, kernel)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\"ksize\": int(random.choice(list(range(self.blur_limit[0], self.blur_limit[1] + 1, 2))))}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"blur_limit\",)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms.Defocus","title":"<code>class  Defocus</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply defocus transform.</p> <p>Parameters:</p> Name Type Description <code>radius</code> <code>int, int) or int</code> <p>range for radius of defocusing. If limit is a single int, the range will be [1, limit]. Default: (3, 10).</p> <code>alias_blur</code> <code>float, float) or float</code> <p>range for alias_blur of defocusing (sigma of gaussian blur). If limit is a single float, the range will be (0, limit). Default: (0.1, 0.5).</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     unit8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1903.12261</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class Defocus(ImageOnlyTransform):\n    \"\"\"Apply defocus transform.\n\n    Args:\n        radius ((int, int) or int): range for radius of defocusing.\n            If limit is a single int, the range will be [1, limit]. Default: (3, 10).\n        alias_blur ((float, float) or float): range for alias_blur of defocusing (sigma of gaussian blur).\n            If limit is a single float, the range will be (0, limit). Default: (0.1, 0.5).\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        unit8, float32\n\n    Reference:\n        https://arxiv.org/abs/1903.12261\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        radius: OnePlusIntRangeType = (3, 10)\n        alias_blur: NonNegativeFloatRangeType = (0.1, 0.5)\n\n    def __init__(\n        self,\n        radius: ScaleIntType = (3, 10),\n        alias_blur: ScaleFloatType = (0.1, 0.5),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.radius = cast(Tuple[int, int], radius)\n        self.alias_blur = cast(Tuple[float, float], alias_blur)\n\n    def apply(self, img: np.ndarray, radius: int = 3, alias_blur: float = 0.5, **params: Any) -&gt; np.ndarray:\n        return F.defocus(img, radius, alias_blur)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"radius\": random_utils.randint(self.radius[0], self.radius[1] + 1),\n            \"alias_blur\": random_utils.uniform(self.alias_blur[0], self.alias_blur[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"radius\", \"alias_blur\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms.GaussianBlur","title":"<code>class  GaussianBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Blur the input image using a Gaussian filter with a random kernel size.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <code>int, (int, int</code> <p>maximum Gaussian kernel size for blurring the input image. Must be zero or odd and in range [0, inf). If set to 0 it will be computed from sigma as <code>round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1</code>. If set single value <code>blur_limit</code> will be in range (0, blur_limit). Default: (3, 7).</p> <code>sigma_limit</code> <code>float, (float, float</code> <p>Gaussian kernel standard deviation. Must be in range [0, inf). If set single value <code>sigma_limit</code> will be in range (0, sigma_limit). If set to 0 sigma will be computed as <code>sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8</code>. Default: 0.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class GaussianBlur(ImageOnlyTransform):\n    \"\"\"Blur the input image using a Gaussian filter with a random kernel size.\n\n    Args:\n        blur_limit (int, (int, int)): maximum Gaussian kernel size for blurring the input image.\n            Must be zero or odd and in range [0, inf). If set to 0 it will be computed from sigma\n            as `round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1`.\n            If set single value `blur_limit` will be in range (0, blur_limit).\n            Default: (3, 7).\n        sigma_limit (float, (float, float)): Gaussian kernel standard deviation. Must be in range [0, inf).\n            If set single value `sigma_limit` will be in range (0, sigma_limit).\n            If set to 0 sigma will be computed as `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`. Default: 0.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BlurInitSchema):\n        sigma_limit: NonNegativeFloatRangeType = 0\n\n        @field_validator(\"blur_limit\")\n        @classmethod\n        def process_blur(cls, value: ScaleIntType, info: ValidationInfo) -&gt; Tuple[int, int]:\n            return process_blur_limit(value, info, min_value=0)\n\n        @model_validator(mode=\"after\")\n        def validate_limits(self) -&gt; Self:\n            if (\n                isinstance(self.blur_limit, (tuple, list))\n                and self.blur_limit[0] == 0\n                and isinstance(self.sigma_limit, (tuple, list))\n                and self.sigma_limit[0] == 0\n            ):\n                self.blur_limit = 3, max(3, self.blur_limit[1])\n                warnings.warn(\n                    \"blur_limit and sigma_limit minimum value can not be both equal to 0. \"\n                    \"blur_limit minimum value changed to 3.\"\n                )\n\n            if isinstance(self.blur_limit, tuple):\n                for v in self.blur_limit:\n                    if v != 0 and v % 2 != 1:\n                        raise ValueError(f\"Blur limit must be 0 or odd. Got: {self.blur_limit}\")\n\n            return self\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = (3, 7),\n        sigma_limit: ScaleFloatType = 0,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n        self.sigma_limit = cast(Tuple[float, float], sigma_limit)\n\n    def apply(self, img: np.ndarray, ksize: int = 3, sigma: float = 0, **params: Any) -&gt; np.ndarray:\n        return F.gaussian_blur(img, ksize, sigma=sigma)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        ksize = random.randrange(self.blur_limit[0], self.blur_limit[1] + 1)\n        if ksize != 0 and ksize % 2 != 1:\n            ksize = (ksize + 1) % (self.blur_limit[1] + 1)\n\n        return {\"ksize\": ksize, \"sigma\": random.uniform(*self.sigma_limit)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"blur_limit\", \"sigma_limit\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms.GlassBlur","title":"<code>class  GlassBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply glass noise to the input image.</p> <p>Parameters:</p> Name Type Description <code>sigma</code> <code>float</code> <p>standard deviation for Gaussian kernel.</p> <code>max_delta</code> <code>int</code> <p>max distance between pixels which are swapped.</p> <code>iterations</code> <code>int</code> <p>number of repeats. Should be in range [1, inf). Default: (2).</p> <code>mode</code> <code>str</code> <p>mode of computation: fast or exact. Default: \"fast\".</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1903.12261 https://github.com/hendrycks/robustness/blob/master/ImageNet-C/create_c/make_imagenet_c.py</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class GlassBlur(ImageOnlyTransform):\n    \"\"\"Apply glass noise to the input image.\n\n    Args:\n        sigma (float): standard deviation for Gaussian kernel.\n        max_delta (int): max distance between pixels which are swapped.\n        iterations (int): number of repeats.\n            Should be in range [1, inf). Default: (2).\n        mode (str): mode of computation: fast or exact. Default: \"fast\".\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://arxiv.org/abs/1903.12261\n        https://github.com/hendrycks/robustness/blob/master/ImageNet-C/create_c/make_imagenet_c.py\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        sigma: float = Field(default=0.7, ge=0, description=\"Standard deviation for the Gaussian kernel.\")\n        max_delta: int = Field(default=4, ge=1, description=\"Maximum distance between pixels that are swapped.\")\n        iterations: int = Field(default=2, ge=1, description=\"Number of times the glass noise effect is applied.\")\n        mode: Literal[\"fast\", \"exact\"] = \"fast\"\n\n    def __init__(\n        self,\n        sigma: float = 0.7,\n        max_delta: int = 4,\n        iterations: int = 2,\n        mode: Literal[\"fast\", \"exact\"] = \"fast\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.sigma = sigma\n        self.max_delta = max_delta\n        self.iterations = iterations\n        self.mode = mode\n\n    def apply(self, img: np.ndarray, *args: Any, dxy: np.ndarray = None, **params: Any) -&gt; np.ndarray:\n        if dxy is None:\n            msg = \"dxy is None\"\n            raise ValueError(msg)\n\n        return F.glass_blur(img, self.sigma, self.max_delta, self.iterations, dxy, self.mode)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, np.ndarray]:\n        img = params[\"image\"]\n\n        height, width = img.shape[:2]\n\n        # generate array containing all necessary values for transformations\n        width_pixels = height - self.max_delta * 2\n        height_pixels = width - self.max_delta * 2\n        total_pixels = int(width_pixels * height_pixels)\n        dxy = random_utils.randint(-self.max_delta, self.max_delta, size=(total_pixels, self.iterations, 2))\n\n        return {\"dxy\": dxy}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"sigma\", \"max_delta\", \"iterations\", \"mode\")\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms.MedianBlur","title":"<code>class  MedianBlur</code> <code>       (blur_limit=7, always_apply=False, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Blur the input image using a median filter with a random aperture linear size.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <code>int</code> <p>maximum aperture linear size for blurring the input image. Must be odd and in range [3, inf). Default: (3, 7).</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class MedianBlur(Blur):\n    \"\"\"Blur the input image using a median filter with a random aperture linear size.\n\n    Args:\n        blur_limit (int): maximum aperture linear size for blurring the input image.\n            Must be odd and in range [3, inf). Default: (3, 7).\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def __init__(self, blur_limit: ScaleIntType = 7, always_apply: bool = False, p: float = 0.5):\n        super().__init__(blur_limit, always_apply, p)\n\n    def apply(self, img: np.ndarray, kernel: int = 3, **params: Any) -&gt; np.ndarray:\n        return F.median_blur(img, kernel)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms.MedianBlur.__init__","title":"<code>__init__ (self, blur_limit=7, always_apply=False, p=0.5)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>def __init__(self, blur_limit: ScaleIntType = 7, always_apply: bool = False, p: float = 0.5):\n    super().__init__(blur_limit, always_apply, p)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms.MotionBlur","title":"<code>class  MotionBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply motion blur to the input image using a random-sized kernel.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <code>int</code> <p>maximum kernel size for blurring the input image. Should be in range [3, inf). Default: (3, 7).</p> <code>allow_shifted</code> <code>bool</code> <p>if set to true creates non shifted kernels only, otherwise creates randomly shifted kernels. Default: True.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class MotionBlur(Blur):\n    \"\"\"Apply motion blur to the input image using a random-sized kernel.\n\n    Args:\n        blur_limit (int): maximum kernel size for blurring the input image.\n            Should be in range [3, inf). Default: (3, 7).\n        allow_shifted (bool): if set to true creates non shifted kernels only,\n            otherwise creates randomly shifted kernels. Default: True.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        allow_shifted: bool = Field(\n            default=True,\n            description=\"If set to true creates non-shifted kernels only, otherwise creates randomly shifted kernels.\",\n        )\n        blur_limit: ScaleIntType = Field(\n            default=(3, 7), description=\"Maximum kernel size for blurring the input image.\"\n        )\n\n        @model_validator(mode=\"after\")\n        def process_blur(self) -&gt; Self:\n            self.blur_limit = cast(Tuple[int, int], to_tuple(self.blur_limit, 3))\n\n            if self.allow_shifted and isinstance(self.blur_limit, tuple) and any(x % 2 != 1 for x in self.blur_limit):\n                raise ValueError(f\"Blur limit must be odd when centered=True. Got: {self.blur_limit}\")\n\n            return self\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = 7,\n        allow_shifted: bool = True,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(blur_limit=blur_limit, always_apply=always_apply, p=p)\n        self.allow_shifted = allow_shifted\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (*super().get_transform_init_args_names(), \"allow_shifted\")\n\n    def apply(self, img: np.ndarray, kernel: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return FMain.convolve(img, kernel=kernel)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        ksize = random.choice(list(range(self.blur_limit[0], self.blur_limit[1] + 1, 2)))\n        if ksize &lt;= TWO:\n            raise ValueError(f\"ksize must be &gt; 2. Got: {ksize}\")\n        kernel = np.zeros((ksize, ksize), dtype=np.uint8)\n        x1, x2 = random.randint(0, ksize - 1), random.randint(0, ksize - 1)\n        if x1 == x2:\n            y1, y2 = random.sample(range(ksize), 2)\n        else:\n            y1, y2 = random.randint(0, ksize - 1), random.randint(0, ksize - 1)\n\n        def make_odd_val(v1: int, v2: int) -&gt; Tuple[int, int]:\n            len_v = abs(v1 - v2) + 1\n            if len_v % 2 != 1:\n                if v2 &gt; v1:\n                    v2 -= 1\n                else:\n                    v1 -= 1\n            return v1, v2\n\n        if not self.allow_shifted:\n            x1, x2 = make_odd_val(x1, x2)\n            y1, y2 = make_odd_val(y1, y2)\n\n            xc = (x1 + x2) / 2\n            yc = (y1 + y2) / 2\n\n            center = ksize / 2 - 0.5\n            dx = xc - center\n            dy = yc - center\n            x1, x2 = (int(i - dx) for i in [x1, x2])\n            y1, y2 = (int(i - dy) for i in [y1, y2])\n\n        cv2.line(kernel, (x1, y1), (x2, y2), 1, thickness=1)\n\n        # Normalize kernel\n        return {\"kernel\": kernel.astype(np.float32) / np.sum(kernel)}\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.blur.transforms.ZoomBlur","title":"<code>class  ZoomBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply zoom blur transform.</p> <p>Parameters:</p> Name Type Description <code>max_factor</code> <code>float, float) or float</code> <p>range for max factor for blurring. If max_factor is a single float, the range will be (1, limit). Default: (1, 1.31). All max_factor values should be larger than 1.</p> <code>step_factor</code> <code>float, float) or float</code> <p>If single float will be used as step parameter for np.arange. If tuple of float step_factor will be in range <code>[step_factor[0], step_factor[1])</code>. Default: (0.01, 0.03). All step_factor values should be positive.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     unit8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1903.12261</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class ZoomBlur(ImageOnlyTransform):\n    \"\"\"Apply zoom blur transform.\n\n    Args:\n        max_factor ((float, float) or float): range for max factor for blurring.\n            If max_factor is a single float, the range will be (1, limit). Default: (1, 1.31).\n            All max_factor values should be larger than 1.\n        step_factor ((float, float) or float): If single float will be used as step parameter for np.arange.\n            If tuple of float step_factor will be in range `[step_factor[0], step_factor[1])`. Default: (0.01, 0.03).\n            All step_factor values should be positive.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        unit8, float32\n\n    Reference:\n        https://arxiv.org/abs/1903.12261\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        max_factor: OnePlusFloatRangeType = (1, 1.31)\n        step_factor: NonNegativeFloatRangeType = (0.01, 0.03)\n\n    def __init__(\n        self,\n        max_factor: ScaleFloatType = (1, 1.31),\n        step_factor: ScaleFloatType = (0.01, 0.03),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.max_factor = cast(Tuple[float, float], max_factor)\n        self.step_factor = cast(Tuple[float, float], step_factor)\n\n    def apply(self, img: np.ndarray, zoom_factors: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        if zoom_factors is None:\n            msg = \"zoom_factors is None\"\n            raise ValueError(msg)\n\n        return F.zoom_blur(img, zoom_factors)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        max_factor = random.uniform(self.max_factor[0], self.max_factor[1])\n        step_factor = random.uniform(self.step_factor[0], self.step_factor[1])\n        return {\"zoom_factors\": np.arange(1.0, max_factor, step_factor)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"max_factor\", \"step_factor\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops","title":"<code>crops</code>  <code>special</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.functional","title":"<code>functional</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.functional.bbox_crop","title":"<code>def bbox_crop    (bbox, x_min, y_min, x_max, y_max, rows, cols)    </code> [view source on GitHub]","text":"<p>Crop a bounding box.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>x_min</code> <code>int</code> <code>y_min</code> <code>int</code> <code>x_max</code> <code>int</code> <code>y_max</code> <code>int</code> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A cropped bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def bbox_crop(\n    bbox: BoxInternalType, x_min: int, y_min: int, x_max: int, y_max: int, rows: int, cols: int\n) -&gt; BoxInternalType:\n    \"\"\"Crop a bounding box.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        x_min:\n        y_min:\n        x_max:\n        y_max:\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A cropped bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    crop_coords = x_min, y_min, x_max, y_max\n    crop_height = y_max - y_min\n    crop_width = x_max - x_min\n    return crop_bbox_by_coords(bbox, crop_coords, crop_height, crop_width, rows, cols)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.functional.crop_bbox_by_coords","title":"<code>def crop_bbox_by_coords    (bbox, crop_coords, crop_height, crop_width, rows, cols)    </code> [view source on GitHub]","text":"<p>Crop a bounding box using the provided coordinates of bottom-left and top-right corners in pixels and the required height and width of the crop.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A cropped box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>crop_coords</code> <code>Tuple[int, int, int, int]</code> <p>Crop coordinates <code>(x1, y1, x2, y2)</code>.</p> <code>crop_height</code> <code>int</code> <code>crop_width</code> <code>int</code> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A cropped bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def crop_bbox_by_coords(\n    bbox: BoxInternalType,\n    crop_coords: Tuple[int, int, int, int],\n    crop_height: int,\n    crop_width: int,\n    rows: int,\n    cols: int,\n) -&gt; BoxInternalType:\n    \"\"\"Crop a bounding box using the provided coordinates of bottom-left and top-right corners in pixels and the\n    required height and width of the crop.\n\n    Args:\n        bbox: A cropped box `(x_min, y_min, x_max, y_max)`.\n        crop_coords: Crop coordinates `(x1, y1, x2, y2)`.\n        crop_height:\n        crop_width:\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A cropped bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    normalized_bbox = denormalize_bbox(bbox, rows, cols)\n    x_min, y_min, x_max, y_max = normalized_bbox[:4]\n    x1, y1 = crop_coords[:2]\n    cropped_bbox = x_min - x1, y_min - y1, x_max - x1, y_max - y1\n    return cast(BoxInternalType, normalize_bbox(cropped_bbox, crop_height, crop_width))\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.functional.crop_keypoint_by_coords","title":"<code>def crop_keypoint_by_coords    (keypoint, crop_coords)    </code> [view source on GitHub]","text":"<p>Crop a keypoint using the provided coordinates of bottom-left and top-right corners in pixels and the required height and width of the crop.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>tuple</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>crop_coords</code> <code>tuple</code> <p>Crop box coords <code>(x1, x2, y1, y2)</code>.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def crop_keypoint_by_coords(\n    keypoint: KeypointInternalType, crop_coords: Tuple[int, int, int, int]\n) -&gt; KeypointInternalType:\n    \"\"\"Crop a keypoint using the provided coordinates of bottom-left and top-right corners in pixels and the\n    required height and width of the crop.\n\n    Args:\n        keypoint (tuple): A keypoint `(x, y, angle, scale)`.\n        crop_coords (tuple): Crop box coords `(x1, x2, y1, y2)`.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    x1, y1 = crop_coords[:2]\n    return x - x1, y - y1, angle, scale\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.functional.keypoint_center_crop","title":"<code>def keypoint_center_crop    (keypoint, crop_height, crop_width, rows, cols)    </code> [view source on GitHub]","text":"<p>Keypoint center crop.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>crop_height</code> <code>int</code> <p>Crop height.</p> <code>crop_width</code> <code>int</code> <p>Crop width.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def keypoint_center_crop(\n    keypoint: KeypointInternalType, crop_height: int, crop_width: int, rows: int, cols: int\n) -&gt; KeypointInternalType:\n    \"\"\"Keypoint center crop.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        crop_height: Crop height.\n        crop_width: Crop width.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    crop_coords = get_center_crop_coords(rows, cols, crop_height, crop_width)\n    return crop_keypoint_by_coords(keypoint, crop_coords)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.functional.keypoint_random_crop","title":"<code>def keypoint_random_crop    (keypoint, crop_height, crop_width, h_start, w_start, rows, cols)    </code> [view source on GitHub]","text":"<p>Keypoint random crop.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>(tuple): A keypoint <code>(x, y, angle, scale)</code>.</p> <code>crop_height</code> <code>int</code> <p>Crop height.</p> <code>crop_width</code> <code>int</code> <p>Crop width.</p> <code>h_start</code> <code>int</code> <p>Crop height start.</p> <code>w_start</code> <code>int</code> <p>Crop width start.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def keypoint_random_crop(\n    keypoint: KeypointInternalType,\n    crop_height: int,\n    crop_width: int,\n    h_start: float,\n    w_start: float,\n    rows: int,\n    cols: int,\n) -&gt; KeypointInternalType:\n    \"\"\"Keypoint random crop.\n\n    Args:\n        keypoint: (tuple): A keypoint `(x, y, angle, scale)`.\n        crop_height (int): Crop height.\n        crop_width (int): Crop width.\n        h_start (int): Crop height start.\n        w_start (int): Crop width start.\n        rows (int): Image height.\n        cols (int): Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    crop_coords = get_random_crop_coords(rows, cols, crop_height, crop_width, h_start, w_start)\n    return crop_keypoint_by_coords(keypoint, crop_coords)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms","title":"<code>transforms</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.BBoxSafeRandomCrop","title":"<code>class  BBoxSafeRandomCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop a random part of the input without loss of bboxes.</p> <p>Parameters:</p> Name Type Description <code>erosion_rate</code> <p>erosion rate applied on input image height before crop.</p> <code>p</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class BBoxSafeRandomCrop(DualTransform):\n    \"\"\"Crop a random part of the input without loss of bboxes.\n\n    Args:\n        erosion_rate: erosion rate applied on input image height before crop.\n        p: probability of applying the transform. Default: 1.\n    Targets:\n        image, mask, bboxes\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        erosion_rate: float = Field(\n            default=0.0, ge=0.0, le=1.0, description=\"Erosion rate applied on input image height before crop.\"\n        )\n        p: ProbabilityType = 1\n\n    def __init__(self, erosion_rate: float = 0.0, always_apply: bool = False, p: float = 1.0):\n        super().__init__(always_apply, p)\n        self.erosion_rate = erosion_rate\n\n    def apply(\n        self,\n        img: np.ndarray,\n        crop_height: int = 0,\n        crop_width: int = 0,\n        h_start: int = 0,\n        w_start: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.random_crop(img, crop_height, crop_width, h_start, w_start)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Union[int, float]]:\n        img_h, img_w = params[\"image\"].shape[:2]\n        if len(params[\"bboxes\"]) == 0:  # less likely, this class is for use with bboxes.\n            erosive_h = int(img_h * (1.0 - self.erosion_rate))\n            crop_height = img_h if erosive_h &gt;= img_h else random.randint(erosive_h, img_h)\n            return {\n                \"h_start\": random.random(),\n                \"w_start\": random.random(),\n                \"crop_height\": crop_height,\n                \"crop_width\": int(crop_height * img_w / img_h),\n            }\n        # get union of all bboxes\n        x, y, x2, y2 = union_of_bboxes(\n            width=img_w, height=img_h, bboxes=params[\"bboxes\"], erosion_rate=self.erosion_rate\n        )\n        # find bigger region\n        bx, by = x * random.random(), y * random.random()\n        bx2, by2 = x2 + (1 - x2) * random.random(), y2 + (1 - y2) * random.random()\n        bw, bh = bx2 - bx, by2 - by\n        crop_height = img_h if bh &gt;= 1.0 else int(img_h * bh)\n        crop_width = img_w if bw &gt;= 1.0 else int(img_w * bw)\n        h_start = np.clip(0.0 if bh &gt;= 1.0 else by / (1.0 - bh), 0.0, 1.0)\n        w_start = np.clip(0.0 if bw &gt;= 1.0 else bx / (1.0 - bw), 0.0, 1.0)\n        return {\"h_start\": h_start, \"w_start\": w_start, \"crop_height\": crop_height, \"crop_width\": crop_width}\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        crop_height: int = 0,\n        crop_width: int = 0,\n        h_start: int = 0,\n        w_start: int = 0,\n        rows: int = 0,\n        cols: int = 0,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.bbox_random_crop(bbox, crop_height, crop_width, h_start, w_start, rows, cols)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\", \"bboxes\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"erosion_rate\",)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.CenterCrop","title":"<code>class  CenterCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop the central part of the input.</p> <p>Parameters:</p> Name Type Description <code>height</code> <p>height of the crop.</p> <code>width</code> <p>width of the crop.</p> <code>p</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class CenterCrop(DualTransform):\n    \"\"\"Crop the central part of the input.\n\n    Args:\n        height: height of the crop.\n        width: width of the crop.\n        p: probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(CropInitSchema):\n        pass\n\n    def __init__(self, height: int, width: int, always_apply: bool = False, p: float = 1.0):\n        super().__init__(always_apply, p)\n        self.height = height\n        self.width = width\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.center_crop(img, self.height, self.width)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_center_crop(bbox, self.height, self.width, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_center_crop(keypoint, self.height, self.width, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"height\", \"width\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.Crop","title":"<code>class  Crop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop region from image.</p> <p>Parameters:</p> Name Type Description <code>x_min</code> <p>Minimum upper left x coordinate.</p> <code>y_min</code> <p>Minimum upper left y coordinate.</p> <code>x_max</code> <p>Maximum lower right x coordinate.</p> <code>y_max</code> <p>Maximum lower right y coordinate.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class Crop(DualTransform):\n    \"\"\"Crop region from image.\n\n    Args:\n        x_min: Minimum upper left x coordinate.\n        y_min: Minimum upper left y coordinate.\n        x_max: Maximum lower right x coordinate.\n        y_max: Maximum lower right y coordinate.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        x_min: Annotated[int, Field(ge=0, description=\"Minimum upper left x coordinate\")]\n        y_min: Annotated[int, Field(ge=0, description=\"Minimum upper left y coordinate\")]\n        x_max: Annotated[int, Field(gt=0, description=\"Maximum lower right x coordinate\")]\n        y_max: Annotated[int, Field(gt=0, description=\"Maximum lower right y coordinate\")]\n        p: ProbabilityType = 1\n\n        @model_validator(mode=\"after\")\n        def validate_coordinates(self) -&gt; Self:\n            if not self.x_min &lt; self.x_max:\n                msg = \"x_max must be greater than x_min\"\n                raise ValueError(msg)\n            if not self.y_min &lt; self.y_max:\n                msg = \"y_max must be greater than y_min\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        x_min: int = 0,\n        y_min: int = 0,\n        x_max: int = 1024,\n        y_max: int = 1024,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n        self.x_min = x_min\n        self.y_min = y_min\n        self.x_max = x_max\n        self.y_max = y_max\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.crop(img, x_min=self.x_min, y_min=self.y_min, x_max=self.x_max, y_max=self.y_max)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_crop(bbox, x_min=self.x_min, y_min=self.y_min, x_max=self.x_max, y_max=self.y_max, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.crop_keypoint_by_coords(keypoint, crop_coords=(self.x_min, self.y_min, self.x_max, self.y_max))\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"x_min\", \"y_min\", \"x_max\", \"y_max\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.CropAndPad","title":"<code>class  CropAndPad</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop and pad images by pixel amounts or fractions of image sizes. Cropping removes pixels at the sides (i.e. extracts a subimage from a given full image). Padding adds pixels to the sides (e.g. black pixels). This transformation will never crop images below a height or width of <code>1</code>.</p> <p>Note</p> <p>This transformation automatically resizes images back to their original size. To deactivate this, add the parameter <code>keep_size=False</code>.</p> <p>Parameters:</p> Name Type Description <code>px</code> <code>int or tuple</code> <p>The number of pixels to crop (negative values) or pad (positive values) on each side of the image. Either this or the parameter <code>percent</code> may be set, not both at the same time.     * If <code>None</code>, then pixel-based cropping/padding will not be used.     * If <code>int</code>, then that exact number of pixels will always be cropped/padded.     * If a <code>tuple</code> of two <code>int</code> s with values <code>a</code> and <code>b</code>,       then each side will be cropped/padded by a random amount sampled       uniformly per image and side from the interval <code>[a, b]</code>. If       however <code>sample_independently</code> is set to <code>False</code>, only one       value will be sampled per image and used for all sides.     * If a <code>tuple</code> of four entries, then the entries represent top,       right, bottom, left. Each entry may be a single <code>int</code> (always       crop/pad by exactly that value), a <code>tuple</code> of two <code>int</code> s       <code>a</code> and <code>b</code> (crop/pad by an amount within <code>[a, b]</code>), a       <code>list</code> of <code>int</code> s (crop/pad by a random value that is       contained in the <code>list</code>).</p> <code>percent</code> <code>float or tuple</code> <p>The number of pixels to crop (negative values) or pad (positive values) on each side of the image given as a fraction of the image height/width. E.g. if this is set to <code>-0.1</code>, the transformation will always crop away <code>10%</code> of the image's height at both the top and the bottom (both <code>10%</code> each), as well as <code>10%</code> of the width at the right and left. Expected value range is <code>(-1.0, inf)</code>. Either this or the parameter <code>px</code> may be set, not both at the same time.     * If <code>None</code>, then fraction-based cropping/padding will not be       used.     * If <code>float</code>, then that fraction will always be cropped/padded.     * If a <code>tuple</code> of two <code>float</code> s with values <code>a</code> and <code>b</code>,       then each side will be cropped/padded by a random fraction       sampled uniformly per image and side from the interval       <code>[a, b]</code>. If however <code>sample_independently</code> is set to       <code>False</code>, only one value will be sampled per image and used for       all sides.     * If a <code>tuple</code> of four entries, then the entries represent top,       right, bottom, left. Each entry may be a single <code>float</code>       (always crop/pad by exactly that percent value), a <code>tuple</code> of       two <code>float</code> s <code>a</code> and <code>b</code> (crop/pad by a fraction from       <code>[a, b]</code>), a <code>list</code> of <code>float</code> s (crop/pad by a random       value that is contained in the list).</p> <code>pad_mode</code> <code>int</code> <p>OpenCV border mode.</p> <code>pad_cval</code> <code>number, Sequence[number]</code> <p>The constant value to use if the pad mode is <code>BORDER_CONSTANT</code>.     * If <code>number</code>, then that value will be used.     * If a <code>tuple</code> of two <code>number</code> s and at least one of them is       a <code>float</code>, then a random number will be uniformly sampled per       image from the continuous interval <code>[a, b]</code> and used as the       value. If both <code>number</code> s are <code>int</code> s, the interval is       discrete.     * If a <code>list</code> of <code>number</code>, then a random value will be chosen       from the elements of the <code>list</code> and used as the value.</p> <code>pad_cval_mask</code> <code>number, Sequence[number]</code> <p>Same as pad_cval but only for masks.</p> <code>keep_size</code> <code>bool</code> <p>After cropping and padding, the result image will usually have a different height/width compared to the original input image. If this parameter is set to <code>True</code>, then the cropped/padded image will be resized to the input image's size, i.e. the output shape is always identical to the input shape.</p> <code>sample_independently</code> <code>bool</code> <p>If <code>False</code> and the values for <code>px</code>/<code>percent</code> result in exactly one probability distribution for all image sides, only one single value will be sampled from that probability distribution and used for all sides. I.e. the crop/pad amount then is the same for all sides. If <code>True</code>, four values will be sampled independently, one per side.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     any</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class CropAndPad(DualTransform):\n    \"\"\"Crop and pad images by pixel amounts or fractions of image sizes.\n    Cropping removes pixels at the sides (i.e. extracts a subimage from a given full image).\n    Padding adds pixels to the sides (e.g. black pixels).\n    This transformation will never crop images below a height or width of ``1``.\n\n    Note:\n        This transformation automatically resizes images back to their original size. To deactivate this, add the\n        parameter ``keep_size=False``.\n\n    Args:\n        px (int or tuple):\n            The number of pixels to crop (negative values) or pad (positive values)\n            on each side of the image. Either this or the parameter `percent` may\n            be set, not both at the same time.\n                * If ``None``, then pixel-based cropping/padding will not be used.\n                * If ``int``, then that exact number of pixels will always be cropped/padded.\n                * If a ``tuple`` of two ``int`` s with values ``a`` and ``b``,\n                  then each side will be cropped/padded by a random amount sampled\n                  uniformly per image and side from the interval ``[a, b]``. If\n                  however `sample_independently` is set to ``False``, only one\n                  value will be sampled per image and used for all sides.\n                * If a ``tuple`` of four entries, then the entries represent top,\n                  right, bottom, left. Each entry may be a single ``int`` (always\n                  crop/pad by exactly that value), a ``tuple`` of two ``int`` s\n                  ``a`` and ``b`` (crop/pad by an amount within ``[a, b]``), a\n                  ``list`` of ``int`` s (crop/pad by a random value that is\n                  contained in the ``list``).\n        percent (float or tuple):\n            The number of pixels to crop (negative values) or pad (positive values)\n            on each side of the image given as a *fraction* of the image\n            height/width. E.g. if this is set to ``-0.1``, the transformation will\n            always crop away ``10%`` of the image's height at both the top and the\n            bottom (both ``10%`` each), as well as ``10%`` of the width at the\n            right and left.\n            Expected value range is ``(-1.0, inf)``.\n            Either this or the parameter `px` may be set, not both\n            at the same time.\n                * If ``None``, then fraction-based cropping/padding will not be\n                  used.\n                * If ``float``, then that fraction will always be cropped/padded.\n                * If a ``tuple`` of two ``float`` s with values ``a`` and ``b``,\n                  then each side will be cropped/padded by a random fraction\n                  sampled uniformly per image and side from the interval\n                  ``[a, b]``. If however `sample_independently` is set to\n                  ``False``, only one value will be sampled per image and used for\n                  all sides.\n                * If a ``tuple`` of four entries, then the entries represent top,\n                  right, bottom, left. Each entry may be a single ``float``\n                  (always crop/pad by exactly that percent value), a ``tuple`` of\n                  two ``float`` s ``a`` and ``b`` (crop/pad by a fraction from\n                  ``[a, b]``), a ``list`` of ``float`` s (crop/pad by a random\n                  value that is contained in the list).\n        pad_mode (int): OpenCV border mode.\n        pad_cval (number, Sequence[number]):\n            The constant value to use if the pad mode is ``BORDER_CONSTANT``.\n                * If ``number``, then that value will be used.\n                * If a ``tuple`` of two ``number`` s and at least one of them is\n                  a ``float``, then a random number will be uniformly sampled per\n                  image from the continuous interval ``[a, b]`` and used as the\n                  value. If both ``number`` s are ``int`` s, the interval is\n                  discrete.\n                * If a ``list`` of ``number``, then a random value will be chosen\n                  from the elements of the ``list`` and used as the value.\n        pad_cval_mask (number, Sequence[number]): Same as pad_cval but only for masks.\n        keep_size (bool):\n            After cropping and padding, the result image will usually have a\n            different height/width compared to the original input image. If this\n            parameter is set to ``True``, then the cropped/padded image will be\n            resized to the input image's size, i.e. the output shape is always identical to the input shape.\n        sample_independently (bool):\n            If ``False`` *and* the values for `px`/`percent` result in exactly\n            *one* probability distribution for all image sides, only one single\n            value will be sampled from that probability distribution and used for\n            all sides. I.e. the crop/pad amount then is the same for all sides.\n            If ``True``, four values will be sampled independently, one per side.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        any\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        px: Optional[Union[int, Tuple[int, int], Tuple[int, int, int, int]]] = Field(\n            default=None, description=\"Number of pixels to crop (negative) or pad (positive).\"\n        )\n        percent: Optional[Union[float, Tuple[float, float], Tuple[float, float, float, float]]] = Field(\n            default=None, description=\"Fraction of image size to crop (negative) or pad (positive).\"\n        )\n        pad_mode: BorderModeType = cv2.BORDER_CONSTANT\n        pad_cval: ColorType = Field(default=0, description=\"Padding value if pad_mode is BORDER_CONSTANT.\")\n        pad_cval_mask: ColorType = Field(\n            default=0, description=\"Padding value for masks if pad_mode is BORDER_CONSTANT.\"\n        )\n        keep_size: bool = Field(\n            default=True,\n            description=\"Whether to resize the image back to the original size after cropping and padding.\",\n        )\n        sample_independently: bool = Field(\n            default=True, description=\"Whether to sample the crop/pad size independently for each side.\"\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        p: ProbabilityType = 1\n\n        @model_validator(mode=\"after\")\n        def check_px_percent(self) -&gt; Self:\n            if self.px is None and self.percent is None:\n                msg = \"px and percent are empty!\"\n                raise ValueError(msg)\n            if self.px is not None and self.percent is not None:\n                msg = \"Only px or percent may be set!\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        px: Optional[Union[int, List[int]]] = None,\n        percent: Optional[Union[float, List[float]]] = None,\n        pad_mode: int = cv2.BORDER_CONSTANT,\n        pad_cval: ColorType = 0,\n        pad_cval_mask: ColorType = 0,\n        keep_size: bool = True,\n        sample_independently: bool = True,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n\n        self.px = px\n        self.percent = percent\n\n        self.pad_mode = pad_mode\n        self.pad_cval = pad_cval\n        self.pad_cval_mask = pad_cval_mask\n\n        self.keep_size = keep_size\n        self.sample_independently = sample_independently\n\n        self.interpolation = interpolation\n\n    def apply(\n        self,\n        img: np.ndarray,\n        crop_params: Sequence[int] = (),\n        pad_params: Sequence[int] = (),\n        pad_value: float = 0,\n        rows: int = 0,\n        cols: int = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.crop_and_pad(\n            img, crop_params, pad_params, pad_value, rows, cols, interpolation, self.pad_mode, self.keep_size\n        )\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        crop_params: Optional[Sequence[int]] = None,\n        pad_params: Optional[Sequence[int]] = None,\n        pad_value_mask: Optional[float] = None,\n        rows: int = 0,\n        cols: int = 0,\n        interpolation: int = cv2.INTER_NEAREST,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.crop_and_pad(\n            mask, crop_params, pad_params, pad_value_mask, rows, cols, interpolation, self.pad_mode, self.keep_size\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        crop_params: Optional[Sequence[int]] = None,\n        pad_params: Optional[Sequence[int]] = None,\n        rows: int = 0,\n        cols: int = 0,\n        result_rows: int = 0,\n        result_cols: int = 0,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.crop_and_pad_bbox(bbox, crop_params, pad_params, rows, cols, result_rows, result_cols)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        crop_params: Optional[Sequence[int]] = None,\n        pad_params: Optional[Sequence[int]] = None,\n        rows: int = 0,\n        cols: int = 0,\n        result_rows: int = 0,\n        result_cols: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.crop_and_pad_keypoint(\n            keypoint, crop_params, pad_params, rows, cols, result_rows, result_cols, self.keep_size\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    @staticmethod\n    def __prevent_zero(val1: int, val2: int, max_val: int) -&gt; Tuple[int, int]:\n        regain = abs(max_val) + 1\n        regain1 = regain // 2\n        regain2 = regain // 2\n        if regain1 + regain2 &lt; regain:\n            regain1 += 1\n\n        if regain1 &gt; val1:\n            diff = regain1 - val1\n            regain1 = val1\n            regain2 += diff\n        elif regain2 &gt; val2:\n            diff = regain2 - val2\n            regain2 = val2\n            regain1 += diff\n\n        val1 = val1 - regain1\n        val2 = val2 - regain2\n\n        return val1, val2\n\n    @staticmethod\n    def _prevent_zero(crop_params: List[int], height: int, width: int) -&gt; List[int]:\n        top, right, bottom, left = crop_params\n\n        remaining_height = height - (top + bottom)\n        remaining_width = width - (left + right)\n\n        if remaining_height &lt; 1:\n            top, bottom = CropAndPad.__prevent_zero(top, bottom, height)\n        if remaining_width &lt; 1:\n            left, right = CropAndPad.__prevent_zero(left, right, width)\n\n        return [max(top, 0), max(right, 0), max(bottom, 0), max(left, 0)]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        if self.px is not None:\n            new_params = self._get_px_params()\n        else:\n            percent_params = self._get_percent_params()\n            new_params = [\n                int(percent_params[0] * height),\n                int(percent_params[1] * width),\n                int(percent_params[2] * height),\n                int(percent_params[3] * width),\n            ]\n\n        pad_params = [max(i, 0) for i in new_params]\n\n        crop_params = self._prevent_zero([-min(i, 0) for i in new_params], height, width)\n\n        top, right, bottom, left = crop_params\n        crop_params = [left, top, width - right, height - bottom]\n        result_rows = crop_params[3] - crop_params[1]\n        result_cols = crop_params[2] - crop_params[0]\n        if result_cols == width and result_rows == height:\n            crop_params = []\n\n        top, right, bottom, left = pad_params\n        pad_params = [top, bottom, left, right]\n        if any(pad_params):\n            result_rows += top + bottom\n            result_cols += left + right\n        else:\n            pad_params = []\n\n        return {\n            \"crop_params\": crop_params or None,\n            \"pad_params\": pad_params or None,\n            \"pad_value\": None if pad_params is None else self._get_pad_value(self.pad_cval),\n            \"pad_value_mask\": None if pad_params is None else self._get_pad_value(self.pad_cval_mask),\n            \"result_rows\": result_rows,\n            \"result_cols\": result_cols,\n        }\n\n    def _get_px_params(self) -&gt; List[int]:\n        if self.px is None:\n            msg = \"px is not set\"\n            raise ValueError(msg)\n\n        if isinstance(self.px, int):\n            params = [self.px] * 4\n        elif len(self.px) == TWO:\n            if self.sample_independently:\n                params = [random.randrange(*self.px) for _ in range(4)]\n            else:\n                px = random.randrange(*self.px)\n                params = [px] * 4\n        elif isinstance(self.px[0], int):\n            params = self.px\n        else:\n            params = [random.randrange(*i) for i in self.px]\n\n        return params\n\n    def _get_percent_params(self) -&gt; List[float]:\n        if self.percent is None:\n            msg = \"percent is not set\"\n            raise ValueError(msg)\n\n        if isinstance(self.percent, float):\n            params = [self.percent] * 4\n        elif len(self.percent) == TWO:\n            if self.sample_independently:\n                params = [random.uniform(*self.percent) for _ in range(4)]\n            else:\n                px = random.uniform(*self.percent)\n                params = [px] * 4\n        elif isinstance(self.percent[0], (int, float)):\n            params = self.percent\n        else:\n            params = [random.uniform(*i) for i in self.percent]\n\n        return params  # params = [top, right, bottom, left]\n\n    @staticmethod\n    def _get_pad_value(pad_value: Union[float, Sequence[float]]) -&gt; Union[int, float]:\n        if isinstance(pad_value, (int, float)):\n            return pad_value\n\n        if len(pad_value) == TWO:\n            a, b = pad_value\n            if isinstance(a, int) and isinstance(b, int):\n                return random.randint(a, b)\n\n            return random.uniform(a, b)\n\n        return random.choice(pad_value)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"px\",\n            \"percent\",\n            \"pad_mode\",\n            \"pad_cval\",\n            \"pad_cval_mask\",\n            \"keep_size\",\n            \"sample_independently\",\n            \"interpolation\",\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.CropNonEmptyMaskIfExists","title":"<code>class  CropNonEmptyMaskIfExists</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop area with mask if mask is non-empty, else make random crop.</p> <p>Parameters:</p> Name Type Description <code>height</code> <p>vertical size of crop in pixels</p> <code>width</code> <p>horizontal size of crop in pixels</p> <code>ignore_values</code> <code>list of int</code> <p>values to ignore in mask, <code>0</code> values are always ignored (e.g. if background value is 5 set <code>ignore_values=[5]</code> to ignore)</p> <code>ignore_channels</code> <code>list of int</code> <p>channels to ignore in mask (e.g. if background is a first channel set <code>ignore_channels=[0]</code> to ignore)</p> <code>p</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class CropNonEmptyMaskIfExists(DualTransform):\n    \"\"\"Crop area with mask if mask is non-empty, else make random crop.\n\n    Args:\n        height: vertical size of crop in pixels\n        width: horizontal size of crop in pixels\n        ignore_values (list of int): values to ignore in mask, `0` values are always ignored\n            (e.g. if background value is 5 set `ignore_values=[5]` to ignore)\n        ignore_channels (list of int): channels to ignore in mask\n            (e.g. if background is a first channel set `ignore_channels=[0]` to ignore)\n        p: probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(CropInitSchema):\n        ignore_values: Optional[List[int]] = Field(\n            default=None, description=\"Values to ignore in mask, `0` values are always ignored\"\n        )\n        ignore_channels: Optional[List[int]] = Field(default=None, description=\"Channels to ignore in mask\")\n\n    def __init__(\n        self,\n        height: int,\n        width: int,\n        ignore_values: Optional[List[int]] = None,\n        ignore_channels: Optional[List[int]] = None,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n\n        self.height = height\n        self.width = width\n        self.ignore_values = ignore_values\n        self.ignore_channels = ignore_channels\n\n    def apply(\n        self, img: np.ndarray, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        return F.crop(img, x_min, y_min, x_max, y_max)\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; BoxInternalType:\n        return F.bbox_crop(\n            bbox, x_min=x_min, x_max=x_max, y_min=y_min, y_max=y_max, rows=params[\"rows\"], cols=params[\"cols\"]\n        )\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        x_min: int = 0,\n        x_max: int = 0,\n        y_min: int = 0,\n        y_max: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.crop_keypoint_by_coords(keypoint, crop_coords=(x_min, y_min, x_max, y_max))\n\n    def _preprocess_mask(self, mask: np.ndarray) -&gt; np.ndarray:\n        mask_height, mask_width = mask.shape[:2]\n\n        if self.ignore_values is not None:\n            ignore_values_np = np.array(self.ignore_values)\n            mask = np.where(np.isin(mask, ignore_values_np), 0, mask)\n\n        if mask.ndim == THREE and self.ignore_channels is not None:\n            target_channels = np.array([ch for ch in range(mask.shape[-1]) if ch not in self.ignore_channels])\n            mask = np.take(mask, target_channels, axis=-1)\n\n        if self.height &gt; mask_height or self.width &gt; mask_width:\n            raise ValueError(\n                f\"Crop size ({self.height},{self.width}) is larger than image ({mask_height},{mask_width})\"\n            )\n\n        return mask\n\n    def update_params(self, params: Dict[str, Any], **kwargs: Any) -&gt; Dict[str, Any]:\n        super().update_params(params, **kwargs)\n        if \"mask\" in kwargs:\n            mask = self._preprocess_mask(kwargs[\"mask\"])\n        elif \"masks\" in kwargs and len(kwargs[\"masks\"]):\n            masks = kwargs[\"masks\"]\n            mask = self._preprocess_mask(np.copy(masks[0]))  # need copy as we perform in-place mod afterwards\n            for m in masks[1:]:\n                mask |= self._preprocess_mask(m)\n        else:\n            msg = \"Can not find mask for CropNonEmptyMaskIfExists\"\n            raise RuntimeError(msg)\n\n        mask_height, mask_width = mask.shape[:2]\n\n        if mask.any():\n            mask = mask.sum(axis=-1) if mask.ndim == THREE else mask\n            non_zero_yx = np.argwhere(mask)\n            y, x = random.choice(non_zero_yx)\n            x_min = x - random.randint(0, self.width - 1)\n            y_min = y - random.randint(0, self.height - 1)\n            x_min = np.clip(x_min, 0, mask_width - self.width)\n            y_min = np.clip(y_min, 0, mask_height - self.height)\n        else:\n            x_min = random.randint(0, mask_width - self.width)\n            y_min = random.randint(0, mask_height - self.height)\n\n        x_max = x_min + self.width\n        y_max = y_min + self.height\n\n        params.update({\"x_min\": x_min, \"x_max\": x_max, \"y_min\": y_min, \"y_max\": y_max})\n        return params\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"height\", \"width\", \"ignore_values\", \"ignore_channels\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.RandomCrop","title":"<code>class  RandomCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop a random part of the input.</p> <p>Parameters:</p> Name Type Description <code>height</code> <p>height of the crop.</p> <code>width</code> <p>width of the crop.</p> <code>p</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomCrop(DualTransform):\n    \"\"\"Crop a random part of the input.\n\n    Args:\n        height: height of the crop.\n        width: width of the crop.\n        p: probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(CropInitSchema):\n        pass\n\n    def __init__(self, height: int, width: int, always_apply: bool = False, p: float = 1.0):\n        super().__init__(always_apply, p)\n        self.height = height\n        self.width = width\n\n    def apply(self, img: np.ndarray, h_start: int = 0, w_start: int = 0, **params: Any) -&gt; np.ndarray:\n        return F.random_crop(img, self.height, self.width, h_start, w_start)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"h_start\": random.random(), \"w_start\": random.random()}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_random_crop(bbox, self.height, self.width, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_random_crop(keypoint, self.height, self.width, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"height\", \"width\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.RandomCropFromBorders","title":"<code>class  RandomCropFromBorders</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop bbox from image randomly cut parts from borders without resize at the end</p> <p>Parameters:</p> Name Type Description <code>crop_left</code> <code>float</code> <p>single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut</p> <code>crop_right</code> <code>float</code> <p>single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut</p> <code>crop_top</code> <code>float</code> <p>singlefloat value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut</p> <code>crop_bottom</code> <code>float</code> <p>single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomCropFromBorders(DualTransform):\n    \"\"\"Crop bbox from image randomly cut parts from borders without resize at the end\n\n    Args:\n        crop_left (float): single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut\n        from left side in range [0, crop_left * width)\n        crop_right (float): single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut\n        from right side in range [(1 - crop_right) * width, width)\n        crop_top (float): singlefloat value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut\n        from top side in range [0, crop_top * height)\n        crop_bottom (float): single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut\n        from bottom side in range [(1 - crop_bottom) * height, height)\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        crop_left: float = Field(\n            default=0.1, ge=0.0, le=1.0, description=\"Fraction of width to randomly crop from the left side.\"\n        )\n        crop_right: float = Field(\n            default=0.1, ge=0.0, le=1.0, description=\"Fraction of width to randomly crop from the right side.\"\n        )\n        crop_top: float = Field(\n            default=0.1, ge=0.0, le=1.0, description=\"Fraction of height to randomly crop from the top side.\"\n        )\n        crop_bottom: float = Field(\n            default=0.1, ge=0.0, le=1.0, description=\"Fraction of height to randomly crop from the bottom side.\"\n        )\n        p: ProbabilityType = 1\n\n        @model_validator(mode=\"after\")\n        def validate_crop_values(self) -&gt; Self:\n            if self.crop_left + self.crop_right &gt;= 1.0:\n                msg = \"The sum of crop_left and crop_right must be less than 1.\"\n                raise ValueError(msg)\n            if self.crop_top + self.crop_bottom &gt;= 1.0:\n                msg = \"The sum of crop_top and crop_bottom must be less than 1.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        crop_left: float = 0.1,\n        crop_right: float = 0.1,\n        crop_top: float = 0.1,\n        crop_bottom: float = 0.1,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n        self.crop_left = crop_left\n        self.crop_right = crop_right\n        self.crop_top = crop_top\n        self.crop_bottom = crop_bottom\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, int]:\n        img = params[\"image\"]\n        x_min = random_utils.randint(0, int(self.crop_left * img.shape[1]))\n        x_max = random_utils.randint(max(x_min + 1, int((1 - self.crop_right) * img.shape[1])), img.shape[1])\n        y_min = random_utils.randint(0, int(self.crop_top * img.shape[0]))\n        y_max = random_utils.randint(max(y_min + 1, int((1 - self.crop_bottom) * img.shape[0])), img.shape[0])\n        return {\"x_min\": x_min, \"x_max\": x_max, \"y_min\": y_min, \"y_max\": y_max}\n\n    def apply(\n        self, img: np.ndarray, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        return F.clamping_crop(img, x_min, y_min, x_max, y_max)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        return F.clamping_crop(mask, x_min, y_min, x_max, y_max)\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        return F.bbox_crop(bbox, x_min, y_min, x_max, y_max, rows, cols)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        x_min: int = 0,\n        x_max: int = 0,\n        y_min: int = 0,\n        y_max: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.crop_keypoint_by_coords(keypoint, crop_coords=(x_min, y_min, x_max, y_max))\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"crop_left\", \"crop_right\", \"crop_top\", \"crop_bottom\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.RandomCropNearBBox","title":"<code>class  RandomCropNearBBox</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop bbox from image with random shift by x,y coordinates</p> <p>Parameters:</p> Name Type Description <code>max_part_shift</code> <code>float, (float, float</code> <p>Max shift in <code>height</code> and <code>width</code> dimensions relative to <code>cropping_bbox</code> dimension. If max_part_shift is a single float, the range will be (0, max_part_shift). Default (0, 0.3).</p> <code>cropping_bbox_key</code> <code>str</code> <p>Additional target key for cropping box. Default <code>cropping_bbox</code>.</p> <code>cropping_box_key</code> <code>str</code> <p>[Deprecated] Use <code>cropping_bbox_key</code> instead.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; aug = Compose([RandomCropNearBBox(max_part_shift=(0.1, 0.5), cropping_bbox_key='test_box')],\n&gt;&gt;&gt;              bbox_params=BboxParams(\"pascal_voc\"))\n&gt;&gt;&gt; result = aug(image=image, bboxes=bboxes, test_box=[0, 5, 10, 20])\n</code></pre> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomCropNearBBox(DualTransform):\n    \"\"\"Crop bbox from image with random shift by x,y coordinates\n\n    Args:\n        max_part_shift (float, (float, float)): Max shift in `height` and `width` dimensions relative\n            to `cropping_bbox` dimension.\n            If max_part_shift is a single float, the range will be (0, max_part_shift).\n            Default (0, 0.3).\n        cropping_bbox_key (str): Additional target key for cropping box. Default `cropping_bbox`.\n        cropping_box_key (str): [Deprecated] Use `cropping_bbox_key` instead.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    Examples:\n        &gt;&gt;&gt; aug = Compose([RandomCropNearBBox(max_part_shift=(0.1, 0.5), cropping_bbox_key='test_box')],\n        &gt;&gt;&gt;              bbox_params=BboxParams(\"pascal_voc\"))\n        &gt;&gt;&gt; result = aug(image=image, bboxes=bboxes, test_box=[0, 5, 10, 20])\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        max_part_shift: ZeroOneRangeType = (0, 0.3)\n        cropping_bbox_key: str = Field(default=\"cropping_bbox\", description=\"Additional target key for cropping box.\")\n        p: ProbabilityType = 1\n\n    def __init__(\n        self,\n        max_part_shift: ScaleFloatType = (0, 0.3),\n        cropping_bbox_key: str = \"cropping_bbox\",\n        cropping_box_key: Optional[str] = None,  # Deprecated\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n        # Check for deprecated parameter and issue warning\n        if cropping_box_key is not None:\n            warn(\n                \"The parameter 'cropping_box_key' is deprecated and will be removed in future versions. \"\n                \"Use 'cropping_bbox_key' instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            # Ensure the new parameter is used even if the old one is passed\n            cropping_bbox_key = cropping_box_key\n\n        self.max_part_shift = cast(Tuple[float, float], max_part_shift)\n        self.cropping_bbox_key = cropping_bbox_key\n\n    def apply(\n        self, img: np.ndarray, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        return F.clamping_crop(img, x_min, y_min, x_max, y_max)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, int]:\n        bbox = params[self.cropping_bbox_key]\n        h_max_shift = round((bbox[3] - bbox[1]) * self.max_part_shift[0])\n        w_max_shift = round((bbox[2] - bbox[0]) * self.max_part_shift[1])\n\n        x_min = bbox[0] - random.randint(-w_max_shift, w_max_shift)\n        x_max = bbox[2] + random.randint(-w_max_shift, w_max_shift)\n\n        y_min = bbox[1] - random.randint(-h_max_shift, h_max_shift)\n        y_max = bbox[3] + random.randint(-h_max_shift, h_max_shift)\n\n        x_min = max(0, x_min)\n        y_min = max(0, y_min)\n\n        return {\"x_min\": x_min, \"x_max\": x_max, \"y_min\": y_min, \"y_max\": y_max}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_crop(bbox, **params)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        x_min: int = 0,\n        x_max: int = 0,\n        y_min: int = 0,\n        y_max: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.crop_keypoint_by_coords(keypoint, crop_coords=(x_min, y_min, x_max, y_max))\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [self.cropping_bbox_key]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"max_part_shift\", \"cropping_bbox_key\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.RandomResizedCrop","title":"<code>class  RandomResizedCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Torchvision's variant of crop a random part of the input and rescale it to some size.</p> <p>Parameters:</p> Name Type Description <code>size</code> <code>int, int</code> <p>target size for the output image, i.e. (height, width) after crop and resize</p> <code>scale</code> <code>float, float</code> <p>range of size of the origin size cropped</p> <code>ratio</code> <code>float, float</code> <p>range of aspect ratio of the origin aspect ratio cropped</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomResizedCrop(_BaseRandomSizedCrop):\n    \"\"\"Torchvision's variant of crop a random part of the input and rescale it to some size.\n\n    Args:\n        size (int, int): target size for the output image, i.e. (height, width) after crop and resize\n        scale ((float, float)): range of size of the origin size cropped\n        ratio ((float, float)): range of aspect ratio of the origin aspect ratio cropped\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: ZeroOneRangeType = (0.08, 1.0)\n        ratio: NonNegativeFloatRangeType = (0.75, 1.3333333333333333)\n        width: Optional[int] = None\n        height: Optional[int] = None\n        size: Optional[ScaleIntType] = None\n        p: ProbabilityType = 1\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n        @model_validator(mode=\"after\")\n        def process(self) -&gt; Self:\n            if isinstance(self.size, int):\n                if isinstance(self.width, int):\n                    self.size = (self.size, self.width)\n                    warn(\n                        \"Initializing with 'size' as an integer and a separate 'width' is deprecated. \"\n                        \"Please use a tuple (height, width) for the 'size' argument.\",\n                        DeprecationWarning,\n                        stacklevel=2,\n                    )\n                else:\n                    msg = \"If size is an integer, width as integer must be specified.\"\n                    raise TypeError(msg)\n\n            if self.size is None:\n                if self.height is None or self.width is None:\n                    message = \"If 'size' is not provided, both 'height' and 'width' must be specified.\"\n                    raise ValueError(message)\n                self.size = (self.height, self.width)\n                warn(\n                    \"Initializing with 'height' and 'width' is deprecated. \"\n                    \"Please use a tuple (height, width) for the 'size' argument.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n\n            return self\n\n    def __init__(\n        self,\n        # NOTE @zetyquickly: when (width, height) are deprecated, make 'size' non optional\n        size: Optional[ScaleIntType] = None,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        *,\n        scale: Tuple[float, float] = (0.08, 1.0),\n        ratio: Tuple[float, float] = (0.75, 1.3333333333333333),\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(size=cast(Tuple[int, int], size), interpolation=interpolation, always_apply=always_apply, p=p)\n        self.scale = scale\n        self.ratio = ratio\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Union[int, float]]:\n        img = params[\"image\"]\n        img_height, img_width = img.shape[:2]\n        area = img_height * img_width\n\n        for _ in range(10):\n            target_area = random_utils.uniform(*self.scale) * area\n            log_ratio = (math.log(self.ratio[0]), math.log(self.ratio[1]))\n            aspect_ratio = math.exp(random_utils.uniform(*log_ratio))\n\n            width = int(round(math.sqrt(target_area * aspect_ratio)))\n            height = int(round(math.sqrt(target_area / aspect_ratio)))\n\n            if 0 &lt; width &lt;= img_width and 0 &lt; height &lt;= img_height:\n                i = random.randint(0, img_height - height)\n                j = random.randint(0, img_width - width)\n                return {\n                    \"crop_height\": height,\n                    \"crop_width\": width,\n                    \"h_start\": i * 1.0 / (img_height - height + 1e-10),\n                    \"w_start\": j * 1.0 / (img_width - width + 1e-10),\n                }\n\n        # Fallback to central crop\n        in_ratio = img_width / img_height\n        if in_ratio &lt; min(self.ratio):\n            width = img_width\n            height = int(round(img_width / min(self.ratio)))\n        elif in_ratio &gt; max(self.ratio):\n            height = img_height\n            width = int(round(height * max(self.ratio)))\n        else:  # whole image\n            width = img_width\n            height = img_height\n        i = (img_height - height) // 2\n        j = (img_width - width) // 2\n        return {\n            \"crop_height\": height,\n            \"crop_width\": width,\n            \"h_start\": i * 1.0 / (img_height - height + 1e-10),\n            \"w_start\": j * 1.0 / (img_width - width + 1e-10),\n        }\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"size\", \"scale\", \"ratio\", \"interpolation\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.RandomSizedBBoxSafeCrop","title":"<code>class  RandomSizedBBoxSafeCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop a random part of the input and rescale it to some size without loss of bboxes.</p> <p>Parameters:</p> Name Type Description <code>height</code> <p>height after crop and resize.</p> <code>width</code> <p>width after crop and resize.</p> <code>erosion_rate</code> <p>erosion rate applied on input image height before crop.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomSizedBBoxSafeCrop(BBoxSafeRandomCrop):\n    \"\"\"Crop a random part of the input and rescale it to some size without loss of bboxes.\n\n    Args:\n        height: height after crop and resize.\n        width: width after crop and resize.\n        erosion_rate: erosion rate applied on input image height before crop.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n    Targets:\n        image, mask, bboxes\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(CropInitSchema):\n        erosion_rate: float = Field(\n            default=0.0, ge=0.0, le=1.0, description=\"Erosion rate applied on input image height before crop.\"\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n    def __init__(\n        self,\n        height: int,\n        width: int,\n        erosion_rate: float = 0.0,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(erosion_rate, always_apply, p)\n        self.height = height\n        self.width = width\n        self.interpolation = interpolation\n\n    def apply(\n        self,\n        img: np.ndarray,\n        crop_height: int = 0,\n        crop_width: int = 0,\n        h_start: int = 0,\n        w_start: int = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        crop = F.random_crop(img, crop_height, crop_width, h_start, w_start)\n        return FGeometric.resize(crop, self.height, self.width, interpolation)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (*super().get_transform_init_args_names(), \"height\", \"width\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.crops.transforms.RandomSizedCrop","title":"<code>class  RandomSizedCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop a random portion of the input and rescale it to a specific size.</p> <p>Parameters:</p> Name Type Description <code>min_max_height</code> <code>int, int</code> <p>crop size limits.</p> <code>size</code> <code>int, int</code> <p>target size for the output image, i.e. (height, width) after crop and resize</p> <code>w2h_ratio</code> <code>float</code> <p>aspect ratio of crop.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomSizedCrop(_BaseRandomSizedCrop):\n    \"\"\"Crop a random portion of the input and rescale it to a specific size.\n\n    Args:\n        min_max_height ((int, int)): crop size limits.\n        size ((int, int)): target size for the output image, i.e. (height, width) after crop and resize\n        w2h_ratio (float): aspect ratio of crop.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        p: ProbabilityType = 1\n        min_max_height: OnePlusIntRangeType\n        w2h_ratio: Annotated[float, Field(gt=0, description=\"Aspect ratio of crop.\")]\n        width: Optional[int] = None\n        height: Optional[int] = None\n        size: Optional[ScaleIntType] = None\n\n        @model_validator(mode=\"after\")\n        def process(self) -&gt; Self:\n            if isinstance(self.size, int):\n                if isinstance(self.width, int):\n                    self.size = (self.size, self.width)\n                    warn(\n                        \"Initializing with 'size' as an integer and a separate 'width' is deprecated. \"\n                        \"Please use a tuple (height, width) for the 'size' argument.\",\n                        DeprecationWarning,\n                        stacklevel=2,\n                    )\n                else:\n                    msg = \"If size is an integer, width as integer must be specified.\"\n                    raise TypeError(msg)\n\n            if self.size is None:\n                if self.height is None or self.width is None:\n                    message = \"If 'size' is not provided, both 'height' and 'width' must be specified.\"\n                    raise ValueError(message)\n                self.size = (self.height, self.width)\n                warn(\n                    \"Initializing with 'height' and 'width' is deprecated. \"\n                    \"Please use a tuple (height, width) for the 'size' argument.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n\n            return self\n\n    def __init__(\n        self,\n        min_max_height: Tuple[int, int],\n        # NOTE @zetyquickly: when (width, height) are deprecated, make 'size' non optional\n        size: Optional[ScaleIntType] = None,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        *,\n        w2h_ratio: float = 1.0,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(size=cast(Tuple[int, int], size), interpolation=interpolation, always_apply=always_apply, p=p)\n        self.min_max_height = min_max_height\n        self.w2h_ratio = w2h_ratio\n\n    def get_params(self) -&gt; Dict[str, Union[int, float]]:\n        crop_height = random_utils.randint(self.min_max_height[0], self.min_max_height[1])\n        return {\n            \"h_start\": random.random(),\n            \"w_start\": random.random(),\n            \"crop_height\": crop_height,\n            \"crop_width\": int(crop_height * self.w2h_ratio),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"min_max_height\", \"size\", \"w2h_ratio\", \"interpolation\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.domain_adaptation","title":"<code>domain_adaptation</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.domain_adaptation.FDA","title":"<code>class  FDA</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Fourier Domain Adaptation (FDA) for simple \"style transfer\" in the context of unsupervised domain adaptation (UDA). FDA manipulates the frequency components of images to reduce the domain gap between source and target datasets, effectively adapting images from one domain to closely resemble those from another without altering their semantic content.</p> <p>This transform is particularly beneficial in scenarios where the training (source) and testing (target) images come from different distributions, such as synthetic versus real images, or day versus night scenes. Unlike traditional domain adaptation methods that may require complex adversarial training, FDA achieves domain alignment by swapping low-frequency components of the Fourier transform between the source and target images. This technique has shown to improve the performance of models on the target domain, particularly for tasks like semantic segmentation, without additional training for domain invariance.</p> <p>The 'beta_limit' parameter controls the extent of frequency component swapping, with lower values preserving more of the original image's characteristics and higher values leading to more pronounced adaptation effects. It is recommended to use beta values less than 0.3 to avoid introducing artifacts.</p> <p>Parameters:</p> Name Type Description <code>reference_images</code> <code>Sequence[Any]</code> <p>Sequence of objects to be converted into images by <code>read_fn</code>. This typically involves paths to images that serve as target domain examples for adaptation.</p> <code>beta_limit</code> <code>float or tuple of float</code> <p>Coefficient beta from the paper, controlling the swapping extent of frequency components. Values should be less than 0.5.</p> <code>read_fn</code> <code>Callable</code> <p>User-defined function for reading images. It takes an element from <code>reference_images</code> and returns a numpy array of image pixels. By default, it is expected to take a path to an image and return a numpy array.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <ul> <li>https://github.com/YanchaoYang/FDA</li> <li>https://openaccess.thecvf.com/content_CVPR_2020/papers/Yang_FDA_Fourier_Domain_Adaptation_for_Semantic_Segmentation_CVPR_2020_paper.pdf</li> </ul> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import albumentations as A\n&gt;&gt;&gt; image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n&gt;&gt;&gt; target_image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n&gt;&gt;&gt; aug = A.Compose([A.FDA([target_image], p=1, read_fn=lambda x: x)])\n&gt;&gt;&gt; result = aug(image=image)\n</code></pre> <p>Note</p> <p>FDA is a powerful tool for domain adaptation, particularly in unsupervised settings where annotated target domain samples are unavailable. It enables significant improvements in model generalization by aligning the low-level statistics of source and target images through a simple yet effective Fourier-based method.</p> Source code in <code>albumentations/augmentations/domain_adaptation.py</code> Python<pre><code>class FDA(ImageOnlyTransform):\n    \"\"\"Fourier Domain Adaptation (FDA) for simple \"style transfer\" in the context of unsupervised domain adaptation\n    (UDA). FDA manipulates the frequency components of images to reduce the domain gap between source\n    and target datasets, effectively adapting images from one domain to closely resemble those from another without\n    altering their semantic content.\n\n    This transform is particularly beneficial in scenarios where the training (source) and testing (target) images\n    come from different distributions, such as synthetic versus real images, or day versus night scenes.\n    Unlike traditional domain adaptation methods that may require complex adversarial training, FDA achieves domain\n    alignment by swapping low-frequency components of the Fourier transform between the source and target images.\n    This technique has shown to improve the performance of models on the target domain, particularly for tasks\n    like semantic segmentation, without additional training for domain invariance.\n\n    The 'beta_limit' parameter controls the extent of frequency component swapping, with lower values preserving more\n    of the original image's characteristics and higher values leading to more pronounced adaptation effects.\n    It is recommended to use beta values less than 0.3 to avoid introducing artifacts.\n\n    Args:\n        reference_images (Sequence[Any]): Sequence of objects to be converted into images by `read_fn`. This typically\n            involves paths to images that serve as target domain examples for adaptation.\n        beta_limit (float or tuple of float): Coefficient beta from the paper, controlling the swapping extent of\n            frequency components. Values should be less than 0.5.\n        read_fn (Callable): User-defined function for reading images. It takes an element from `reference_images` and\n            returns a numpy array of image pixels. By default, it is expected to take a path to an image and return a\n            numpy array.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        - https://github.com/YanchaoYang/FDA\n        - https://openaccess.thecvf.com/content_CVPR_2020/papers/Yang_FDA_Fourier_Domain_Adaptation_for_Semantic_Segmentation_CVPR_2020_paper.pdf\n\n    Example:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import albumentations as A\n        &gt;&gt;&gt; image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n        &gt;&gt;&gt; target_image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n        &gt;&gt;&gt; aug = A.Compose([A.FDA([target_image], p=1, read_fn=lambda x: x)])\n        &gt;&gt;&gt; result = aug(image=image)\n\n    Note:\n        FDA is a powerful tool for domain adaptation, particularly in unsupervised settings where annotated target\n        domain samples are unavailable. It enables significant improvements in model generalization by aligning\n        the low-level statistics of source and target images through a simple yet effective Fourier-based method.\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        reference_images: Sequence[Any]\n        read_fn: Callable[[Any], np.ndarray]\n        beta_limit: NonNegativeFloatRangeType = (0, 0.1)\n\n        @field_validator(\"beta_limit\")\n        @classmethod\n        def check_ranges(cls, value: Tuple[float, float]) -&gt; Tuple[float, float]:\n            bounds = 0, MAX_BETA_LIMIT\n            if not bounds[0] &lt;= value[0] &lt;= value[1] &lt;= bounds[1]:\n                raise ValueError(f\"Values should be in the range {bounds} got {value} \")\n            return value\n\n    def __init__(\n        self,\n        reference_images: Sequence[Any],\n        beta_limit: ScaleFloatType = (0, 0.1),\n        read_fn: Callable[[Any], np.ndarray] = read_rgb_image,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.reference_images = reference_images\n        self.read_fn = read_fn\n        self.beta_limit = cast(Tuple[float, float], beta_limit)\n\n    def apply(\n        self, img: np.ndarray, target_image: Optional[np.ndarray] = None, beta: float = 0.1, **params: Any\n    ) -&gt; np.ndarray:\n        return fourier_domain_adaptation(img, target_image, beta)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, np.ndarray]:\n        img = params[\"image\"]\n        target_img = self.read_fn(random.choice(self.reference_images))\n        target_img = cv2.resize(target_img, dsize=(img.shape[1], img.shape[0]))\n\n        return {\"target_image\": target_img}\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"beta\": random.uniform(self.beta_limit[0], self.beta_limit[1])}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return \"reference_images\", \"beta_limit\", \"read_fn\"\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        msg = \"FDA can not be serialized.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.domain_adaptation.HistogramMatching","title":"<code>class  HistogramMatching</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Implements histogram matching, a technique that adjusts the pixel values of an input image to match the histogram of a reference image. This adjustment ensures that the output image has a similar tone and contrast to the reference. The process is applied independently to each channel of multi-channel images, provided both the input and reference images have the same number of channels.</p> <p>Histogram matching serves as an effective normalization method in image processing tasks such as feature matching. It is particularly useful when images originate from varied sources or are captured under different lighting conditions, helping to standardize the images' appearance before further processing.</p> <p>Parameters:</p> Name Type Description <code>reference_images</code> <code>Sequence[Any]</code> <p>A sequence of objects to be converted into images by <code>read_fn</code>. Typically, this is a sequence of image paths.</p> <code>blend_ratio</code> <code>Tuple[float, float]</code> <p>Specifies the minimum and maximum blend ratio for blending the matched image with the original image. A random blend factor within this range is chosen for each image to increase the diversity of the output images.</p> <code>read_fn</code> <code>Callable[[Any], np.ndarray]</code> <p>A user-defined function for reading images, which accepts an element from <code>reference_images</code> and returns a numpy array of image pixels. By default, this is expected to take a file path and return an image as a numpy array.</p> <code>p</code> <code>float</code> <p>The probability of applying the transform to any given image. Defaults to 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Note</p> <p>This class cannot be serialized directly due to its dynamic nature and dependency on external image data. An attempt to serialize it will raise a NotImplementedError.</p> <p>Reference</p> <p>https://scikit-image.org/docs/dev/auto_examples/color_exposure/plot_histogram_matching.html</p> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import albumentations as A\n&gt;&gt;&gt; image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n&gt;&gt;&gt; target_image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n&gt;&gt;&gt; aug = A.Compose([A.HistogramMatching([target_image], p=1, read_fn=lambda x: x)])\n&gt;&gt;&gt; result = aug(image=image)\n</code></pre> Source code in <code>albumentations/augmentations/domain_adaptation.py</code> Python<pre><code>class HistogramMatching(ImageOnlyTransform):\n    \"\"\"Implements histogram matching, a technique that adjusts the pixel values of an input image\n    to match the histogram of a reference image. This adjustment ensures that the output image\n    has a similar tone and contrast to the reference. The process is applied independently to\n    each channel of multi-channel images, provided both the input and reference images have the\n    same number of channels.\n\n    Histogram matching serves as an effective normalization method in image processing tasks such\n    as feature matching. It is particularly useful when images originate from varied sources or are\n    captured under different lighting conditions, helping to standardize the images' appearance\n    before further processing.\n\n    Args:\n        reference_images (Sequence[Any]): A sequence of objects to be converted into images by `read_fn`.\n            Typically, this is a sequence of image paths.\n        blend_ratio (Tuple[float, float]): Specifies the minimum and maximum blend ratio for blending the matched\n            image with the original image. A random blend factor within this range is chosen for each image to\n            increase the diversity of the output images.\n        read_fn (Callable[[Any], np.ndarray]): A user-defined function for reading images, which accepts an\n            element from `reference_images` and returns a numpy array of image pixels. By default, this is expected\n            to take a file path and return an image as a numpy array.\n        p (float): The probability of applying the transform to any given image. Defaults to 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Note:\n        This class cannot be serialized directly due to its dynamic nature and dependency on external image data.\n        An attempt to serialize it will raise a NotImplementedError.\n\n    Reference:\n        https://scikit-image.org/docs/dev/auto_examples/color_exposure/plot_histogram_matching.html\n\n    Example:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import albumentations as A\n        &gt;&gt;&gt; image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n        &gt;&gt;&gt; target_image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n        &gt;&gt;&gt; aug = A.Compose([A.HistogramMatching([target_image], p=1, read_fn=lambda x: x)])\n        &gt;&gt;&gt; result = aug(image=image)\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        reference_images: Sequence[Any]\n        blend_ratio: ZeroOneRangeType = (0.5, 1.0)\n        read_fn: Callable[[Any], np.ndarray]\n\n    def __init__(\n        self,\n        reference_images: Sequence[Any],\n        blend_ratio: Tuple[float, float] = (0.5, 1.0),\n        read_fn: Callable[[Any], np.ndarray] = read_rgb_image,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.reference_images = reference_images\n        self.read_fn = read_fn\n        self.blend_ratio = blend_ratio\n\n    def apply(\n        self: np.ndarray,\n        img: np.ndarray,\n        reference_image: Optional[np.ndarray] = None,\n        blend_ratio: float = 0.5,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return apply_histogram(img, reference_image, blend_ratio)\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        return {\n            \"reference_image\": self.read_fn(random.choice(self.reference_images)),\n            \"blend_ratio\": random.uniform(self.blend_ratio[0], self.blend_ratio[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"reference_images\", \"blend_ratio\", \"read_fn\")\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        msg = \"HistogramMatching can not be serialized.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.domain_adaptation.PixelDistributionAdaptation","title":"<code>class  PixelDistributionAdaptation</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Performs pixel-level domain adaptation by aligning the pixel value distribution of an input image with that of a reference image. This process involves fitting a simple statistical transformation (such as PCA, StandardScaler, or MinMaxScaler) to both the original and the reference images, transforming the original image with the transformation trained on it, and then applying the inverse transformation using the transform fitted on the reference image. The result is an adapted image that retains the original content while mimicking the pixel value distribution of the reference domain.</p> <p>The process can be visualized as two main steps: 1. Adjusting the original image to a standard distribution space using a selected transform. 2. Moving the adjusted image into the distribution space of the reference image by applying the inverse    of the transform fitted on the reference image.</p> <p>This technique is especially useful in scenarios where images from different domains (e.g., synthetic vs. real images, day vs. night scenes) need to be harmonized for better consistency or performance in image processing tasks.</p> <p>Parameters:</p> Name Type Description <code>reference_images</code> <code>Sequence[Any]</code> <p>A sequence of objects (typically image paths) that will be converted into images by <code>read_fn</code>. These images serve as references for the domain adaptation.</p> <code>blend_ratio</code> <code>Tuple[float, float]</code> <p>Specifies the minimum and maximum blend ratio for mixing the adapted image with the original, enhancing the diversity of the output images.</p> <code>read_fn</code> <code>Callable</code> <p>A user-defined function for reading and converting the objects in <code>reference_images</code> into numpy arrays. By default, it assumes these objects are image paths.</p> <code>transform_type</code> <code>str</code> <p>Specifies the type of statistical transformation to apply. Supported values are \"pca\" for Principal Component Analysis, \"standard\" for StandardScaler, and \"minmax\" for MinMaxScaler.</p> <code>p</code> <code>float</code> <p>The probability of applying the transform to any given image. Default is 1.0.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>For more information on the underlying approach, see: https://github.com/arsenyinfo/qudida</p> <p>Note</p> <p>The PixelDistributionAdaptation transform is a novel way to perform domain adaptation at the pixel level, suitable for adjusting images across different conditions without complex modeling. It is effective for preparing images before more advanced processing or analysis.</p> Source code in <code>albumentations/augmentations/domain_adaptation.py</code> Python<pre><code>class PixelDistributionAdaptation(ImageOnlyTransform):\n    \"\"\"Performs pixel-level domain adaptation by aligning the pixel value distribution of an input image\n    with that of a reference image. This process involves fitting a simple statistical transformation\n    (such as PCA, StandardScaler, or MinMaxScaler) to both the original and the reference images,\n    transforming the original image with the transformation trained on it, and then applying the inverse\n    transformation using the transform fitted on the reference image. The result is an adapted image\n    that retains the original content while mimicking the pixel value distribution of the reference domain.\n\n    The process can be visualized as two main steps:\n    1. Adjusting the original image to a standard distribution space using a selected transform.\n    2. Moving the adjusted image into the distribution space of the reference image by applying the inverse\n       of the transform fitted on the reference image.\n\n    This technique is especially useful in scenarios where images from different domains (e.g., synthetic\n    vs. real images, day vs. night scenes) need to be harmonized for better consistency or performance in\n    image processing tasks.\n\n    Args:\n        reference_images (Sequence[Any]): A sequence of objects (typically image paths) that will be\n            converted into images by `read_fn`. These images serve as references for the domain adaptation.\n        blend_ratio (Tuple[float, float]): Specifies the minimum and maximum blend ratio for mixing\n            the adapted image with the original, enhancing the diversity of the output images.\n        read_fn (Callable): A user-defined function for reading and converting the objects in\n            `reference_images` into numpy arrays. By default, it assumes these objects are image paths.\n        transform_type (str): Specifies the type of statistical transformation to apply. Supported values\n            are \"pca\" for Principal Component Analysis, \"standard\" for StandardScaler, and \"minmax\" for\n            MinMaxScaler.\n        p (float): The probability of applying the transform to any given image. Default is 1.0.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        For more information on the underlying approach, see: https://github.com/arsenyinfo/qudida\n\n    Note:\n        The PixelDistributionAdaptation transform is a novel way to perform domain adaptation at the pixel level,\n        suitable for adjusting images across different conditions without complex modeling. It is effective\n        for preparing images before more advanced processing or analysis.\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        reference_images: Sequence[Any]\n        blend_ratio: ZeroOneRangeType = (0.25, 1.0)\n        read_fn: Callable[[Any], np.ndarray]\n        transform_type: Literal[\"pca\", \"standard\", \"minmax\"]\n\n    def __init__(\n        self,\n        reference_images: Sequence[Any],\n        blend_ratio: Tuple[float, float] = (0.25, 1.0),\n        read_fn: Callable[[Any], np.ndarray] = read_rgb_image,\n        transform_type: Literal[\"pca\", \"standard\", \"minmax\"] = \"pca\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.reference_images = reference_images\n        self.read_fn = read_fn\n        self.blend_ratio = blend_ratio\n        self.transform_type = transform_type\n\n    @staticmethod\n    def _validate_shape(img: np.ndarray) -&gt; None:\n        if is_grayscale_image(img) or is_multispectral_image(img):\n            raise ValueError(\n                f\"Unexpected image shape: expected 3 dimensions, got {len(img.shape)}.\"\n                f\"Is it a grayscale or multispectral image? It's not supported for now.\"\n            )\n\n    def ensure_uint8(self, img: np.ndarray) -&gt; Tuple[np.ndarray, bool]:\n        if img.dtype == np.float32:\n            if img.min() &lt; 0 or img.max() &gt; 1:\n                message = (\n                    \"PixelDistributionAdaptation uses uint8 under the hood, so float32 should be converted,\"\n                    \"Can not do it automatically when the image is out of [0..1] range.\"\n                )\n                raise TypeError(message)\n            return (img * 255).astype(\"uint8\"), True\n        return img, False\n\n    def apply(self, img: np.ndarray, reference_image: np.ndarray, blend_ratio: float, **params: Any) -&gt; np.ndarray:\n        self._validate_shape(img)\n        reference_image, _ = self.ensure_uint8(reference_image)\n        img, needs_reconvert = self.ensure_uint8(img)\n\n        adapted = adapt_pixel_distribution(\n            img,\n            ref=reference_image,\n            weight=blend_ratio,\n            transform_type=self.transform_type,\n        )\n        if needs_reconvert:\n            adapted = adapted.astype(\"float32\") * (1 / 255)\n        return adapted\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"reference_image\": self.read_fn(random.choice(self.reference_images)),\n            \"blend_ratio\": random.uniform(self.blend_ratio[0], self.blend_ratio[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return \"reference_images\", \"blend_ratio\", \"read_fn\", \"transform_type\"\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        msg = \"PixelDistributionAdaptation can not be serialized.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.domain_adaptation_functional","title":"<code>domain_adaptation_functional</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.domain_adaptation_functional.DomainAdapter","title":"<code>class  DomainAdapter</code> <code>       (transformer, ref_img, color_conversions=(None, None))                   </code>  [view source on GitHub]","text":"<p>Source: https://github.com/arsenyinfo/qudida by Arseny Kravchenko</p> Source code in <code>albumentations/augmentations/domain_adaptation_functional.py</code> Python<pre><code>class DomainAdapter:\n    \"\"\"Source: https://github.com/arsenyinfo/qudida by Arseny Kravchenko\"\"\"\n\n    def __init__(\n        self,\n        transformer: TransformerInterface,\n        ref_img: np.ndarray,\n        color_conversions: Tuple[None, None] = (None, None),\n    ):\n        self.color_in, self.color_out = color_conversions\n        self.source_transformer = deepcopy(transformer)\n        self.target_transformer = transformer\n        self.target_transformer.fit(self.flatten(ref_img))\n\n    def to_colorspace(self, img: np.ndarray) -&gt; np.ndarray:\n        return img if self.color_in is None else cv2.cvtColor(img, self.color_in)\n\n    def from_colorspace(self, img: np.ndarray) -&gt; np.ndarray:\n        if self.color_out is None:\n            return img\n        return cv2.cvtColor(img.astype(\"uint8\"), self.color_out)\n\n    def flatten(self, img: np.ndarray) -&gt; np.ndarray:\n        img = self.to_colorspace(img)\n        img = img.astype(\"float32\") / 255.0\n        return img.reshape(-1, 3)\n\n    def reconstruct(self, pixels: np.ndarray, height: int, width: int) -&gt; np.ndarray:\n        pixels = (np.clip(pixels, 0, 1) * 255).astype(\"uint8\")\n        return self.from_colorspace(pixels.reshape(height, width, 3))\n\n    @staticmethod\n    def _pca_sign(x: np.ndarray) -&gt; np.ndarray:\n        return np.sign(np.trace(x.components_))\n\n    def __call__(self, image: np.ndarray) -&gt; np.ndarray:\n        height, width = image.shape[:2]\n        pixels = self.flatten(image)\n        self.source_transformer.fit(pixels)\n\n        # dirty hack to make sure colors are not inverted\n        if (\n            hasattr(self.target_transformer, \"components_\")\n            and hasattr(self.source_transformer, \"components_\")\n            and self._pca_sign(self.target_transformer) != self._pca_sign(self.source_transformer)\n        ):\n            self.target_transformer.components_ *= -1\n\n        representation = self.source_transformer.transform(pixels)\n        result = self.target_transformer.inverse_transform(representation)\n        return self.reconstruct(result, height, width)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout","title":"<code>dropout</code>  <code>special</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.channel_dropout","title":"<code>channel_dropout</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.channel_dropout.ChannelDropout","title":"<code>class  ChannelDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly Drop Channels in the input Image.</p> <p>Parameters:</p> Name Type Description <code>channel_drop_range</code> <code>int, int</code> <p>range from which we choose the number of channels to drop.</p> <code>fill_value</code> <code>int, float</code> <p>pixel value for the dropped channel.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, uint16, unit32, float32</p> Source code in <code>albumentations/augmentations/dropout/channel_dropout.py</code> Python<pre><code>class ChannelDropout(ImageOnlyTransform):\n    \"\"\"Randomly Drop Channels in the input Image.\n\n    Args:\n        channel_drop_range (int, int): range from which we choose the number of channels to drop.\n        fill_value (int, float): pixel value for the dropped channel.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, uint16, unit32, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        channel_drop_range: OnePlusIntRangeType = (1, 1)\n        fill_value: Annotated[ColorType, Field(description=\"Pixel value for the dropped channel.\")]\n\n    def __init__(\n        self,\n        channel_drop_range: Tuple[int, int] = (1, 1),\n        fill_value: float = 0,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        self.channel_drop_range = channel_drop_range\n        self.fill_value = fill_value\n\n    def apply(self, img: np.ndarray, channels_to_drop: Tuple[int, ...] = (0,), **params: Any) -&gt; np.ndarray:\n        return channel_dropout(img, channels_to_drop, self.fill_value)\n\n    def get_params_dependent_on_targets(self, params: Mapping[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        num_channels = img.shape[-1]\n\n        if is_grayscale_image(img):\n            msg = \"Images has one channel. ChannelDropout is not defined.\"\n            raise NotImplementedError(msg)\n\n        if self.channel_drop_range[1] &gt;= num_channels:\n            msg = \"Can not drop all channels in ChannelDropout.\"\n            raise ValueError(msg)\n\n        num_drop_channels = random_utils.randint(self.channel_drop_range[0], self.channel_drop_range[1] + 1)\n\n        channels_to_drop = random.sample(range(num_channels), k=num_drop_channels)\n\n        return {\"channels_to_drop\": channels_to_drop}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"channel_drop_range\", \"fill_value\"\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.coarse_dropout","title":"<code>coarse_dropout</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.coarse_dropout.CoarseDropout","title":"<code>class  CoarseDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>CoarseDropout of the rectangular regions in the image.</p> <p>Parameters:</p> Name Type Description <code>max_holes</code> <code>int</code> <p>Maximum number of regions to zero out.</p> <code>max_height</code> <code>int, float</code> <p>Maximum height of the hole.</p> <code>max_width</code> <code>int, float</code> <p>Maximum width of the hole.</p> <code>min_holes</code> <code>int</code> <p>Minimum number of regions to zero out. If <code>None</code>, <code>min_holes</code> is be set to <code>max_holes</code>. Default: <code>None</code>.</p> <code>min_height</code> <code>int, float</code> <p>Minimum height of the hole. Default: None. If <code>None</code>, <code>min_height</code> is set to <code>max_height</code>. Default: <code>None</code>. If float, it is calculated as a fraction of the image height.</p> <code>min_width</code> <code>int, float</code> <p>Minimum width of the hole. If <code>None</code>, <code>min_height</code> is set to <code>max_width</code>. Default: <code>None</code>. If float, it is calculated as a fraction of the image width.</p> <code>fill_value</code> <code>int, float, list of int, list of float</code> <p>value for dropped pixels.</p> <code>mask_fill_value</code> <code>int, float, list of int, list of float</code> <p>fill value for dropped pixels in mask. If <code>None</code> - mask is not affected. Default: <code>None</code>.</p> <p>Targets</p> <p>image, mask, keypoints</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1708.04552 https://github.com/uoguelph-mlrg/Cutout/blob/master/util/cutout.py https://github.com/aleju/imgaug/blob/master/imgaug/augmenters/arithmetic.py</p> Source code in <code>albumentations/augmentations/dropout/coarse_dropout.py</code> Python<pre><code>class CoarseDropout(DualTransform):\n    \"\"\"CoarseDropout of the rectangular regions in the image.\n\n    Args:\n        max_holes (int): Maximum number of regions to zero out.\n        max_height (int, float): Maximum height of the hole.\n        If float, it is calculated as a fraction of the image height.\n        max_width (int, float): Maximum width of the hole.\n        If float, it is calculated as a fraction of the image width.\n        min_holes (int): Minimum number of regions to zero out. If `None`,\n            `min_holes` is be set to `max_holes`. Default: `None`.\n        min_height (int, float): Minimum height of the hole. Default: None. If `None`,\n            `min_height` is set to `max_height`. Default: `None`.\n            If float, it is calculated as a fraction of the image height.\n        min_width (int, float): Minimum width of the hole. If `None`, `min_height` is\n            set to `max_width`. Default: `None`.\n            If float, it is calculated as a fraction of the image width.\n\n        fill_value (int, float, list of int, list of float): value for dropped pixels.\n        mask_fill_value (int, float, list of int, list of float): fill value for dropped pixels\n            in mask. If `None` - mask is not affected. Default: `None`.\n\n    Targets:\n        image, mask, keypoints\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://arxiv.org/abs/1708.04552\n        https://github.com/uoguelph-mlrg/Cutout/blob/master/util/cutout.py\n        https://github.com/aleju/imgaug/blob/master/imgaug/augmenters/arithmetic.py\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        max_holes: int = Field(default=8, ge=0, description=\"Maximum number of regions to zero out.\")\n        max_height: ScalarType = Field(default=8, ge=0, description=\"Maximum height of the hole.\")\n        max_width: ScalarType = Field(default=8, ge=0, description=\"Maximum width of the hole.\")\n        min_holes: Optional[int] = Field(default=None, ge=0, description=\"Minimum number of regions to zero out.\")\n        min_height: Optional[ScalarType] = Field(default=None, ge=0, description=\"Minimum height of the hole.\")\n        min_width: Optional[ScalarType] = Field(default=None, ge=0, description=\"Minimum width of the hole.\")\n        fill_value: ColorType = Field(default=0, description=\"Value for dropped pixels.\")\n        mask_fill_value: Optional[ColorType] = Field(default=None, description=\"Fill value for dropped pixels in mask.\")\n\n        @model_validator(mode=\"after\")\n        def check_holes_and_dimensions(self) -&gt; Self:\n            self.min_holes = self.min_holes if self.min_holes is not None else self.max_holes\n\n            self.min_height = self.min_height if self.min_height is not None else self.max_height\n            self.min_width = self.min_width if self.min_width is not None else self.max_width\n\n            if not 0 &lt; self.min_height &lt;= self.max_height:\n                raise ValueError(\n                    f\"Invalid combination of min_height and max_height. Got: {[self.min_height, self.max_height]}\"\n                )\n            if not 0 &lt; self.min_width &lt;= self.max_width:\n                raise ValueError(\n                    f\"Invalid combination of min_width and max_width. Got: {[self.min_width, self.max_width]}\"\n                )\n            if not 0 &lt; self.min_holes &lt;= self.max_holes:\n                raise ValueError(\n                    f\"Invalid combination of min_holes and max_holes. Got: {[self.min_holes, self.max_holes]}\"\n                )\n            return self\n\n    def __init__(\n        self,\n        max_holes: int = 8,\n        max_height: ScalarType = 8,\n        max_width: ScalarType = 8,\n        min_holes: Optional[int] = None,\n        min_height: Optional[ScalarType] = None,\n        min_width: Optional[ScalarType] = None,\n        fill_value: ColorType = 0,\n        mask_fill_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.min_holes = cast(int, min_holes)\n        self.max_holes = max_holes\n        self.min_height = cast(ScalarType, min_height)\n        self.max_height = max_height\n        self.min_width = cast(ScalarType, min_width)\n        self.max_width = max_width\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n\n    def apply(\n        self,\n        img: np.ndarray,\n        fill_value: ScalarType = 0,\n        holes: Iterable[Tuple[int, int, int, int]] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return cutout(img, holes, fill_value)\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        mask_fill_value: ScalarType = 0,\n        holes: Iterable[Tuple[int, int, int, int]] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if mask_fill_value is None:\n            return mask\n        return cutout(mask, holes, mask_fill_value)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        holes = []\n        for _ in range(random.randint(self.min_holes, self.max_holes)):\n            if all(\n                [\n                    isinstance(self.min_height, int),\n                    isinstance(self.min_width, int),\n                    isinstance(self.max_height, int),\n                    isinstance(self.max_width, int),\n                ]\n            ):\n                hole_height = random.randint(int(self.min_height), int(self.max_height))\n                hole_width = random.randint(int(self.min_width), int(self.max_width))\n            elif all(\n                [\n                    isinstance(self.min_height, float),\n                    isinstance(self.min_width, float),\n                    isinstance(self.max_height, float),\n                    isinstance(self.max_width, float),\n                ]\n            ):\n                hole_height = int(height * random.uniform(self.min_height, self.max_height))\n                hole_width = int(width * random.uniform(self.min_width, self.max_width))\n            else:\n                msg = \"Min width, max width, \\\n                    min height and max height \\\n                    should all either be ints or floats. \\\n                    Got: {} respectively\".format(\n                    [\n                        type(self.min_width),\n                        type(self.max_width),\n                        type(self.min_height),\n                        type(self.max_height),\n                    ]\n                )\n                raise ValueError(msg)\n\n            y1 = random.randint(0, height - hole_height)\n            x1 = random.randint(0, width - hole_width)\n            y2 = y1 + hole_height\n            x2 = x1 + hole_width\n            holes.append((x1, y1, x2, y2))\n\n        return {\"holes\": holes}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def apply_to_keypoints(\n        self, keypoints: Sequence[KeypointType], holes: Iterable[Tuple[int, int, int, int]] = (), **params: Any\n    ) -&gt; List[KeypointType]:\n        return [keypoint for keypoint in keypoints if not any(keypoint_in_hole(keypoint, hole) for hole in holes)]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"max_holes\",\n            \"max_height\",\n            \"max_width\",\n            \"min_holes\",\n            \"min_height\",\n            \"min_width\",\n            \"fill_value\",\n            \"mask_fill_value\",\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.grid_dropout","title":"<code>grid_dropout</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.grid_dropout.GridDropout","title":"<code>class  GridDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.</p> <p>Parameters:</p> Name Type Description <code>ratio</code> <p>the ratio of the mask holes to the unit_size (same for horizontal and vertical directions). Must be between 0 and 1. Default: 0.5.</p> <code>unit_size_min</code> <code>int</code> <p>minimum size of the grid unit. Must be between 2 and the image shorter edge. If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: <code>None</code>.</p> <code>unit_size_max</code> <code>int</code> <p>maximum size of the grid unit. Must be between 2 and the image shorter edge. If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: <code>None</code>.</p> <code>holes_number_x</code> <code>int</code> <p>the number of grid units in x direction. Must be between 1 and image width//2. If 'None', grid unit width is set as image_width//10. Default: <code>None</code>.</p> <code>holes_number_y</code> <code>int</code> <p>the number of grid units in y direction. Must be between 1 and image height//2. If <code>None</code>, grid unit height is set equal to the grid unit width or image height, whatever is smaller.</p> <code>shift_x</code> <code>int</code> <p>offsets of the grid start in x direction from (0,0) coordinate. Clipped between 0 and grid unit_width - hole_width. Default: 0.</p> <code>shift_y</code> <code>int</code> <p>offsets of the grid start in y direction from (0,0) coordinate. Clipped between 0 and grid unit height - hole_height. Default: 0.</p> <code>random_offset</code> <code>boolean</code> <p>weather to offset the grid randomly between 0 and grid unit size - hole size If 'True', entered shift_x, shift_y are ignored and set randomly. Default: <code>False</code>.</p> <code>fill_value</code> <code>int</code> <p>value for the dropped pixels. Default = 0</p> <code>mask_fill_value</code> <code>int</code> <p>value for the dropped pixels in mask. If <code>None</code>, transformation is not applied to the mask. Default: <code>None</code>.</p> <p>Targets</p> <p>image, mask</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/2001.04086</p> Source code in <code>albumentations/augmentations/dropout/grid_dropout.py</code> Python<pre><code>class GridDropout(DualTransform):\n    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio: the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK)\n\n    class InitSchema(BaseTransformInitSchema):\n        ratio: float = Field(description=\"The ratio of the mask holes to the unit_size.\", ge=0, le=1)\n        unit_size_min: Optional[int] = Field(None, description=\"Minimum size of the grid unit.\", ge=2)\n        unit_size_max: Optional[int] = Field(None, description=\"Maximum size of the grid unit.\", ge=2)\n        holes_number_x: Optional[int] = Field(None, description=\"The number of grid units in x direction.\", ge=1)\n        holes_number_y: Optional[int] = Field(None, description=\"The number of grid units in y direction.\", ge=1)\n        shift_x: int = Field(0, description=\"Offsets of the grid start in x direction.\", ge=0)\n        shift_y: int = Field(0, description=\"Offsets of the grid start in y direction.\", ge=0)\n        random_offset: bool = Field(False, description=\"Whether to offset the grid randomly.\")\n        fill_value: Optional[ColorType] = Field(0, description=\"Value for the dropped pixels.\")\n        mask_fill_value: Optional[ColorType] = Field(None, description=\"Value for the dropped pixels in mask.\")\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: Optional[int] = None,\n        unit_size_max: Optional[int] = None,\n        holes_number_x: Optional[int] = None,\n        holes_number_y: Optional[int] = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: float = 0,\n        mask_fill_value: Optional[ScalarType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n\n    def apply(self, img: np.ndarray, holes: Iterable[Tuple[int, int, int, int]] = (), **params: Any) -&gt; np.ndarray:\n        return F.cutout(img, holes, self.fill_value)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, holes: Iterable[Tuple[int, int, int, int]] = (), **params: Any\n    ) -&gt; np.ndarray:\n        if self.mask_fill_value is None:\n            return mask\n\n        return F.cutout(mask, holes, self.mask_fill_value)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n        unit_width, unit_height = self._calculate_unit_dimensions(width, height)\n        hole_width, hole_height = self._calculate_hole_dimensions(unit_width, unit_height)\n        shift_x, shift_y = self._calculate_shifts(unit_width, unit_height, hole_width, hole_height)\n        holes = self._generate_holes(width, height, unit_width, unit_height, hole_width, hole_height, shift_x, shift_y)\n        return {\"holes\": holes}\n\n    def _calculate_unit_dimensions(self, width: int, height: int) -&gt; Tuple[int, int]:\n        \"\"\"Calculates the dimensions of the grid units.\"\"\"\n        if self.unit_size_min is not None and self.unit_size_max is not None:\n            self._validate_unit_sizes(height, width)\n            unit_size = random.randint(self.unit_size_min, self.unit_size_max)\n            return unit_size, unit_size\n\n        return self._calculate_dimensions_based_on_holes(width, height)\n\n    def _validate_unit_sizes(self, height: int, width: int) -&gt; None:\n        \"\"\"Validates the minimum and maximum unit sizes.\"\"\"\n        if self.unit_size_min is not None and self.unit_size_max is not None:\n            if not TWO &lt;= self.unit_size_min &lt;= self.unit_size_max:\n                msg = \"Max unit size should be &gt;= min size, both at least 2 pixels.\"\n                raise ValueError(msg)\n            if self.unit_size_max &gt; min(height, width):\n                msg = \"Grid size limits must be within the shortest image edge.\"\n                raise ValueError(msg)\n        else:\n            msg = \"unit_size_min and unit_size_max must not be None.\"\n            raise ValueError(msg)\n\n    def _calculate_dimensions_based_on_holes(self, width: int, height: int) -&gt; Tuple[int, int]:\n        \"\"\"Calculates dimensions based on the number of holes specified.\"\"\"\n        unit_width = self._calculate_dimension(width, self.holes_number_x, 10)\n        unit_height = self._calculate_dimension(height, self.holes_number_y, unit_width)\n        return unit_width, unit_height\n\n    def _calculate_dimension(self, dimension: int, holes_number: Optional[int], fallback: int) -&gt; int:\n        \"\"\"Helper function to calculate unit width or height.\"\"\"\n        if holes_number is None:\n            return max(2, dimension // fallback)\n\n        if not 1 &lt;= holes_number &lt;= dimension // 2:\n            raise ValueError(f\"The number of holes must be between 1 and {dimension // 2}.\")\n        return dimension // holes_number\n\n    def _calculate_hole_dimensions(self, unit_width: int, unit_height: int) -&gt; Tuple[int, int]:\n        \"\"\"Calculates the dimensions of the holes to be dropped out.\"\"\"\n        hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        return hole_width, hole_height\n\n    def _calculate_shifts(\n        self, unit_width: int, unit_height: int, hole_width: int, hole_height: int\n    ) -&gt; Tuple[int, int]:\n        \"\"\"Calculates the shifts for the grid start.\"\"\"\n        if self.random_offset:\n            shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        else:\n            shift_x = 0 if self.shift_x is None else min(max(0, self.shift_x), unit_width - hole_width)\n            shift_y = 0 if self.shift_y is None else min(max(0, self.shift_y), unit_height - hole_height)\n        return shift_x, shift_y\n\n    def _generate_holes(\n        self,\n        width: int,\n        height: int,\n        unit_width: int,\n        unit_height: int,\n        hole_width: int,\n        hole_height: int,\n        shift_x: int,\n        shift_y: int,\n    ) -&gt; List[Tuple[int, int, int, int]]:\n        \"\"\"Generates the list of holes to be dropped out.\"\"\"\n        holes = []\n        for i in range(width // unit_width + 1):\n            for j in range(height // unit_height + 1):\n                x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n        return holes\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"random_offset\",\n            \"fill_value\",\n            \"mask_fill_value\",\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.mask_dropout","title":"<code>mask_dropout</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.mask_dropout.MaskDropout","title":"<code>class  MaskDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Image &amp; mask augmentation that zero out mask and image regions corresponding to randomly chosen object instance from mask.</p> <p>Mask must be single-channel image, zero values treated as background. Image can be any number of channels.</p> <p>Parameters:</p> Name Type Description <code>max_objects</code> <p>Maximum number of labels that can be zeroed out. Can be tuple, in this case it's [min, max]</p> <code>image_fill_value</code> <p>Fill value to use when filling image. Can be 'inpaint' to apply inpainting (works only  for 3-channel images)</p> <code>mask_fill_value</code> <p>Fill value to use when filling mask.</p> <p>Targets</p> <p>image, mask</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://www.kaggle.com/c/severstal-steel-defect-detection/discussion/114254</p> Source code in <code>albumentations/augmentations/dropout/mask_dropout.py</code> Python<pre><code>class MaskDropout(DualTransform):\n    \"\"\"Image &amp; mask augmentation that zero out mask and image regions corresponding\n    to randomly chosen object instance from mask.\n\n    Mask must be single-channel image, zero values treated as background.\n    Image can be any number of channels.\n\n    Args:\n        max_objects: Maximum number of labels that can be zeroed out. Can be tuple, in this case it's [min, max]\n        image_fill_value: Fill value to use when filling image.\n            Can be 'inpaint' to apply inpainting (works only  for 3-channel images)\n        mask_fill_value: Fill value to use when filling mask.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://www.kaggle.com/c/severstal-steel-defect-detection/discussion/114254\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK)\n\n    class InitSchema(BaseTransformInitSchema):\n        max_objects: OnePlusIntRangeType = (1, 1)\n\n        image_fill_value: Union[float, Literal[\"inpaint\"]] = Field(\n            default=0,\n            description=(\n                \"Fill value to use when filling image. \"\n                \"Can be 'inpaint' to apply inpainting (works only for 3-channel images).\"\n            ),\n        )\n        mask_fill_value: float = Field(default=0, description=\"Fill value to use when filling mask.\")\n\n    def __init__(\n        self,\n        max_objects: ScaleIntType = (1, 1),\n        image_fill_value: Union[float, Literal[\"inpaint\"]] = 0,\n        mask_fill_value: ScalarType = 0,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.max_objects = cast(Tuple[int, int], max_objects)\n        self.image_fill_value = image_fill_value\n        self.mask_fill_value = mask_fill_value\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"mask\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        mask = params[\"mask\"]\n\n        label_image, num_labels = label(mask, return_num=True)\n\n        if num_labels == 0:\n            dropout_mask = None\n        else:\n            objects_to_drop = random.randint(self.max_objects[0], self.max_objects[1])\n            objects_to_drop = min(num_labels, objects_to_drop)\n\n            if objects_to_drop == num_labels:\n                dropout_mask = mask &gt; 0\n            else:\n                labels_index = random.sample(range(1, num_labels + 1), objects_to_drop)\n                dropout_mask = np.zeros((mask.shape[0], mask.shape[1]), dtype=bool)\n                for label_index in labels_index:\n                    dropout_mask |= label_image == label_index\n\n        params.update({\"dropout_mask\": dropout_mask})\n        del params[\"mask\"]\n        return params\n\n    def apply(self, img: np.ndarray, dropout_mask: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        if dropout_mask is None:\n            return img\n\n        if self.image_fill_value == \"inpaint\":\n            dropout_mask = dropout_mask.astype(np.uint8)\n            _, _, width, height = cv2.boundingRect(dropout_mask)\n            radius = min(3, max(width, height) // 2)\n            return cv2.inpaint(img, dropout_mask, radius, cv2.INPAINT_NS)\n\n        img = img.copy()\n        img[dropout_mask] = self.image_fill_value\n\n        return img\n\n    def apply_to_mask(self, mask: np.ndarray, dropout_mask: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        if dropout_mask is None:\n            return mask\n\n        mask = mask.copy()\n        mask[dropout_mask] = self.mask_fill_value\n        return mask\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"max_objects\", \"image_fill_value\", \"mask_fill_value\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.xy_masking","title":"<code>xy_masking</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.xy_masking.XYMasking","title":"<code>class  XYMasking</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Applies masking strips to an image, either horizontally (X axis) or vertically (Y axis), simulating occlusions. This transform is useful for training models to recognize images with varied visibility conditions. It's particularly effective for spectrogram images, allowing spectral and frequency masking to improve model robustness.</p> <p>At least one of <code>max_x_length</code> or <code>max_y_length</code> must be specified, dictating the mask's maximum size along each axis.</p> <p>Parameters:</p> Name Type Description <code>num_masks_x</code> <code>Union[int, Tuple[int, int]]</code> <p>Number or range of horizontal regions to mask. Defaults to 0.</p> <code>num_masks_y</code> <code>Union[int, Tuple[int, int]]</code> <p>Number or range of vertical regions to mask. Defaults to 0.</p> <code>mask_x_length</code> <code>[Union[int, Tuple[int, int]]</code> <p>Specifies the length of the masks along the X (horizontal) axis. If an integer is provided, it sets a fixed mask length. If a tuple of two integers (min, max) is provided, the mask length is randomly chosen within this range for each mask. This allows for variable-length masks in the horizontal direction.</p> <code>mask_y_length</code> <code>Union[int, Tuple[int, int]]</code> <p>Specifies the height of the masks along the Y (vertical) axis. Similar to <code>mask_x_length</code>, an integer sets a fixed mask height, while a tuple (min, max) allows for variable-height masks, chosen randomly within the specified range for each mask. This flexibility facilitates creating masks of various sizes in the vertical direction.</p> <code>fill_value</code> <code>Union[int, float, List[int], List[float]]</code> <p>Value to fill image masks. Defaults to 0.</p> <code>mask_fill_value</code> <code>Optional[Union[int, float, List[int], List[float]]]</code> <p>Value to fill masks in the mask. If <code>None</code>, uses mask is not affected. Default: <code>None</code>.</p> <code>p</code> <code>float</code> <p>Probability of applying the transform. Defaults to 0.5.</p> <p>Targets</p> <p>image, mask, keypoints</p> <p>Image types:     uint8, float32</p> <p>Note: Either <code>max_x_length</code> or <code>max_y_length</code> or both must be defined.</p> Source code in <code>albumentations/augmentations/dropout/xy_masking.py</code> Python<pre><code>class XYMasking(DualTransform):\n    \"\"\"Applies masking strips to an image, either horizontally (X axis) or vertically (Y axis),\n    simulating occlusions. This transform is useful for training models to recognize images\n    with varied visibility conditions. It's particularly effective for spectrogram images,\n    allowing spectral and frequency masking to improve model robustness.\n\n    At least one of `max_x_length` or `max_y_length` must be specified, dictating the mask's\n    maximum size along each axis.\n\n    Args:\n        num_masks_x (Union[int, Tuple[int, int]]): Number or range of horizontal regions to mask. Defaults to 0.\n        num_masks_y (Union[int, Tuple[int, int]]): Number or range of vertical regions to mask. Defaults to 0.\n        mask_x_length ([Union[int, Tuple[int, int]]): Specifies the length of the masks along\n            the X (horizontal) axis. If an integer is provided, it sets a fixed mask length.\n            If a tuple of two integers (min, max) is provided,\n            the mask length is randomly chosen within this range for each mask.\n            This allows for variable-length masks in the horizontal direction.\n        mask_y_length (Union[int, Tuple[int, int]]): Specifies the height of the masks along\n            the Y (vertical) axis. Similar to `mask_x_length`, an integer sets a fixed mask height,\n            while a tuple (min, max) allows for variable-height masks, chosen randomly\n            within the specified range for each mask. This flexibility facilitates creating masks of various\n            sizes in the vertical direction.\n        fill_value (Union[int, float, List[int], List[float]]): Value to fill image masks. Defaults to 0.\n        mask_fill_value (Optional[Union[int, float, List[int], List[float]]]): Value to fill masks in the mask.\n            If `None`, uses mask is not affected. Default: `None`.\n        p (float): Probability of applying the transform. Defaults to 0.5.\n\n    Targets:\n        image, mask, keypoints\n\n    Image types:\n        uint8, float32\n\n    Note: Either `max_x_length` or `max_y_length` or both must be defined.\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        num_masks_x: NonNegativeIntRangeType = 0\n        num_masks_y: NonNegativeIntRangeType = 0\n        mask_x_length: NonNegativeIntRangeType = 0\n        mask_y_length: NonNegativeIntRangeType = 0\n\n        fill_value: ColorType = Field(default=0, description=\"Value to fill image masks.\")\n        mask_fill_value: ColorType = Field(default=0, description=\"Value to fill masks in the mask.\")\n\n        @model_validator(mode=\"after\")\n        def check_mask_length(self) -&gt; Self:\n            if (\n                isinstance(self.mask_x_length, int)\n                and self.mask_x_length &lt;= 0\n                and isinstance(self.mask_y_length, int)\n                and self.mask_y_length &lt;= 0\n            ):\n                msg = \"At least one of `mask_x_length` or `mask_y_length` Should be a positive number.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        num_masks_x: ScaleIntType = 0,\n        num_masks_y: ScaleIntType = 0,\n        mask_x_length: ScaleIntType = 0,\n        mask_y_length: ScaleIntType = 0,\n        fill_value: ColorType = 0,\n        mask_fill_value: ColorType = 0,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.num_masks_x = cast(Tuple[int, int], num_masks_x)\n        self.num_masks_y = cast(Tuple[int, int], num_masks_y)\n\n        self.mask_x_length = cast(Tuple[int, int], mask_x_length)\n        self.mask_y_length = cast(Tuple[int, int], mask_y_length)\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n\n    def apply(\n        self,\n        img: np.ndarray,\n        masks_x: List[Tuple[int, int, int, int]],\n        masks_y: List[Tuple[int, int, int, int]],\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return cutout(img, masks_x + masks_y, self.fill_value)\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        masks_x: List[Tuple[int, int, int, int]],\n        masks_y: List[Tuple[int, int, int, int]],\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if self.mask_fill_value is None:\n            return mask\n        return cutout(mask, masks_x + masks_y, self.mask_fill_value)\n\n    def validate_mask_length(\n        self, mask_length: Optional[Tuple[int, int]], dimension_size: int, dimension_name: str\n    ) -&gt; None:\n        \"\"\"Validate the mask length against the corresponding image dimension size.\n\n        Args:\n            mask_length (Optional[Tuple[int, int]]): The length of the mask to be validated.\n            dimension_size (int): The size of the image dimension (width or height)\n                against which to validate the mask length.\n            dimension_name (str): The name of the dimension ('width' or 'height') for error messaging.\n\n        \"\"\"\n        if mask_length is not None:\n            if isinstance(mask_length, (tuple, list)):\n                if mask_length[0] &lt; 0 or mask_length[1] &gt; dimension_size:\n                    raise ValueError(\n                        f\"{dimension_name} range {mask_length} is out of valid range [0, {dimension_size}]\"\n                    )\n            elif mask_length &lt; 0 or mask_length &gt; dimension_size:\n                raise ValueError(f\"{dimension_name} {mask_length} exceeds image {dimension_name} {dimension_size}\")\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, List[Tuple[int, int, int, int]]]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        # Use the helper method to validate mask lengths against image dimensions\n        self.validate_mask_length(self.mask_x_length, width, \"mask_x_length\")\n        self.validate_mask_length(self.mask_y_length, height, \"mask_y_length\")\n\n        masks_x = self.generate_masks(self.num_masks_x, width, height, self.mask_x_length, axis=\"x\")\n        masks_y = self.generate_masks(self.num_masks_y, width, height, self.mask_y_length, axis=\"y\")\n\n        return {\"masks_x\": masks_x, \"masks_y\": masks_y}\n\n    @staticmethod\n    def generate_mask_size(mask_length: Tuple[int, int]) -&gt; int:\n        return random.randint(mask_length[0], mask_length[1])\n\n    def generate_masks(\n        self,\n        num_masks: Tuple[int, int],\n        width: int,\n        height: int,\n        max_length: Optional[Tuple[int, int]],\n        axis: str,\n    ) -&gt; List[Tuple[int, int, int, int]]:\n        if max_length is None or max_length == 0 or isinstance(num_masks, (int, float)) and num_masks == 0:\n            return []\n\n        masks = []\n\n        num_masks_integer = (\n            num_masks if isinstance(num_masks, int) else random_utils.randint(num_masks[0], num_masks[1])\n        )\n\n        for _ in range(num_masks_integer):\n            length = self.generate_mask_size(max_length)\n\n            if axis == \"x\":\n                x1 = random.randint(0, width - length)\n                y1 = 0\n                x2, y2 = x1 + length, height\n            else:  # axis == 'y'\n                y1 = random.randint(0, height - length)\n                x1 = 0\n                x2, y2 = width, y1 + length\n\n            masks.append((x1, y1, x2, y2))\n        return masks\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def apply_to_keypoints(\n        self,\n        keypoints: Sequence[KeypointType],\n        masks_x: List[Tuple[int, int, int, int]],\n        masks_y: List[Tuple[int, int, int, int]],\n        **params: Any,\n    ) -&gt; List[KeypointType]:\n        return [\n            keypoint\n            for keypoint in keypoints\n            if not any(keypoint_in_hole(keypoint, hole) for hole in masks_x + masks_y)\n        ]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"num_masks_x\",\n            \"num_masks_y\",\n            \"mask_x_length\",\n            \"mask_y_length\",\n            \"fill_value\",\n            \"mask_fill_value\",\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.dropout.xy_masking.XYMasking.validate_mask_length","title":"<code>validate_mask_length (self, mask_length, dimension_size, dimension_name)</code>","text":"<p>Validate the mask length against the corresponding image dimension size.</p> <p>Parameters:</p> Name Type Description <code>mask_length</code> <code>Optional[Tuple[int, int]]</code> <p>The length of the mask to be validated.</p> <code>dimension_size</code> <code>int</code> <p>The size of the image dimension (width or height) against which to validate the mask length.</p> <code>dimension_name</code> <code>str</code> <p>The name of the dimension ('width' or 'height') for error messaging.</p> Source code in <code>albumentations/augmentations/dropout/xy_masking.py</code> Python<pre><code>def validate_mask_length(\n    self, mask_length: Optional[Tuple[int, int]], dimension_size: int, dimension_name: str\n) -&gt; None:\n    \"\"\"Validate the mask length against the corresponding image dimension size.\n\n    Args:\n        mask_length (Optional[Tuple[int, int]]): The length of the mask to be validated.\n        dimension_size (int): The size of the image dimension (width or height)\n            against which to validate the mask length.\n        dimension_name (str): The name of the dimension ('width' or 'height') for error messaging.\n\n    \"\"\"\n    if mask_length is not None:\n        if isinstance(mask_length, (tuple, list)):\n            if mask_length[0] &lt; 0 or mask_length[1] &gt; dimension_size:\n                raise ValueError(\n                    f\"{dimension_name} range {mask_length} is out of valid range [0, {dimension_size}]\"\n                )\n        elif mask_length &lt; 0 or mask_length &gt; dimension_size:\n            raise ValueError(f\"{dimension_name} {mask_length} exceeds image {dimension_name} {dimension_size}\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional","title":"<code>functional</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.add_fog","title":"<code>def add_fog    (img, fog_coef, alpha_coef, haze_list)    </code> [view source on GitHub]","text":"<p>Add fog to the image.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>Image.</p> <code>fog_coef</code> <code>float</code> <p>Fog coefficient.</p> <code>alpha_coef</code> <code>float</code> <p>Alpha coefficient.</p> <code>haze_list</code> <code>List[Tuple[int, int]]</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef add_fog(img: np.ndarray, fog_coef: float, alpha_coef: float, haze_list: List[Tuple[int, int]]) -&gt; np.ndarray:\n    \"\"\"Add fog to the image.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img: Image.\n        fog_coef: Fog coefficient.\n        alpha_coef: Alpha coefficient.\n        haze_list:\n\n    Returns:\n        Image.\n\n    \"\"\"\n    non_rgb_warning(img)\n\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomFog augmentation\")\n\n    width = img.shape[1]\n\n    hw = max(int(width // 3 * fog_coef), 10)\n\n    for haze_points in haze_list:\n        x, y = haze_points\n        overlay = img.copy()\n        output = img.copy()\n        alpha = alpha_coef * fog_coef\n        rad = hw // 2\n        point = (x + hw // 2, y + hw // 2)\n        cv2.circle(overlay, point, int(rad), (255, 255, 255), -1)\n        cv2.addWeighted(overlay, alpha, output, 1 - alpha, 0, output)\n\n        img = output.copy()\n\n    image_rgb = cv2.blur(img, (hw // 10, hw // 10))\n\n    if needs_float:\n        image_rgb = to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.add_gravel","title":"<code>def add_gravel    (img, gravels)    </code> [view source on GitHub]","text":"<p>Add gravel to the image.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>numpy.ndarray</code> <p>image to add gravel to</p> <code>gravels</code> <code>list</code> <p>list of gravel parameters. (float, float, float, float): (top-left x, top-left y, bottom-right x, bottom right y)</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@ensure_contiguous\n@preserve_shape\ndef add_gravel(img: np.ndarray, gravels: List[Any]) -&gt; np.ndarray:\n    \"\"\"Add gravel to the image.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img (numpy.ndarray): image to add gravel to\n        gravels (list): list of gravel parameters. (float, float, float, float):\n            (top-left x, top-left y, bottom-right x, bottom right y)\n\n    Returns:\n        numpy.ndarray:\n\n    \"\"\"\n    non_rgb_warning(img)\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for AddGravel augmentation\")\n\n    image_hls = cv2.cvtColor(img, cv2.COLOR_RGB2HLS)\n\n    for gravel in gravels:\n        y1, y2, x1, x2, sat = gravel\n        image_hls[x1:x2, y1:y2, 1] = sat\n\n    image_rgb = cv2.cvtColor(image_hls, cv2.COLOR_HLS2RGB)\n\n    if needs_float:\n        image_rgb = to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.add_rain","title":"<code>def add_rain    (img, slant, drop_length, drop_width, drop_color, blur_value, brightness_coefficient, rain_drops)    </code> [view source on GitHub]","text":"<p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>Image.</p> <code>slant</code> <code>int</code> <code>drop_length</code> <code>int</code> <code>drop_width</code> <code>int</code> <code>drop_color</code> <code>Tuple[int, int, int]</code> <code>blur_value</code> <code>int</code> <p>Rainy view are blurry.</p> <code>brightness_coefficient</code> <code>float</code> <p>Rainy days are usually shady.</p> <code>rain_drops</code> <code>List[Tuple[int, int]]</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef add_rain(\n    img: np.ndarray,\n    slant: int,\n    drop_length: int,\n    drop_width: int,\n    drop_color: Tuple[int, int, int],\n    blur_value: int,\n    brightness_coefficient: float,\n    rain_drops: List[Tuple[int, int]],\n) -&gt; np.ndarray:\n    \"\"\"From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img: Image.\n        slant:\n        drop_length:\n        drop_width:\n        drop_color:\n        blur_value: Rainy view are blurry.\n        brightness_coefficient: Rainy days are usually shady.\n        rain_drops:\n\n    Returns:\n        Image\n\n    \"\"\"\n    non_rgb_warning(img)\n\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomRain augmentation\")\n\n    image = img.copy()\n\n    for rain_drop_x0, rain_drop_y0 in rain_drops:\n        rain_drop_x1 = rain_drop_x0 + slant\n        rain_drop_y1 = rain_drop_y0 + drop_length\n\n        cv2.line(\n            image,\n            (rain_drop_x0, rain_drop_y0),\n            (rain_drop_x1, rain_drop_y1),\n            drop_color,\n            drop_width,\n        )\n\n    image = cv2.blur(image, (blur_value, blur_value))  # rainy view are blurry\n    image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV).astype(np.float32)\n    image_hsv[:, :, 2] *= brightness_coefficient\n\n    image_rgb = cv2.cvtColor(image_hsv.astype(np.uint8), cv2.COLOR_HSV2RGB)\n\n    if needs_float:\n        return to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.add_shadow","title":"<code>def add_shadow    (img, vertices_list)    </code> [view source on GitHub]","text":"<p>Add shadows to the image.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>numpy.ndarray</code> <code>vertices_list</code> <code>list[numpy.ndarray]</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Reference</p> <p>https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@ensure_contiguous\n@preserve_shape\ndef add_shadow(img: np.ndarray, vertices_list: List[np.ndarray]) -&gt; np.ndarray:\n    \"\"\"Add shadows to the image.\n\n    Args:\n        img (numpy.ndarray):\n        vertices_list (list[numpy.ndarray]):\n\n    Returns:\n        numpy.ndarray:\n\n    Reference:\n        https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n    \"\"\"\n    non_rgb_warning(img)\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomShadow augmentation\")\n\n    image_hls = cv2.cvtColor(img, cv2.COLOR_RGB2HLS)\n    mask = np.zeros_like(img)\n\n    # adding all shadow polygons on empty mask, single 255 denotes only red channel\n    cv2.fillPoly(mask, vertices_list, 255)\n\n    # if red channel is hot, image's \"Lightness\" channel's brightness is lowered\n    red_max_value_ind = mask[:, :, 0] == MAX_VALUES_BY_DTYPE[np.dtype(\"uint8\")]\n    image_hls[:, :, 1][red_max_value_ind] = image_hls[:, :, 1][red_max_value_ind] * 0.5\n\n    image_rgb = cv2.cvtColor(image_hls, cv2.COLOR_HLS2RGB)\n\n    if needs_float:\n        return to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.add_snow","title":"<code>def add_snow    (img, snow_point, brightness_coeff)    </code> [view source on GitHub]","text":"<p>Bleaches out pixels, imitation snow.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>Image.</p> <code>snow_point</code> <code>float</code> <p>Number of show points.</p> <code>brightness_coeff</code> <code>float</code> <p>Brightness coefficient.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef add_snow(img: np.ndarray, snow_point: float, brightness_coeff: float) -&gt; np.ndarray:\n    \"\"\"Bleaches out pixels, imitation snow.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img: Image.\n        snow_point: Number of show points.\n        brightness_coeff: Brightness coefficient.\n\n    Returns:\n        Image.\n\n    \"\"\"\n    non_rgb_warning(img)\n\n    input_dtype = img.dtype\n    needs_float = False\n\n    snow_point *= 127.5  # = 255 / 2\n    snow_point += 85  # = 255 / 3\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomSnow augmentation\")\n\n    image_hls = cv2.cvtColor(img, cv2.COLOR_RGB2HLS)\n    image_hls = np.array(image_hls, dtype=np.float32)\n\n    image_hls[:, :, 1][image_hls[:, :, 1] &lt; snow_point] *= brightness_coeff\n\n    image_hls[:, :, 1] = clip(image_hls[:, :, 1], np.uint8, 255)\n\n    image_hls = np.array(image_hls, dtype=np.uint8)\n\n    image_rgb = cv2.cvtColor(image_hls, cv2.COLOR_HLS2RGB)\n\n    if needs_float:\n        image_rgb = to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.add_sun_flare","title":"<code>def add_sun_flare    (img, flare_center_x, flare_center_y, src_radius, src_color, circles)    </code> [view source on GitHub]","text":"<p>Add sun flare.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>numpy.ndarray</code> <code>flare_center_x</code> <code>float</code> <code>flare_center_y</code> <code>float</code> <code>src_radius</code> <code>int</code> <code>src_color</code> <code>int, int, int</code> <code>circles</code> <code>list</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef add_sun_flare(\n    img: np.ndarray,\n    flare_center_x: float,\n    flare_center_y: float,\n    src_radius: int,\n    src_color: ColorType,\n    circles: List[Any],\n) -&gt; np.ndarray:\n    \"\"\"Add sun flare.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img (numpy.ndarray):\n        flare_center_x (float):\n        flare_center_y (float):\n        src_radius:\n        src_color (int, int, int):\n        circles (list):\n\n    Returns:\n        numpy.ndarray:\n\n    \"\"\"\n    non_rgb_warning(img)\n\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomSunFlareaugmentation\")\n\n    overlay = img.copy()\n    output = img.copy()\n\n    for alpha, (x, y), rad3, (r_color, g_color, b_color) in circles:\n        cv2.circle(overlay, (x, y), rad3, (r_color, g_color, b_color), -1)\n\n        cv2.addWeighted(overlay, alpha, output, 1 - alpha, 0, output)\n\n    point = (int(flare_center_x), int(flare_center_y))\n\n    overlay = output.copy()\n    num_times = src_radius // 10\n    alpha = np.linspace(0.0, 1, num=num_times)\n    rad = np.linspace(1, src_radius, num=num_times)\n    for i in range(num_times):\n        cv2.circle(overlay, point, int(rad[i]), src_color, -1)\n        alp = alpha[num_times - i - 1] * alpha[num_times - i - 1] * alpha[num_times - i - 1]\n        cv2.addWeighted(overlay, alp, output, 1 - alp, 0, output)\n\n    image_rgb = output\n\n    if needs_float:\n        image_rgb = to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.bbox_from_mask","title":"<code>def bbox_from_mask    (mask)    </code> [view source on GitHub]","text":"<p>Create bounding box from binary mask (fast version)</p> <p>Parameters:</p> Name Type Description <code>mask</code> <code>numpy.ndarray</code> <p>binary mask.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box tuple <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def bbox_from_mask(mask: np.ndarray) -&gt; Tuple[int, int, int, int]:\n    \"\"\"Create bounding box from binary mask (fast version)\n\n    Args:\n        mask (numpy.ndarray): binary mask.\n\n    Returns:\n        tuple: A bounding box tuple `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    rows = np.any(mask, axis=1)\n    if not rows.any():\n        return -1, -1, -1, -1\n    cols = np.any(mask, axis=0)\n    y_min, y_max = np.where(rows)[0][[0, -1]]\n    x_min, x_max = np.where(cols)[0][[0, -1]]\n    return x_min, y_min, x_max + 1, y_max + 1\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.fancy_pca","title":"<code>def fancy_pca    (img, alpha=0.1)    </code> [view source on GitHub]","text":"<p>Perform 'Fancy PCA' augmentation from: http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>numpy array with (h, w, rgb) shape, as ints between 0-255</p> <code>alpha</code> <code>float</code> <p>how much to perturb/scale the eigen vecs and vals     the paper used std=0.1</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy image-like array as uint8 range(0, 255)</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def fancy_pca(img: np.ndarray, alpha: float = 0.1) -&gt; np.ndarray:\n    \"\"\"Perform 'Fancy PCA' augmentation from:\n    http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf\n\n    Args:\n        img: numpy array with (h, w, rgb) shape, as ints between 0-255\n        alpha: how much to perturb/scale the eigen vecs and vals\n                the paper used std=0.1\n\n    Returns:\n        numpy image-like array as uint8 range(0, 255)\n\n    \"\"\"\n    if not is_rgb_image(img) or img.dtype != np.uint8:\n        msg = \"Image must be RGB image in uint8 format.\"\n        raise TypeError(msg)\n\n    orig_img = img.astype(float).copy()\n\n    img = img / 255.0  # rescale to 0 to 1 range\n\n    # flatten image to columns of RGB\n    img_rs = img.reshape(-1, 3)\n    # img_rs shape (640000, 3)\n\n    # center mean\n    img_centered = img_rs - np.mean(img_rs, axis=0)\n\n    # paper says 3x3 covariance matrix\n    img_cov = np.cov(img_centered, rowvar=False)\n\n    # eigen values and eigen vectors\n    eig_vals, eig_vecs = np.linalg.eigh(img_cov)\n\n    # sort values and vector\n    sort_perm = eig_vals[::-1].argsort()\n    eig_vals[::-1].sort()\n    eig_vecs = eig_vecs[:, sort_perm]\n\n    # &gt; get [p1, p2, p3]\n    m1 = np.column_stack(eig_vecs)\n\n    # get 3x1 matrix of eigen values multiplied by random variable draw from normal\n    # distribution with mean of 0 and standard deviation of 0.1\n    m2 = np.zeros((3, 1))\n    # according to the paper alpha should only be draw once per augmentation (not once per channel)\n    # &gt; alpha = np.random.normal(0, alpha_std)\n\n    # broad cast to speed things up\n    m2[:, 0] = alpha * eig_vals[:]\n\n    # this is the vector that we're going to add to each pixel in a moment\n    add_vect = np.array(m1) @ np.array(m2)\n\n    for idx in range(3):  # RGB\n        orig_img[..., idx] += add_vect[idx] * 255\n\n    # for image processing it was found that working with float 0.0 to 1.0\n    # was easier than integers between 0-255\n    # &gt; orig_img /= 255.0\n    orig_img = np.clip(orig_img, 0.0, 255.0)\n\n    # &gt; orig_img *= 255\n    return orig_img.astype(np.uint8)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.iso_noise","title":"<code>def iso_noise    (image, color_shift=0.05, intensity=0.5, random_state=None, ** kwargs)    </code> [view source on GitHub]","text":"<p>Apply poisson noise to image to simulate camera sensor noise.</p> <p>Parameters:</p> Name Type Description <code>image</code> <code>numpy.ndarray</code> <p>Input image, currently, only RGB, uint8 images are supported.</p> <code>color_shift</code> <code>float</code> <code>intensity</code> <code>float</code> <p>Multiplication factor for noise values. Values of ~0.5 are produce noticeable,        yet acceptable level of noise.</p> <code>random_state</code> <code>Optional[int]</code> <code>**kwargs</code> <code>Any</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Noised image</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@clipped\ndef iso_noise(\n    image: np.ndarray,\n    color_shift: float = 0.05,\n    intensity: float = 0.5,\n    random_state: Optional[int] = None,\n    **kwargs: Any,\n) -&gt; np.ndarray:\n    \"\"\"Apply poisson noise to image to simulate camera sensor noise.\n\n    Args:\n        image (numpy.ndarray): Input image, currently, only RGB, uint8 images are supported.\n        color_shift (float):\n        intensity (float): Multiplication factor for noise values. Values of ~0.5 are produce noticeable,\n                   yet acceptable level of noise.\n        random_state:\n        **kwargs:\n\n    Returns:\n        numpy.ndarray: Noised image\n\n    \"\"\"\n    if image.dtype != np.uint8:\n        msg = \"Image must have uint8 channel type\"\n        raise TypeError(msg)\n    if not is_rgb_image(image):\n        msg = \"Image must be RGB\"\n        raise TypeError(msg)\n\n    one_over_255 = float(1.0 / 255.0)\n    image = np.multiply(image, one_over_255, dtype=np.float32)\n    hls = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    _, stddev = cv2.meanStdDev(hls)\n\n    luminance_noise = random_utils.poisson(stddev[1] * intensity * 255, size=hls.shape[:2], random_state=random_state)\n    color_noise = random_utils.normal(0, color_shift * 360 * intensity, size=hls.shape[:2], random_state=random_state)\n\n    hue = hls[..., 0]\n    hue += color_noise\n    hue %= 360\n\n    luminance = hls[..., 1]\n    luminance += (luminance_noise / 255) * (1.0 - luminance)\n\n    image = cv2.cvtColor(hls, cv2.COLOR_HLS2RGB) * 255\n    return image.astype(np.uint8)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.mask_from_bbox","title":"<code>def mask_from_bbox    (img, bbox)    </code> [view source on GitHub]","text":"<p>Create binary mask from bounding box</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>input image</p> <code>bbox</code> <code>Tuple[int, int, int, int]</code> <p>A bounding box tuple <code>(x_min, y_min, x_max, y_max)</code></p> <p>Returns:</p> Type Description <code>mask</code> <p>binary mask</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def mask_from_bbox(img: np.ndarray, bbox: Tuple[int, int, int, int]) -&gt; np.ndarray:\n    \"\"\"Create binary mask from bounding box\n\n    Args:\n        img: input image\n        bbox: A bounding box tuple `(x_min, y_min, x_max, y_max)`\n\n    Returns:\n        mask: binary mask\n\n    \"\"\"\n    mask = np.zeros(img.shape[:2], dtype=np.uint8)\n    x_min, y_min, x_max, y_max = bbox\n    mask[y_min:y_max, x_min:x_max] = 1\n    return mask\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.move_tone_curve","title":"<code>def move_tone_curve    (img, low_y, high_y)    </code> [view source on GitHub]","text":"<p>Rescales the relationship between bright and dark areas of the image by manipulating its tone curve.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>RGB or grayscale image.</p> <code>low_y</code> <code>float</code> <p>y-position of a Bezier control point used to adjust the tone curve, must be in range [0, 1]</p> <code>high_y</code> <code>float</code> <p>y-position of a Bezier control point used to adjust image tone curve, must be in range [0, 1]</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef move_tone_curve(img: np.ndarray, low_y: float, high_y: float) -&gt; np.ndarray:\n    \"\"\"Rescales the relationship between bright and dark areas of the image by manipulating its tone curve.\n\n    Args:\n        img: RGB or grayscale image.\n        low_y: y-position of a Bezier control point used\n            to adjust the tone curve, must be in range [0, 1]\n        high_y: y-position of a Bezier control point used\n            to adjust image tone curve, must be in range [0, 1]\n\n    \"\"\"\n    input_dtype = img.dtype\n\n    if not 0 &lt;= low_y &lt;= 1:\n        msg = \"low_shift must be in range [0, 1]\"\n        raise ValueError(msg)\n    if not 0 &lt;= high_y &lt;= 1:\n        msg = \"high_shift must be in range [0, 1]\"\n        raise ValueError(msg)\n\n    if input_dtype != np.uint8:\n        raise ValueError(f\"Unsupported image type {input_dtype}\")\n\n    t = np.linspace(0.0, 1.0, 256)\n\n    # Defines response of a four-point Bezier curve\n    def evaluate_bez(t: np.ndarray) -&gt; np.ndarray:\n        return 3 * (1 - t) ** 2 * t * low_y + 3 * (1 - t) * t**2 * high_y + t**3\n\n    evaluate_bez = np.vectorize(evaluate_bez)\n    remapping = np.rint(evaluate_bez(t) * 255).astype(np.uint8)\n\n    lut_fn = _maybe_process_in_chunks(cv2.LUT, lut=remapping)\n    return lut_fn(img)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.multiply","title":"<code>def multiply    (img, multiplier)    </code> [view source on GitHub]","text":"<p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>Image.</p> <code>multiplier</code> <code>ndarray</code> <p>Multiplier coefficient.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image multiplied by <code>multiplier</code> coefficient.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def multiply(img: np.ndarray, multiplier: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Args:\n\n        img: Image.\n        multiplier: Multiplier coefficient.\n\n    Returns:\n        Image multiplied by `multiplier` coefficient.\n\n    \"\"\"\n    if img.dtype == np.uint8:\n        if len(multiplier.shape) == 1:\n            return _multiply_uint8_optimized(img, multiplier)\n\n        return _multiply_uint8(img, multiplier)\n\n    return _multiply_non_uint8(img, multiplier)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.normalize_per_image","title":"<code>def normalize_per_image    (img, normalization)    </code> [view source on GitHub]","text":"<p>Apply per-image normalization based on the specified strategy.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>np.ndarray</code> <p>The image to be normalized, expected to be in HWC format.</p> <code>normalization</code> <code>str</code> <p>The normalization strategy to apply. Options include:                  \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\".</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The normalized image.</p> <p>Reference</p> <p>https://github.com/ChristofHenkel/kaggle-landmark-2021-1st-place/blob/main/data/ch_ds_1.py</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef normalize_per_image(\n    img: np.ndarray, normalization: Literal[\"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\"]\n) -&gt; np.ndarray:\n    \"\"\"Apply per-image normalization based on the specified strategy.\n\n    Args:\n        img (np.ndarray): The image to be normalized, expected to be in HWC format.\n        normalization (str): The normalization strategy to apply. Options include:\n                             \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\".\n\n    Returns:\n        np.ndarray: The normalized image.\n\n    Reference:\n        https://github.com/ChristofHenkel/kaggle-landmark-2021-1st-place/blob/main/data/ch_ds_1.py\n    \"\"\"\n    img = img.astype(np.float32)\n\n    if img.ndim == GRAYSCALE_SHAPE_LENGTH:\n        img = np.expand_dims(img, axis=-1)  # Ensure the image is at least 3D\n\n    if normalization == \"image\":\n        # Normalize the whole image based on its global mean and std\n        mean = img.mean()\n        std = img.std() + 1e-4  # Adding a small epsilon to avoid division by zero\n        normalized_img = (img - mean) / std\n        normalized_img = normalized_img.clip(-20, 20)  # Clipping outliers\n\n    elif normalization == \"image_per_channel\":\n        # Normalize the image per channel based on each channel's mean and std\n        pixel_mean = img.mean(axis=(0, 1))\n        pixel_std = img.std(axis=(0, 1)) + 1e-4\n        normalized_img = (img - pixel_mean[None, None, :]) / pixel_std[None, None, :]\n        normalized_img = normalized_img.clip(-20, 20)\n\n    elif normalization == \"min_max\":\n        # Apply min-max normalization to the whole image\n        img_min = img.min()\n        img_max = img.max()\n        normalized_img = (img - img_min) / (img_max - img_min)\n\n    elif normalization == \"min_max_per_channel\":\n        # Apply min-max normalization per channel\n        img_min = img.min(axis=(0, 1), keepdims=True)\n        img_max = img.max(axis=(0, 1), keepdims=True)\n        normalized_img = (img - img_min) / (img_max - img_min)\n\n    else:\n        raise ValueError(f\"Unknown normalization method: {normalization}\")\n\n    return normalized_img\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.posterize","title":"<code>def posterize    (img, bits)    </code> [view source on GitHub]","text":"<p>Reduce the number of bits for each color channel.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>image to posterize.</p> <code>bits</code> <code>int</code> <p>number of high bits. Must be in range [0, 8]</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image with reduced color channels.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef posterize(img: np.ndarray, bits: int) -&gt; np.ndarray:\n    \"\"\"Reduce the number of bits for each color channel.\n\n    Args:\n        img: image to posterize.\n        bits: number of high bits. Must be in range [0, 8]\n\n    Returns:\n        Image with reduced color channels.\n\n    \"\"\"\n    bits_array = np.uint8(bits)\n\n    if img.dtype != np.uint8:\n        msg = \"Image must have uint8 channel type\"\n        raise TypeError(msg)\n    if np.any((bits_array &lt; 0) | (bits_array &gt; EIGHT)):\n        msg = \"bits must be in range [0, 8]\"\n        raise ValueError(msg)\n\n    if not bits_array.shape or len(bits_array) == 1:\n        if bits_array == 0:\n            return np.zeros_like(img)\n        if bits_array == EIGHT:\n            return img.copy()\n\n        lut = np.arange(0, 256, dtype=np.uint8)\n        mask = ~np.uint8(2 ** (8 - bits_array) - 1)\n        lut &amp;= mask\n\n        return cv2.LUT(img, lut)\n\n    if not is_rgb_image(img):\n        msg = \"If bits is iterable image must be RGB\"\n        raise TypeError(msg)\n\n    result_img = np.empty_like(img)\n    for i, channel_bits in enumerate(bits_array):\n        if channel_bits == 0:\n            result_img[..., i] = np.zeros_like(img[..., i])\n        elif channel_bits == EIGHT:\n            result_img[..., i] = img[..., i].copy()\n        else:\n            lut = np.arange(0, 256, dtype=np.uint8)\n            mask = ~np.uint8(2 ** (8 - channel_bits) - 1)\n            lut &amp;= mask\n\n            result_img[..., i] = cv2.LUT(img[..., i], lut)\n\n    return result_img\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.solarize","title":"<code>def solarize    (img, threshold=128)    </code> [view source on GitHub]","text":"<p>Invert all pixel values above a threshold.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>The image to solarize.</p> <code>threshold</code> <code>int</code> <p>All pixels above this grayscale level are inverted.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Solarized image.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def solarize(img: np.ndarray, threshold: int = 128) -&gt; np.ndarray:\n    \"\"\"Invert all pixel values above a threshold.\n\n    Args:\n        img: The image to solarize.\n        threshold: All pixels above this grayscale level are inverted.\n\n    Returns:\n        Solarized image.\n\n    \"\"\"\n    dtype = img.dtype\n    max_val = MAX_VALUES_BY_DTYPE[dtype]\n\n    if dtype == np.dtype(\"uint8\"):\n        lut = [(i if i &lt; threshold else max_val - i) for i in range(int(max_val) + 1)]\n\n        prev_shape = img.shape\n        img = cv2.LUT(img, np.array(lut, dtype=dtype))\n\n        if len(prev_shape) != len(img.shape):\n            img = np.expand_dims(img, -1)\n        return img\n\n    result_img = img.copy()\n    cond = img &gt;= threshold\n    result_img[cond] = max_val - result_img[cond]\n    return result_img\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.split_uniform_grid","title":"<code>def split_uniform_grid    (image_shape, grid)    </code> [view source on GitHub]","text":"<p>Splits an image shape into a uniform grid specified by the grid dimensions.</p> <p>Parameters:</p> Name Type Description <code>image_shape</code> <code>Tuple[int, int]</code> <p>The shape of the image as (height, width).</p> <code>grid</code> <code>Tuple[int, int]</code> <p>The grid size as (rows, columns).</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>An array containing the tiles' coordinates in the format (start_y, start_x, end_y, end_x).</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def split_uniform_grid(image_shape: Tuple[int, int], grid: Tuple[int, int]) -&gt; np.ndarray:\n    \"\"\"Splits an image shape into a uniform grid specified by the grid dimensions.\n\n    Args:\n        image_shape (Tuple[int, int]): The shape of the image as (height, width).\n        grid (Tuple[int, int]): The grid size as (rows, columns).\n\n    Returns:\n        np.ndarray: An array containing the tiles' coordinates in the format (start_y, start_x, end_y, end_x).\n    \"\"\"\n    height, width = image_shape\n    n_rows, n_cols = (int(x) for x in grid)\n\n    # Compute split points for the grid\n    height_splits = np.linspace(0, height, n_rows + 1, dtype=int)\n    width_splits = np.linspace(0, width, n_cols + 1, dtype=int)\n\n    # Calculate tiles coordinates\n    tiles = [\n        (height_splits[i], width_splits[j], height_splits[i + 1], width_splits[j + 1])\n        for i in range(n_rows)\n        for j in range(n_cols)\n    ]\n\n    return np.array(tiles)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.functional.swap_tiles_on_image","title":"<code>def swap_tiles_on_image    (image, tiles, mapping=None)    </code> [view source on GitHub]","text":"<p>Swap tiles on the image according to the new format.</p> <p>Parameters:</p> Name Type Description <code>image</code> <code>ndarray</code> <p>Input image.</p> <code>tiles</code> <code>ndarray</code> <p>Array of tiles with each tile as [start_y, start_x, end_y, end_x].</p> <code>mapping</code> <code>Optional[List[int]]</code> <p>List of new tile indices.</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Output image with tiles swapped according to the random shuffle.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def swap_tiles_on_image(image: np.ndarray, tiles: np.ndarray, mapping: Optional[List[int]] = None) -&gt; np.ndarray:\n    \"\"\"Swap tiles on the image according to the new format.\n\n    Args:\n        image: Input image.\n        tiles: Array of tiles with each tile as [start_y, start_x, end_y, end_x].\n        mapping: List of new tile indices.\n\n    Returns:\n        np.ndarray: Output image with tiles swapped according to the random shuffle.\n    \"\"\"\n    # If no tiles are provided, return a copy of the original image\n    if tiles.size == 0 or mapping is None:\n        return image.copy()\n\n    # Create a copy of the image to retain original for reference\n    new_image = np.empty_like(image)\n    for num, new_index in enumerate(mapping):\n        start_y, start_x, end_y, end_x = tiles[new_index]\n        start_y_orig, start_x_orig, end_y_orig, end_x_orig = tiles[num]\n        # Assign the corresponding tile from the original image to the new image\n        new_image[start_y:end_y, start_x:end_x] = image[start_y_orig:end_y_orig, start_x_orig:end_x_orig]\n\n    return new_image\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric","title":"<code>geometric</code>  <code>special</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional","title":"<code>functional</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.bbox_flip","title":"<code>def bbox_flip    (bbox, d, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a bounding box either vertically, horizontally or both depending on the value of <code>d</code>.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>d</code> <code>int</code> <p>dimension. 0 for vertical flip, 1 for horizontal, -1 for transpose</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if value of <code>d</code> is not -1, 0 or 1.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_flip(bbox: BoxInternalType, d: int, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Flip a bounding box either vertically, horizontally or both depending on the value of `d`.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        d: dimension. 0 for vertical flip, 1 for horizontal, -1 for transpose\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: if value of `d` is not -1, 0 or 1.\n\n    \"\"\"\n    if d == 0:\n        bbox = bbox_vflip(bbox, rows, cols)\n    elif d == 1:\n        bbox = bbox_hflip(bbox, rows, cols)\n    elif d == -1:\n        bbox = bbox_hflip(bbox, rows, cols)\n        bbox = bbox_vflip(bbox, rows, cols)\n    else:\n        raise ValueError(f\"Invalid d value {d}. Valid values are -1, 0 and 1\")\n    return bbox\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.bbox_hflip","title":"<code>def bbox_hflip    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a bounding box horizontally around the y-axis.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_hflip(bbox: BoxInternalType, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Flip a bounding box horizontally around the y-axis.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    return 1 - x_max, y_min, 1 - x_min, y_max\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.bbox_rot90","title":"<code>def bbox_rot90    (bbox, factor, rows, cols)    </code> [view source on GitHub]","text":"<p>Rotates a bounding box by 90 degrees CCW (see np.rot90)</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box tuple (x_min, y_min, x_max, y_max).</p> <code>factor</code> <code>int</code> <p>Number of CCW rotations. Must be in set {0, 1, 2, 3} See np.rot90.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box tuple (x_min, y_min, x_max, y_max).</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_rot90(bbox: BoxInternalType, factor: int, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Rotates a bounding box by 90 degrees CCW (see np.rot90)\n\n    Args:\n        bbox: A bounding box tuple (x_min, y_min, x_max, y_max).\n        factor: Number of CCW rotations. Must be in set {0, 1, 2, 3} See np.rot90.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        tuple: A bounding box tuple (x_min, y_min, x_max, y_max).\n\n    \"\"\"\n    if factor not in {0, 1, 2, 3}:\n        msg = \"Parameter n must be in set {0, 1, 2, 3}\"\n        raise ValueError(msg)\n    x_min, y_min, x_max, y_max = bbox[:4]\n    if factor == 1:\n        bbox = y_min, 1 - x_max, y_max, 1 - x_min\n    elif factor == TWO:\n        bbox = 1 - x_max, 1 - y_max, 1 - x_min, 1 - y_min\n    elif factor == THREE:\n        bbox = 1 - y_max, x_min, 1 - y_min, x_max\n    return bbox\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.bbox_rotate","title":"<code>def bbox_rotate    (bbox, angle, method, rows, cols)    </code> [view source on GitHub]","text":"<p>Rotates a bounding box by angle degrees.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>angle</code> <code>float</code> <p>Angle of rotation in degrees.</p> <code>method</code> <code>str</code> <p>Rotation method used. Should be one of: \"largest_box\", \"ellipse\". Default: \"largest_box\".</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>References</p> <p>https://arxiv.org/abs/2109.13488</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_rotate(bbox: BoxInternalType, angle: float, method: str, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Rotates a bounding box by angle degrees.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        angle: Angle of rotation in degrees.\n        method: Rotation method used. Should be one of: \"largest_box\", \"ellipse\". Default: \"largest_box\".\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    References:\n        https://arxiv.org/abs/2109.13488\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    scale = cols / float(rows)\n    if method == \"largest_box\":\n        x = np.array([x_min, x_max, x_max, x_min]) - 0.5\n        y = np.array([y_min, y_min, y_max, y_max]) - 0.5\n    elif method == \"ellipse\":\n        w = (x_max - x_min) / 2\n        h = (y_max - y_min) / 2\n        data = np.arange(0, 360, dtype=np.float32)\n        x = w * np.sin(np.radians(data)) + (w + x_min - 0.5)\n        y = h * np.cos(np.radians(data)) + (h + y_min - 0.5)\n    else:\n        raise ValueError(f\"Method {method} is not a valid rotation method.\")\n    angle = np.deg2rad(angle)\n    x_t = (np.cos(angle) * x * scale + np.sin(angle) * y) / scale\n    y_t = -np.sin(angle) * x * scale + np.cos(angle) * y\n    x_t = x_t + 0.5\n    y_t = y_t + 0.5\n\n    x_min, x_max = min(x_t), max(x_t)\n    y_min, y_max = min(y_t), max(y_t)\n\n    return x_min, y_min, x_max, y_max\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.bbox_transpose","title":"<code>def bbox_transpose    (bbox, axis, rows, cols)    </code> [view source on GitHub]","text":"<p>Transposes a bounding box along given axis.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>axis</code> <code>int</code> <p>0 - main axis, 1 - secondary axis.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box tuple <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If axis not equal to 0 or 1.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_transpose(bbox: KeypointInternalType, axis: int, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Transposes a bounding box along given axis.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        axis: 0 - main axis, 1 - secondary axis.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box tuple `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: If axis not equal to 0 or 1.\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    if axis not in {0, 1}:\n        msg = \"Axis must be either 0 or 1.\"\n        raise ValueError(msg)\n    if axis == 0:\n        bbox = (y_min, x_min, y_max, x_max)\n    if axis == 1:\n        bbox = (1 - y_max, 1 - x_max, 1 - y_min, 1 - x_min)\n    return bbox\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.bbox_vflip","title":"<code>def bbox_vflip    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a bounding box vertically around the x-axis.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_vflip(bbox: BoxInternalType, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Flip a bounding box vertically around the x-axis.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        tuple: A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    return x_min, 1 - y_max, x_max, 1 - y_min\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.elastic_transform","title":"<code>def elastic_transform    (img, alpha, sigma, alpha_affine, interpolation=1, border_mode=4, value=None, random_state=None, approximate=False, same_dxdy=False)    </code> [view source on GitHub]","text":"<p>Elastic deformation of images as described in [Simard2003]_ (with modifications). Based on https://gist.github.com/ernestum/601cdf56d2b424757de5</p> <p>.. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for      Convolutional Neural Networks applied to Visual Document Analysis\", in      Proc. of the International Conference on Document Analysis and      Recognition, 2003.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef elastic_transform(\n    img: np.ndarray,\n    alpha: float,\n    sigma: float,\n    alpha_affine: float,\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n    random_state: Optional[np.random.RandomState] = None,\n    approximate: bool = False,\n    same_dxdy: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications).\n    Based on https://gist.github.com/ernestum/601cdf56d2b424757de5\n\n    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for\n         Convolutional Neural Networks applied to Visual Document Analysis\", in\n         Proc. of the International Conference on Document Analysis and\n         Recognition, 2003.\n    \"\"\"\n    height, width = img.shape[:2]\n\n    # Random affine\n    center_square = np.array((height, width), dtype=np.float32) // 2\n    square_size = min((height, width)) // 3\n    alpha = float(alpha)\n    sigma = float(sigma)\n    alpha_affine = float(alpha_affine)\n\n    pts1 = np.array(\n        [\n            center_square + square_size,\n            [center_square[0] + square_size, center_square[1] - square_size],\n            center_square - square_size,\n        ],\n        dtype=np.float32,\n    )\n    pts2 = pts1 + random_utils.uniform(-alpha_affine, alpha_affine, size=pts1.shape, random_state=random_state).astype(\n        np.float32\n    )\n    matrix = cv2.getAffineTransform(pts1, pts2)\n\n    warp_fn = _maybe_process_in_chunks(\n        cv2.warpAffine, M=matrix, dsize=(width, height), flags=interpolation, borderMode=border_mode, borderValue=value\n    )\n    img = warp_fn(img)\n\n    if approximate:\n        # Approximate computation smooth displacement map with a large enough kernel.\n        # On large images (512+) this is approximately 2X times faster\n        dx = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n        cv2.GaussianBlur(dx, (17, 17), sigma, dst=dx)\n        dx *= alpha\n        if same_dxdy:\n            # Speed up even more\n            dy = dx\n        else:\n            dy = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n            cv2.GaussianBlur(dy, (17, 17), sigma, dst=dy)\n            dy *= alpha\n    else:\n        dx = np.float32(\n            gaussian_filter((random_utils.rand(height, width, random_state=random_state) * 2 - 1), sigma) * alpha\n        )\n        if same_dxdy:\n            # Speed up\n            dy = dx\n        else:\n            dy = np.float32(\n                gaussian_filter((random_utils.rand(height, width, random_state=random_state) * 2 - 1), sigma) * alpha\n            )\n\n    x, y = np.meshgrid(np.arange(width), np.arange(height))\n\n    map_x = np.float32(x + dx)\n    map_y = np.float32(y + dy)\n\n    remap_fn = _maybe_process_in_chunks(\n        cv2.remap, map1=map_x, map2=map_y, interpolation=interpolation, borderMode=border_mode, borderValue=value\n    )\n    return remap_fn(img)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.elastic_transform_approx","title":"<code>def elastic_transform_approx    (img, alpha, sigma, alpha_affine, interpolation=1, border_mode=4, value=None, random_state=None)    </code> [view source on GitHub]","text":"<p>Elastic deformation of images as described in [Simard2003]_ (with modifications for speed). Based on https://gist.github.com/ernestum/601cdf56d2b424757de5</p> <p>.. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for      Convolutional Neural Networks applied to Visual Document Analysis\", in      Proc. of the International Conference on Document Analysis and      Recognition, 2003.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef elastic_transform_approx(\n    img: np.ndarray,\n    alpha: float,\n    sigma: float,\n    alpha_affine: float,\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n    random_state: Optional[np.random.RandomState] = None,\n) -&gt; np.ndarray:\n    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications for speed).\n    Based on https://gist.github.com/ernestum/601cdf56d2b424757de5\n\n    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for\n         Convolutional Neural Networks applied to Visual Document Analysis\", in\n         Proc. of the International Conference on Document Analysis and\n         Recognition, 2003.\n    \"\"\"\n    height, width = img.shape[:2]\n\n    # Random affine\n    center_square = np.array((height, width), dtype=np.float32) // 2\n    square_size = min((height, width)) // 3\n    alpha = float(alpha)\n    sigma = float(sigma)\n    alpha_affine = float(alpha_affine)\n\n    pts1 = np.array(\n        [\n            center_square + square_size,\n            [center_square[0] + square_size, center_square[1] - square_size],\n            center_square - square_size,\n        ],\n        dtype=np.float32,\n    )\n    pts2 = pts1 + random_utils.uniform(-alpha_affine, alpha_affine, size=pts1.shape, random_state=random_state).astype(\n        np.float32\n    )\n    matrix = cv2.getAffineTransform(pts1, pts2)\n\n    warp_fn = _maybe_process_in_chunks(\n        cv2.warpAffine,\n        M=matrix,\n        dsize=(width, height),\n        flags=interpolation,\n        borderMode=border_mode,\n        borderValue=value,\n    )\n    img = warp_fn(img)\n\n    dx = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n    cv2.GaussianBlur(dx, (17, 17), sigma, dst=dx)\n    dx *= alpha\n\n    dy = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n    cv2.GaussianBlur(dy, (17, 17), sigma, dst=dy)\n    dy *= alpha\n\n    x, y = np.meshgrid(np.arange(width), np.arange(height))\n\n    map_x = np.float32(x + dx)\n    map_y = np.float32(y + dy)\n\n    remap_fn = _maybe_process_in_chunks(\n        cv2.remap,\n        map1=map_x,\n        map2=map_y,\n        interpolation=interpolation,\n        borderMode=border_mode,\n        borderValue=value,\n    )\n    return remap_fn(img)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.find_keypoint","title":"<code>def find_keypoint    (position, distance_map, threshold, inverted)    </code> [view source on GitHub]","text":"<p>Determine if a valid keypoint can be found at the given position.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def find_keypoint(\n    position: Tuple[int, int], distance_map: np.ndarray, threshold: Optional[float], inverted: bool\n) -&gt; Optional[Tuple[float, float]]:\n    \"\"\"Determine if a valid keypoint can be found at the given position.\"\"\"\n    y, x = position\n    value = distance_map[y, x]\n    if not inverted and threshold is not None and value &gt;= threshold:\n        return None\n    if inverted and threshold is not None and value &lt; threshold:\n        return None\n    return float(x), float(y)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.from_distance_maps","title":"<code>def from_distance_maps    (distance_maps, inverted, if_not_found_coords, threshold=None)    </code> [view source on GitHub]","text":"<p>Convert outputs of <code>to_distance_maps</code> to <code>KeypointsOnImage</code>. This is the inverse of <code>to_distance_maps</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def from_distance_maps(\n    distance_maps: np.ndarray,\n    inverted: bool,\n    if_not_found_coords: Optional[Union[Sequence[int], Dict[str, Any]]],\n    threshold: Optional[float] = None,\n) -&gt; List[Tuple[float, float]]:\n    \"\"\"Convert outputs of `to_distance_maps` to `KeypointsOnImage`.\n    This is the inverse of `to_distance_maps`.\n    \"\"\"\n    if distance_maps.ndim != THREE:\n        msg = f\"Expected three-dimensional input, got {distance_maps.ndim} dimensions and shape {distance_maps.shape}.\"\n        raise ValueError(msg)\n    height, width, nb_keypoints = distance_maps.shape\n\n    drop_if_not_found, if_not_found_x, if_not_found_y = validate_if_not_found_coords(if_not_found_coords)\n\n    keypoints = []\n    for i in range(nb_keypoints):\n        hitidx_flat = np.argmax(distance_maps[..., i]) if inverted else np.argmin(distance_maps[..., i])\n        hitidx_ndim = np.unravel_index(hitidx_flat, (height, width))\n        keypoint = find_keypoint(hitidx_ndim, distance_maps[:, :, i], threshold, inverted)\n        if keypoint:\n            keypoints.append(keypoint)\n        elif not drop_if_not_found:\n            keypoints.append((if_not_found_x, if_not_found_y))\n\n    return keypoints\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.grid_distortion","title":"<code>def grid_distortion    (img, num_steps=10, xsteps=(), ysteps=(), interpolation=1, border_mode=4, value=None)    </code> [view source on GitHub]","text":"<p>Perform a grid distortion of an input image.</p> <p>Reference</p> <p>http://pythology.blogspot.sg/2014/03/interpolation-on-regular-distorted-grid.html</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef grid_distortion(\n    img: np.ndarray,\n    num_steps: int = 10,\n    xsteps: Tuple[()] = (),\n    ysteps: Tuple[()] = (),\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n) -&gt; np.ndarray:\n    \"\"\"Perform a grid distortion of an input image.\n\n    Reference:\n        http://pythology.blogspot.sg/2014/03/interpolation-on-regular-distorted-grid.html\n    \"\"\"\n    height, width = img.shape[:2]\n\n    x_step = width // num_steps\n    xx = np.zeros(width, np.float32)\n    prev = 0\n    for idx in range(num_steps + 1):\n        x = idx * x_step\n        start = int(x)\n        end = int(x) + x_step\n        if end &gt; width:\n            end = width\n            cur = width\n        else:\n            cur = prev + x_step * xsteps[idx]\n\n        xx[start:end] = np.linspace(prev, cur, end - start)\n        prev = cur\n\n    y_step = height // num_steps\n    yy = np.zeros(height, np.float32)\n    prev = 0\n    for idx in range(num_steps + 1):\n        y = idx * y_step\n        start = int(y)\n        end = int(y) + y_step\n        if end &gt; height:\n            end = height\n            cur = height\n        else:\n            cur = prev + y_step * ysteps[idx]\n\n        yy[start:end] = np.linspace(prev, cur, end - start)\n        prev = cur\n\n    map_x, map_y = np.meshgrid(xx, yy)\n    map_x = map_x.astype(np.float32)\n    map_y = map_y.astype(np.float32)\n\n    remap_fn = _maybe_process_in_chunks(\n        cv2.remap,\n        map1=map_x,\n        map2=map_y,\n        interpolation=interpolation,\n        borderMode=border_mode,\n        borderValue=value,\n    )\n    return remap_fn(img)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.keypoint_flip","title":"<code>def keypoint_flip    (keypoint, d, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a keypoint either vertically, horizontally or both depending on the value of <code>d</code>.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>d</code> <code>int</code> <p>Number of flip. Must be -1, 0 or 1: * 0 - vertical flip, * 1 - horizontal flip, * -1 - vertical and horizontal flip.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if value of <code>d</code> is not -1, 0 or 1.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def keypoint_flip(keypoint: KeypointInternalType, d: int, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Flip a keypoint either vertically, horizontally or both depending on the value of `d`.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        d: Number of flip. Must be -1, 0 or 1:\n            * 0 - vertical flip,\n            * 1 - horizontal flip,\n            * -1 - vertical and horizontal flip.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    Raises:\n        ValueError: if value of `d` is not -1, 0 or 1.\n\n    \"\"\"\n    if d == 0:\n        keypoint = keypoint_vflip(keypoint, rows, cols)\n    elif d == 1:\n        keypoint = keypoint_hflip(keypoint, rows, cols)\n    elif d == -1:\n        keypoint = keypoint_hflip(keypoint, rows, cols)\n        keypoint = keypoint_vflip(keypoint, rows, cols)\n    else:\n        raise ValueError(f\"Invalid d value {d}. Valid values are -1, 0 and 1\")\n    return keypoint\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.keypoint_hflip","title":"<code>def keypoint_hflip    (keypoint, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a keypoint horizontally around the y-axis.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_hflip(keypoint: KeypointInternalType, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Flip a keypoint horizontally around the y-axis.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    angle = math.pi - angle\n    return (cols - 1) - x, y, angle, scale\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.keypoint_rot90","title":"<code>def keypoint_rot90    (keypoint, factor, rows, cols, ** params)    </code> [view source on GitHub]","text":"<p>Rotates a keypoint by 90 degrees CCW (see np.rot90)</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>factor</code> <code>int</code> <p>Number of CCW rotations. Must be in range [0;3] See np.rot90.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if factor not in set {0, 1, 2, 3}</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_rot90(\n    keypoint: KeypointInternalType, factor: int, rows: int, cols: int, **params: Any\n) -&gt; KeypointInternalType:\n    \"\"\"Rotates a keypoint by 90 degrees CCW (see np.rot90)\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        factor: Number of CCW rotations. Must be in range [0;3] See np.rot90.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        tuple: A keypoint `(x, y, angle, scale)`.\n\n    Raises:\n        ValueError: if factor not in set {0, 1, 2, 3}\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n\n    if factor not in {0, 1, 2, 3}:\n        msg = \"Parameter n must be in set {0, 1, 2, 3}\"\n        raise ValueError(msg)\n\n    if factor == 1:\n        x, y, angle = y, (cols - 1) - x, angle - math.pi / 2\n    elif factor == TWO:\n        x, y, angle = (cols - 1) - x, (rows - 1) - y, angle - math.pi\n    elif factor == THREE:\n        x, y, angle = (rows - 1) - y, x, angle + math.pi / 2\n\n    return x, y, angle, scale\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.keypoint_rotate","title":"<code>def keypoint_rotate    (keypoint, angle, rows, cols, ** params)    </code> [view source on GitHub]","text":"<p>Rotate a keypoint by angle.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>angle</code> <code>float</code> <p>Rotation angle.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_rotate(\n    keypoint: KeypointInternalType, angle: float, rows: int, cols: int, **params: Any\n) -&gt; KeypointInternalType:\n    \"\"\"Rotate a keypoint by angle.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        angle: Rotation angle.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    center = (cols - 1) * 0.5, (rows - 1) * 0.5\n    matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n    x, y, a, s = keypoint[:4]\n    x, y = cv2.transform(np.array([[[x, y]]]), matrix).squeeze()\n    return x, y, a + math.radians(angle), s\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.keypoint_scale","title":"<code>def keypoint_scale    (keypoint, scale_x, scale_y)    </code> [view source on GitHub]","text":"<p>Scales a keypoint by scale_x and scale_y.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>scale_x</code> <code>float</code> <p>Scale coefficient x-axis.</p> <code>scale_y</code> <code>float</code> <p>Scale coefficient y-axis.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def keypoint_scale(keypoint: KeypointInternalType, scale_x: float, scale_y: float) -&gt; KeypointInternalType:\n    \"\"\"Scales a keypoint by scale_x and scale_y.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        scale_x: Scale coefficient x-axis.\n        scale_y: Scale coefficient y-axis.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    return x * scale_x, y * scale_y, angle, scale * max(scale_x, scale_y)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.keypoint_transpose","title":"<code>def keypoint_transpose    (keypoint)    </code> [view source on GitHub]","text":"<p>Rotate a keypoint by angle.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def keypoint_transpose(keypoint: KeypointInternalType) -&gt; KeypointInternalType:\n    \"\"\"Rotate a keypoint by angle.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n\n    angle = np.pi - angle if angle &lt;= np.pi else 3 * np.pi - angle\n\n    return y, x, angle, scale\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.keypoint_vflip","title":"<code>def keypoint_vflip    (keypoint, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a keypoint vertically around the x-axis.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_vflip(keypoint: KeypointInternalType, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Flip a keypoint vertically around the x-axis.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        tuple: A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    angle = -angle\n    return x, (rows - 1) - y, angle, scale\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.optical_distortion","title":"<code>def optical_distortion    (img, k=0, dx=0, dy=0, interpolation=1, border_mode=4, value=None)    </code> [view source on GitHub]","text":"<p>Barrel / pincushion distortion. Unconventional augment.</p> <p>Reference</p> <p>|  https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion |  https://stackoverflow.com/questions/10364201/image-transformation-in-opencv |  https://stackoverflow.com/questions/2477774/correcting-fisheye-distortion-programmatically |  http://www.coldvision.io/2017/03/02/advanced-lane-finding-using-opencv/</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef optical_distortion(\n    img: np.ndarray,\n    k: int = 0,\n    dx: int = 0,\n    dy: int = 0,\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n) -&gt; np.ndarray:\n    \"\"\"Barrel / pincushion distortion. Unconventional augment.\n\n    Reference:\n        |  https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion\n        |  https://stackoverflow.com/questions/10364201/image-transformation-in-opencv\n        |  https://stackoverflow.com/questions/2477774/correcting-fisheye-distortion-programmatically\n        |  http://www.coldvision.io/2017/03/02/advanced-lane-finding-using-opencv/\n    \"\"\"\n    height, width = img.shape[:2]\n\n    fx = width\n    fy = height\n\n    cx = width * 0.5 + dx\n    cy = height * 0.5 + dy\n\n    camera_matrix = np.array([[fx, 0, cx], [0, fy, cy], [0, 0, 1]], dtype=np.float32)\n\n    distortion = np.array([k, k, 0, 0, 0], dtype=np.float32)\n    map1, map2 = cv2.initUndistortRectifyMap(camera_matrix, distortion, None, None, (width, height), cv2.CV_32FC1)\n    return cv2.remap(img, map1, map2, interpolation=interpolation, borderMode=border_mode, borderValue=value)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.rotation2d_matrix_to_euler_angles","title":"<code>def rotation2d_matrix_to_euler_angles    (matrix, y_up=False)    </code> [view source on GitHub]","text":"<p>matrix (np.ndarray): Rotation matrix y_up (bool): is Y axis looks up or down</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def rotation2d_matrix_to_euler_angles(matrix: np.ndarray, y_up: bool = False) -&gt; float:\n    \"\"\"Args:\n    matrix (np.ndarray): Rotation matrix\n    y_up (bool): is Y axis looks up or down\n\n    \"\"\"\n    if y_up:\n        return np.arctan2(matrix[1, 0], matrix[0, 0])\n    return np.arctan2(-matrix[1, 0], matrix[0, 0])\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.to_distance_maps","title":"<code>def to_distance_maps    (keypoints, height, width, inverted=False)    </code> [view source on GitHub]","text":"<p>Generate a <code>(H,W,N)</code> array of distance maps for <code>N</code> keypoints.</p> <p>The <code>n</code>-th distance map contains at every location <code>(y, x)</code> the euclidean distance to the <code>n</code>-th keypoint.</p> <p>This function can be used as a helper when augmenting keypoints with a method that only supports the augmentation of images.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <p>keypoint coordinates</p> <code>height</code> <code>int</code> <p>image height</p> <code>width</code> <code>int</code> <p>image width</p> <code>inverted</code> <code>bool</code> <p>If <code>True</code>, inverted distance maps are returned where each distance value d is replaced by <code>d/(d+1)</code>, i.e. the distance maps have values in the range <code>(0.0, 1.0]</code> with <code>1.0</code> denoting exactly the position of the respective keypoint.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(H, W, N) ndarray     A <code>float32</code> array containing <code>N</code> distance maps for <code>N</code>     keypoints. Each location <code>(y, x, n)</code> in the array denotes the     euclidean distance at <code>(y, x)</code> to the <code>n</code>-th keypoint.     If <code>inverted</code> is <code>True</code>, the distance <code>d</code> is replaced     by <code>d/(d+1)</code>. The height and width of the array match the     height and width in <code>KeypointsOnImage.shape</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def to_distance_maps(\n    keypoints: Sequence[Tuple[float, float]], height: int, width: int, inverted: bool = False\n) -&gt; np.ndarray:\n    \"\"\"Generate a ``(H,W,N)`` array of distance maps for ``N`` keypoints.\n\n    The ``n``-th distance map contains at every location ``(y, x)`` the\n    euclidean distance to the ``n``-th keypoint.\n\n    This function can be used as a helper when augmenting keypoints with a\n    method that only supports the augmentation of images.\n\n    Args:\n        keypoint: keypoint coordinates\n        height: image height\n        width: image width\n        inverted (bool): If ``True``, inverted distance maps are returned where each\n            distance value d is replaced by ``d/(d+1)``, i.e. the distance\n            maps have values in the range ``(0.0, 1.0]`` with ``1.0`` denoting\n            exactly the position of the respective keypoint.\n\n    Returns:\n        (H, W, N) ndarray\n            A ``float32`` array containing ``N`` distance maps for ``N``\n            keypoints. Each location ``(y, x, n)`` in the array denotes the\n            euclidean distance at ``(y, x)`` to the ``n``-th keypoint.\n            If `inverted` is ``True``, the distance ``d`` is replaced\n            by ``d/(d+1)``. The height and width of the array match the\n            height and width in ``KeypointsOnImage.shape``.\n\n    \"\"\"\n    distance_maps = np.zeros((height, width, len(keypoints)), dtype=np.float32)\n\n    yy = np.arange(0, height)\n    xx = np.arange(0, width)\n    grid_xx, grid_yy = np.meshgrid(xx, yy)\n\n    for i, (x, y) in enumerate(keypoints):\n        distance_maps[:, :, i] = (grid_xx - x) ** 2 + (grid_yy - y) ** 2\n\n    distance_maps = np.sqrt(distance_maps)\n    if inverted:\n        return 1 / (distance_maps + 1)\n    return distance_maps\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.functional.validate_if_not_found_coords","title":"<code>def validate_if_not_found_coords    (if_not_found_coords)    </code> [view source on GitHub]","text":"<p>Validate and process <code>if_not_found_coords</code> parameter.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def validate_if_not_found_coords(\n    if_not_found_coords: Optional[Union[Sequence[int], Dict[str, Any]]],\n) -&gt; Tuple[bool, int, int]:\n    \"\"\"Validate and process `if_not_found_coords` parameter.\"\"\"\n    if if_not_found_coords is None:\n        return True, -1, -1\n    if isinstance(if_not_found_coords, (tuple, list)):\n        if len(if_not_found_coords) != TWO:\n            msg = \"Expected tuple/list 'if_not_found_coords' to contain exactly two entries.\"\n            raise ValueError(msg)\n        return False, if_not_found_coords[0], if_not_found_coords[1]\n    if isinstance(if_not_found_coords, dict):\n        return False, if_not_found_coords[\"x\"], if_not_found_coords[\"y\"]\n\n    msg = \"Expected if_not_found_coords to be None, tuple, list, or dict.\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.resize","title":"<code>resize</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.resize.LongestMaxSize","title":"<code>class  LongestMaxSize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rescale an image so that maximum side is equal to max_size, keeping the aspect ratio of the initial image.</p> <p>Parameters:</p> Name Type Description <code>max_size</code> <code>int, list of int</code> <p>maximum size of the image after the transformation. When using a list, max size will be randomly selected from the values in the list.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>interpolation method. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class LongestMaxSize(DualTransform):\n    \"\"\"Rescale an image so that maximum side is equal to max_size, keeping the aspect ratio of the initial image.\n\n    Args:\n        max_size (int, list of int): maximum size of the image after the transformation. When using a list, max size\n            will be randomly selected from the values in the list.\n        interpolation (OpenCV flag): interpolation method. Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(MaxSizeInitSchema):\n        pass\n\n    def __init__(\n        self,\n        max_size: Union[int, Sequence[int]] = 1024,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1,\n    ):\n        super().__init__(always_apply, p)\n        self.interpolation = interpolation\n        self.max_size = max_size\n\n    def apply(\n        self, img: np.ndarray, max_size: int = 1024, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.longest_max_size(img, max_size=max_size, interpolation=interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        # Bounding box coordinates are scale invariant\n        return bbox\n\n    def apply_to_keypoint(\n        self, keypoint: KeypointInternalType, max_size: int = 1024, **params: Any\n    ) -&gt; KeypointInternalType:\n        height = params[\"rows\"]\n        width = params[\"cols\"]\n\n        scale = max_size / max([height, width])\n        return F.keypoint_scale(keypoint, scale, scale)\n\n    def get_params(self) -&gt; Dict[str, int]:\n        return {\"max_size\": self.max_size if isinstance(self.max_size, int) else random.choice(self.max_size)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"max_size\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.resize.RandomScale","title":"<code>class  RandomScale</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly resize the input. Output image size is different from the input image size.</p> <p>Parameters:</p> Name Type Description <code>scale_limit</code> <code>float, float) or float</code> <p>scaling factor range. If scale_limit is a single float value, the range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1. If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high). Default: (-0.1, 0.1).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class RandomScale(DualTransform):\n    \"\"\"Randomly resize the input. Output image size is different from the input image size.\n\n    Args:\n        scale_limit ((float, float) or float): scaling factor range. If scale_limit is a single float value, the\n            range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1.\n            If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high).\n            Default: (-0.1, 0.1).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale_limit: ScaleFloatType = Field(\n            default=0.1,\n            description=\"Scaling factor range. If a single float value =&gt; (1-scale_limit, 1 + scale_limit).\",\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n        @field_validator(\"scale_limit\")\n        @classmethod\n        def check_scale_limit(cls, v: ScaleFloatType) -&gt; Tuple[float, float]:\n            return to_tuple(v, bias=1.0)\n\n    def __init__(\n        self,\n        scale_limit: ScaleFloatType = 0.1,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.scale_limit = cast(Tuple[float, float], scale_limit)\n        self.interpolation = interpolation\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"scale\": random.uniform(self.scale_limit[0], self.scale_limit[1])}\n\n    def apply(\n        self, img: np.ndarray, scale: float = 0, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.scale(img, scale, interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        # Bounding box coordinates are scale invariant\n        return bbox\n\n    def apply_to_keypoint(\n        self, keypoint: KeypointInternalType, scale: float = 0, **params: Any\n    ) -&gt; KeypointInternalType:\n        return F.keypoint_scale(keypoint, scale, scale)\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\"interpolation\": self.interpolation, \"scale_limit\": to_tuple(self.scale_limit, bias=-1.0)}\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.resize.Resize","title":"<code>class  Resize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Resize the input to the given height and width.</p> <p>Parameters:</p> Name Type Description <code>height</code> <code>int</code> <p>desired height of the output.</p> <code>width</code> <code>int</code> <p>desired width of the output.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class Resize(DualTransform):\n    \"\"\"Resize the input to the given height and width.\n\n    Args:\n        height (int): desired height of the output.\n        width (int): desired width of the output.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        height: int = Field(ge=1, description=\"Desired height of the output.\")\n        width: int = Field(ge=1, description=\"Desired width of the output.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        p: ProbabilityType = 1\n\n    def __init__(\n        self, height: int, width: int, interpolation: int = cv2.INTER_LINEAR, always_apply: bool = False, p: float = 1\n    ):\n        super().__init__(always_apply, p)\n        self.height = height\n        self.width = width\n        self.interpolation = interpolation\n\n    def apply(self, img: np.ndarray, interpolation: int = cv2.INTER_LINEAR, **params: Any) -&gt; np.ndarray:\n        return F.resize(img, height=self.height, width=self.width, interpolation=interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        # Bounding box coordinates are scale invariant\n        return bbox\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        height = params[\"rows\"]\n        width = params[\"cols\"]\n        scale_x = self.width / width\n        scale_y = self.height / height\n        return F.keypoint_scale(keypoint, scale_x, scale_y)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"height\", \"width\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.resize.SmallestMaxSize","title":"<code>class  SmallestMaxSize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rescale an image so that minimum side is equal to max_size, keeping the aspect ratio of the initial image.</p> <p>Parameters:</p> Name Type Description <code>max_size</code> <code>int, list of int</code> <p>maximum size of smallest side of the image after the transformation. When using a list, max size will be randomly selected from the values in the list.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>interpolation method. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class SmallestMaxSize(DualTransform):\n    \"\"\"Rescale an image so that minimum side is equal to max_size, keeping the aspect ratio of the initial image.\n\n    Args:\n        max_size (int, list of int): maximum size of smallest side of the image after the transformation. When using a\n            list, max size will be randomly selected from the values in the list.\n        interpolation (OpenCV flag): interpolation method. Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(MaxSizeInitSchema):\n        pass\n\n    def __init__(\n        self,\n        max_size: Union[int, Sequence[int]] = 1024,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1,\n    ):\n        super().__init__(always_apply, p)\n        self.interpolation = interpolation\n        self.max_size = max_size\n\n    def apply(\n        self, img: np.ndarray, max_size: int = 1024, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.smallest_max_size(img, max_size=max_size, interpolation=interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return bbox\n\n    def apply_to_keypoint(\n        self, keypoint: KeypointInternalType, max_size: int = 1024, **params: Any\n    ) -&gt; KeypointInternalType:\n        height = params[\"rows\"]\n        width = params[\"cols\"]\n\n        scale = max_size / min([height, width])\n        return F.keypoint_scale(keypoint, scale, scale)\n\n    def get_params(self) -&gt; Dict[str, int]:\n        return {\"max_size\": self.max_size if isinstance(self.max_size, int) else random.choice(self.max_size)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"max_size\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.rotate","title":"<code>rotate</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.rotate.RandomRotate90","title":"<code>class  RandomRotate90</code> <code> </code>  [view source on GitHub]","text":"<p>Randomly rotate the input by 90 degrees zero or more times.</p> <p>Parameters:</p> Name Type Description <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>class RandomRotate90(DualTransform):\n    \"\"\"Randomly rotate the input by 90 degrees zero or more times.\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, factor: float = 0, **params: Any) -&gt; np.ndarray:\n        \"\"\"Args:\n        factor (int): number of times the input will be rotated by 90 degrees.\n\n        \"\"\"\n        return np.ascontiguousarray(np.rot90(img, factor))\n\n    def get_params(self) -&gt; Dict[str, int]:\n        # Random int in the range [0, 3]\n        return {\"factor\": random.randint(0, 3)}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, factor: int = 0, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_rot90(bbox, factor, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, factor: int = 0, **params: Any) -&gt; BoxInternalType:\n        return F.keypoint_rot90(keypoint, factor, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.rotate.RandomRotate90.apply","title":"<code>apply (self, img, factor=0, **params)</code>","text":"<p>factor (int): number of times the input will be rotated by 90 degrees.</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>def apply(self, img: np.ndarray, factor: float = 0, **params: Any) -&gt; np.ndarray:\n    \"\"\"Args:\n    factor (int): number of times the input will be rotated by 90 degrees.\n\n    \"\"\"\n    return np.ascontiguousarray(np.rot90(img, factor))\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.rotate.Rotate","title":"<code>class  Rotate</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rotate the input by an angle selected randomly from the uniform distribution.</p> <p>Parameters:</p> Name Type Description <code>limit</code> <p>range from which a random angle is picked. If limit is a single int an angle is picked from (-limit, limit). Default: (-90, 90)</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>rotate_method</code> <code>str</code> <p>rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\". Default: \"largest_box\"</p> <code>crop_border</code> <code>bool</code> <p>If True would make a largest possible crop within rotated image</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>class Rotate(DualTransform):\n    \"\"\"Rotate the input by an angle selected randomly from the uniform distribution.\n\n    Args:\n        limit: range from which a random angle is picked. If limit is a single int\n            an angle is picked from (-limit, limit). Default: (-90, 90)\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        rotate_method (str): rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\".\n            Default: \"largest_box\"\n        crop_border (bool): If True would make a largest possible crop within rotated image\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(RotateInitSchema):\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\"\n        crop_border: bool = Field(\n            default=False, description=\"If True, makes a largest possible crop within the rotated image.\"\n        )\n\n    def __init__(\n        self,\n        limit: ScaleFloatType = 90,\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\",\n        crop_border: bool = False,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.limit = cast(Tuple[float, float], limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n        self.rotate_method = rotate_method\n        self.crop_border = crop_border\n\n    def apply(\n        self,\n        img: np.ndarray,\n        angle: float = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        img_out = F.rotate(img, angle, interpolation, self.border_mode, self.value)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.crop(img_out, x_min, y_min, x_max, y_max)\n        return img_out\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        angle: float,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        img_out = F.rotate(mask, angle, cv2.INTER_NEAREST, self.border_mode, self.mask_value)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.crop(img_out, x_min, y_min, x_max, y_max)\n        return img_out\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        angle: float = 0,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        cols: int = 0,\n        rows: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        bbox_out = F.bbox_rotate(bbox, angle, self.rotate_method, rows, cols)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.bbox_crop(bbox_out, x_min, y_min, x_max, y_max, rows, cols)\n        return bbox_out\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        angle: float = 0,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        cols: int = 0,\n        rows: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        keypoint_out = F.keypoint_rotate(keypoint, angle, rows, cols, **params)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.crop_keypoint_by_coords(keypoint_out, (x_min, y_min, x_max, y_max))\n        return keypoint_out\n\n    @staticmethod\n    def _rotated_rect_with_max_area(height: int, width: int, angle: float) -&gt; Dict[str, int]:\n        \"\"\"Given a rectangle of size wxh that has been rotated by 'angle' (in\n        degrees), computes the width and height of the largest possible\n        axis-aligned rectangle (maximal area) within the rotated rectangle.\n\n        Reference:\n            https://stackoverflow.com/questions/16702966/rotate-image-and-crop-out-black-borders\n        \"\"\"\n        angle = math.radians(angle)\n        width_is_longer = width &gt;= height\n        side_long, side_short = (width, height) if width_is_longer else (height, width)\n\n        # since the solutions for angle, -angle and 180-angle are all the same,\n        # it is sufficient to look at the first quadrant and the absolute values of sin,cos:\n        sin_a, cos_a = abs(math.sin(angle)), abs(math.cos(angle))\n        if side_short &lt;= 2.0 * sin_a * cos_a * side_long or abs(sin_a - cos_a) &lt; SMALL_NUMBER:\n            # half constrained case: two crop corners touch the longer side,\n            # the other two corners are on the mid-line parallel to the longer line\n            x = 0.5 * side_short\n            wr, hr = (x / sin_a, x / cos_a) if width_is_longer else (x / cos_a, x / sin_a)\n        else:\n            # fully constrained case: crop touches all 4 sides\n            cos_2a = cos_a * cos_a - sin_a * sin_a\n            wr, hr = (width * cos_a - height * sin_a) / cos_2a, (height * cos_a - width * sin_a) / cos_2a\n\n        return {\n            \"x_min\": max(0, int(width / 2 - wr / 2)),\n            \"x_max\": min(width, int(width / 2 + wr / 2)),\n            \"y_min\": max(0, int(height / 2 - hr / 2)),\n            \"y_max\": min(height, int(height / 2 + hr / 2)),\n        }\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        out_params = {\"angle\": random.uniform(self.limit[0], self.limit[1])}\n        if self.crop_border:\n            height, width = params[\"image\"].shape[:2]\n            out_params.update(self._rotated_rect_with_max_area(height, width, out_params[\"angle\"]))\n        return out_params\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"limit\", \"interpolation\", \"border_mode\", \"value\", \"mask_value\", \"rotate_method\", \"crop_border\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.rotate.SafeRotate","title":"<code>class  SafeRotate</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rotate the input inside the input's frame by an angle selected randomly from the uniform distribution.</p> <p>The resulting image may have artifacts in it. After rotation, the image may have a different aspect ratio, and after resizing, it returns to its original shape with the original aspect ratio of the image. For these reason we may see some artifacts.</p> <p>Parameters:</p> Name Type Description <code>limit</code> <code>int, int) or int</code> <p>range from which a random angle is picked. If limit is a single int an angle is picked from (-limit, limit). Default: (-90, 90)</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>class SafeRotate(DualTransform):\n    \"\"\"Rotate the input inside the input's frame by an angle selected randomly from the uniform distribution.\n\n    The resulting image may have artifacts in it. After rotation, the image may have a different aspect ratio, and\n    after resizing, it returns to its original shape with the original aspect ratio of the image. For these reason we\n    may see some artifacts.\n\n    Args:\n        limit ((int, int) or int): range from which a random angle is picked. If limit is a single int\n            an angle is picked from (-limit, limit). Default: (-90, 90)\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(RotateInitSchema):\n        pass\n\n    def __init__(\n        self,\n        limit: ScaleFloatType = (-90, 90),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.limit = cast(Tuple[float, float], limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def apply(self, img: np.ndarray, matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.safe_rotate(img, matrix, cast(int, self.interpolation), self.value, self.border_mode)\n\n    def apply_to_mask(self, mask: np.ndarray, matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.safe_rotate(mask, matrix, cv2.INTER_NEAREST, self.mask_value, self.border_mode)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, cols: int = 0, rows: int = 0, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_safe_rotate(bbox, params[\"matrix\"], cols, rows)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        angle: float = 0,\n        scale_x: float = 0,\n        scale_y: float = 0,\n        cols: int = 0,\n        rows: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.keypoint_safe_rotate(keypoint, params[\"matrix\"], angle, scale_x, scale_y, cols, rows)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        angle = random.uniform(self.limit[0], self.limit[1])\n\n        image = params[\"image\"]\n        height, width = image.shape[:2]\n\n        # https://stackoverflow.com/questions/43892506/opencv-python-rotate-image-without-cropping-sides\n        image_center = (width / 2, height / 2)\n\n        # Rotation Matrix\n        rotation_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n\n        # rotation calculates the cos and sin, taking absolutes of those.\n        abs_cos = abs(rotation_mat[0, 0])\n        abs_sin = abs(rotation_mat[0, 1])\n\n        # find the new width and height bounds\n        new_w = math.ceil(height * abs_sin + width * abs_cos)\n        new_h = math.ceil(height * abs_cos + width * abs_sin)\n\n        scale_x = width / new_w\n        scale_y = height / new_h\n\n        # Shift the image to create padding\n        rotation_mat[0, 2] += new_w / 2 - image_center[0]\n        rotation_mat[1, 2] += new_h / 2 - image_center[1]\n\n        # Rescale to original size\n        scale_mat = np.diag(np.ones(3))\n        scale_mat[0, 0] *= scale_x\n        scale_mat[1, 1] *= scale_y\n        _tmp = np.diag(np.ones(3))\n        _tmp[:2] = rotation_mat\n        _tmp = scale_mat @ _tmp\n        rotation_mat = _tmp[:2]\n\n        return {\"matrix\": rotation_mat, \"angle\": angle, \"scale_x\": scale_x, \"scale_y\": scale_y}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str, str]:\n        return (\"limit\", \"interpolation\", \"border_mode\", \"value\", \"mask_value\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms","title":"<code>transforms</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.Affine","title":"<code>class  Affine</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Augmentation to apply affine transformations to images. This is mostly a wrapper around the corresponding classes and functions in OpenCV.</p> <p>Affine transformations involve:</p> <pre><code>- Translation (\"move\" image on the x-/y-axis)\n- Rotation\n- Scaling (\"zoom\" in/out)\n- Shear (move one side of the image, turning a square into a trapezoid)\n</code></pre> <p>All such transformations can create \"new\" pixels in the image without a defined content, e.g. if the image is translated to the left, pixels are created on the right. A method has to be defined to deal with these pixel values. The parameters <code>cval</code> and <code>mode</code> of this class deal with this.</p> <p>Some transformations involve interpolations between several pixels of the input image to generate output pixel values. The parameters <code>interpolation</code> and <code>mask_interpolation</code> deals with the method of interpolation used for this.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <code>number, tuple of number or dict</code> <p>Scaling factor to use, where <code>1.0</code> denotes \"no change\" and <code>0.5</code> is zoomed out to <code>50</code> percent of the original size.     * If a single number, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from the interval <code>[a, b]</code>.       That the same range will be used for both x- and y-axis. To keep the aspect ratio, set       <code>keep_ratio=True</code>, then the same value will be used for both x- and y-axis.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes. Note that when       the <code>keep_ratio=True</code>, the x- and y-axis ranges should be the same.</p> <code>translate_percent</code> <code>None, number, tuple of number or dict</code> <p>Translation as a fraction of the image height/width (x-translation, y-translation), where <code>0</code> denotes \"no change\" and <code>0.5</code> denotes \"half of the axis size\".     * If <code>None</code> then equivalent to <code>0.0</code> unless <code>translate_px</code> has a value other than <code>None</code>.     * If a single number, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from the interval <code>[a, b]</code>.       That sampled fraction value will be used identically for both x- and y-axis.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes.</p> <code>translate_px</code> <code>None, int, tuple of int or dict</code> <p>Translation in pixels.     * If <code>None</code> then equivalent to <code>0</code> unless <code>translate_percent</code> has a value other than <code>None</code>.     * If a single int, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from       the discrete interval <code>[a..b]</code>. That number will be used identically for both x- and y-axis.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes.</p> <code>rotate</code> <code>number or tuple of number</code> <p>Rotation in degrees (NOT radians), i.e. expected value range is around <code>[-360, 360]</code>. Rotation happens around the center of the image, not the top left corner as in some other frameworks.     * If a number, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from the interval <code>[a, b]</code>       and used as the rotation value.</p> <code>shear</code> <code>number, tuple of number or dict</code> <p>Shear in degrees (NOT radians), i.e. expected value range is around <code>[-360, 360]</code>, with reasonable values being in the range of <code>[-45, 45]</code>.     * If a number, then that value will be used for all images as       the shear on the x-axis (no shear on the y-axis will be done).     * If a tuple <code>(a, b)</code>, then two value will be uniformly sampled per image       from the interval <code>[a, b]</code> and be used as the x- and y-shear value.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes.</p> <code>interpolation</code> <code>int</code> <p>OpenCV interpolation flag.</p> <code>mask_interpolation</code> <code>int</code> <p>OpenCV interpolation flag.</p> <code>cval</code> <code>number or sequence of number</code> <p>The constant value to use when filling in newly created pixels. (E.g. translating by 1px to the right will create a new 1px-wide column of pixels on the left of the image). The value is only used when <code>mode=constant</code>. The expected value range is <code>[0, 255]</code> for <code>uint8</code> images.</p> <code>cval_mask</code> <code>number or tuple of number</code> <p>Same as cval but only for masks.</p> <code>mode</code> <code>int</code> <p>OpenCV border flag.</p> <code>fit_output</code> <code>bool</code> <p>If True, the image plane size and position will be adjusted to tightly capture the whole image after affine transformation (<code>translate_percent</code> and <code>translate_px</code> are ignored). Otherwise (<code>False</code>),  parts of the transformed image may end up outside the image plane. Fitting the output shape can be useful to avoid corners of the image being outside the image plane after applying rotations. Default: False</p> <code>keep_ratio</code> <code>bool</code> <p>When True, the original aspect ratio will be kept when the random scale is applied.                Default: False.</p> <code>rotate_method</code> <code>str</code> <p>rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\"[1]. Default: \"largest_box\"</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>[1] https://arxiv.org/abs/2109.13488</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Affine(DualTransform):\n    \"\"\"Augmentation to apply affine transformations to images.\n    This is mostly a wrapper around the corresponding classes and functions in OpenCV.\n\n    Affine transformations involve:\n\n        - Translation (\"move\" image on the x-/y-axis)\n        - Rotation\n        - Scaling (\"zoom\" in/out)\n        - Shear (move one side of the image, turning a square into a trapezoid)\n\n    All such transformations can create \"new\" pixels in the image without a defined content, e.g.\n    if the image is translated to the left, pixels are created on the right.\n    A method has to be defined to deal with these pixel values.\n    The parameters `cval` and `mode` of this class deal with this.\n\n    Some transformations involve interpolations between several pixels\n    of the input image to generate output pixel values. The parameters `interpolation` and\n    `mask_interpolation` deals with the method of interpolation used for this.\n\n    Args:\n        scale (number, tuple of number or dict): Scaling factor to use, where ``1.0`` denotes \"no change\" and\n            ``0.5`` is zoomed out to ``50`` percent of the original size.\n                * If a single number, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from the interval ``[a, b]``.\n                  That the same range will be used for both x- and y-axis. To keep the aspect ratio, set\n                  ``keep_ratio=True``, then the same value will be used for both x- and y-axis.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes. Note that when\n                  the ``keep_ratio=True``, the x- and y-axis ranges should be the same.\n        translate_percent (None, number, tuple of number or dict): Translation as a fraction of the image height/width\n            (x-translation, y-translation), where ``0`` denotes \"no change\"\n            and ``0.5`` denotes \"half of the axis size\".\n                * If ``None`` then equivalent to ``0.0`` unless `translate_px` has a value other than ``None``.\n                * If a single number, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from the interval ``[a, b]``.\n                  That sampled fraction value will be used identically for both x- and y-axis.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes.\n        translate_px (None, int, tuple of int or dict): Translation in pixels.\n                * If ``None`` then equivalent to ``0`` unless `translate_percent` has a value other than ``None``.\n                * If a single int, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from\n                  the discrete interval ``[a..b]``. That number will be used identically for both x- and y-axis.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes.\n        rotate (number or tuple of number): Rotation in degrees (**NOT** radians), i.e. expected value range is\n            around ``[-360, 360]``. Rotation happens around the *center* of the image,\n            not the top left corner as in some other frameworks.\n                * If a number, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from the interval ``[a, b]``\n                  and used as the rotation value.\n        shear (number, tuple of number or dict): Shear in degrees (**NOT** radians), i.e. expected value range is\n            around ``[-360, 360]``, with reasonable values being in the range of ``[-45, 45]``.\n                * If a number, then that value will be used for all images as\n                  the shear on the x-axis (no shear on the y-axis will be done).\n                * If a tuple ``(a, b)``, then two value will be uniformly sampled per image\n                  from the interval ``[a, b]`` and be used as the x- and y-shear value.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes.\n        interpolation (int): OpenCV interpolation flag.\n        mask_interpolation (int): OpenCV interpolation flag.\n        cval (number or sequence of number): The constant value to use when filling in newly created pixels.\n            (E.g. translating by 1px to the right will create a new 1px-wide column of pixels\n            on the left of the image).\n            The value is only used when `mode=constant`. The expected value range is ``[0, 255]`` for ``uint8`` images.\n        cval_mask (number or tuple of number): Same as cval but only for masks.\n        mode (int): OpenCV border flag.\n        fit_output (bool): If True, the image plane size and position will be adjusted to tightly capture\n            the whole image after affine transformation (`translate_percent` and `translate_px` are ignored).\n            Otherwise (``False``),  parts of the transformed image may end up outside the image plane.\n            Fitting the output shape can be useful to avoid corners of the image being outside the image plane\n            after applying rotations. Default: False\n        keep_ratio (bool): When True, the original aspect ratio will be kept when the random scale is applied.\n                           Default: False.\n        rotate_method (str): rotation method used for the bounding boxes. Should be one of \"largest_box\" or\n            \"ellipse\"[1].\n            Default: \"largest_box\"\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        [1] https://arxiv.org/abs/2109.13488\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: Optional[Union[ScaleFloatType, Dict[str, Any]]] = Field(\n            default=None, description=\"Scaling factor or dictionary for independent axis scaling.\"\n        )\n        translate_percent: Optional[Union[ScaleFloatType, Dict[str, Any]]] = Field(\n            default=None, description=\"Translation as a fraction of the image dimension.\"\n        )\n        translate_px: Optional[Union[ScaleIntType, Dict[str, Any]]] = Field(\n            default=None, description=\"Translation in pixels.\"\n        )\n        rotate: Optional[ScaleFloatType] = Field(default=None, description=\"Rotation angle in degrees.\")\n        shear: Optional[Union[ScaleFloatType, Dict[str, Any]]] = Field(\n            default=None, description=\"Shear angle in degrees.\"\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        mask_interpolation: InterpolationType = cv2.INTER_NEAREST\n\n        cval: ColorType = Field(default=0, description=\"Value used for constant padding.\")\n        cval_mask: ColorType = Field(default=0, description=\"Value used for mask constant padding.\")\n        mode: BorderModeType = cv2.BORDER_CONSTANT\n        fit_output: Annotated[bool, Field(default=False, description=\"Adjust output to capture whole image.\")]\n        keep_ratio: Annotated[bool, Field(default=False, description=\"Maintain aspect ratio when scaling.\")]\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\"\n\n    def __init__(\n        self,\n        scale: Optional[Union[ScaleFloatType, Dict[str, Any]]] = None,\n        translate_percent: Optional[Union[ScaleFloatType, Dict[str, Any]]] = None,\n        translate_px: Optional[Union[ScaleIntType, Dict[str, Any]]] = None,\n        rotate: Optional[ScaleFloatType] = None,\n        shear: Optional[Union[ScaleFloatType, Dict[str, Any]]] = None,\n        interpolation: int = cv2.INTER_LINEAR,\n        mask_interpolation: int = cv2.INTER_NEAREST,\n        cval: ColorType = 0,\n        cval_mask: ColorType = 0,\n        mode: int = cv2.BORDER_CONSTANT,\n        fit_output: bool = False,\n        keep_ratio: bool = False,\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        params = [scale, translate_percent, translate_px, rotate, shear]\n        if all(p is None for p in params):\n            scale = {\"x\": (0.9, 1.1), \"y\": (0.9, 1.1)}\n            translate_percent = {\"x\": (-0.1, 0.1), \"y\": (-0.1, 0.1)}\n            rotate = (-15, 15)\n            shear = {\"x\": (-10, 10), \"y\": (-10, 10)}\n        else:\n            scale = scale if scale is not None else 1.0\n            rotate = rotate if rotate is not None else 0.0\n            shear = shear if shear is not None else 0.0\n\n        self.interpolation = interpolation\n        self.mask_interpolation = mask_interpolation\n        self.cval = cval\n        self.cval_mask = cval_mask\n        self.mode = mode\n        self.scale = self._handle_dict_arg(scale, \"scale\")\n        self.translate_percent, self.translate_px = self._handle_translate_arg(translate_px, translate_percent)\n        self.rotate = to_tuple(rotate, rotate)\n        self.fit_output = fit_output\n        self.shear = self._handle_dict_arg(shear, \"shear\")\n        self.keep_ratio = keep_ratio\n        self.rotate_method = rotate_method\n\n        if self.keep_ratio and self.scale[\"x\"] != self.scale[\"y\"]:\n            raise ValueError(f\"When keep_ratio is True, the x and y scale range should be identical. got {self.scale}\")\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"interpolation\",\n            \"mask_interpolation\",\n            \"cval\",\n            \"mode\",\n            \"scale\",\n            \"translate_percent\",\n            \"translate_px\",\n            \"rotate\",\n            \"fit_output\",\n            \"shear\",\n            \"cval_mask\",\n            \"keep_ratio\",\n            \"rotate_method\",\n        )\n\n    @staticmethod\n    def _handle_dict_arg(\n        val: Union[float, Tuple[float, float], Dict[str, Any]], name: str, default: float = 1.0\n    ) -&gt; Dict[str, Any]:\n        if isinstance(val, dict):\n            if \"x\" not in val and \"y\" not in val:\n                raise ValueError(\n                    f'Expected {name} dictionary to contain at least key \"x\" or ' 'key \"y\". Found neither of them.'\n                )\n            x = val.get(\"x\", default)\n            y = val.get(\"y\", default)\n            return {\"x\": to_tuple(x, x), \"y\": to_tuple(y, y)}\n        return {\"x\": to_tuple(val, val), \"y\": to_tuple(val, val)}\n\n    @classmethod\n    def _handle_translate_arg(\n        cls,\n        translate_px: Optional[Union[ScaleFloatType, Dict[str, Any]]],\n        translate_percent: Optional[Union[ScaleFloatType, Dict[str, Any]]],\n    ) -&gt; Any:\n        if translate_percent is None and translate_px is None:\n            translate_px = 0\n\n        if translate_percent is not None and translate_px is not None:\n            msg = \"Expected either translate_percent or translate_px to be \" \"provided, \" \"but neither of them was.\"\n            raise ValueError(msg)\n\n        if translate_percent is not None:\n            # translate by percent\n            return cls._handle_dict_arg(translate_percent, \"translate_percent\", default=0.0), translate_px\n\n        if translate_px is None:\n            msg = \"translate_px is None.\"\n            raise ValueError(msg)\n        # translate by pixels\n        return translate_percent, cls._handle_dict_arg(translate_px, \"translate_px\")\n\n    def apply(\n        self,\n        img: np.ndarray,\n        matrix: skimage.transform.ProjectiveTransform = None,\n        output_shape: Sequence[int] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.warp_affine(\n            img,\n            matrix,\n            interpolation=cast(int, self.interpolation),\n            cval=self.cval,\n            mode=self.mode,\n            output_shape=output_shape,\n        )\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        matrix: skimage.transform.ProjectiveTransform = None,\n        output_shape: Sequence[int] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.warp_affine(\n            mask,\n            matrix,\n            interpolation=self.mask_interpolation,\n            cval=self.cval_mask,\n            mode=self.mode,\n            output_shape=output_shape,\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        matrix: skimage.transform.ProjectiveTransform = None,\n        rows: int = 0,\n        cols: int = 0,\n        output_shape: Sequence[int] = (),\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.bbox_affine(bbox, matrix, self.rotate_method, rows, cols, output_shape)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        matrix: Optional[skimage.transform.ProjectiveTransform] = None,\n        scale: Optional[Dict[str, Any]] = None,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        if scale is None:\n            msg = \"Expected scale to be provided, but got None.\"\n            raise ValueError(msg)\n        if matrix is None:\n            msg = \"Expected matrix to be provided, but got None.\"\n            raise ValueError(msg)\n\n        return F.keypoint_affine(keypoint, matrix=matrix, scale=scale)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        translate: Dict[str, Union[int, float]]\n        if self.translate_px is not None:\n            translate = {key: random.randint(*value) for key, value in self.translate_px.items()}\n        elif self.translate_percent is not None:\n            translate = {key: random.uniform(*value) for key, value in self.translate_percent.items()}\n            translate[\"x\"] = translate[\"x\"] * width\n            translate[\"y\"] = translate[\"y\"] * height\n        else:\n            translate = {\"x\": 0, \"y\": 0}\n\n        # Look to issue https://github.com/albumentations-team/albumentations/issues/1079\n        shear = {key: -random.uniform(*value) for key, value in self.shear.items()}\n        scale = {key: random.uniform(*value) for key, value in self.scale.items()}\n        if self.keep_ratio:\n            scale[\"y\"] = scale[\"x\"]\n\n        # Look to issue https://github.com/albumentations-team/albumentations/issues/1079\n        rotate = -random.uniform(*self.rotate)\n\n        # for images we use additional shifts of (0.5, 0.5) as otherwise\n        # we get an ugly black border for 90deg rotations\n        shift_x = width / 2 - 0.5\n        shift_y = height / 2 - 0.5\n\n        matrix_to_topleft = skimage.transform.SimilarityTransform(translation=[-shift_x, -shift_y])\n        matrix_shear_y_rot = skimage.transform.AffineTransform(rotation=-np.pi / 2)\n        matrix_shear_y = skimage.transform.AffineTransform(shear=np.deg2rad(shear[\"y\"]))\n        matrix_shear_y_rot_inv = skimage.transform.AffineTransform(rotation=np.pi / 2)\n        matrix_transforms = skimage.transform.AffineTransform(\n            scale=(scale[\"x\"], scale[\"y\"]),\n            translation=(translate[\"x\"], translate[\"y\"]),\n            rotation=np.deg2rad(rotate),\n            shear=np.deg2rad(shear[\"x\"]),\n        )\n        matrix_to_center = skimage.transform.SimilarityTransform(translation=[shift_x, shift_y])\n        matrix = (\n            matrix_to_topleft\n            + matrix_shear_y_rot\n            + matrix_shear_y\n            + matrix_shear_y_rot_inv\n            + matrix_transforms\n            + matrix_to_center\n        )\n        if self.fit_output:\n            matrix, output_shape = self._compute_affine_warp_output_shape(matrix, params[\"image\"].shape)\n        else:\n            output_shape = params[\"image\"].shape\n\n        return {\n            \"rotate\": rotate,\n            \"scale\": scale,\n            \"matrix\": matrix,\n            \"output_shape\": output_shape,\n        }\n\n    @staticmethod\n    def _compute_affine_warp_output_shape(\n        matrix: skimage.transform.ProjectiveTransform, input_shape: Sequence[int]\n    ) -&gt; Tuple[skimage.transform.ProjectiveTransform, Sequence[int]]:\n        height, width = input_shape[:2]\n\n        if height == 0 or width == 0:\n            return matrix, input_shape\n\n        # determine shape of output image\n        corners = np.array([[0, 0], [0, height - 1], [width - 1, height - 1], [width - 1, 0]])\n        corners = matrix(corners)\n        minc = corners[:, 0].min()\n        minr = corners[:, 1].min()\n        maxc = corners[:, 0].max()\n        maxr = corners[:, 1].max()\n        out_height = maxr - minr + 1\n        out_width = maxc - minc + 1\n        if len(input_shape) == THREE:\n            output_shape = np.ceil((out_height, out_width, input_shape[2]))\n        else:\n            output_shape = np.ceil((out_height, out_width))\n        output_shape_tuple = tuple([int(v) for v in output_shape.tolist()])\n        # fit output image in new shape\n        translation = (-minc, -minr)\n        matrix_to_fit = skimage.transform.SimilarityTransform(translation=translation)\n        matrix = matrix + matrix_to_fit\n        return matrix, output_shape_tuple\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.ElasticTransform","title":"<code>class  ElasticTransform</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Elastic deformation of images as described in [Simard2003]_ (with modifications).</p> <p>.. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for      Convolutional Neural Networks applied to Visual Document Analysis\", in      Proc. of the International Conference on Document Analysis and      Recognition, 2003.</p> <p>Parameters:</p> Name Type Description <code>alpha</code> <code>float</code> <code>sigma</code> <code>float</code> <p>Gaussian filter parameter.</p> <code>alpha_affine</code> <code>float</code> <p>The range will be (-alpha_affine, alpha_affine)</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>approximate</code> <code>boolean</code> <p>Whether to smooth displacement map with fixed kernel size.                    Enabling this option gives ~2X speedup on large images.</p> <code>same_dxdy</code> <code>boolean</code> <p>Whether to use same random generated shift for x and y.                  Enabling this option gives ~2X speedup.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://gist.github.com/ernestum/601cdf56d2b424757de5</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class ElasticTransform(DualTransform):\n    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications).\n\n    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for\n         Convolutional Neural Networks applied to Visual Document Analysis\", in\n         Proc. of the International Conference on Document Analysis and\n         Recognition, 2003.\n\n    Args:\n        alpha (float):\n        sigma (float): Gaussian filter parameter.\n        alpha_affine (float): The range will be (-alpha_affine, alpha_affine)\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        approximate (boolean): Whether to smooth displacement map with fixed kernel size.\n                               Enabling this option gives ~2X speedup on large images.\n        same_dxdy (boolean): Whether to use same random generated shift for x and y.\n                             Enabling this option gives ~2X speedup.\n\n    Targets:\n        image, mask, bboxes\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://gist.github.com/ernestum/601cdf56d2b424757de5\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        alpha: Annotated[float, Field(default=1, description=\"Alpha parameter.\", ge=0)]\n        sigma: Annotated[float, Field(default=50, description=\"Sigma parameter for Gaussian filter.\", ge=0)]\n        alpha_affine: Annotated[float, Field(default=50, description=\"Alpha affine parameter.\", ge=0)]\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[Union[int, float, List[int], List[float]]] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        mask_value: Optional[Union[float, List[int], List[float]]] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\"\n        )\n        approximate: Annotated[bool, Field(default=False, description=\"Approximate displacement map smoothing.\")]\n        same_dxdy: Annotated[bool, Field(default=False, description=\"Use same shift for x and y.\")]\n\n    def __init__(\n        self,\n        alpha: float = 1,\n        sigma: float = 50,\n        alpha_affine: float = 50,\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[Union[int, float, List[int], List[float]]] = None,\n        mask_value: Optional[Union[int, float, List[int], List[float]]] = None,\n        always_apply: bool = False,\n        approximate: bool = False,\n        same_dxdy: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.alpha = alpha\n        self.alpha_affine = alpha_affine\n        self.sigma = sigma\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n        self.approximate = approximate\n        self.same_dxdy = same_dxdy\n\n    def apply(\n        self, img: np.ndarray, random_state: Optional[int] = None, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.elastic_transform(\n            img,\n            self.alpha,\n            self.sigma,\n            self.alpha_affine,\n            interpolation,\n            self.border_mode,\n            self.value,\n            np.random.RandomState(random_state),\n            self.approximate,\n            self.same_dxdy,\n        )\n\n    def apply_to_mask(self, mask: np.ndarray, random_state: Optional[int] = None, **params: Any) -&gt; np.ndarray:\n        return F.elastic_transform(\n            mask,\n            self.alpha,\n            self.sigma,\n            self.alpha_affine,\n            cv2.INTER_NEAREST,\n            self.border_mode,\n            self.mask_value,\n            np.random.RandomState(random_state),\n            self.approximate,\n            self.same_dxdy,\n        )\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, random_state: Optional[int] = None, **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        mask = np.zeros((rows, cols), dtype=np.uint8)\n        bbox_denorm = F.denormalize_bbox(bbox, rows, cols)\n        x_min, y_min, x_max, y_max = bbox_denorm[:4]\n        x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)\n        mask[y_min:y_max, x_min:x_max] = 1\n        mask = F.elastic_transform(\n            mask,\n            self.alpha,\n            self.sigma,\n            self.alpha_affine,\n            cv2.INTER_NEAREST,\n            self.border_mode,\n            self.mask_value,\n            np.random.RandomState(random_state),\n            self.approximate,\n        )\n        bbox_returned = bbox_from_mask(mask)\n        return cast(BoxInternalType, F.normalize_bbox(bbox_returned, rows, cols))\n\n    def get_params(self) -&gt; Dict[str, int]:\n        return {\"random_state\": random.randint(0, 10000)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"alpha\",\n            \"sigma\",\n            \"alpha_affine\",\n            \"interpolation\",\n            \"border_mode\",\n            \"value\",\n            \"mask_value\",\n            \"approximate\",\n            \"same_dxdy\",\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.Flip","title":"<code>class  Flip</code> <code> </code>  [view source on GitHub]","text":"<p>Flip the input either horizontally, vertically or both horizontally and vertically.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Flip(DualTransform):\n    \"\"\"Flip the input either horizontally, vertically or both horizontally and vertically.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, d: int = 0, **params: Any) -&gt; np.ndarray:\n        \"\"\"Args:\n        d (int): code that specifies how to flip the input. 0 for vertical flipping, 1 for horizontal flipping,\n                -1 for both vertical and horizontal flipping (which is also could be seen as rotating the input by\n                180 degrees).\n        \"\"\"\n        return F.random_flip(img, d)\n\n    def get_params(self) -&gt; Dict[str, int]:\n        # Random int in the range [-1, 1]\n        return {\"d\": random.randint(-1, 1)}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_flip(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_flip(keypoint, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.Flip.apply","title":"<code>apply (self, img, d=0, **params)</code>","text":"<p>d (int): code that specifies how to flip the input. 0 for vertical flipping, 1 for horizontal flipping,         -1 for both vertical and horizontal flipping (which is also could be seen as rotating the input by         180 degrees).</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>def apply(self, img: np.ndarray, d: int = 0, **params: Any) -&gt; np.ndarray:\n    \"\"\"Args:\n    d (int): code that specifies how to flip the input. 0 for vertical flipping, 1 for horizontal flipping,\n            -1 for both vertical and horizontal flipping (which is also could be seen as rotating the input by\n            180 degrees).\n    \"\"\"\n    return F.random_flip(img, d)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.GridDistortion","title":"<code>class  GridDistortion</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Parameters:</p> Name Type Description <code>num_steps</code> <code>int</code> <p>count of grid cells on each side.</p> <code>distort_limit</code> <code>float, (float, float</code> <p>If distort_limit is a single float, the range will be (-distort_limit, distort_limit). Default: (-0.03, 0.03).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>normalized</code> <code>bool</code> <p>if true, distortion will be normalized to do not go outside the image. Default: False See for more information: https://github.com/albumentations-team/albumentations/pull/722</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class GridDistortion(DualTransform):\n    \"\"\"Args:\n        num_steps (int): count of grid cells on each side.\n        distort_limit (float, (float, float)): If distort_limit is a single float, the range\n            will be (-distort_limit, distort_limit). Default: (-0.03, 0.03).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        normalized (bool): if true, distortion will be normalized to do not go outside the image. Default: False\n            See for more information: https://github.com/albumentations-team/albumentations/pull/722\n\n    Targets:\n        image, mask, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        num_steps: Annotated[int, Field(ge=1, description=\"Count of grid cells on each side.\")]\n        distort_limit: SymmetricRangeType = (-0.03, 0.03)\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        mask_value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value for mask if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        normalized: bool = Field(\n            default=False, description=\"If true, distortion will be normalized to not go outside the image.\"\n        )\n\n        @field_validator(\"distort_limit\")\n        @classmethod\n        def check_limits(cls, v: Tuple[float, float], info: ValidationInfo) -&gt; Tuple[float, float]:\n            bounds = -1, 1\n            result = to_tuple(v)\n            check_range(result, *bounds, info.field_name)\n            return result\n\n    def __init__(\n        self,\n        num_steps: int = 5,\n        distort_limit: ScaleFloatType = (-0.3, 0.3),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        normalized: bool = False,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        self.num_steps = num_steps\n        self.distort_limit = cast(Tuple[float, float], distort_limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n        self.normalized = normalized\n\n    def apply(\n        self,\n        img: np.ndarray,\n        stepsx: Tuple[()] = (),\n        stepsy: Tuple[()] = (),\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.grid_distortion(img, self.num_steps, stepsx, stepsy, interpolation, self.border_mode, self.value)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, stepsx: Tuple[()] = (), stepsy: Tuple[()] = (), **params: Any\n    ) -&gt; np.ndarray:\n        return F.grid_distortion(\n            mask, self.num_steps, stepsx, stepsy, cv2.INTER_NEAREST, self.border_mode, self.mask_value\n        )\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, stepsx: Tuple[()] = (), stepsy: Tuple[()] = (), **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        mask = np.zeros((rows, cols), dtype=np.uint8)\n        bbox_denorm = F.denormalize_bbox(bbox, rows, cols)\n        x_min, y_min, x_max, y_max = bbox_denorm[:4]\n        x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)\n        mask[y_min:y_max, x_min:x_max] = 1\n        mask = F.grid_distortion(\n            mask, self.num_steps, stepsx, stepsy, cv2.INTER_NEAREST, self.border_mode, self.mask_value\n        )\n        bbox_returned = bbox_from_mask(mask)\n        return cast(BoxInternalType, F.normalize_bbox(bbox_returned, rows, cols))\n\n    def _normalize(self, h: int, w: int, xsteps: List[float], ysteps: List[float]) -&gt; Dict[str, Any]:\n        # compensate for smaller last steps in source image.\n        x_step = w // self.num_steps\n        last_x_step = min(w, ((self.num_steps + 1) * x_step)) - (self.num_steps * x_step)\n        xsteps[-1] *= last_x_step / x_step\n\n        y_step = h // self.num_steps\n        last_y_step = min(h, ((self.num_steps + 1) * y_step)) - (self.num_steps * y_step)\n        ysteps[-1] *= last_y_step / y_step\n\n        # now normalize such that distortion never leaves image bounds.\n        tx = w / math.floor(w / self.num_steps)\n        ty = h / math.floor(h / self.num_steps)\n        xsteps = np.array(xsteps) * (tx / np.sum(xsteps))\n        ysteps = np.array(ysteps) * (ty / np.sum(ysteps))\n\n        return {\"stepsx\": xsteps, \"stepsy\": ysteps}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        stepsx = [\n            1 + random_utils.uniform(self.distort_limit[0], self.distort_limit[1]) for _ in range(self.num_steps + 1)\n        ]\n        stepsy = [\n            1 + random_utils.uniform(self.distort_limit[0], self.distort_limit[1]) for _ in range(self.num_steps + 1)\n        ]\n\n        if self.normalized:\n            return self._normalize(height, width, stepsx, stepsy)\n\n        return {\"stepsx\": stepsx, \"stepsy\": stepsy}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"num_steps\", \"distort_limit\", \"interpolation\", \"border_mode\", \"value\", \"mask_value\", \"normalized\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.HorizontalFlip","title":"<code>class  HorizontalFlip</code> <code> </code>  [view source on GitHub]","text":"<p>Flip the input horizontally around the y-axis.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class HorizontalFlip(DualTransform):\n    \"\"\"Flip the input horizontally around the y-axis.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if img.ndim == THREE and img.shape[2] &gt; 1 and img.dtype == np.uint8:\n            # Opencv is faster than numpy only in case of\n            # non-gray scale 8bits images\n            return F.hflip_cv2(img)\n\n        return F.hflip(img)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_hflip(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_hflip(keypoint, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.OpticalDistortion","title":"<code>class  OpticalDistortion</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Parameters:</p> Name Type Description <code>distort_limit</code> <code>float, (float, float</code> <p>If distort_limit is a single float, the range will be (-distort_limit, distort_limit). Default: (-0.05, 0.05).</p> <code>shift_limit</code> <code>float, (float, float</code> <p>If shift_limit is a single float, the range will be (-shift_limit, shift_limit). Default: (-0.05, 0.05).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class OpticalDistortion(DualTransform):\n    \"\"\"Args:\n        distort_limit (float, (float, float)): If distort_limit is a single float, the range\n            will be (-distort_limit, distort_limit). Default: (-0.05, 0.05).\n        shift_limit (float, (float, float))): If shift_limit is a single float, the range\n            will be (-shift_limit, shift_limit). Default: (-0.05, 0.05).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n\n    Targets:\n        image, mask, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        distort_limit: SymmetricRangeType = (-0.05, 0.05)\n        shift_limit: SymmetricRangeType = (-0.05, 0.05)\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        mask_value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value for mask if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n\n    def __init__(\n        self,\n        distort_limit: ScaleFloatType = (-0.05, 0.05),\n        shift_limit: ScaleFloatType = (-0.05, 0.05),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.shift_limit = cast(Tuple[float, float], shift_limit)\n        self.distort_limit = cast(Tuple[float, float], distort_limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def apply(\n        self,\n        img: np.ndarray,\n        k: int = 0,\n        dx: int = 0,\n        dy: int = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.optical_distortion(img, k, dx, dy, interpolation, self.border_mode, self.value)\n\n    def apply_to_mask(self, mask: np.ndarray, k: int = 0, dx: int = 0, dy: int = 0, **params: Any) -&gt; np.ndarray:\n        return F.optical_distortion(mask, k, dx, dy, cv2.INTER_NEAREST, self.border_mode, self.mask_value)\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, k: int = 0, dx: int = 0, dy: int = 0, **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        mask = np.zeros((rows, cols), dtype=np.uint8)\n        bbox_denorm = F.denormalize_bbox(bbox, rows, cols)\n        x_min, y_min, x_max, y_max = bbox_denorm[:4]\n        x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)\n        mask[y_min:y_max, x_min:x_max] = 1\n        mask = F.optical_distortion(mask, k, dx, dy, cv2.INTER_NEAREST, self.border_mode, self.mask_value)\n        bbox_returned = bbox_from_mask(mask)\n        return cast(BoxInternalType, F.normalize_bbox(bbox_returned, rows, cols))\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"k\": random.uniform(self.distort_limit[0], self.distort_limit[1]),\n            \"dx\": round(random.uniform(self.shift_limit[0], self.shift_limit[1])),\n            \"dy\": round(random.uniform(self.shift_limit[0], self.shift_limit[1])),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"distort_limit\",\n            \"shift_limit\",\n            \"interpolation\",\n            \"border_mode\",\n            \"value\",\n            \"mask_value\",\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.PadIfNeeded","title":"<code>class  PadIfNeeded</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Pad side of the image / max if side is less than desired number.</p> <p>Parameters:</p> Name Type Description <code>min_height</code> <code>int</code> <p>minimal result image height.</p> <code>min_width</code> <code>int</code> <p>minimal result image width.</p> <code>pad_height_divisor</code> <code>int</code> <p>if not None, ensures image height is dividable by value of this argument.</p> <code>pad_width_divisor</code> <code>int</code> <p>if not None, ensures image width is dividable by value of this argument.</p> <code>position</code> <code>Union[str, PositionType]</code> <p>Position of the image. should be PositionType.CENTER or PositionType.TOP_LEFT or PositionType.TOP_RIGHT or PositionType.BOTTOM_LEFT or PositionType.BOTTOM_RIGHT. or PositionType.RANDOM. Default: PositionType.CENTER.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>OpenCV border mode.</p> <code>value</code> <code>int, float, list of int, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of int,         list of float</code> <p>padding value for mask if border_mode is cv2.BORDER_CONSTANT.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class PadIfNeeded(DualTransform):\n    \"\"\"Pad side of the image / max if side is less than desired number.\n\n    Args:\n        min_height (int): minimal result image height.\n        min_width (int): minimal result image width.\n        pad_height_divisor (int): if not None, ensures image height is dividable by value of this argument.\n        pad_width_divisor (int): if not None, ensures image width is dividable by value of this argument.\n        position (Union[str, PositionType]): Position of the image. should be PositionType.CENTER or\n            PositionType.TOP_LEFT or PositionType.TOP_RIGHT or PositionType.BOTTOM_LEFT or PositionType.BOTTOM_RIGHT.\n            or PositionType.RANDOM. Default: PositionType.CENTER.\n        border_mode (OpenCV flag): OpenCV border mode.\n        value (int, float, list of int, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of int,\n                    list of float): padding value for mask if border_mode is cv2.BORDER_CONSTANT.\n        p (float): probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class PositionType(Enum):\n        \"\"\"Enumerates the types of positions for placing an object within a container.\n\n        This Enum class is utilized to define specific anchor positions that an object can\n        assume relative to a container. It's particularly useful in image processing, UI layout,\n        and graphic design to specify the alignment and positioning of elements.\n\n        Attributes:\n            CENTER (str): Specifies that the object should be placed at the center.\n            TOP_LEFT (str): Specifies that the object should be placed at the top-left corner.\n            TOP_RIGHT (str): Specifies that the object should be placed at the top-right corner.\n            BOTTOM_LEFT (str): Specifies that the object should be placed at the bottom-left corner.\n            BOTTOM_RIGHT (str): Specifies that the object should be placed at the bottom-right corner.\n            RANDOM (str): Indicates that the object's position should be determined randomly.\n\n        \"\"\"\n\n        CENTER = \"center\"\n        TOP_LEFT = \"top_left\"\n        TOP_RIGHT = \"top_right\"\n        BOTTOM_LEFT = \"bottom_left\"\n        BOTTOM_RIGHT = \"bottom_right\"\n        RANDOM = \"random\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        min_height: Optional[int] = Field(default=None, ge=1, description=\"Minimal result image height.\")\n        min_width: Optional[int] = Field(default=None, ge=1, description=\"Minimal result image width.\")\n        pad_height_divisor: Optional[int] = Field(\n            default=None, ge=1, description=\"Ensures image height is divisible by this value.\"\n        )\n        pad_width_divisor: Optional[int] = Field(\n            default=None, ge=1, description=\"Ensures image width is divisible by this value.\"\n        )\n        position: str = Field(default=\"center\", description=\"Position of the padded image.\")\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[ColorType] = Field(default=None, description=\"Value for border if BORDER_CONSTANT is used.\")\n        mask_value: Optional[ColorType] = Field(\n            default=None, description=\"Value for mask border if BORDER_CONSTANT is used.\"\n        )\n        p: ProbabilityType = 1.0\n\n        @model_validator(mode=\"after\")\n        def validate_divisibility(self) -&gt; Self:\n            if (self.min_height is None) == (self.pad_height_divisor is None):\n                msg = \"Only one of 'min_height' and 'pad_height_divisor' parameters must be set\"\n                raise ValueError(msg)\n            if (self.min_width is None) == (self.pad_width_divisor is None):\n                msg = \"Only one of 'min_width' and 'pad_width_divisor' parameters must be set\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        min_height: Optional[int] = 1024,\n        min_width: Optional[int] = 1024,\n        pad_height_divisor: Optional[int] = None,\n        pad_width_divisor: Optional[int] = None,\n        position: Union[PositionType, str] = PositionType.CENTER,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n        self.min_height = min_height\n        self.min_width = min_width\n        self.pad_width_divisor = pad_width_divisor\n        self.pad_height_divisor = pad_height_divisor\n        self.position = PadIfNeeded.PositionType(position)\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def update_params(self, params: Dict[str, Any], **kwargs: Any) -&gt; Dict[str, Any]:\n        params = super().update_params(params, **kwargs)\n        rows = params[\"rows\"]\n        cols = params[\"cols\"]\n\n        if self.min_height is not None:\n            if rows &lt; self.min_height:\n                h_pad_top = int((self.min_height - rows) / 2.0)\n                h_pad_bottom = self.min_height - rows - h_pad_top\n            else:\n                h_pad_top = 0\n                h_pad_bottom = 0\n        else:\n            pad_remained = rows % self.pad_height_divisor\n            pad_rows = self.pad_height_divisor - pad_remained if pad_remained &gt; 0 else 0\n\n            h_pad_top = pad_rows // 2\n            h_pad_bottom = pad_rows - h_pad_top\n\n        if self.min_width is not None:\n            if cols &lt; self.min_width:\n                w_pad_left = int((self.min_width - cols) / 2.0)\n                w_pad_right = self.min_width - cols - w_pad_left\n            else:\n                w_pad_left = 0\n                w_pad_right = 0\n        else:\n            pad_remainder = cols % self.pad_width_divisor\n            pad_cols = self.pad_width_divisor - pad_remainder if pad_remainder &gt; 0 else 0\n\n            w_pad_left = pad_cols // 2\n            w_pad_right = pad_cols - w_pad_left\n\n        h_pad_top, h_pad_bottom, w_pad_left, w_pad_right = self.__update_position_params(\n            h_top=h_pad_top, h_bottom=h_pad_bottom, w_left=w_pad_left, w_right=w_pad_right\n        )\n\n        params.update(\n            {\n                \"pad_top\": h_pad_top,\n                \"pad_bottom\": h_pad_bottom,\n                \"pad_left\": w_pad_left,\n                \"pad_right\": w_pad_right,\n            }\n        )\n        return params\n\n    def apply(\n        self,\n        img: np.ndarray,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.pad_with_params(\n            img,\n            pad_top,\n            pad_bottom,\n            pad_left,\n            pad_right,\n            border_mode=self.border_mode,\n            value=self.value,\n        )\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.pad_with_params(\n            mask,\n            pad_top,\n            pad_bottom,\n            pad_left,\n            pad_right,\n            border_mode=self.border_mode,\n            value=self.mask_value,\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        rows: int = 0,\n        cols: int = 0,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        x_min, y_min, x_max, y_max = denormalize_bbox(bbox, rows, cols)[:4]\n        bbox = x_min + pad_left, y_min + pad_top, x_max + pad_left, y_max + pad_top\n        return cast(BoxInternalType, normalize_bbox(bbox, rows + pad_top + pad_bottom, cols + pad_left + pad_right))\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        x, y, angle, scale = keypoint[:4]\n        return x + pad_left, y + pad_top, angle, scale\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"min_height\",\n            \"min_width\",\n            \"pad_height_divisor\",\n            \"pad_width_divisor\",\n            \"position\",\n            \"border_mode\",\n            \"value\",\n            \"mask_value\",\n        )\n\n    def __update_position_params(\n        self, h_top: int, h_bottom: int, w_left: int, w_right: int\n    ) -&gt; Tuple[int, int, int, int]:\n        if self.position == PadIfNeeded.PositionType.TOP_LEFT:\n            h_bottom += h_top\n            w_right += w_left\n            h_top = 0\n            w_left = 0\n\n        elif self.position == PadIfNeeded.PositionType.TOP_RIGHT:\n            h_bottom += h_top\n            w_left += w_right\n            h_top = 0\n            w_right = 0\n\n        elif self.position == PadIfNeeded.PositionType.BOTTOM_LEFT:\n            h_top += h_bottom\n            w_right += w_left\n            h_bottom = 0\n            w_left = 0\n\n        elif self.position == PadIfNeeded.PositionType.BOTTOM_RIGHT:\n            h_top += h_bottom\n            w_left += w_right\n            h_bottom = 0\n            w_right = 0\n\n        elif self.position == PadIfNeeded.PositionType.RANDOM:\n            h_pad = h_top + h_bottom\n            w_pad = w_left + w_right\n            h_top = random.randint(0, h_pad)\n            h_bottom = h_pad - h_top\n            w_left = random.randint(0, w_pad)\n            w_right = w_pad - w_left\n\n        return h_top, h_bottom, w_left, w_right\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.PadIfNeeded.PositionType","title":"<code>class  PositionType</code> <code> </code>","text":"<p>Enumerates the types of positions for placing an object within a container.</p> <p>This Enum class is utilized to define specific anchor positions that an object can assume relative to a container. It's particularly useful in image processing, UI layout, and graphic design to specify the alignment and positioning of elements.</p> <p>Attributes:</p> Name Type Description <code>CENTER</code> <code>str</code> <p>Specifies that the object should be placed at the center.</p> <code>TOP_LEFT</code> <code>str</code> <p>Specifies that the object should be placed at the top-left corner.</p> <code>TOP_RIGHT</code> <code>str</code> <p>Specifies that the object should be placed at the top-right corner.</p> <code>BOTTOM_LEFT</code> <code>str</code> <p>Specifies that the object should be placed at the bottom-left corner.</p> <code>BOTTOM_RIGHT</code> <code>str</code> <p>Specifies that the object should be placed at the bottom-right corner.</p> <code>RANDOM</code> <code>str</code> <p>Indicates that the object's position should be determined randomly.</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class PositionType(Enum):\n    \"\"\"Enumerates the types of positions for placing an object within a container.\n\n    This Enum class is utilized to define specific anchor positions that an object can\n    assume relative to a container. It's particularly useful in image processing, UI layout,\n    and graphic design to specify the alignment and positioning of elements.\n\n    Attributes:\n        CENTER (str): Specifies that the object should be placed at the center.\n        TOP_LEFT (str): Specifies that the object should be placed at the top-left corner.\n        TOP_RIGHT (str): Specifies that the object should be placed at the top-right corner.\n        BOTTOM_LEFT (str): Specifies that the object should be placed at the bottom-left corner.\n        BOTTOM_RIGHT (str): Specifies that the object should be placed at the bottom-right corner.\n        RANDOM (str): Indicates that the object's position should be determined randomly.\n\n    \"\"\"\n\n    CENTER = \"center\"\n    TOP_LEFT = \"top_left\"\n    TOP_RIGHT = \"top_right\"\n    BOTTOM_LEFT = \"bottom_left\"\n    BOTTOM_RIGHT = \"bottom_right\"\n    RANDOM = \"random\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.Perspective","title":"<code>class  Perspective</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Perform a random four point perspective transform of the input.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <p>standard deviation of the normal distributions. These are used to sample the random distances of the subimage's corners from the full image's corners. If scale is a single float value, the range will be (0, scale). Default: (0.05, 0.1).</p> <code>keep_size</code> <p>Whether to resize image back to their original size after applying the perspective transform. If set to False, the resulting images may end up having different shapes and will always be a list, never an array. Default: True</p> <code>pad_mode</code> <code>OpenCV flag</code> <p>OpenCV border mode.</p> <code>pad_val</code> <code>int, float, list of int, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT. Default: 0</p> <code>mask_pad_val</code> <code>int, float, list of int, list of float</code> <p>padding value for mask if border_mode is cv2.BORDER_CONSTANT. Default: 0</p> <code>fit_output</code> <code>bool</code> <p>If True, the image plane size and position will be adjusted to still capture the whole image after perspective transformation. (Followed by image resizing if keep_size is set to True.) Otherwise, parts of the transformed image may be outside of the image plane. This setting should not be set to True when using large scale values as it could lead to very large images. Default: False</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Perspective(DualTransform):\n    \"\"\"Perform a random four point perspective transform of the input.\n\n    Args:\n        scale: standard deviation of the normal distributions. These are used to sample\n            the random distances of the subimage's corners from the full image's corners.\n            If scale is a single float value, the range will be (0, scale). Default: (0.05, 0.1).\n        keep_size: Whether to resize image back to their original size after applying the perspective\n            transform. If set to False, the resulting images may end up having different shapes\n            and will always be a list, never an array. Default: True\n        pad_mode (OpenCV flag): OpenCV border mode.\n        pad_val (int, float, list of int, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n            Default: 0\n        mask_pad_val (int, float, list of int, list of float): padding value for mask\n            if border_mode is cv2.BORDER_CONSTANT. Default: 0\n        fit_output (bool): If True, the image plane size and position will be adjusted to still capture\n            the whole image after perspective transformation. (Followed by image resizing if keep_size is set to True.)\n            Otherwise, parts of the transformed image may be outside of the image plane.\n            This setting should not be set to True when using large scale values as it could lead to very large images.\n            Default: False\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: NonNegativeFloatRangeType = (0.05, 0.1)\n        keep_size: Annotated[bool, Field(default=True, description=\"Keep size after transform.\")]\n        pad_mode: BorderModeType = cv2.BORDER_CONSTANT\n        pad_val: Optional[ColorType] = Field(\n            default=0,\n            description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\",\n        )\n        mask_pad_val: Optional[ColorType] = Field(\n            default=0,\n            description=\"Mask padding value if border_mode is cv2.BORDER_CONSTANT.\",\n        )\n        fit_output: Annotated[bool, Field(default=False, description=\"Adjust image plane to capture whole image.\")]\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n    def __init__(\n        self,\n        scale: ScaleFloatType = (0.05, 0.1),\n        keep_size: bool = True,\n        pad_mode: int = cv2.BORDER_CONSTANT,\n        pad_val: Union[ColorType] = 0,\n        mask_pad_val: Union[ColorType] = 0,\n        fit_output: bool = False,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.scale = cast(Tuple[float, float], scale)\n        self.keep_size = keep_size\n        self.pad_mode = pad_mode\n        self.pad_val = pad_val\n        self.mask_pad_val = mask_pad_val\n        self.fit_output = fit_output\n        self.interpolation = interpolation\n\n    def apply(\n        self,\n        img: np.ndarray,\n        matrix: np.ndarray,\n        max_height: int,\n        max_width: int,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.perspective(\n            img, matrix, max_width, max_height, self.pad_val, self.pad_mode, self.keep_size, params[\"interpolation\"]\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        matrix: np.ndarray,\n        max_height: int,\n        max_width: int,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.perspective_bbox(bbox, params[\"rows\"], params[\"cols\"], matrix, max_width, max_height, self.keep_size)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        matrix: np.ndarray,\n        max_height: int,\n        max_width: int,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.perspective_keypoint(\n            keypoint, params[\"rows\"], params[\"cols\"], matrix, max_width, max_height, self.keep_size\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        scale = random_utils.uniform(*self.scale)\n        points = random_utils.normal(0, scale, [4, 2])\n        points = np.mod(np.abs(points), 0.32)\n\n        # top left -- no changes needed, just use jitter\n        # top right\n        points[1, 0] = 1.0 - points[1, 0]  # w = 1.0 - jitter\n        # bottom right\n        points[2] = 1.0 - points[2]  # w = 1.0 - jitt\n        # bottom left\n        points[3, 1] = 1.0 - points[3, 1]  # h = 1.0 - jitter\n\n        points[:, 0] *= width\n        points[:, 1] *= height\n\n        # Obtain a consistent order of the points and unpack them individually.\n        # Warning: don't just do (tl, tr, br, bl) = _order_points(...)\n        # here, because the reordered points is used further below.\n        points = self._order_points(points)\n        tl, tr, br, bl = points\n\n        # compute the width of the new image, which will be the\n        # maximum distance between bottom-right and bottom-left\n        # x-coordiates or the top-right and top-left x-coordinates\n        min_width = None\n        max_width = None\n        while min_width is None or min_width &lt; TWO:\n            width_top = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))\n            width_bottom = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))\n            max_width = int(max(width_top, width_bottom))\n            min_width = int(min(width_top, width_bottom))\n            if min_width &lt; TWO:\n                step_size = (2 - min_width) / 2\n                tl[0] -= step_size\n                tr[0] += step_size\n                bl[0] -= step_size\n                br[0] += step_size\n\n        # compute the height of the new image, which will be the maximum distance between the top-right\n        # and bottom-right y-coordinates or the top-left and bottom-left y-coordinates\n        min_height = None\n        max_height = None\n        while min_height is None or min_height &lt; TWO:\n            height_right = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))\n            height_left = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))\n            max_height = int(max(height_right, height_left))\n            min_height = int(min(height_right, height_left))\n            if min_height &lt; TWO:\n                step_size = (2 - min_height) / 2\n                tl[1] -= step_size\n                tr[1] -= step_size\n                bl[1] += step_size\n                br[1] += step_size\n\n        # now that we have the dimensions of the new image, construct\n        # the set of destination points to obtain a \"birds eye view\",\n        # (i.e. top-down view) of the image, again specifying points\n        # in the top-left, top-right, bottom-right, and bottom-left order\n        # do not use width-1 or height-1 here, as for e.g. width=3, height=2\n        # the bottom right coordinate is at (3.0, 2.0) and not (2.0, 1.0)\n        dst = np.array([[0, 0], [max_width, 0], [max_width, max_height], [0, max_height]], dtype=np.float32)\n\n        # compute the perspective transform matrix and then apply it\n        m = cv2.getPerspectiveTransform(points, dst)\n\n        if self.fit_output:\n            m, max_width, max_height = self._expand_transform(m, (height, width))\n\n        return {\"matrix\": m, \"max_height\": max_height, \"max_width\": max_width, \"interpolation\": self.interpolation}\n\n    @classmethod\n    def _expand_transform(cls, matrix: np.ndarray, shape: SizeType) -&gt; Tuple[np.ndarray, int, int]:\n        height, width = shape[:2]\n        # do not use width-1 or height-1 here, as for e.g. width=3, height=2, max_height\n        # the bottom right coordinate is at (3.0, 2.0) and not (2.0, 1.0)\n        rect = np.array([[0, 0], [width, 0], [width, height], [0, height]], dtype=np.float32)\n        dst = cv2.perspectiveTransform(np.array([rect]), matrix)[0]\n\n        # get min x, y over transformed 4 points\n        # then modify target points by subtracting these minima  =&gt; shift to (0, 0)\n        dst -= dst.min(axis=0, keepdims=True)\n        dst = np.around(dst, decimals=0)\n\n        matrix_expanded = cv2.getPerspectiveTransform(rect, dst)\n        max_width, max_height = dst.max(axis=0)\n        return matrix_expanded, int(max_width), int(max_height)\n\n    @staticmethod\n    def _order_points(pts: np.ndarray) -&gt; np.ndarray:\n        pts = np.array(sorted(pts, key=lambda x: x[0]))\n        left = pts[:2]  # points with smallest x coordinate - left points\n        right = pts[2:]  # points with greatest x coordinate - right points\n\n        if left[0][1] &lt; left[1][1]:\n            tl, bl = left\n        else:\n            bl, tl = left\n\n        if right[0][1] &lt; right[1][1]:\n            tr, br = right\n        else:\n            br, tr = right\n\n        return np.array([tl, tr, br, bl], dtype=np.float32)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"scale\", \"keep_size\", \"pad_mode\", \"pad_val\", \"mask_pad_val\", \"fit_output\", \"interpolation\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.PiecewiseAffine","title":"<code>class  PiecewiseAffine</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply affine transformations that differ between local neighborhoods. This augmentation places a regular grid of points on an image and randomly moves the neighborhood of these point around via affine transformations. This leads to local distortions.</p> <p>This is mostly a wrapper around scikit-image's <code>PiecewiseAffine</code>. See also <code>Affine</code> for a similar technique.</p> <p>Note</p> <p>This augmenter is very slow. Try to use <code>ElasticTransformation</code> instead, which is at least 10x faster.</p> <p>Note</p> <p>For coordinate-based inputs (keypoints, bounding boxes, polygons, ...), this augmenter still has to perform an image-based augmentation, which will make it significantly slower and not fully correct for such inputs than other transforms.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <code>float, tuple of float</code> <p>Each point on the regular grid is moved around via a normal distribution. This scale factor is equivalent to the normal distribution's sigma. Note that the jitter (how far each point is moved in which direction) is multiplied by the height/width of the image if <code>absolute_scale=False</code> (default), so this scale can be the same for different sized images. Recommended values are in the range <code>0.01</code> to <code>0.05</code> (weak to strong augmentations).     * If a single <code>float</code>, then that value will always be used as the scale.     * If a tuple <code>(a, b)</code> of <code>float</code> s, then a random value will       be uniformly sampled per image from the interval <code>[a, b]</code>.</p> <code>nb_rows</code> <code>int, tuple of int</code> <p>Number of rows of points that the regular grid should have. Must be at least <code>2</code>. For large images, you might want to pick a higher value than <code>4</code>. You might have to then adjust scale to lower values.     * If a single <code>int</code>, then that value will always be used as the number of rows.     * If a tuple <code>(a, b)</code>, then a value from the discrete interval       <code>[a..b]</code> will be uniformly sampled per image.</p> <code>nb_cols</code> <code>int, tuple of int</code> <p>Number of columns. Analogous to <code>nb_rows</code>.</p> <code>interpolation</code> <code>int</code> <p>The order of interpolation. The order has to be in the range 0-5:  - 0: Nearest-neighbor  - 1: Bi-linear (default)  - 2: Bi-quadratic  - 3: Bi-cubic  - 4: Bi-quartic  - 5: Bi-quintic</p> <code>mask_interpolation</code> <code>int</code> <p>same as interpolation but for mask.</p> <code>cval</code> <code>number</code> <p>The constant value to use when filling in newly created pixels.</p> <code>cval_mask</code> <code>number</code> <p>Same as cval but only for masks.</p> <code>mode</code> <code>str</code> <p>{'constant', 'edge', 'symmetric', 'reflect', 'wrap'}, optional Points outside the boundaries of the input are filled according to the given mode.  Modes match the behaviour of <code>numpy.pad</code>.</p> <code>absolute_scale</code> <code>bool</code> <p>Take <code>scale</code> as an absolute value rather than a relative value.</p> <code>keypoints_threshold</code> <code>float</code> <p>Used as threshold in conversion from distance maps to keypoints. The search for keypoints works by searching for the argmin (non-inverted) or argmax (inverted) in each channel. This parameters contains the maximum (non-inverted) or minimum (inverted) value to accept in order to view a hit as a keypoint. Use <code>None</code> to use no min/max. Default: 0.01</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class PiecewiseAffine(DualTransform):\n    \"\"\"Apply affine transformations that differ between local neighborhoods.\n    This augmentation places a regular grid of points on an image and randomly moves the neighborhood of these point\n    around via affine transformations. This leads to local distortions.\n\n    This is mostly a wrapper around scikit-image's ``PiecewiseAffine``.\n    See also ``Affine`` for a similar technique.\n\n    Note:\n        This augmenter is very slow. Try to use ``ElasticTransformation`` instead, which is at least 10x faster.\n\n    Note:\n        For coordinate-based inputs (keypoints, bounding boxes, polygons, ...),\n        this augmenter still has to perform an image-based augmentation,\n        which will make it significantly slower and not fully correct for such inputs than other transforms.\n\n    Args:\n        scale (float, tuple of float): Each point on the regular grid is moved around via a normal distribution.\n            This scale factor is equivalent to the normal distribution's sigma.\n            Note that the jitter (how far each point is moved in which direction) is multiplied by the height/width of\n            the image if ``absolute_scale=False`` (default), so this scale can be the same for different sized images.\n            Recommended values are in the range ``0.01`` to ``0.05`` (weak to strong augmentations).\n                * If a single ``float``, then that value will always be used as the scale.\n                * If a tuple ``(a, b)`` of ``float`` s, then a random value will\n                  be uniformly sampled per image from the interval ``[a, b]``.\n        nb_rows (int, tuple of int): Number of rows of points that the regular grid should have.\n            Must be at least ``2``. For large images, you might want to pick a higher value than ``4``.\n            You might have to then adjust scale to lower values.\n                * If a single ``int``, then that value will always be used as the number of rows.\n                * If a tuple ``(a, b)``, then a value from the discrete interval\n                  ``[a..b]`` will be uniformly sampled per image.\n        nb_cols (int, tuple of int): Number of columns. Analogous to `nb_rows`.\n        interpolation (int): The order of interpolation. The order has to be in the range 0-5:\n             - 0: Nearest-neighbor\n             - 1: Bi-linear (default)\n             - 2: Bi-quadratic\n             - 3: Bi-cubic\n             - 4: Bi-quartic\n             - 5: Bi-quintic\n        mask_interpolation (int): same as interpolation but for mask.\n        cval (number): The constant value to use when filling in newly created pixels.\n        cval_mask (number): Same as cval but only for masks.\n        mode (str): {'constant', 'edge', 'symmetric', 'reflect', 'wrap'}, optional\n            Points outside the boundaries of the input are filled according\n            to the given mode.  Modes match the behaviour of `numpy.pad`.\n        absolute_scale (bool): Take `scale` as an absolute value rather than a relative value.\n        keypoints_threshold (float): Used as threshold in conversion from distance maps to keypoints.\n            The search for keypoints works by searching for the\n            argmin (non-inverted) or argmax (inverted) in each channel. This\n            parameters contains the maximum (non-inverted) or minimum (inverted) value to accept in order to view a hit\n            as a keypoint. Use ``None`` to use no min/max. Default: 0.01\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: NonNegativeFloatRangeType = (0.03, 0.05)\n        nb_rows: ScaleIntType = Field(default=4, description=\"Number of rows in the regular grid.\")\n        nb_cols: ScaleIntType = Field(default=4, description=\"Number of columns in the regular grid.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        mask_interpolation: InterpolationType = cv2.INTER_NEAREST\n        cval: int = Field(default=0, description=\"Constant value used for newly created pixels.\")\n        cval_mask: int = Field(default=0, description=\"Constant value used for newly created mask pixels.\")\n        mode: Literal[\"constant\", \"edge\", \"symmetric\", \"reflect\", \"wrap\"] = \"constant\"\n        absolute_scale: bool = Field(\n            default=False, description=\"Whether scale is an absolute value rather than relative.\"\n        )\n        keypoints_threshold: float = Field(\n            default=0.01, description=\"Threshold for conversion from distance maps to keypoints.\"\n        )\n\n        @field_validator(\"nb_rows\", \"nb_cols\")\n        @classmethod\n        def process_range(cls, value: ScaleFloatType, info: ValidationInfo) -&gt; Tuple[float, float]:\n            bounds = 2, BIG_INTEGER\n            result = to_tuple(value, value)\n            check_range(result, *bounds, info.field_name)\n            return result\n\n    def __init__(\n        self,\n        scale: ScaleFloatType = (0.03, 0.05),\n        nb_rows: ScaleIntType = 4,\n        nb_cols: ScaleIntType = 4,\n        interpolation: int = cv2.INTER_LINEAR,\n        mask_interpolation: int = cv2.INTER_NEAREST,\n        cval: int = 0,\n        cval_mask: int = 0,\n        mode: Literal[\"constant\", \"edge\", \"symmetric\", \"reflect\", \"wrap\"] = \"constant\",\n        absolute_scale: bool = False,\n        always_apply: bool = False,\n        keypoints_threshold: float = 0.01,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        warn(\"This augmenter is very slow. Try to use ``ElasticTransformation`` instead, which is at least 10x faster.\")\n\n        self.scale = cast(Tuple[float, float], scale)\n        self.nb_rows = cast(Tuple[int, int], nb_rows)\n        self.nb_cols = cast(Tuple[int, int], nb_cols)\n        self.interpolation = interpolation\n        self.mask_interpolation = mask_interpolation\n        self.cval = cval\n        self.cval_mask = cval_mask\n        self.mode = mode\n        self.absolute_scale = absolute_scale\n        self.keypoints_threshold = keypoints_threshold\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"scale\",\n            \"nb_rows\",\n            \"nb_cols\",\n            \"interpolation\",\n            \"mask_interpolation\",\n            \"cval\",\n            \"cval_mask\",\n            \"mode\",\n            \"absolute_scale\",\n            \"keypoints_threshold\",\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        nb_rows = np.clip(random.randint(*self.nb_rows), 2, None)\n        nb_cols = np.clip(random.randint(*self.nb_cols), 2, None)\n        nb_cells = nb_cols * nb_rows\n        scale = random.uniform(*self.scale)\n\n        jitter: np.ndarray = random_utils.normal(0, scale, (nb_cells, 2))\n        if not np.any(jitter &gt; 0):\n            for _ in range(10):  # See: https://github.com/albumentations-team/albumentations/issues/1442\n                jitter = random_utils.normal(0, scale, (nb_cells, 2))\n                if np.any(jitter &gt; 0):\n                    break\n            if not np.any(jitter &gt; 0):\n                return {\"matrix\": None}\n\n        y = np.linspace(0, height, nb_rows)\n        x = np.linspace(0, width, nb_cols)\n\n        # (H, W) and (H, W) for H=rows, W=cols\n        xx_src, yy_src = np.meshgrid(x, y)\n\n        # (1, HW, 2) =&gt; (HW, 2) for H=rows, W=cols\n        points_src = np.dstack([yy_src.flat, xx_src.flat])[0]\n\n        if self.absolute_scale:\n            jitter[:, 0] = jitter[:, 0] / height if height &gt; 0 else 0.0\n            jitter[:, 1] = jitter[:, 1] / width if width &gt; 0 else 0.0\n\n        jitter[:, 0] = jitter[:, 0] * height\n        jitter[:, 1] = jitter[:, 1] * width\n\n        points_dest = np.copy(points_src)\n        points_dest[:, 0] = points_dest[:, 0] + jitter[:, 0]\n        points_dest[:, 1] = points_dest[:, 1] + jitter[:, 1]\n\n        # Restrict all destination points to be inside the image plane.\n        # This is necessary, as otherwise keypoints could be augmented\n        # outside of the image plane and these would be replaced by\n        # (-1, -1), which would not conform with the behaviour of the other augmenters.\n        points_dest[:, 0] = np.clip(points_dest[:, 0], 0, height - 1)\n        points_dest[:, 1] = np.clip(points_dest[:, 1], 0, width - 1)\n\n        matrix = skimage.transform.PiecewiseAffineTransform()\n        matrix.estimate(points_src[:, ::-1], points_dest[:, ::-1])\n\n        return {\n            \"matrix\": matrix,\n        }\n\n    def apply(\n        self, img: np.ndarray, matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None, **params: Any\n    ) -&gt; np.ndarray:\n        return F.piecewise_affine(img, matrix, cast(int, self.interpolation), self.mode, self.cval)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None, **params: Any\n    ) -&gt; np.ndarray:\n        return F.piecewise_affine(mask, matrix, self.mask_interpolation, self.mode, self.cval_mask)\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        rows: int = 0,\n        cols: int = 0,\n        matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.bbox_piecewise_affine(bbox, matrix, rows, cols, self.keypoints_threshold)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        rows: int = 0,\n        cols: int = 0,\n        matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.keypoint_piecewise_affine(keypoint, matrix, rows, cols, self.keypoints_threshold)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.ShiftScaleRotate","title":"<code>class  ShiftScaleRotate</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly apply affine transforms: translate, scale and rotate the input.</p> <p>Parameters:</p> Name Type Description <code>shift_limit</code> <code>float, float) or float</code> <p>shift factor range for both height and width. If shift_limit is a single float value, the range will be (-shift_limit, shift_limit). Absolute values for lower and upper bounds should lie in range [-1, 1]. Default: (-0.0625, 0.0625).</p> <code>scale_limit</code> <code>float, float) or float</code> <p>scaling factor range. If scale_limit is a single float value, the range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1. If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high). Default: (-0.1, 0.1).</p> <code>rotate_limit</code> <code>int, int) or int</code> <p>rotation range. If rotate_limit is a single int value, the range will be (-rotate_limit, rotate_limit). Default: (-45, 45).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of int, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of int,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>shift_limit_x</code> <code>float, float) or float</code> <p>shift factor range for width. If it is set then this value instead of shift_limit will be used for shifting width.  If shift_limit_x is a single float value, the range will be (-shift_limit_x, shift_limit_x). Absolute values for lower and upper bounds should lie in the range [-1, 1]. Default: None.</p> <code>shift_limit_y</code> <code>float, float) or float</code> <p>shift factor range for height. If it is set then this value instead of shift_limit will be used for shifting height.  If shift_limit_y is a single float value, the range will be (-shift_limit_y, shift_limit_y). Absolute values for lower and upper bounds should lie in the range [-, 1]. Default: None.</p> <code>rotate_method</code> <code>str</code> <p>rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\". Default: \"largest_box\"</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class ShiftScaleRotate(Affine):\n    \"\"\"Randomly apply affine transforms: translate, scale and rotate the input.\n\n    Args:\n        shift_limit ((float, float) or float): shift factor range for both height and width. If shift_limit\n            is a single float value, the range will be (-shift_limit, shift_limit). Absolute values for lower and\n            upper bounds should lie in range [-1, 1]. Default: (-0.0625, 0.0625).\n        scale_limit ((float, float) or float): scaling factor range. If scale_limit is a single float value, the\n            range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1.\n            If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high).\n            Default: (-0.1, 0.1).\n        rotate_limit ((int, int) or int): rotation range. If rotate_limit is a single int value, the\n            range will be (-rotate_limit, rotate_limit). Default: (-45, 45).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of int, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of int,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        shift_limit_x ((float, float) or float): shift factor range for width. If it is set then this value\n            instead of shift_limit will be used for shifting width.  If shift_limit_x is a single float value,\n            the range will be (-shift_limit_x, shift_limit_x). Absolute values for lower and upper bounds should lie in\n            the range [-1, 1]. Default: None.\n        shift_limit_y ((float, float) or float): shift factor range for height. If it is set then this value\n            instead of shift_limit will be used for shifting height.  If shift_limit_y is a single float value,\n            the range will be (-shift_limit_y, shift_limit_y). Absolute values for lower and upper bounds should lie\n            in the range [-, 1]. Default: None.\n        rotate_method (str): rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\".\n            Default: \"largest_box\"\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        shift_limit: SymmetricRangeType = (-0.0625, 0.0625)\n        scale_limit: SymmetricRangeType = (-0.1, 0.1)\n        rotate_limit: SymmetricRangeType = (-45, 45)\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: ColorType = 0\n        mask_value: ColorType = 0\n        shift_limit_x: Optional[ScaleFloatType] = Field(default=None)\n        shift_limit_y: Optional[ScaleFloatType] = Field(default=None)\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\"\n\n        @model_validator(mode=\"after\")\n        def check_shift_limit(self) -&gt; Self:\n            bounds = -1, 1\n            self.shift_limit_x = to_tuple(self.shift_limit_x if self.shift_limit_x is not None else self.shift_limit)\n            check_range(self.shift_limit_x, *bounds, \"shift_limit_x\")\n            self.shift_limit_y = to_tuple(self.shift_limit_y if self.shift_limit_y is not None else self.shift_limit)\n            check_range(self.shift_limit_y, *bounds, \"shift_limit_y\")\n            return self\n\n        @field_validator(\"scale_limit\")\n        @classmethod\n        def check_scale_limit(cls, value: ScaleFloatType, info: ValidationInfo) -&gt; ScaleFloatType:\n            bounds = 0, float(\"inf\")\n            result = to_tuple(value, bias=1.0)\n            check_range(result, *bounds, str(info.field_name))\n            return result\n\n    def __init__(\n        self,\n        shift_limit: ScaleFloatType = (-0.0625, 0.0625),\n        scale_limit: ScaleFloatType = (-0.1, 0.1),\n        rotate_limit: ScaleFloatType = (-45, 45),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: ColorType = 0,\n        mask_value: ColorType = 0,\n        shift_limit_x: Optional[ScaleFloatType] = None,\n        shift_limit_y: Optional[ScaleFloatType] = None,\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(\n            scale=scale_limit,\n            translate_percent={\"x\": shift_limit_x, \"y\": shift_limit_y},\n            rotate=rotate_limit,\n            shear=(0, 0),\n            interpolation=interpolation,\n            mask_interpolation=cv2.INTER_NEAREST,\n            cval=value,\n            cval_mask=mask_value,\n            mode=border_mode,\n            fit_output=False,\n            keep_ratio=False,\n            rotate_method=rotate_method,\n            always_apply=always_apply,\n            p=p,\n        )\n        warn(\n            \"ShiftScaleRotate is deprecated. Please use Affine transform instead .\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.shift_limit_x = cast(Tuple[float, float], shift_limit_x)\n        self.shift_limit_y = cast(Tuple[float, float], shift_limit_y)\n        self.scale_limit = cast(Tuple[float, float], scale_limit)\n        self.rotate_limit = cast(Tuple[int, int], rotate_limit)\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\n            \"shift_limit_x\": self.shift_limit_x,\n            \"shift_limit_y\": self.shift_limit_y,\n            \"scale_limit\": to_tuple(self.scale_limit, bias=-1.0),\n            \"rotate_limit\": self.rotate_limit,\n            \"interpolation\": self.interpolation,\n            \"border_mode\": self.border_mode,\n            \"value\": self.value,\n            \"mask_value\": self.mask_value,\n            \"rotate_method\": self.rotate_method,\n        }\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.Transpose","title":"<code>class  Transpose</code> <code> </code>  [view source on GitHub]","text":"<p>Transpose the input by swapping rows and columns.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Transpose(DualTransform):\n    \"\"\"Transpose the input by swapping rows and columns.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.transpose(img)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_transpose(bbox, 0, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_transpose(keypoint)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.geometric.transforms.VerticalFlip","title":"<code>class  VerticalFlip</code> <code> </code>  [view source on GitHub]","text":"<p>Flip the input vertically around the x-axis.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class VerticalFlip(DualTransform):\n    \"\"\"Flip the input vertically around the x-axis.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.vflip(img)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_vflip(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_vflip(keypoint, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.mixing","title":"<code>mixing</code>  <code>special</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.mixing.transforms","title":"<code>transforms</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.mixing.transforms.MixUp","title":"<code>class  MixUp</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Performs MixUp data augmentation, blending images, masks, and class labels with reference data.</p> <p>MixUp augmentation linearly combines an input (image, mask, and class label) with another set from a predefined reference dataset. The mixing degree is controlled by a parameter \u03bb (lambda), sampled from a Beta distribution. This method is known for improving model generalization by promoting linear behavior between classes and smoothing decision boundaries.</p> <p>Reference</p> <p>Zhang, H., Cisse, M., Dauphin, Y.N., and Lopez-Paz, D. (2018). mixup: Beyond Empirical Risk Minimization. In International Conference on Learning Representations. https://arxiv.org/abs/1710.09412</p> <p>Parameters:</p> Name Type Description <code>reference_data</code> <code>Optional[Union[Generator[ReferenceImage, None, None], Sequence[Any]]]</code> <p>A sequence or generator of dictionaries containing the reference data for mixing If None or an empty sequence is provided, no operation is performed and a warning is issued.</p> <code>read_fn</code> <code>Callable[[ReferenceImage], Dict[str, Any]]</code> <p>A function to process items from reference_data. It should accept items from reference_data and return a dictionary containing processed data:     - The returned dictionary must include an 'image' key with a numpy array value.     - It may also include 'mask', 'global_label' each associated with numpy array values. Defaults to a function that assumes input dictionary contains numpy arrays and directly returns it.</p> <code>mix_coef_return_name</code> <code>str</code> <p>Name used for the applied alpha coefficient in the returned dictionary. Defaults to \"mix_coef\".</p> <code>alpha</code> <code>float</code> <p>The alpha parameter for the Beta distribution, influencing the mix's balance. Must be \u2265 0. Higher values lead to more uniform mixing. Defaults to 0.4.</p> <code>p</code> <code>float</code> <p>The probability of applying the transformation. Defaults to 0.5.</p> <p>Targets</p> <p>image, mask, global_label</p> <p>Image types:     - uint8, float32</p> <p>Exceptions:</p> Type Description <code>- ValueError</code> <p>If the alpha parameter is negative.</p> <code>- NotImplementedError</code> <p>If the transform is applied to bounding boxes or keypoints.</p> <p>Notes</p> <ul> <li>If no reference data is provided, a warning is issued, and the transform acts as a no-op.</li> <li>Notes if images are in float32 format, they should be within [0, 1] range.</li> </ul> <p>Example Usage:     import albumentations as A     import numpy as np     from albumentations.core.types import ReferenceImage</p> <pre><code># Prepare reference data\n# Note: This code generates random reference data for demonstration purposes only.\n# In real-world applications, it's crucial to use meaningful and representative data.\n# The quality and relevance of your input data significantly impact the effectiveness\n# of the augmentation process. Ensure your data closely aligns with your specific\n# use case and application requirements.\nreference_data = [ReferenceImage(image=np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8),\n                                 mask=np.random.randint(0, 4, (100, 100, 1), dtype=np.uint8),\n                                 global_label=np.random.choice([0, 1], size=3)) for i in range(10)]\n\n# In this example, the lambda function simply returns its input, which works well for\n# data already in the expected format. For more complex scenarios, where the data might not be in\n# the required format or additional processing is needed, a more sophisticated function can be implemented.\n# Below is a hypothetical example where the input data is a file path, # and the function reads the image\n# file, converts it to a specific format, and possibly performs other preprocessing steps.\n\n# Example of a more complex read_fn that reads an image from a file path, converts it to RGB, and resizes it.\n# def custom_read_fn(file_path):\n#     from PIL import Image\n#     image = Image.open(file_path).convert('RGB')\n#     image = image.resize((100, 100))  # Example resize, adjust as needed.\n#     return np.array(image)\n\n# aug = A.Compose([A.RandomRotate90(), A.MixUp(p=1, reference_data=reference_data, read_fn=lambda x: x)])\n\n# For simplicity, the original lambda function is used in this example.\n# Replace `lambda x: x` with `custom_read_fn`if you need to process the data more extensively.\n\n# Apply augmentations\nimage = np.empty([100, 100, 3], dtype=np.uint8)\nmask = np.empty([100, 100], dtype=np.uint8)\nglobal_label = np.array([0, 1, 0])\ndata = aug(image=image, global_label=global_label, mask=mask)\ntransformed_image = data[\"image\"]\ntransformed_mask = data[\"mask\"]\ntransformed_global_label = data[\"global_label\"]\n\n# Print applied mix coefficient\nprint(data[\"mix_coef\"])  # Output: e.g., 0.9991580344142427\n</code></pre> Source code in <code>albumentations/augmentations/mixing/transforms.py</code> Python<pre><code>class MixUp(ReferenceBasedTransform):\n    \"\"\"Performs MixUp data augmentation, blending images, masks, and class labels with reference data.\n\n    MixUp augmentation linearly combines an input (image, mask, and class label) with another set from a predefined\n    reference dataset. The mixing degree is controlled by a parameter \u03bb (lambda), sampled from a Beta distribution.\n    This method is known for improving model generalization by promoting linear behavior between classes and\n    smoothing decision boundaries.\n\n    Reference:\n        Zhang, H., Cisse, M., Dauphin, Y.N., and Lopez-Paz, D. (2018). mixup: Beyond Empirical Risk Minimization.\n        In International Conference on Learning Representations. https://arxiv.org/abs/1710.09412\n\n    Args:\n        reference_data (Optional[Union[Generator[ReferenceImage, None, None], Sequence[Any]]]):\n            A sequence or generator of dictionaries containing the reference data for mixing\n            If None or an empty sequence is provided, no operation is performed and a warning is issued.\n        read_fn (Callable[[ReferenceImage], Dict[str, Any]]):\n            A function to process items from reference_data. It should accept items from reference_data\n            and return a dictionary containing processed data:\n                - The returned dictionary must include an 'image' key with a numpy array value.\n                - It may also include 'mask', 'global_label' each associated with numpy array values.\n            Defaults to a function that assumes input dictionary contains numpy arrays and directly returns it.\n        mix_coef_return_name (str): Name used for the applied alpha coefficient in the returned dictionary.\n            Defaults to \"mix_coef\".\n        alpha (float):\n            The alpha parameter for the Beta distribution, influencing the mix's balance. Must be \u2265 0.\n            Higher values lead to more uniform mixing. Defaults to 0.4.\n        p (float):\n            The probability of applying the transformation. Defaults to 0.5.\n\n    Targets:\n        image, mask, global_label\n\n    Image types:\n        - uint8, float32\n\n    Raises:\n        - ValueError: If the alpha parameter is negative.\n        - NotImplementedError: If the transform is applied to bounding boxes or keypoints.\n\n    Notes:\n        - If no reference data is provided, a warning is issued, and the transform acts as a no-op.\n        - Notes if images are in float32 format, they should be within [0, 1] range.\n\n    Example Usage:\n        import albumentations as A\n        import numpy as np\n        from albumentations.core.types import ReferenceImage\n\n        # Prepare reference data\n        # Note: This code generates random reference data for demonstration purposes only.\n        # In real-world applications, it's crucial to use meaningful and representative data.\n        # The quality and relevance of your input data significantly impact the effectiveness\n        # of the augmentation process. Ensure your data closely aligns with your specific\n        # use case and application requirements.\n        reference_data = [ReferenceImage(image=np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8),\n                                         mask=np.random.randint(0, 4, (100, 100, 1), dtype=np.uint8),\n                                         global_label=np.random.choice([0, 1], size=3)) for i in range(10)]\n\n        # In this example, the lambda function simply returns its input, which works well for\n        # data already in the expected format. For more complex scenarios, where the data might not be in\n        # the required format or additional processing is needed, a more sophisticated function can be implemented.\n        # Below is a hypothetical example where the input data is a file path, # and the function reads the image\n        # file, converts it to a specific format, and possibly performs other preprocessing steps.\n\n        # Example of a more complex read_fn that reads an image from a file path, converts it to RGB, and resizes it.\n        # def custom_read_fn(file_path):\n        #     from PIL import Image\n        #     image = Image.open(file_path).convert('RGB')\n        #     image = image.resize((100, 100))  # Example resize, adjust as needed.\n        #     return np.array(image)\n\n        # aug = A.Compose([A.RandomRotate90(), A.MixUp(p=1, reference_data=reference_data, read_fn=lambda x: x)])\n\n        # For simplicity, the original lambda function is used in this example.\n        # Replace `lambda x: x` with `custom_read_fn`if you need to process the data more extensively.\n\n        # Apply augmentations\n        image = np.empty([100, 100, 3], dtype=np.uint8)\n        mask = np.empty([100, 100], dtype=np.uint8)\n        global_label = np.array([0, 1, 0])\n        data = aug(image=image, global_label=global_label, mask=mask)\n        transformed_image = data[\"image\"]\n        transformed_mask = data[\"mask\"]\n        transformed_global_label = data[\"global_label\"]\n\n        # Print applied mix coefficient\n        print(data[\"mix_coef\"])  # Output: e.g., 0.9991580344142427\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.GLOBAL_LABEL)\n\n    class InitSchema(BaseTransformInitSchema):\n        reference_data: Optional[Union[Generator[Any, None, None], Sequence[Any]]] = None\n        read_fn: Callable[[ReferenceImage], Any]\n        alpha: Annotated[float, Field(default=0.4, ge=0, le=1)]\n        mix_coef_return_name: str = \"mix_coef\"\n\n    def __init__(\n        self,\n        reference_data: Optional[Union[Generator[Any, None, None], Sequence[Any]]] = None,\n        read_fn: Callable[[ReferenceImage], Any] = lambda x: {\"image\": x, \"mask\": None, \"class_label\": None},\n        alpha: float = 0.4,\n        mix_coef_return_name: str = \"mix_coef\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.mix_coef_return_name = mix_coef_return_name\n\n        self.read_fn = read_fn\n        self.alpha = alpha\n\n        if reference_data is None:\n            warn(\"No reference data provided for MixUp. This transform will act as a no-op.\")\n            # Create an empty generator\n            self.reference_data: List[Any] = []\n        elif (\n            isinstance(reference_data, types.GeneratorType)\n            or isinstance(reference_data, Iterable)\n            and not isinstance(reference_data, str)\n        ):\n            self.reference_data = reference_data  # type: ignore[assignment]\n        else:\n            msg = \"reference_data must be a list, tuple, generator, or None.\"\n            raise TypeError(msg)\n\n    def apply(self, img: np.ndarray, mix_data: ReferenceImage, mix_coef: float, **params: Any) -&gt; np.ndarray:\n        if not mix_data:\n            return img\n\n        mix_img = mix_data[\"image\"]\n\n        if not is_grayscale_image(img) and img.shape != mix_img.shape:\n            msg = \"The shape of the reference image should be the same as the input image.\"\n            raise ValueError(msg)\n\n        return add_weighted(img, mix_coef, mix_img, 1 - mix_coef) if mix_img is not None else img\n\n    def apply_to_mask(self, mask: np.ndarray, mix_data: ReferenceImage, mix_coef: float, **params: Any) -&gt; np.ndarray:\n        mix_mask = mix_data.get(\"mask\")\n        return add_weighted(mask, mix_coef, mix_mask, 1 - mix_coef) if mix_mask is not None else mask\n\n    def apply_to_global_label(\n        self, label: np.ndarray, mix_data: ReferenceImage, mix_coef: float, **params: Any\n    ) -&gt; np.ndarray:\n        mix_label = mix_data.get(\"global_label\")\n        if mix_label is not None and label is not None:\n            return mix_coef * label + (1 - mix_coef) * mix_label\n        return label\n\n    def apply_to_bboxes(self, bboxes: Sequence[BoxType], mix_data: ReferenceImage, **params: Any) -&gt; Sequence[BoxType]:\n        msg = \"MixUp does not support bounding boxes yet, feel free to submit pull request to https://github.com/albumentations-team/albumentations/.\"\n        raise NotImplementedError(msg)\n\n    def apply_to_keypoints(\n        self, keypoints: Sequence[KeypointType], *args: Any, **params: Any\n    ) -&gt; Sequence[KeypointType]:\n        msg = \"MixUp does not support keypoints yet, feel free to submit pull request to https://github.com/albumentations-team/albumentations/.\"\n        raise NotImplementedError(msg)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"reference_data\", \"alpha\"\n\n    def get_params(self) -&gt; Dict[str, Union[None, float, Dict[str, Any]]]:\n        mix_data = None\n        # Check if reference_data is not empty and is a sequence (list, tuple, np.array)\n        if isinstance(self.reference_data, Sequence) and not isinstance(self.reference_data, (str, bytes)):\n            if len(self.reference_data) &gt; 0:  # Additional check to ensure it's not empty\n                mix_idx = random.randint(0, len(self.reference_data) - 1)\n                mix_data = self.reference_data[mix_idx]\n        # Check if reference_data is an iterator or generator\n        elif isinstance(self.reference_data, Iterator):\n            try:\n                mix_data = next(self.reference_data)  # Attempt to get the next item\n            except StopIteration:\n                warn(\n                    \"Reference data iterator/generator has been exhausted. \"\n                    \"Further mixing augmentations will not be applied.\",\n                    RuntimeWarning,\n                )\n                return {\"mix_data\": {}, \"mix_coef\": 1}\n\n        # If mix_data is None or empty after the above checks, return default values\n        if mix_data is None:\n            return {\"mix_data\": {}, \"mix_coef\": 1}\n\n        # If mix_data is not None, calculate mix_coef and apply read_fn\n        mix_coef = beta(self.alpha, self.alpha)  # Assuming beta is defined elsewhere\n        return {\"mix_data\": self.read_fn(mix_data), \"mix_coef\": mix_coef}\n\n    def apply_with_params(self, params: Dict[str, Any], *args: Any, **kwargs: Any) -&gt; Dict[str, Any]:\n        res = super().apply_with_params(params, *args, **kwargs)\n        if self.mix_coef_return_name:\n            res[self.mix_coef_return_name] = params[\"mix_coef\"]\n        return res\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms","title":"<code>transforms</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.CLAHE","title":"<code>class  CLAHE</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply Contrast Limited Adaptive Histogram Equalization to the input image.</p> <p>Parameters:</p> Name Type Description <code>clip_limit</code> <p>upper threshold value for contrast limiting. If clip_limit is a single float value, the range will be (1, clip_limit). Default: (1, 4).</p> <code>tile_grid_size</code> <p>size of grid for histogram equalization. Default: (8, 8).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class CLAHE(ImageOnlyTransform):\n    \"\"\"Apply Contrast Limited Adaptive Histogram Equalization to the input image.\n\n    Args:\n        clip_limit: upper threshold value for contrast limiting.\n            If clip_limit is a single float value, the range will be (1, clip_limit). Default: (1, 4).\n        tile_grid_size: size of grid for histogram equalization. Default: (8, 8).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        clip_limit: OnePlusFloatRangeType = (1.0, 4.0)\n        tile_grid_size: OnePlusIntRangeType = (8, 8)\n\n    def __init__(\n        self,\n        clip_limit: ScaleFloatType = 4.0,\n        tile_grid_size: Tuple[int, int] = (8, 8),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.clip_limit = cast(Tuple[float, float], clip_limit)\n        self.tile_grid_size = tile_grid_size\n\n    def apply(self, img: np.ndarray, clip_limit: float = 2, **params: Any) -&gt; np.ndarray:\n        if not is_rgb_image(img) and not is_grayscale_image(img):\n            msg = \"CLAHE transformation expects 1-channel or 3-channel images.\"\n            raise TypeError(msg)\n\n        return F.clahe(img, clip_limit, self.tile_grid_size)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"clip_limit\": random.uniform(self.clip_limit[0], self.clip_limit[1])}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"clip_limit\", \"tile_grid_size\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ChannelShuffle","title":"<code>class  ChannelShuffle</code> <code> </code>  [view source on GitHub]","text":"<p>Randomly rearrange channels of the input RGB image.</p> <p>Parameters:</p> Name Type Description <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ChannelShuffle(ImageOnlyTransform):\n    \"\"\"Randomly rearrange channels of the input RGB image.\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def apply(self, img: np.ndarray, channels_shuffled: Tuple[int, int, int] = (0, 1, 2), **params: Any) -&gt; np.ndarray:\n        return F.channel_shuffle(img, channels_shuffled)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        ch_arr = list(range(img.shape[2]))\n        random.shuffle(ch_arr)\n        return {\"channels_shuffled\": ch_arr}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ChromaticAberration","title":"<code>class  ChromaticAberration</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Add lateral chromatic aberration by distorting the red and blue channels of the input image.</p> <p>Parameters:</p> Name Type Description <code>primary_distortion_limit</code> <p>range of the primary radial distortion coefficient. If primary_distortion_limit is a single float value, the range will be (-primary_distortion_limit, primary_distortion_limit). Controls the distortion in the center of the image (positive values result in pincushion distortion, negative values result in barrel distortion). Default: 0.02.</p> <code>secondary_distortion_limit</code> <p>range of the secondary radial distortion coefficient. If secondary_distortion_limit is a single float value, the range will be (-secondary_distortion_limit, secondary_distortion_limit). Controls the distortion in the corners of the image (positive values result in pincushion distortion, negative values result in barrel distortion). Default: 0.05.</p> <code>mode</code> <p>type of color fringing. Supported modes are 'green_purple', 'red_blue' and 'random'. 'random' will choose one of the modes 'green_purple' or 'red_blue' randomly. Default: 'green_purple'.</p> <code>interpolation</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ChromaticAberration(ImageOnlyTransform):\n    \"\"\"Add lateral chromatic aberration by distorting the red and blue channels of the input image.\n\n    Args:\n        primary_distortion_limit: range of the primary radial distortion coefficient.\n            If primary_distortion_limit is a single float value, the range will be\n            (-primary_distortion_limit, primary_distortion_limit).\n            Controls the distortion in the center of the image (positive values result in pincushion distortion,\n            negative values result in barrel distortion).\n            Default: 0.02.\n        secondary_distortion_limit: range of the secondary radial distortion coefficient.\n            If secondary_distortion_limit is a single float value, the range will be\n            (-secondary_distortion_limit, secondary_distortion_limit).\n            Controls the distortion in the corners of the image (positive values result in pincushion distortion,\n            negative values result in barrel distortion).\n            Default: 0.05.\n        mode: type of color fringing.\n            Supported modes are 'green_purple', 'red_blue' and 'random'.\n            'random' will choose one of the modes 'green_purple' or 'red_blue' randomly.\n            Default: 'green_purple'.\n        interpolation: flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p: probability of applying the transform.\n            Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        primary_distortion_limit: SymmetricRangeType = (-0.02, 0.02)\n        secondary_distortion_limit: SymmetricRangeType = (-0.05, 0.05)\n        mode: ChromaticAberrationMode = Field(default=\"green_purple\", description=\"Type of color fringing.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n    def __init__(\n        self,\n        primary_distortion_limit: ScaleFloatType = (-0.02, 0.02),\n        secondary_distortion_limit: ScaleFloatType = (-0.05, 0.05),\n        mode: ChromaticAberrationMode = \"green_purple\",\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.primary_distortion_limit = cast(Tuple[float, float], primary_distortion_limit)\n        self.secondary_distortion_limit = cast(Tuple[float, float], secondary_distortion_limit)\n        self.mode = mode\n        self.interpolation = interpolation\n\n    def apply(\n        self,\n        img: np.ndarray,\n        primary_distortion_red: float = -0.02,\n        secondary_distortion_red: float = -0.05,\n        primary_distortion_blue: float = -0.02,\n        secondary_distortion_blue: float = -0.05,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.chromatic_aberration(\n            img,\n            primary_distortion_red,\n            secondary_distortion_red,\n            primary_distortion_blue,\n            secondary_distortion_blue,\n            cast(int, self.interpolation),\n        )\n\n    def get_params(self) -&gt; Dict[str, float]:\n        primary_distortion_red = random_utils.uniform(*self.primary_distortion_limit)\n        secondary_distortion_red = random_utils.uniform(*self.secondary_distortion_limit)\n        primary_distortion_blue = random_utils.uniform(*self.primary_distortion_limit)\n        secondary_distortion_blue = random_utils.uniform(*self.secondary_distortion_limit)\n\n        secondary_distortion_red = self._match_sign(primary_distortion_red, secondary_distortion_red)\n        secondary_distortion_blue = self._match_sign(primary_distortion_blue, secondary_distortion_blue)\n\n        if self.mode == \"green_purple\":\n            # distortion coefficients of the red and blue channels have the same sign\n            primary_distortion_blue = self._match_sign(primary_distortion_red, primary_distortion_blue)\n            secondary_distortion_blue = self._match_sign(secondary_distortion_red, secondary_distortion_blue)\n        if self.mode == \"red_blue\":\n            # distortion coefficients of the red and blue channels have the opposite sign\n            primary_distortion_blue = self._unmatch_sign(primary_distortion_red, primary_distortion_blue)\n            secondary_distortion_blue = self._unmatch_sign(secondary_distortion_red, secondary_distortion_blue)\n\n        return {\n            \"primary_distortion_red\": primary_distortion_red,\n            \"secondary_distortion_red\": secondary_distortion_red,\n            \"primary_distortion_blue\": primary_distortion_blue,\n            \"secondary_distortion_blue\": secondary_distortion_blue,\n        }\n\n    @staticmethod\n    def _match_sign(a: float, b: float) -&gt; float:\n        # Match the sign of b to a\n        if (a &lt; 0 &lt; b) or (a &gt; 0 &gt; b):\n            return -b\n        return b\n\n    @staticmethod\n    def _unmatch_sign(a: float, b: float) -&gt; float:\n        # Unmatch the sign of b to a\n        if (a &lt; 0 and b &lt; 0) or (a &gt; 0 and b &gt; 0):\n            return -b\n        return b\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return \"primary_distortion_limit\", \"secondary_distortion_limit\", \"mode\", \"interpolation\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ColorJitter","title":"<code>class  ColorJitter</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly changes the brightness, contrast, and saturation of an image. Compared to ColorJitter from torchvision, this transform gives a little bit different results because Pillow (used in torchvision) and OpenCV (used in Albumentations) transform an image to HSV format by different formulas. Another difference - Pillow uses uint8 overflow, but we use value saturation.</p> <p>Parameters:</p> Name Type Description <code>brightness</code> <code>float or tuple of float (min, max</code> <p>How much to jitter brightness. If float:     brightness_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness] If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.</p> <code>contrast</code> <code>float or tuple of float (min, max</code> <p>How much to jitter contrast. If float:     contrast_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness] If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.</p> <code>saturation</code> <code>float or tuple of float (min, max</code> <p>How much to jitter saturation. If float:    saturation_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness] If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.</p> <code>hue</code> <code>float or tuple of float (min, max</code> <p>How much to jitter hue. If float:    saturation_factor is chosen uniformly from [-hue, hue]. Should have 0 &lt;= hue &lt;= 0.5. If Tuple[float, float]] will be sampled from that range. Both values should be in range [-0.5, 0.5].</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ColorJitter(ImageOnlyTransform):\n    \"\"\"Randomly changes the brightness, contrast, and saturation of an image. Compared to ColorJitter from torchvision,\n    this transform gives a little bit different results because Pillow (used in torchvision) and OpenCV (used in\n    Albumentations) transform an image to HSV format by different formulas. Another difference - Pillow uses uint8\n    overflow, but we use value saturation.\n\n    Args:\n        brightness (float or tuple of float (min, max)): How much to jitter brightness.\n            If float:\n                brightness_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness]\n            If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.\n        contrast (float or tuple of float (min, max)): How much to jitter contrast.\n            If float:\n                contrast_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness]\n            If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.\n        saturation (float or tuple of float (min, max)): How much to jitter saturation.\n            If float:\n               saturation_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness]\n            If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.\n        hue (float or tuple of float (min, max)): How much to jitter hue.\n            If float:\n               saturation_factor is chosen uniformly from [-hue, hue]. Should have 0 &lt;= hue &lt;= 0.5.\n            If Tuple[float, float]] will be sampled from that range. Both values should be in range [-0.5, 0.5].\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        brightness: Annotated[ScaleFloatType, Field(default=0.2, description=\"Range for jittering brightness.\")]\n        contrast: Annotated[ScaleFloatType, Field(default=0.2, description=\"Range for jittering contrast.\")]\n        saturation: Annotated[ScaleFloatType, Field(default=0.2, description=\"Range for jittering saturation.\")]\n        hue: Annotated[ScaleFloatType, Field(default=0.2, description=\"Range for jittering hue.\")]\n\n        @field_validator(\"brightness\", \"contrast\", \"saturation\", \"hue\")\n        @classmethod\n        def check_ranges(cls, value: ScaleFloatType, info: ValidationInfo) -&gt; Tuple[float, float]:\n            if info.field_name == \"hue\":\n                bounds = -0.5, 0.5\n                bias = 0\n                clip = False\n            elif info.field_name in [\"brightness\", \"contrast\", \"saturation\"]:\n                bounds = 0, float(\"inf\")\n                bias = 1\n                clip = True\n\n            if isinstance(value, numbers.Number):\n                if value &lt; 0:\n                    raise ValueError(f\"If {info.field_name} is a single number, it must be non negative.\")\n                value = [bias - value, bias + value]\n                if clip:\n                    value[0] = max(value[0], 0)\n            elif isinstance(value, (tuple, list)) and len(value) == PAIR:\n                check_range(value, *bounds, info.field_name)\n\n            return cast(Tuple[float, float], value)\n\n    def __init__(\n        self,\n        brightness: ScaleFloatType = (0.8, 1),\n        contrast: ScaleFloatType = (0.8, 1),\n        saturation: ScaleFloatType = (0.8, 1),\n        hue: ScaleFloatType = (-0.5, 0.5),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        self.brightness = cast(Tuple[float, float], brightness)\n        self.contrast = cast(Tuple[float, float], contrast)\n        self.saturation = cast(Tuple[float, float], saturation)\n        self.hue = cast(Tuple[float, float], hue)\n\n        self.transforms = [\n            F.adjust_brightness_torchvision,\n            F.adjust_contrast_torchvision,\n            F.adjust_saturation_torchvision,\n            F.adjust_hue_torchvision,\n        ]\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        brightness = random.uniform(self.brightness[0], self.brightness[1])\n        contrast = random.uniform(self.contrast[0], self.contrast[1])\n        saturation = random.uniform(self.saturation[0], self.saturation[1])\n        hue = random.uniform(self.hue[0], self.hue[1])\n\n        order = [0, 1, 2, 3]\n        random_utils.shuffle(order)\n\n        return {\n            \"brightness\": brightness,\n            \"contrast\": contrast,\n            \"saturation\": saturation,\n            \"hue\": hue,\n            \"order\": order,\n        }\n\n    def apply(\n        self,\n        img: np.ndarray,\n        brightness: float = 1.0,\n        contrast: float = 1.0,\n        saturation: float = 1.0,\n        hue: float = 0,\n        order: Optional[List[int]] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if order is None:\n            order = [0, 1, 2, 3]\n        if not is_rgb_image(img) and not is_grayscale_image(img):\n            msg = \"ColorJitter transformation expects 1-channel or 3-channel images.\"\n            raise TypeError(msg)\n        color_transforms = [brightness, contrast, saturation, hue]\n        for i in order:\n            img = self.transforms[i](img, color_transforms[i])  # type: ignore[operator]\n        return img\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"brightness\", \"contrast\", \"saturation\", \"hue\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Downscale","title":"<code>class  Downscale</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Decreases image quality by downscaling and upscaling back.</p> <p>Parameters:</p> Name Type Description <code>scale_min</code> <p>lower bound on the image scale. Should be &lt;= scale_max.</p> <code>scale_max</code> <p>upper bound on the image scale. Should be &lt; 1.</p> <code>interpolation</code> <p>cv2 interpolation method. Could be: - single cv2 interpolation flag - selected method will be used for downscale and upscale. - dict(downscale=flag, upscale=flag) - Downscale.Interpolation(downscale=flag, upscale=flag) - Default: Interpolation(downscale=cv2.INTER_NEAREST, upscale=cv2.INTER_NEAREST)</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Downscale(ImageOnlyTransform):\n    \"\"\"Decreases image quality by downscaling and upscaling back.\n\n    Args:\n        scale_min: lower bound on the image scale. Should be &lt;= scale_max.\n        scale_max: upper bound on the image scale. Should be &lt; 1.\n        interpolation: cv2 interpolation method. Could be:\n            - single cv2 interpolation flag - selected method will be used for downscale and upscale.\n            - dict(downscale=flag, upscale=flag)\n            - Downscale.Interpolation(downscale=flag, upscale=flag) -\n            Default: Interpolation(downscale=cv2.INTER_NEAREST, upscale=cv2.INTER_NEAREST)\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        scale_min: float = Field(default=0.25, ge=0, le=1, description=\"Lower bound on the image scale.\")\n        scale_max: float = Field(default=0.25, ge=0, lt=1, description=\"Upper bound on the image scale.\")\n        interpolation: Optional[Union[int, Interpolation, Dict[str, int]]] = Field(\n            default_factory=lambda: Interpolation(downscale=cv2.INTER_NEAREST, upscale=cv2.INTER_NEAREST),\n            description=\"CV2 interpolation method or a dictionary specifying downscale and upscale methods.\",\n        )\n\n        @model_validator(mode=\"after\")\n        def validate_scale(self) -&gt; Self:\n            if self.scale_min &gt; self.scale_max:\n                msg = \"scale_min must be less than or equal to scale_max\"\n                raise ValueError(msg)\n            return self\n\n        @field_validator(\"interpolation\")\n        @classmethod\n        def set_interpolation(cls, v: Any) -&gt; Interpolation:\n            if isinstance(v, dict):\n                return Interpolation(**v)\n            if isinstance(v, int):\n                return Interpolation(downscale=v, upscale=v)\n            if isinstance(v, Interpolation):\n                return v\n            if v is None:\n                return Interpolation(downscale=cv2.INTER_NEAREST, upscale=cv2.INTER_NEAREST)\n\n            msg = (\n                \"Interpolation must be an int, Interpolation instance, \"\n                \"or dict specifying downscale and upscale methods.\"\n            )\n            raise ValueError(msg)\n\n    def __init__(\n        self,\n        scale_min: float = 0.25,\n        scale_max: float = 0.25,\n        interpolation: Optional[Union[int, Interpolation, Dict[str, int]]] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.scale_min = scale_min\n        self.scale_max = scale_max\n        self.interpolation = cast(Interpolation, interpolation)\n\n    def apply(self, img: np.ndarray, scale: float, **params: Any) -&gt; np.ndarray:\n        if isinstance(self.interpolation, int):\n            msg = \"Should not be here, added for typing purposes. Please report this issue.\"\n            raise TypeError(msg)\n        return F.downscale(\n            img,\n            scale=scale,\n            down_interpolation=self.interpolation.downscale,\n            up_interpolation=self.interpolation.upscale,\n        )\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\"scale\": random.uniform(self.scale_min, self.scale_max)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return \"scale_min\", \"scale_max\"\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        if isinstance(self.interpolation, int):\n            msg = \"Should not be here, added for typing purposes. Please report this issue.\"\n            raise TypeError(msg)\n        result = super().to_dict_private()\n        result[\"interpolation\"] = {\"upscale\": self.interpolation.upscale, \"downscale\": self.interpolation.downscale}\n        return result\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Emboss","title":"<code>class  Emboss</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Emboss the input image and overlays the result with the original image.</p> <p>Parameters:</p> Name Type Description <code>alpha</code> <p>range to choose the visibility of the embossed image. At 0, only the original image is visible,at 1.0 only its embossed version is visible. Default: (0.2, 0.5).</p> <code>strength</code> <p>strength range of the embossing. Default: (0.2, 0.7).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Emboss(ImageOnlyTransform):\n    \"\"\"Emboss the input image and overlays the result with the original image.\n\n    Args:\n        alpha: range to choose the visibility of the embossed image. At 0, only the original image is\n            visible,at 1.0 only its embossed version is visible. Default: (0.2, 0.5).\n        strength: strength range of the embossing. Default: (0.2, 0.7).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        alpha: ZeroOneRangeType = (0.2, 0.5)\n        strength: NonNegativeFloatRangeType = (0.2, 0.7)\n\n    def __init__(\n        self,\n        alpha: Tuple[float, float] = (0.2, 0.5),\n        strength: Tuple[float, float] = (0.2, 0.7),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.alpha = alpha\n        self.strength = strength\n\n    @staticmethod\n    def __generate_emboss_matrix(alpha_sample: np.ndarray, strength_sample: np.ndarray) -&gt; np.ndarray:\n        matrix_nochange = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]], dtype=np.float32)\n        matrix_effect = np.array(\n            [\n                [-1 - strength_sample, 0 - strength_sample, 0],\n                [0 - strength_sample, 1, 0 + strength_sample],\n                [0, 0 + strength_sample, 1 + strength_sample],\n            ],\n            dtype=np.float32,\n        )\n        return (1 - alpha_sample) * matrix_nochange + alpha_sample * matrix_effect\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        alpha = random.uniform(*self.alpha)\n        strength = random.uniform(*self.strength)\n        emboss_matrix = self.__generate_emboss_matrix(alpha_sample=alpha, strength_sample=strength)\n        return {\"emboss_matrix\": emboss_matrix}\n\n    def apply(self, img: np.ndarray, emboss_matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.convolve(img, emboss_matrix)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"alpha\", \"strength\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Equalize","title":"<code>class  Equalize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Equalize the image histogram.</p> <p>Parameters:</p> Name Type Description <code>mode</code> <code>str</code> <p>{'cv', 'pil'}. Use OpenCV or Pillow equalization method.</p> <code>by_channels</code> <code>bool</code> <p>If True, use equalization by channels separately, else convert image to YCbCr representation and use equalization by <code>Y</code> channel.</p> <code>mask</code> <code>np.ndarray, callable</code> <p>If given, only the pixels selected by the mask are included in the analysis. Maybe 1 channel or 3 channel array or callable. Function signature must include <code>image</code> argument.</p> <code>mask_params</code> <code>list of str</code> <p>Params for mask function.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Equalize(ImageOnlyTransform):\n    \"\"\"Equalize the image histogram.\n\n    Args:\n        mode (str): {'cv', 'pil'}. Use OpenCV or Pillow equalization method.\n        by_channels (bool): If True, use equalization by channels separately,\n            else convert image to YCbCr representation and use equalization by `Y` channel.\n        mask (np.ndarray, callable): If given, only the pixels selected by\n            the mask are included in the analysis. Maybe 1 channel or 3 channel array or callable.\n            Function signature must include `image` argument.\n        mask_params (list of str): Params for mask function.\n\n    Targets:\n        image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        mode: ImageMode = \"cv\"\n        by_channels: Annotated[bool, Field(default=True, description=\"Equalize channels separately if True\")]\n        mask: Annotated[\n            Optional[Union[np.ndarray, Callable[..., Any]]],\n            Field(default=None, description=\"Mask to apply for equalization\"),\n        ]\n        mask_params: Annotated[Sequence[str], Field(default=[], description=\"Parameters for mask function\")]\n\n    def __init__(\n        self,\n        mode: ImageMode = \"cv\",\n        by_channels: bool = True,\n        mask: Optional[Union[np.ndarray, Callable[..., Any]]] = None,\n        mask_params: Sequence[str] = (),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        self.mode = mode\n        self.by_channels = by_channels\n        self.mask = mask\n        self.mask_params = mask_params\n\n    def apply(self, img: np.ndarray, mask: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.equalize(img, mode=self.mode, by_channels=self.by_channels, mask=mask)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        if not callable(self.mask):\n            return {\"mask\": self.mask}\n\n        return {\"mask\": self.mask(**params)}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\", *list(self.mask_params)]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"mode\", \"by_channels\", \"mask\", \"mask_params\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.FancyPCA","title":"<code>class  FancyPCA</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Augment RGB image using FancyPCA from Krizhevsky's paper \"ImageNet Classification with Deep Convolutional Neural Networks\"</p> <p>Parameters:</p> Name Type Description <code>alpha</code> <p>how much to perturb/scale the eigen vecs and vals. scale is samples from gaussian distribution (mu=0, sigma=alpha)</p> <p>Targets</p> <p>image</p> <p>Image types:     3-channel uint8 images only</p> <p>Credit</p> <p>http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf https://deshanadesai.github.io/notes/Fancy-PCA-with-Scikit-Image https://pixelatedbrian.github.io/2018-04-29-fancy_pca/</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class FancyPCA(ImageOnlyTransform):\n    \"\"\"Augment RGB image using FancyPCA from Krizhevsky's paper\n    \"ImageNet Classification with Deep Convolutional Neural Networks\"\n\n    Args:\n        alpha:  how much to perturb/scale the eigen vecs and vals.\n            scale is samples from gaussian distribution (mu=0, sigma=alpha)\n\n    Targets:\n        image\n\n    Image types:\n        3-channel uint8 images only\n\n    Credit:\n        http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf\n        https://deshanadesai.github.io/notes/Fancy-PCA-with-Scikit-Image\n        https://pixelatedbrian.github.io/2018-04-29-fancy_pca/\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        alpha: float = Field(default=0.1, description=\"Scale for perturbing the eigen vectors and values\", ge=0)\n\n    def __init__(self, alpha: float = 0.1, always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply=always_apply, p=p)\n        self.alpha = alpha\n\n    def apply(self, img: np.ndarray, alpha: float = 0.1, **params: Any) -&gt; np.ndarray:\n        return F.fancy_pca(img, alpha)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"alpha\": random.gauss(0, self.alpha)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"alpha\",)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.FromFloat","title":"<code>class  FromFloat</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Take an input array where all values should lie in the range [0, 1.0], multiply them by <code>max_value</code> and then cast the resulted value to a type specified by <code>dtype</code>. If <code>max_value</code> is None the transform will try to infer the maximum value for the data type from the <code>dtype</code> argument.</p> <p>This is the inverse transform for :class:<code>~albumentations.augmentations.transforms.ToFloat</code>.</p> <p>Parameters:</p> Name Type Description <code>max_value</code> <p>maximum possible input value. Default: None.</p> <code>dtype</code> <p>data type of the output. See the <code>'Data types' page from the NumPy docs</code>_. Default: 'uint16'.</p> <code>p</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image</p> <p>Image types:     float32</p> <p>.. _'Data types' page from the NumPy docs:    https://docs.scipy.org/doc/numpy/user/basics.types.html</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class FromFloat(ImageOnlyTransform):\n    \"\"\"Take an input array where all values should lie in the range [0, 1.0], multiply them by `max_value` and then\n    cast the resulted value to a type specified by `dtype`. If `max_value` is None the transform will try to infer\n    the maximum value for the data type from the `dtype` argument.\n\n    This is the inverse transform for :class:`~albumentations.augmentations.transforms.ToFloat`.\n\n    Args:\n        max_value: maximum possible input value. Default: None.\n        dtype: data type of the output. See the `'Data types' page from the NumPy docs`_.\n            Default: 'uint16'.\n        p: probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image\n\n    Image types:\n        float32\n\n    .. _'Data types' page from the NumPy docs:\n       https://docs.scipy.org/doc/numpy/user/basics.types.html\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        dtype: Literal[\"uint8\", \"uint16\", \"float32\", \"float64\"]\n        max_value: Optional[float] = Field(default=None, description=\"Maximum possible input value.\")\n        p: ProbabilityType = 1\n\n    def __init__(\n        self,\n        dtype: Literal[\"uint8\", \"uint16\", \"float32\", \"float64\"] = \"uint16\",\n        max_value: Optional[float] = None,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.dtype = np.dtype(dtype)\n        self.max_value = max_value\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.from_float(img, self.dtype, self.max_value)\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\"dtype\": self.dtype.name, \"max_value\": self.max_value}\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.GaussNoise","title":"<code>class  GaussNoise</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply gaussian noise to the input image.</p> <p>Parameters:</p> Name Type Description <code>var_limit</code> <p>variance range for noise. If var_limit is a single float, the range will be (0, var_limit). Default: (10.0, 50.0).</p> <code>mean</code> <p>mean of the noise. Default: 0</p> <code>per_channel</code> <p>if set to True, noise will be sampled for each channel independently. Otherwise, the noise will be sampled once for all channels. Default: True</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class GaussNoise(ImageOnlyTransform):\n    \"\"\"Apply gaussian noise to the input image.\n\n    Args:\n        var_limit: variance range for noise. If var_limit is a single float, the range\n            will be (0, var_limit). Default: (10.0, 50.0).\n        mean: mean of the noise. Default: 0\n        per_channel: if set to True, noise will be sampled for each channel independently.\n            Otherwise, the noise will be sampled once for all channels. Default: True\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        var_limit: NonNegativeFloatRangeType = Field(default=(10.0, 50.0), description=\"Variance range for noise.\")\n        mean: float = Field(default=0, description=\"Mean of the noise.\")\n        per_channel: bool = Field(default=True, description=\"Apply noise per channel.\")\n\n    def __init__(\n        self,\n        var_limit: ScaleFloatType = (10.0, 50.0),\n        mean: float = 0,\n        per_channel: bool = True,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.var_limit = cast(Tuple[float, float], var_limit)\n        self.mean = mean\n        self.per_channel = per_channel\n\n    def apply(self, img: np.ndarray, gauss: Optional[float] = None, **params: Any) -&gt; np.ndarray:\n        return F.gauss_noise(img, gauss=gauss)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, float]:\n        image = params[\"image\"]\n        var = random.uniform(self.var_limit[0], self.var_limit[1])\n        sigma = var**0.5\n\n        if self.per_channel:\n            gauss = random_utils.normal(self.mean, sigma, image.shape)\n        else:\n            gauss = random_utils.normal(self.mean, sigma, image.shape[:2])\n            if len(image.shape) &gt; GRAYSCALE_SHAPE_LEN:\n                gauss = np.expand_dims(gauss, -1)\n\n        return {\"gauss\": gauss}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"var_limit\", \"per_channel\", \"mean\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.HueSaturationValue","title":"<code>class  HueSaturationValue</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly change hue, saturation and value of the input image.</p> <p>Parameters:</p> Name Type Description <code>hue_shift_limit</code> <p>range for changing hue. If hue_shift_limit is a single int, the range will be (-hue_shift_limit, hue_shift_limit). Default: (-20, 20).</p> <code>sat_shift_limit</code> <p>range for changing saturation. If sat_shift_limit is a single int, the range will be (-sat_shift_limit, sat_shift_limit). Default: (-30, 30).</p> <code>val_shift_limit</code> <p>range for changing value. If val_shift_limit is a single int, the range will be (-val_shift_limit, val_shift_limit). Default: (-20, 20).</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class HueSaturationValue(ImageOnlyTransform):\n    \"\"\"Randomly change hue, saturation and value of the input image.\n\n    Args:\n        hue_shift_limit: range for changing hue. If hue_shift_limit is a single int, the range\n            will be (-hue_shift_limit, hue_shift_limit). Default: (-20, 20).\n        sat_shift_limit: range for changing saturation. If sat_shift_limit is a single int,\n            the range will be (-sat_shift_limit, sat_shift_limit). Default: (-30, 30).\n        val_shift_limit: range for changing value. If val_shift_limit is a single int, the range\n            will be (-val_shift_limit, val_shift_limit). Default: (-20, 20).\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        hue_shift_limit: SymmetricRangeType = (-20, 20)\n        sat_shift_limit: SymmetricRangeType = (-30, 30)\n        val_shift_limit: SymmetricRangeType = (-20, 20)\n\n    def __init__(\n        self,\n        hue_shift_limit: ScaleIntType = 20,\n        sat_shift_limit: ScaleIntType = 30,\n        val_shift_limit: ScaleIntType = 20,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.hue_shift_limit = cast(Tuple[float, float], hue_shift_limit)\n        self.sat_shift_limit = cast(Tuple[float, float], sat_shift_limit)\n        self.val_shift_limit = cast(Tuple[float, float], val_shift_limit)\n\n    def apply(\n        self, img: np.ndarray, hue_shift: int = 0, sat_shift: int = 0, val_shift: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        if not is_rgb_image(img) and not is_grayscale_image(img):\n            msg = \"HueSaturationValue transformation expects 1-channel or 3-channel images.\"\n            raise TypeError(msg)\n        return F.shift_hsv(img, hue_shift, sat_shift, val_shift)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"hue_shift\": random.uniform(self.hue_shift_limit[0], self.hue_shift_limit[1]),\n            \"sat_shift\": random.uniform(self.sat_shift_limit[0], self.sat_shift_limit[1]),\n            \"val_shift\": random.uniform(self.val_shift_limit[0], self.val_shift_limit[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"hue_shift_limit\", \"sat_shift_limit\", \"val_shift_limit\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ISONoise","title":"<code>class  ISONoise</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply camera sensor noise.</p> <p>Parameters:</p> Name Type Description <code>color_shift</code> <code>float, float</code> <p>variance range for color hue change. Measured as a fraction of 360 degree Hue angle in HLS colorspace.</p> <code>intensity</code> <code>float, float</code> <p>Multiplicative factor that control strength of color and luminace noise.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ISONoise(ImageOnlyTransform):\n    \"\"\"Apply camera sensor noise.\n\n    Args:\n        color_shift (float, float): variance range for color hue change.\n            Measured as a fraction of 360 degree Hue angle in HLS colorspace.\n        intensity ((float, float): Multiplicative factor that control strength\n            of color and luminace noise.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        color_shift: Tuple[float, float] = Field(\n            default=(0.01, 0.05),\n            description=(\n                \"Variance range for color hue change. Measured as a fraction of 360 degree Hue angle in HLS colorspace.\"\n            ),\n        )\n        intensity: Tuple[float, float] = Field(\n            default=(0.1, 0.5), description=\"Multiplicative factor that control strength of color and luminance noise.\"\n        )\n\n    def __init__(\n        self,\n        color_shift: Tuple[float, float] = (0.01, 0.05),\n        intensity: Tuple[float, float] = (0.1, 0.5),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.intensity = intensity\n        self.color_shift = color_shift\n\n    def apply(\n        self,\n        img: np.ndarray,\n        color_shift: float = 0.05,\n        intensity: float = 1.0,\n        random_state: Optional[int] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.iso_noise(img, color_shift, intensity, np.random.RandomState(random_state))\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"color_shift\": random_utils.uniform(self.color_shift[0], self.color_shift[1]),\n            \"intensity\": random_utils.uniform(self.intensity[0], self.intensity[1]),\n            \"random_state\": random_utils.randint(0, 65536),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"intensity\", \"color_shift\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ImageCompression","title":"<code>class  ImageCompression</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Decreases image quality by Jpeg, WebP compression of an image.</p> <p>Parameters:</p> Name Type Description <code>quality_lower</code> <p>lower bound on the image quality. Should be in [0, 100] range for jpeg and [1, 100] for webp.</p> <code>quality_upper</code> <p>upper bound on the image quality. Should be in [0, 100] range for jpeg and [1, 100] for webp.</p> <code>compression_type</code> <code>ImageCompressionType</code> <p>should be ImageCompressionType.JPEG or ImageCompressionType.WEBP. Default: ImageCompressionType.JPEG</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ImageCompression(ImageOnlyTransform):\n    \"\"\"Decreases image quality by Jpeg, WebP compression of an image.\n\n    Args:\n        quality_lower: lower bound on the image quality. Should be in [0, 100] range for jpeg and [1, 100] for webp.\n        quality_upper: upper bound on the image quality. Should be in [0, 100] range for jpeg and [1, 100] for webp.\n        compression_type (ImageCompressionType): should be ImageCompressionType.JPEG or ImageCompressionType.WEBP.\n            Default: ImageCompressionType.JPEG\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        quality_lower: int = Field(default=99, description=\"Lower bound on the image quality\", ge=1, le=100)\n        quality_upper: int = Field(default=100, description=\"Upper bound on the image quality\", ge=1, le=100)\n        compression_type: ImageCompressionType = Field(\n            default=ImageCompressionType.JPEG, description=\"Image compression format\"\n        )\n\n        @model_validator(mode=\"after\")\n        def validate_quality(self) -&gt; Self:\n            if self.quality_lower &gt;= self.quality_upper:\n                msg = \"quality_lower must be less than quality_upper\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        quality_lower: int = 99,\n        quality_upper: int = 100,\n        compression_type: ImageCompressionType = ImageCompressionType.JPEG,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        self.quality_lower = quality_lower\n        self.quality_upper = quality_upper\n        self.compression_type = compression_type\n\n    def apply(self, img: np.ndarray, quality: int = 100, image_type: str = \".jpg\", **params: Any) -&gt; np.ndarray:\n        if img.ndim != GRAYSCALE_SHAPE_LEN and img.shape[-1] not in (1, 3, 4):\n            msg = \"ImageCompression transformation expects 1, 3 or 4 channel images.\"\n            raise TypeError(msg)\n        return F.image_compression(img, quality, image_type)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        image_type = \".jpg\"\n\n        if self.compression_type == ImageCompressionType.WEBP:\n            image_type = \".webp\"\n\n        return {\n            \"quality\": random_utils.randint(self.quality_lower, self.quality_upper + 1),\n            \"image_type\": image_type,\n        }\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\n            \"quality_lower\": self.quality_lower,\n            \"quality_upper\": self.quality_upper,\n            \"compression_type\": self.compression_type.value,\n        }\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.InvertImg","title":"<code>class  InvertImg</code> <code> </code>  [view source on GitHub]","text":"<p>Invert the input image by subtracting pixel values from max values of the image types, i.e., 255 for uint8 and 1.0 for float32.</p> <p>Parameters:</p> Name Type Description <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class InvertImg(ImageOnlyTransform):\n    \"\"\"Invert the input image by subtracting pixel values from max values of the image types,\n    i.e., 255 for uint8 and 1.0 for float32.\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.invert(img)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Lambda","title":"<code>class  Lambda</code> <code>       (image=None, mask=None, keypoint=None, bbox=None, global_label=None, name=None, always_apply=False, p=1.0)                   </code>  [view source on GitHub]","text":"<p>A flexible transformation class for using user-defined transformation functions per targets. Function signature must include **kwargs to accept optional arguments like interpolation method, image size, etc:</p> <p>Parameters:</p> Name Type Description <code>image</code> <code>Optional[Callable[..., Any]]</code> <p>Image transformation function.</p> <code>mask</code> <code>Optional[Callable[..., Any]]</code> <p>Mask transformation function.</p> <code>keypoint</code> <code>Optional[Callable[..., Any]]</code> <p>Keypoint transformation function.</p> <code>bbox</code> <code>Optional[Callable[..., Any]]</code> <p>BBox transformation function.</p> <code>global_label</code> <code>Optional[Callable[..., Any]]</code> <p>Global label transformation function.</p> <code>always_apply</code> <code>bool</code> <p>Indicates whether this transformation should be always applied.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints, global_label</p> <p>Image types:     Any</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Lambda(NoOp):\n    \"\"\"A flexible transformation class for using user-defined transformation functions per targets.\n    Function signature must include **kwargs to accept optional arguments like interpolation method, image size, etc:\n\n    Args:\n        image: Image transformation function.\n        mask: Mask transformation function.\n        keypoint: Keypoint transformation function.\n        bbox: BBox transformation function.\n        global_label: Global label transformation function.\n        always_apply: Indicates whether this transformation should be always applied.\n        p: probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image, mask, bboxes, keypoints, global_label\n\n    Image types:\n        Any\n\n    \"\"\"\n\n    def __init__(\n        self,\n        image: Optional[Callable[..., Any]] = None,\n        mask: Optional[Callable[..., Any]] = None,\n        keypoint: Optional[Callable[..., Any]] = None,\n        bbox: Optional[Callable[..., Any]] = None,\n        global_label: Optional[Callable[..., Any]] = None,\n        name: Optional[str] = None,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n\n        self.name = name\n        self.custom_apply_fns = {\n            target_name: F.noop for target_name in (\"image\", \"mask\", \"keypoint\", \"bbox\", \"global_label\")\n        }\n        for target_name, custom_apply_fn in {\n            \"image\": image,\n            \"mask\": mask,\n            \"keypoint\": keypoint,\n            \"bbox\": bbox,\n            \"global_label\": global_label,\n        }.items():\n            if custom_apply_fn is not None:\n                if isinstance(custom_apply_fn, LambdaType) and custom_apply_fn.__name__ == \"&lt;lambda&gt;\":\n                    warnings.warn(\n                        \"Using lambda is incompatible with multiprocessing. \"\n                        \"Consider using regular functions or partial().\"\n                    )\n\n                self.custom_apply_fns[target_name] = custom_apply_fn\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        fn = self.custom_apply_fns[\"image\"]\n        return fn(img, **params)\n\n    def apply_to_mask(self, mask: np.ndarray, **params: Any) -&gt; np.ndarray:\n        fn = self.custom_apply_fns[\"mask\"]\n        return fn(mask, **params)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        fn = self.custom_apply_fns[\"bbox\"]\n        return fn(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        fn = self.custom_apply_fns[\"keypoint\"]\n        return fn(keypoint, **params)\n\n    def apply_to_global_label(self, label: np.ndarray, **params: Any) -&gt; np.ndarray:\n        fn = self.custom_apply_fns[\"global_label\"]\n        return fn(label, **params)\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return False\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        if self.name is None:\n            msg = (\n                \"To make a Lambda transform serializable you should provide the `name` argument, \"\n                \"e.g. `Lambda(name='my_transform', image=&lt;some func&gt;, ...)`.\"\n            )\n            raise ValueError(msg)\n        return {\"__class_fullname__\": self.get_class_fullname(), \"__name__\": self.name}\n\n    def __repr__(self) -&gt; str:\n        state = {\"name\": self.name}\n        state.update(self.custom_apply_fns.items())  # type: ignore[arg-type]\n        state.update(self.get_base_init_args())\n        return f\"{self.__class__.__name__}({format_args(state)})\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Lambda.__init__","title":"<code>__init__ (self, image=None, mask=None, keypoint=None, bbox=None, global_label=None, name=None, always_apply=False, p=1.0)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>def __init__(\n    self,\n    image: Optional[Callable[..., Any]] = None,\n    mask: Optional[Callable[..., Any]] = None,\n    keypoint: Optional[Callable[..., Any]] = None,\n    bbox: Optional[Callable[..., Any]] = None,\n    global_label: Optional[Callable[..., Any]] = None,\n    name: Optional[str] = None,\n    always_apply: bool = False,\n    p: float = 1.0,\n):\n    super().__init__(always_apply, p)\n\n    self.name = name\n    self.custom_apply_fns = {\n        target_name: F.noop for target_name in (\"image\", \"mask\", \"keypoint\", \"bbox\", \"global_label\")\n    }\n    for target_name, custom_apply_fn in {\n        \"image\": image,\n        \"mask\": mask,\n        \"keypoint\": keypoint,\n        \"bbox\": bbox,\n        \"global_label\": global_label,\n    }.items():\n        if custom_apply_fn is not None:\n            if isinstance(custom_apply_fn, LambdaType) and custom_apply_fn.__name__ == \"&lt;lambda&gt;\":\n                warnings.warn(\n                    \"Using lambda is incompatible with multiprocessing. \"\n                    \"Consider using regular functions or partial().\"\n                )\n\n            self.custom_apply_fns[target_name] = custom_apply_fn\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Morphological","title":"<code>class  Morphological</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply a morphological operation (dilation or erosion) to an image, with particular value for enhancing document scans.</p> <p>Morphological operations modify the structure of the image. Dilation expands the white (foreground) regions in a binary or grayscale image, while erosion shrinks them. These operations are beneficial in document processing, for example: - Dilation helps in closing up gaps within text or making thin lines thicker,     enhancing legibility for OCR (Optical Character Recognition). - Erosion can remove small white noise and detach connected objects,     making the structure of larger objects more pronounced.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <code>int or tuple/list of int</code> <p>Specifies the size of the structuring element (kernel) used for the operation. - If an integer is provided, a square kernel of that size will be used. - If a tuple or list is provided, it should contain two integers representing the minimum     and maximum sizes for the dilation kernel.</p> <code>operation</code> <code>str</code> <p>The morphological operation to apply. Options are 'dilation' or 'erosion'. Default is 'dilation'.</p> <code>always_apply</code> <code>bool</code> <p>Whether to always apply this transformation. Default is False.</p> <code>p</code> <code>float</code> <p>The probability of applying this transformation. Default is 0.5.</p> <p>Targets</p> <p>image, mask</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://github.com/facebookresearch/nougat</p> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; import albumentations as A\n&gt;&gt;&gt; transform = A.Compose([\n&gt;&gt;&gt;     A.Morphological(scale=(2, 3), operation='dilation', p=0.5)\n&gt;&gt;&gt; ])\n&gt;&gt;&gt; image = transform(image=image)[\"image\"]\n</code></pre> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Morphological(DualTransform):\n    \"\"\"Apply a morphological operation (dilation or erosion) to an image,\n    with particular value for enhancing document scans.\n\n    Morphological operations modify the structure of the image.\n    Dilation expands the white (foreground) regions in a binary or grayscale image, while erosion shrinks them.\n    These operations are beneficial in document processing, for example:\n    - Dilation helps in closing up gaps within text or making thin lines thicker,\n        enhancing legibility for OCR (Optical Character Recognition).\n    - Erosion can remove small white noise and detach connected objects,\n        making the structure of larger objects more pronounced.\n\n    Args:\n        scale (int or tuple/list of int): Specifies the size of the structuring element (kernel) used for the operation.\n            - If an integer is provided, a square kernel of that size will be used.\n            - If a tuple or list is provided, it should contain two integers representing the minimum\n                and maximum sizes for the dilation kernel.\n        operation (str, optional): The morphological operation to apply. Options are 'dilation' or 'erosion'.\n            Default is 'dilation'.\n        always_apply (bool, optional): Whether to always apply this transformation. Default is False.\n        p (float, optional): The probability of applying this transformation. Default is 0.5.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://github.com/facebookresearch/nougat\n\n    Example:\n        &gt;&gt;&gt; import albumentations as A\n        &gt;&gt;&gt; transform = A.Compose([\n        &gt;&gt;&gt;     A.Morphological(scale=(2, 3), operation='dilation', p=0.5)\n        &gt;&gt;&gt; ])\n        &gt;&gt;&gt; image = transform(image=image)[\"image\"]\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: OnePlusIntRangeType = (2, 3)\n        operation: MorphologyMode = \"dilation\"\n\n    def __init__(\n        self,\n        scale: ScaleIntType = (2, 3),\n        operation: MorphologyMode = \"dilation\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.scale = cast(Tuple[int, int], scale)\n        self.operation = operation\n\n    def apply(self, img: np.ndarray, kernel: Tuple[int, int], **params: Any) -&gt; np.ndarray:\n        return F.morphology(img, kernel, self.operation)\n\n    def apply_to_mask(self, mask: np.ndarray, kernel: Tuple[int, int], **params: Any) -&gt; np.ndarray:\n        return F.morphology(mask, kernel, self.operation)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"kernel\": cv2.getStructuringElement(cv2.MORPH_ELLIPSE, self.scale),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"scale\", \"operation\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.MultiplicativeNoise","title":"<code>class  MultiplicativeNoise</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Multiply image to random number or array of numbers.</p> <p>Parameters:</p> Name Type Description <code>multiplier</code> <p>If single float image will be multiplied to this number. If tuple of float multiplier will be in range <code>[multiplier[0], multiplier[1])</code>. Default: (0.9, 1.1).</p> <code>per_channel</code> <p>If <code>False</code>, same values for all channels will be used. If <code>True</code> use sample values for each channels. Default False.</p> <code>elementwise</code> <p>If <code>False</code> multiply multiply all pixels in an image with a random value sampled once. If <code>True</code> Multiply image pixels with values that are pixelwise randomly sampled. Default: False.</p> <p>Targets</p> <p>image</p> <p>Image types:     Any</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class MultiplicativeNoise(ImageOnlyTransform):\n    \"\"\"Multiply image to random number or array of numbers.\n\n    Args:\n        multiplier: If single float image will be multiplied to this number.\n            If tuple of float multiplier will be in range `[multiplier[0], multiplier[1])`. Default: (0.9, 1.1).\n        per_channel: If `False`, same values for all channels will be used.\n            If `True` use sample values for each channels. Default False.\n        elementwise: If `False` multiply multiply all pixels in an image with a random value sampled once.\n            If `True` Multiply image pixels with values that are pixelwise randomly sampled. Default: False.\n\n    Targets:\n        image\n\n    Image types:\n        Any\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        multiplier: NonNegativeFloatRangeType = (0.9, 1.1)\n        per_channel: bool = Field(default=False, description=\"Apply multiplier per channel.\")\n        elementwise: bool = Field(default=False, description=\"Apply multiplier element-wise to pixels.\")\n\n    def __init__(\n        self,\n        multiplier: ScaleFloatType = (0.9, 1.1),\n        per_channel: bool = False,\n        elementwise: bool = False,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.multiplier = cast(Tuple[float, float], multiplier)\n        self.per_channel = per_channel\n        self.elementwise = elementwise\n\n    def apply(self, img: np.ndarray, multiplier: float = np.array([1]), **kwargs: Any) -&gt; np.ndarray:\n        return F.multiply(img, multiplier)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        if self.multiplier[0] == self.multiplier[1]:\n            return {\"multiplier\": np.array([self.multiplier[0]])}\n\n        img = params[\"image\"]\n\n        height, width = img.shape[:2]\n\n        num_channels = (1 if is_grayscale_image(img) else img.shape[-1]) if self.per_channel else 1\n\n        shape = [height, width, num_channels] if self.elementwise else [num_channels]\n\n        multiplier = random_utils.uniform(self.multiplier[0], self.multiplier[1], tuple(shape))\n        if is_grayscale_image(img) and img.ndim == GRAYSCALE_SHAPE_LEN:\n            multiplier = np.squeeze(multiplier)\n\n        return {\"multiplier\": multiplier}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return \"multiplier\", \"per_channel\", \"elementwise\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Normalize","title":"<code>class  Normalize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Applies various normalization techniques to an image. The specific normalization technique can be selected     with the <code>normalization</code> parameter.</p> <p>Standard normalization is applied using the formula:     <code>img = (img - mean * max_pixel_value) / (std * max_pixel_value)</code>.     Other normalization techniques adjust the image based on global or per-channel statistics,     or scale pixel values to a specified range.</p> <p>Parameters:</p> Name Type Description <code>mean</code> <code>Optional[ColorType]</code> <p>Mean values for standard normalization. For \"standard\" normalization, the default values are ImageNet mean values: (0.485, 0.456, 0.406). For \"inception\" normalization, use mean values of (0.5, 0.5, 0.5).</p> <code>std</code> <code>Optional[ColorType]</code> <p>Standard deviation values for standard normalization. For \"standard\" normalization, the default values are ImageNet standard deviation :(0.229, 0.224, 0.225). For \"inception\" normalization, use standard deviation values of (0.5, 0.5, 0.5).</p> <code>max_pixel_value</code> <code>Optional[float]</code> <p>Maximum possible pixel value, used for scaling in standard normalization. Defaults to 255.0.</p> <code>normalization</code> <code>Literal[\"standard\", \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\", \"inception\"]) Specifies the normalization technique to apply. Defaults to \"standard\". - \"standard\"</code> <p>Applies the formula <code>(img - mean * max_pixel_value) / (std * max_pixel_value)</code>.     The default mean and std are based on ImageNet. - \"image\": Normalizes the whole image based on its global mean and standard deviation. - \"image_per_channel\": Normalizes the image per channel based on each channel's mean and standard deviation. - \"min_max\": Scales the image pixel values to a [0, 1] range based on the global     minimum and maximum pixel values. - \"min_max_per_channel\": Scales each channel of the image pixel values to a [0, 1]     range based on the per-channel minimum and maximum pixel values. - \"inception\": Applies normalization suitable for Inception models     with mean and std values of (0.5, 0.5, 0.5) respectively.</p> <code>p</code> <code>float</code> <p>Probability of applying the transform. Defaults to 1.0.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Note</p> <p>For \"standard\" normalization, <code>mean</code>, <code>std</code>, and <code>max_pixel_value</code> must be provided. For \"inception\" normalization, the specific mean and std values should be used. For other normalization types, these parameters are ignored.</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Normalize(ImageOnlyTransform):\n    \"\"\"Applies various normalization techniques to an image. The specific normalization technique can be selected\n        with the `normalization` parameter.\n\n    Standard normalization is applied using the formula:\n        `img = (img - mean * max_pixel_value) / (std * max_pixel_value)`.\n        Other normalization techniques adjust the image based on global or per-channel statistics,\n        or scale pixel values to a specified range.\n\n    Args:\n        mean (Optional[ColorType]): Mean values for standard normalization.\n            For \"standard\" normalization, the default values are ImageNet mean values: (0.485, 0.456, 0.406).\n            For \"inception\" normalization, use mean values of (0.5, 0.5, 0.5).\n        std (Optional[ColorType]): Standard deviation values for standard normalization.\n            For \"standard\" normalization, the default values are ImageNet standard deviation :(0.229, 0.224, 0.225).\n            For \"inception\" normalization, use standard deviation values of (0.5, 0.5, 0.5).\n        max_pixel_value (Optional[float]): Maximum possible pixel value, used for scaling in standard normalization.\n            Defaults to 255.0.\n        normalization (Literal[\"standard\", \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\", \"inception\"])\n            Specifies the normalization technique to apply. Defaults to \"standard\".\n            - \"standard\": Applies the formula `(img - mean * max_pixel_value) / (std * max_pixel_value)`.\n                The default mean and std are based on ImageNet.\n            - \"image\": Normalizes the whole image based on its global mean and standard deviation.\n            - \"image_per_channel\": Normalizes the image per channel based on each channel's mean and standard deviation.\n            - \"min_max\": Scales the image pixel values to a [0, 1] range based on the global\n                minimum and maximum pixel values.\n            - \"min_max_per_channel\": Scales each channel of the image pixel values to a [0, 1]\n                range based on the per-channel minimum and maximum pixel values.\n            - \"inception\": Applies normalization suitable for Inception models\n                with mean and std values of (0.5, 0.5, 0.5) respectively.\n\n        p (float): Probability of applying the transform. Defaults to 1.0.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Note:\n        For \"standard\" normalization, `mean`, `std`, and `max_pixel_value` must be provided.\n        For \"inception\" normalization, the specific mean and std values should be used.\n        For other normalization types, these parameters are ignored.\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        mean: Optional[ColorType] = Field(\n            default=(0.485, 0.456, 0.406),\n            description=\"Mean values for normalization, defaulting to ImageNet mean values.\",\n        )\n        std: Optional[ColorType] = Field(\n            default=(0.229, 0.224, 0.225),\n            description=\"Standard deviation values for normalization, defaulting to ImageNet std values.\",\n        )\n        max_pixel_value: Optional[float] = Field(default=255.0, description=\"Maximum possible pixel value.\")\n        normalization: Literal[\n            \"standard\", \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\", \"inception\"\n        ] = \"standard\"\n        p: ProbabilityType = 1\n\n        @model_validator(mode=\"after\")\n        def validate_normalization(self) -&gt; Self:\n            if (\n                self.mean is None\n                or self.std is None\n                or self.max_pixel_value is None\n                and self.normalization == \"standard\"\n            ):\n                raise ValueError(\"mean, std, and max_pixel_value must be provided for standard normalization.\")\n            return self\n\n    def __init__(\n        self,\n        mean: Optional[ColorType] = (0.485, 0.456, 0.406),\n        std: Optional[ColorType] = (0.229, 0.224, 0.225),\n        max_pixel_value: Optional[float] = 255.0,\n        normalization: Literal[\"standard\", \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\"] = \"standard\",\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.mean = mean\n        self.std = std\n        self.max_pixel_value = max_pixel_value\n        self.normalization = normalization\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if self.normalization == \"standard\":\n            return F.normalize(\n                img, cast(ColorType, self.mean), cast(ColorType, self.std), cast(float, self.max_pixel_value)\n            )\n        if self.normalization in {\"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\"}:\n            return F.normalize_per_image(img, self.normalization)\n        raise ValueError(f\"Unknown normalization type: {self.normalization}\")\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"mean\", \"std\", \"max_pixel_value\", \"normalization\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.PixelDropout","title":"<code>class  PixelDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Set pixels to 0 with some probability.</p> <p>Parameters:</p> Name Type Description <code>dropout_prob</code> <code>float</code> <p>pixel drop probability. Default: 0.01</p> <code>per_channel</code> <code>bool</code> <p>if set to <code>True</code> drop mask will be sampled for each channel, otherwise the same mask will be sampled for all channels. Default: False</p> <code>drop_value</code> <code>number or sequence of numbers or None</code> <p>Value that will be set in dropped place. If set to None value will be sampled randomly, default ranges will be used:     - uint8 - [0, 255]     - uint16 - [0, 65535]     - uint32 - [0, 4294967295]     - float, double - [0, 1] Default: 0</p> <code>mask_drop_value</code> <code>number or sequence of numbers or None</code> <p>Value that will be set in dropped place in masks. If set to None masks will be unchanged. Default: 0</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask</p> <p>Image types:     any</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class PixelDropout(DualTransform):\n    \"\"\"Set pixels to 0 with some probability.\n\n    Args:\n        dropout_prob (float): pixel drop probability. Default: 0.01\n        per_channel (bool): if set to `True` drop mask will be sampled for each channel,\n            otherwise the same mask will be sampled for all channels. Default: False\n        drop_value (number or sequence of numbers or None): Value that will be set in dropped place.\n            If set to None value will be sampled randomly, default ranges will be used:\n                - uint8 - [0, 255]\n                - uint16 - [0, 65535]\n                - uint32 - [0, 4294967295]\n                - float, double - [0, 1]\n            Default: 0\n        mask_drop_value (number or sequence of numbers or None): Value that will be set in dropped place in masks.\n            If set to None masks will be unchanged. Default: 0\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask\n    Image types:\n        any\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        dropout_prob: ProbabilityType = 0.01\n        per_channel: bool = Field(default=False, description=\"Sample drop mask per channel.\")\n        drop_value: Optional[ScaleFloatType] = Field(\n            default=0, description=\"Value to set in dropped pixels. None for random sampling.\"\n        )\n        mask_drop_value: Optional[ScaleFloatType] = Field(\n            default=None, description=\"Value to set in dropped pixels in masks. None to leave masks unchanged.\"\n        )\n\n        @model_validator(mode=\"after\")\n        def validate_mask_drop_value(self) -&gt; Self:\n            if self.mask_drop_value is not None and self.per_channel:\n                msg = \"PixelDropout supports mask only with per_channel=False.\"\n                raise ValueError(msg)\n            return self\n\n    _targets = (Targets.IMAGE, Targets.MASK)\n\n    def __init__(\n        self,\n        dropout_prob: float = 0.01,\n        per_channel: bool = False,\n        drop_value: Optional[ScaleFloatType] = 0,\n        mask_drop_value: Optional[ScaleFloatType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.dropout_prob = dropout_prob\n        self.per_channel = per_channel\n        self.drop_value = drop_value\n        self.mask_drop_value = mask_drop_value\n\n    def apply(\n        self,\n        img: np.ndarray,\n        drop_mask: Optional[np.ndarray] = None,\n        drop_value: Union[float, Sequence[float]] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.pixel_dropout(img, drop_mask, drop_value)\n\n    def apply_to_mask(self, mask: np.ndarray, drop_mask: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        if self.mask_drop_value is None:\n            return mask\n\n        if mask.ndim == GRAYSCALE_SHAPE_LEN:\n            drop_mask = np.squeeze(drop_mask)\n\n        return F.pixel_dropout(mask, drop_mask, self.mask_drop_value)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return bbox\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return keypoint\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        shape = img.shape if self.per_channel else img.shape[:2]\n\n        rnd = np.random.RandomState(random.randint(0, 1 &lt;&lt; 31))\n        # Use choice to create boolean matrix, if we will use binomial after that we will need type conversion\n        drop_mask = rnd.choice([True, False], shape, p=[self.dropout_prob, 1 - self.dropout_prob])\n\n        drop_value: Union[float, Sequence[float], np.ndarray]\n        if drop_mask.ndim != img.ndim:\n            drop_mask = np.expand_dims(drop_mask, -1)\n        if self.drop_value is None:\n            drop_shape = 1 if is_grayscale_image(img) else int(img.shape[-1])\n\n            if img.dtype in (np.uint8, np.uint16, np.uint32):\n                drop_value = rnd.randint(0, int(F.MAX_VALUES_BY_DTYPE[img.dtype]), drop_shape, img.dtype)\n            elif img.dtype in [np.float32, np.double]:\n                drop_value = rnd.uniform(0, 1, drop_shape).astype(img.dtype)\n            else:\n                raise ValueError(f\"Unsupported dtype: {img.dtype}\")\n        else:\n            drop_value = self.drop_value\n\n        return {\"drop_mask\": drop_mask, \"drop_value\": drop_value}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"dropout_prob\", \"per_channel\", \"drop_value\", \"mask_drop_value\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Posterize","title":"<code>class  Posterize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Reduce the number of bits for each color channel.</p> <p>Parameters:</p> Name Type Description <code>num_bits</code> <code>int, int) or int,       or list of ints [r, g, b],       or list of ints [[r1, r1], [g1, g2], [b1, b2]]</code> <p>number of high bits. If num_bits is a single value, the range will be [num_bits, num_bits]. Must be in range [0, 8]. Default: 4.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets: image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Posterize(ImageOnlyTransform):\n    \"\"\"Reduce the number of bits for each color channel.\n\n    Args:\n        num_bits ((int, int) or int,\n                  or list of ints [r, g, b],\n                  or list of ints [[r1, r1], [g1, g2], [b1, b2]]): number of high bits.\n            If num_bits is a single value, the range will be [num_bits, num_bits].\n            Must be in range [0, 8]. Default: 4.\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n    image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        num_bits: Annotated[\n            Union[int, Tuple[int, int], Tuple[int, int, int]], Field(default=4, description=\"Number of high bits\")\n        ]\n\n        @field_validator(\"num_bits\")\n        @classmethod\n        def validate_num_bits(cls, num_bits: Any) -&gt; Union[Tuple[int, int], List[Tuple[int, int]]]:\n            if isinstance(num_bits, int):\n                return cast(Tuple[int, int], to_tuple(num_bits, num_bits))\n            if isinstance(num_bits, Sequence) and len(num_bits) == NUM_BITS_ARRAY_LENGTH:\n                return [cast(Tuple[int, int], to_tuple(i, 0)) for i in num_bits]\n            return cast(Tuple[int, int], to_tuple(num_bits, 0))\n\n    def __init__(\n        self,\n        num_bits: Union[int, Tuple[int, int], Tuple[int, int, int]] = 4,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.num_bits = cast(Union[Tuple[int, ...], List[Tuple[int, ...]]], num_bits)\n\n    def apply(self, img: np.ndarray, num_bits: int = 1, **params: Any) -&gt; np.ndarray:\n        return F.posterize(img, num_bits)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        if len(self.num_bits) == NUM_BITS_ARRAY_LENGTH:\n            return {\"num_bits\": [random.randint(int(i[0]), int(i[1])) for i in self.num_bits]}  # type: ignore[index]\n        num_bits = self.num_bits\n        return {\"num_bits\": random.randint(int(num_bits[0]), int(num_bits[1]))}  # type: ignore[arg-type]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"num_bits\",)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RGBShift","title":"<code>class  RGBShift</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly shift values for each channel of the input RGB image.</p> <p>Parameters:</p> Name Type Description <code>r_shift_limit</code> <p>range for changing values for the red channel. If r_shift_limit is a single int, the range will be (-r_shift_limit, r_shift_limit). Default: (-20, 20).</p> <code>g_shift_limit</code> <p>range for changing values for the green channel. If g_shift_limit is a single int, the range  will be (-g_shift_limit, g_shift_limit). Default: (-20, 20).</p> <code>b_shift_limit</code> <p>range for changing values for the blue channel. If b_shift_limit is a single int, the range will be (-b_shift_limit, b_shift_limit). Default: (-20, 20).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RGBShift(ImageOnlyTransform):\n    \"\"\"Randomly shift values for each channel of the input RGB image.\n\n    Args:\n        r_shift_limit: range for changing values for the red channel. If r_shift_limit is a single\n            int, the range will be (-r_shift_limit, r_shift_limit). Default: (-20, 20).\n        g_shift_limit: range for changing values for the green channel. If g_shift_limit is a\n            single int, the range  will be (-g_shift_limit, g_shift_limit). Default: (-20, 20).\n        b_shift_limit: range for changing values for the blue channel. If b_shift_limit is a single\n            int, the range will be (-b_shift_limit, b_shift_limit). Default: (-20, 20).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        r_shift_limit: SymmetricRangeType = (-20, 20)\n        g_shift_limit: SymmetricRangeType = (-20, 20)\n        b_shift_limit: SymmetricRangeType = (-20, 20)\n\n    def __init__(\n        self,\n        r_shift_limit: ScaleIntType = (-20, 20),\n        g_shift_limit: ScaleIntType = (-20, 20),\n        b_shift_limit: ScaleIntType = (-20, 20),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.r_shift_limit = cast(Tuple[float, float], r_shift_limit)\n        self.g_shift_limit = cast(Tuple[float, float], g_shift_limit)\n        self.b_shift_limit = cast(Tuple[float, float], b_shift_limit)\n\n    def apply(self, img: np.ndarray, r_shift: int = 0, g_shift: int = 0, b_shift: int = 0, **params: Any) -&gt; np.ndarray:\n        if not is_rgb_image(img):\n            msg = \"RGBShift transformation expects 3-channel images.\"\n            raise TypeError(msg)\n        return F.shift_rgb(img, r_shift, g_shift, b_shift)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"r_shift\": random.uniform(self.r_shift_limit[0], self.r_shift_limit[1]),\n            \"g_shift\": random.uniform(self.g_shift_limit[0], self.g_shift_limit[1]),\n            \"b_shift\": random.uniform(self.b_shift_limit[0], self.b_shift_limit[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"r_shift_limit\", \"g_shift_limit\", \"b_shift_limit\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomBrightnessContrast","title":"<code>class  RandomBrightnessContrast</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly change brightness and contrast of the input image.</p> <p>Parameters:</p> Name Type Description <code>brightness_limit</code> <p>factor range for changing brightness. If limit is a single float, the range will be (-limit, limit). Default: (-0.2, 0.2).</p> <code>contrast_limit</code> <p>factor range for changing contrast. If limit is a single float, the range will be (-limit, limit). Default: (-0.2, 0.2).</p> <code>brightness_by_max</code> <p>If True adjust contrast by image dtype maximum, else adjust contrast by image mean.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomBrightnessContrast(ImageOnlyTransform):\n    \"\"\"Randomly change brightness and contrast of the input image.\n\n    Args:\n        brightness_limit: factor range for changing brightness.\n            If limit is a single float, the range will be (-limit, limit). Default: (-0.2, 0.2).\n        contrast_limit: factor range for changing contrast.\n            If limit is a single float, the range will be (-limit, limit). Default: (-0.2, 0.2).\n        brightness_by_max: If True adjust contrast by image dtype maximum,\n            else adjust contrast by image mean.\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        brightness_limit: SymmetricRangeType = (-0.2, 0.2)\n        contrast_limit: SymmetricRangeType = (-0.2, 0.2)\n        brightness_by_max: bool = Field(default=True, description=\"Adjust brightness by image dtype maximum if True.\")\n\n    def __init__(\n        self,\n        brightness_limit: ScaleFloatType = (-0.2, 0.2),\n        contrast_limit: ScaleFloatType = (-0.2, 0.2),\n        brightness_by_max: bool = True,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.brightness_limit = cast(Tuple[float, float], brightness_limit)\n        self.contrast_limit = cast(Tuple[float, float], contrast_limit)\n        self.brightness_by_max = brightness_by_max\n\n    def apply(self, img: np.ndarray, alpha: float = 1.0, beta: float = 0.0, **params: Any) -&gt; np.ndarray:\n        return F.brightness_contrast_adjust(img, alpha, beta, self.brightness_by_max)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"alpha\": 1.0 + random.uniform(self.contrast_limit[0], self.contrast_limit[1]),\n            \"beta\": 0.0 + random.uniform(self.brightness_limit[0], self.brightness_limit[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"brightness_limit\", \"contrast_limit\", \"brightness_by_max\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomFog","title":"<code>class  RandomFog</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Simulates fog for the image</p> <p>Parameters:</p> Name Type Description <code>fog_coef_lower</code> <p>lower limit for fog intensity coefficient. Should be in [0, 1] range.</p> <code>fog_coef_upper</code> <p>upper limit for fog intensity coefficient. Should be in [0, 1] range.</p> <code>alpha_coef</code> <p>transparency of the fog circles. Should be in [0, 1] range.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomFog(ImageOnlyTransform):\n    \"\"\"Simulates fog for the image\n\n    Args:\n        fog_coef_lower: lower limit for fog intensity coefficient. Should be in [0, 1] range.\n        fog_coef_upper: upper limit for fog intensity coefficient. Should be in [0, 1] range.\n        alpha_coef: transparency of the fog circles. Should be in [0, 1] range.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        fog_coef_lower: float = Field(default=0.3, description=\"Lower limit for fog intensity coefficient\", ge=0, le=1)\n        fog_coef_upper: float = Field(default=1, description=\"Upper limit for fog intensity coefficient\", ge=0, le=1)\n        alpha_coef: float = Field(default=0.08, description=\"Transparency of the fog circles\", ge=0, le=1)\n\n        @model_validator(mode=\"after\")\n        def validate_fog_coefficients(self) -&gt; Self:\n            if self.fog_coef_lower &gt; self.fog_coef_upper:\n                msg = \"fog_coef_upper must be greater than or equal to fog_coef_lower.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        fog_coef_lower: float = 0.3,\n        fog_coef_upper: float = 1,\n        alpha_coef: float = 0.08,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.fog_coef_lower = fog_coef_lower\n        self.fog_coef_upper = fog_coef_upper\n        self.alpha_coef = alpha_coef\n\n    def apply(\n        self,\n        img: np.ndarray,\n        fog_coef: np.ndarray = 0.1,\n        haze_list: Optional[List[Tuple[int, int]]] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if haze_list is None:\n            haze_list = []\n        return F.add_fog(img, fog_coef, self.alpha_coef, haze_list)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        fog_coef = random.uniform(self.fog_coef_lower, self.fog_coef_upper)\n\n        height, width = imshape = img.shape[:2]\n\n        hw = max(1, int(width // 3 * fog_coef))\n\n        haze_list = []\n        midx = width // 2 - 2 * hw\n        midy = height // 2 - hw\n        index = 1\n\n        while midx &gt; -hw or midy &gt; -hw:\n            for _ in range(hw // 10 * index):\n                x = random_utils.randint(midx, width - midx - hw + 1)\n                y = random_utils.randint(midy, height - midy - hw + 1)\n                haze_list.append((x, y))\n\n            midx -= 3 * hw * width // sum(imshape)\n            midy -= 3 * hw * height // sum(imshape)\n            index += 1\n\n        return {\"haze_list\": haze_list, \"fog_coef\": fog_coef}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"fog_coef_lower\", \"fog_coef_upper\", \"alpha_coef\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomGamma","title":"<code>class  RandomGamma</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Applies random gamma correction to an image as a form of data augmentation.</p> <p>This class adjusts the luminance of an image by applying gamma correction with a randomly selected gamma value from a specified range. Gamma correction can simulate various lighting conditions, potentially enhancing model generalization.</p> <p>Attributes:</p> Name Type Description <code>gamma_limit</code> <code>Union[int, Tuple[int, int]]</code> <p>The range for gamma adjustment. If <code>gamma_limit</code> is a single int, the range will be interpreted as (-gamma_limit, gamma_limit), defining how much to adjust the image's gamma. Default is (80, 120).</p> <code>always_apply</code> <code>bool</code> <p>If <code>True</code>, the transform will always be applied, regardless of <code>p</code>. Default is <code>False</code>.</p> <code>p</code> <code>float</code> <p>The probability that the transform will be applied. Default is 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://en.wikipedia.org/wiki/Gamma_correction</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomGamma(ImageOnlyTransform):\n    \"\"\"Applies random gamma correction to an image as a form of data augmentation.\n\n    This class adjusts the luminance of an image by applying gamma correction with a randomly\n    selected gamma value from a specified range. Gamma correction can simulate various lighting\n    conditions, potentially enhancing model generalization.\n\n    Attributes:\n        gamma_limit (Union[int, Tuple[int, int]]): The range for gamma adjustment. If `gamma_limit` is a single\n            int, the range will be interpreted as (-gamma_limit, gamma_limit), defining how much\n            to adjust the image's gamma. Default is (80, 120).\n        always_apply (bool): If `True`, the transform will always be applied, regardless of `p`.\n            Default is `False`.\n        p (float): The probability that the transform will be applied. Default is 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n         https://en.wikipedia.org/wiki/Gamma_correction\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        gamma_limit: OnePlusFloatRangeType = (80, 120)\n\n    def __init__(\n        self,\n        gamma_limit: ScaleIntType = (80, 120),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.gamma_limit = cast(Tuple[float, float], gamma_limit)\n\n    def apply(self, img: np.ndarray, gamma: float = 1, **params: Any) -&gt; np.ndarray:\n        return F.gamma_transform(img, gamma=gamma)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"gamma\": random.uniform(self.gamma_limit[0], self.gamma_limit[1]) / 100.0}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"gamma_limit\",)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomGravel","title":"<code>class  RandomGravel</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Add gravels.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>gravel_roi</code> <p>(top-left x, top-left y, bottom-right x, bottom right y). Should be in [0, 1] range</p> <code>number_of_patches</code> <p>no. of gravel patches required</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomGravel(ImageOnlyTransform):\n    \"\"\"Add gravels.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        gravel_roi: (top-left x, top-left y,\n            bottom-right x, bottom right y). Should be in [0, 1] range\n        number_of_patches: no. of gravel patches required\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        gravel_roi: Tuple[float, float, float, float] = Field(\n            default=(0.1, 0.4, 0.9, 0.9), description=\"Region of interest for gravel placement\"\n        )\n        number_of_patches: int = Field(default=2, description=\"Number of gravel patches\", ge=1)\n\n        @model_validator(mode=\"after\")\n        def validate_gravel_roi(self) -&gt; Self:\n            gravel_lower_x, gravel_lower_y, gravel_upper_x, gravel_upper_y = self.gravel_roi\n            if not 0 &lt;= gravel_lower_x &lt; gravel_upper_x &lt;= 1 or not 0 &lt;= gravel_lower_y &lt; gravel_upper_y &lt;= 1:\n                raise ValueError(f\"Invalid gravel_roi. Got: {self.gravel_roi}.\")\n            return self\n\n    def __init__(\n        self,\n        gravel_roi: Tuple[float, float, float, float] = (0.1, 0.4, 0.9, 0.9),\n        number_of_patches: int = 2,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.gravel_roi = gravel_roi\n        self.number_of_patches = number_of_patches\n\n    def generate_gravel_patch(self, rectangular_roi: Tuple[int, int, int, int]) -&gt; np.ndarray:\n        x1, y1, x2, y2 = rectangular_roi\n        area = abs((x2 - x1) * (y2 - y1))\n        count = area // 10\n        gravels = np.empty([count, 2], dtype=np.int64)\n        gravels[:, 0] = random_utils.randint(x1, x2, count)\n        gravels[:, 1] = random_utils.randint(y1, y2, count)\n        return gravels\n\n    def apply(self, img: np.ndarray, gravels_infos: Optional[List[Any]] = None, **params: Any) -&gt; np.ndarray:\n        if gravels_infos is None:\n            gravels_infos = []\n        return F.add_gravel(img, gravels_infos)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, np.ndarray]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        x_min, y_min, x_max, y_max = self.gravel_roi\n        x_min = int(x_min * width)\n        x_max = int(x_max * width)\n        y_min = int(y_min * height)\n        y_max = int(y_max * height)\n\n        max_height = 200\n        max_width = 30\n\n        rectangular_rois = np.zeros([self.number_of_patches, 4], dtype=np.int64)\n        xx1 = random_utils.randint(x_min + 1, x_max, self.number_of_patches)  # xmax\n        xx2 = random_utils.randint(x_min, xx1)  # xmin\n        yy1 = random_utils.randint(y_min + 1, y_max, self.number_of_patches)  # ymax\n        yy2 = random_utils.randint(y_min, yy1)  # ymin\n\n        rectangular_rois[:, 0] = xx2\n        rectangular_rois[:, 1] = yy2\n        rectangular_rois[:, 2] = [min(tup) for tup in zip(xx1, xx2 + max_height)]\n        rectangular_rois[:, 3] = [min(tup) for tup in zip(yy1, yy2 + max_width)]\n\n        minx = []\n        maxx = []\n        miny = []\n        maxy = []\n        val = []\n        for roi in rectangular_rois:\n            gravels = self.generate_gravel_patch(roi)\n            x = gravels[:, 0]\n            y = gravels[:, 1]\n            r = random_utils.randint(1, 4, len(gravels))\n            sat = random_utils.randint(0, 255, len(gravels))\n            miny.append(np.maximum(y - r, 0))\n            maxy.append(np.minimum(y + r, y))\n            minx.append(np.maximum(x - r, 0))\n            maxx.append(np.minimum(x + r, x))\n            val.append(sat)\n\n        return {\n            \"gravels_infos\": np.stack(\n                [\n                    np.concatenate(miny),\n                    np.concatenate(maxy),\n                    np.concatenate(minx),\n                    np.concatenate(maxx),\n                    np.concatenate(val),\n                ],\n                1,\n            )\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return \"gravel_roi\", \"number_of_patches\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomGridShuffle","title":"<code>class  RandomGridShuffle</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Random shuffle grid's cells on image.</p> <p>Parameters:</p> Name Type Description <code>grid</code> <code>int, int</code> <p>size of grid for splitting image.</p> <p>Targets</p> <p>image, mask, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomGridShuffle(DualTransform):\n    \"\"\"Random shuffle grid's cells on image.\n\n    Args:\n        grid ((int, int)): size of grid for splitting image.\n\n    Targets:\n        image, mask, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        grid: OnePlusIntRangeType = (3, 3)\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS)\n\n    def __init__(self, grid: Tuple[int, int] = (3, 3), always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply=always_apply, p=p)\n        self.grid = grid\n\n    def apply(self, img: np.ndarray, tiles: np.ndarray, mapping: List[int], **params: Any) -&gt; np.ndarray:\n        return F.swap_tiles_on_image(img, tiles, mapping)\n\n    def apply_to_mask(self, mask: np.ndarray, tiles: np.ndarray, mapping: List[int], **params: Any) -&gt; np.ndarray:\n        return F.swap_tiles_on_image(mask, tiles, mapping)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        tiles: np.ndarray,\n        mapping: List[int],\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        x, y = keypoint[:2]\n\n        # Find which original tile the keypoint belongs to\n        for original_index, new_index in enumerate(mapping):\n            start_y, start_x, end_y, end_x = tiles[original_index]\n            # check if the keypoint is in this tile\n            if start_y &lt;= y &lt; end_y and start_x &lt;= x &lt; end_x:\n                # Get the new tile's coordinates\n                new_start_y, new_start_x = tiles[new_index][:2]\n\n                # Map the keypoint to the new tile's position\n                new_x = (x - start_x) + new_start_x\n                new_y = (y - start_y) + new_start_y\n\n                return (new_x, new_y, *keypoint[2:])\n\n        # If the keypoint wasn't in any tile (shouldn't happen), log a warning for debugging purposes\n        warn(\n            \"Keypoint not in any tile, returning it unchanged. This is unexpected and should be investigated.\",\n            RuntimeWarning,\n        )\n        return keypoint\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, weight = params[\"image\"].shape[:2]\n        # check if image size is divisible by grid\n        # if not, warn and return empty dict -&gt; no changes will be applied\n        if height % self.grid[0] != 0 or weight % self.grid[1] != 0:\n            warn(\"Image size must be divisible by grid size\")\n            return {\"tiles\": np.array([]), \"mapping\": []}\n        # Generate the original grid\n        original_tiles = F.split_uniform_grid((height, weight), self.grid)\n        # Shuffle order of tiles\n        mapping = random_utils.shuffle(list(range(len(original_tiles))))\n        return {\"tiles\": original_tiles, \"mapping\": mapping}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"grid\",)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomRain","title":"<code>class  RandomRain</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Adds rain effects.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>slant_lower</code> <p>should be in range [-20, 20].</p> <code>slant_upper</code> <p>should be in range [-20, 20].</p> <code>drop_length</code> <p>should be in range [0, 100].</p> <code>drop_width</code> <p>should be in range [1, 5].</p> <code>drop_color</code> <code>list of (r, g, b</code> <p>rain lines color.</p> <code>blur_value</code> <code>int</code> <p>rainy view are blurry</p> <code>brightness_coefficient</code> <code>float</code> <p>rainy days are usually shady. Should be in range [0, 1].</p> <code>rain_type</code> <p>One of [None, \"drizzle\", \"heavy\", \"torrential\"]</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomRain(ImageOnlyTransform):\n    \"\"\"Adds rain effects.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        slant_lower: should be in range [-20, 20].\n        slant_upper: should be in range [-20, 20].\n        drop_length: should be in range [0, 100].\n        drop_width: should be in range [1, 5].\n        drop_color (list of (r, g, b)): rain lines color.\n        blur_value (int): rainy view are blurry\n        brightness_coefficient (float): rainy days are usually shady. Should be in range [0, 1].\n        rain_type: One of [None, \"drizzle\", \"heavy\", \"torrential\"]\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        slant_lower: int = Field(default=-10, description=\"Lower bound for rain slant angle\", ge=-20, le=20)\n        slant_upper: int = Field(default=10, description=\"Upper bound for rain slant angle\", ge=-20, le=20)\n        drop_length: int = Field(default=20, description=\"Length of raindrops\", ge=0, le=100)\n        drop_width: int = Field(default=1, description=\"Width of raindrops\", ge=1, le=5)\n        drop_color: Tuple[int, int, int] = Field(default=(200, 200, 200), description=\"Color of raindrops\")\n        blur_value: int = Field(default=7, description=\"Blur value for simulating rain effect\", ge=0)\n        brightness_coefficient: float = Field(\n            default=0.7, description=\"Brightness coefficient for rainy effect\", ge=0, le=1\n        )\n        rain_type: Optional[RainMode] = Field(default=None, description=\"Type of rain to simulate\")\n\n        @model_validator(mode=\"after\")\n        def validate_slant_range_and_rain_type(self) -&gt; Self:\n            if self.slant_lower &gt;= self.slant_upper:\n                msg = \"slant_upper must be greater than or equal to slant_lower.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        slant_lower: int = -10,\n        slant_upper: int = 10,\n        drop_length: int = 20,\n        drop_width: int = 1,\n        drop_color: Tuple[int, int, int] = (200, 200, 200),\n        blur_value: int = 7,\n        brightness_coefficient: float = 0.7,\n        rain_type: Optional[RainMode] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.slant_lower = slant_lower\n        self.slant_upper = slant_upper\n        self.drop_length = drop_length\n        self.drop_width = drop_width\n        self.drop_color = drop_color\n        self.blur_value = blur_value\n        self.brightness_coefficient = brightness_coefficient\n        self.rain_type = rain_type\n\n    def apply(\n        self,\n        img: np.ndarray,\n        slant: int = 10,\n        drop_length: int = 20,\n        rain_drops: Optional[List[Tuple[int, int]]] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if rain_drops is None:\n            rain_drops = []\n        return F.add_rain(\n            img,\n            slant,\n            drop_length,\n            self.drop_width,\n            self.drop_color,\n            self.blur_value,\n            self.brightness_coefficient,\n            rain_drops,\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        slant = int(random.uniform(self.slant_lower, self.slant_upper))\n\n        height, width = img.shape[:2]\n        area = height * width\n\n        if self.rain_type == \"drizzle\":\n            num_drops = area // 770\n            drop_length = 10\n        elif self.rain_type == \"heavy\":\n            num_drops = width * height // 600\n            drop_length = 30\n        elif self.rain_type == \"torrential\":\n            num_drops = area // 500\n            drop_length = 60\n        else:\n            drop_length = self.drop_length\n            num_drops = area // 600\n\n        rain_drops = []\n\n        for _ in range(num_drops):  # If You want heavy rain, try increasing this\n            x = random_utils.randint(slant, width + 1) if slant &lt; 0 else random_utils.randint(0, width - slant + 1)\n\n            y = random_utils.randint(0, height - drop_length + 1)\n\n            rain_drops.append((x, y))\n\n        return {\"drop_length\": drop_length, \"slant\": slant, \"rain_drops\": rain_drops}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"slant_lower\",\n            \"slant_upper\",\n            \"drop_length\",\n            \"drop_width\",\n            \"drop_color\",\n            \"blur_value\",\n            \"brightness_coefficient\",\n            \"rain_type\",\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomShadow","title":"<code>class  RandomShadow</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Simulates shadows for the image</p> <p>Parameters:</p> Name Type Description <code>shadow_roi</code> <p>region of the image where shadows will appear. All values should be in range [0, 1].</p> <code>num_shadows_limit</code> <p>Lower and upper limits for the possible number of shadows.</p> <code>shadow_dimension</code> <p>number of edges in the shadow polygons</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomShadow(ImageOnlyTransform):\n    \"\"\"Simulates shadows for the image\n\n    Args:\n        shadow_roi: region of the image where shadows\n            will appear. All values should be in range [0, 1].\n        num_shadows_limit: Lower and upper limits for the possible number of shadows.\n        shadow_dimension: number of edges in the shadow polygons\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        shadow_roi: Tuple[float, float, float, float] = Field(\n            default=(0, 0.5, 1, 1), description=\"Region of the image where shadows will appear\"\n        )\n        num_shadows_limit: Tuple[int, int] = Field(default=(1, 2))\n        num_shadows_lower: Optional[int] = Field(\n            default=None, description=\"Lower limit for the possible number of shadows\"\n        )\n        num_shadows_upper: Optional[int] = Field(\n            default=None, description=\"Upper limit for the possible number of shadows\"\n        )\n        shadow_dimension: int = Field(default=5, description=\"Number of edges in the shadow polygons\", gt=0)\n\n        @model_validator(mode=\"after\")\n        def validate_shadows(self) -&gt; Self:\n            if self.num_shadows_limit[0] &gt; self.num_shadows_limit[1]:\n                msg = \"num_shadows_limit[0] must be less than or equal to num_shadows_limit[1].\"\n                raise ValueError(msg)\n\n            shadow_lower_x, shadow_lower_y, shadow_upper_x, shadow_upper_y = self.shadow_roi\n\n            if not 0 &lt;= shadow_lower_x &lt;= shadow_upper_x &lt;= 1 or not 0 &lt;= shadow_lower_y &lt;= shadow_upper_y &lt;= 1:\n                raise ValueError(f\"Invalid shadow_roi. Got: {self.shadow_roi}\")\n\n            if self.num_shadows_lower is not None or self.num_shadows_upper is not None:\n                warn(\n                    \"`num_shadows_lower` and `num_shadows_upper` are deprecated. \"\n                    \"Use `num_shadows_limit` as tuple (num_shadows_lower, num_shadows_upper) instead.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n                self.num_shadows_limit = cast(Tuple[int, int], (self.num_shadows_lower, self.num_shadows_upper))\n                self.num_shadows_lower = None\n                self.num_shadows_upper = None\n\n            return self\n\n    def __init__(\n        self,\n        shadow_roi: Tuple[float, float, float, float] = (0, 0.5, 1, 1),\n        num_shadows_limit: Tuple[int, int] = (1, 2),\n        num_shadows_lower: Optional[int] = None,\n        num_shadows_upper: Optional[int] = None,\n        shadow_dimension: int = 5,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        self.shadow_roi = shadow_roi\n        self.shadow_dimension = shadow_dimension\n        self.num_shadows_limit = num_shadows_limit\n\n    def apply(self, img: np.ndarray, vertices_list: Optional[List[np.ndarray]] = None, **params: Any) -&gt; np.ndarray:\n        if vertices_list is None:\n            vertices_list = []\n        return F.add_shadow(img, vertices_list)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, List[np.ndarray]]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        num_shadows = random_utils.randint(self.num_shadows_limit[0], self.num_shadows_limit[1] + 1)\n\n        x_min, y_min, x_max, y_max = self.shadow_roi\n\n        x_min = int(x_min * width)\n        x_max = int(x_max * width)\n        y_min = int(y_min * height)\n        y_max = int(y_max * height)\n\n        vertices_list = [\n            np.stack(\n                [\n                    random_utils.randint(x_min, x_max, size=5),\n                    random_utils.randint(y_min, y_max, size=5),\n                ],\n                axis=1,\n            )\n            for _ in range(num_shadows)\n        ]\n\n        return {\"vertices_list\": vertices_list}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"shadow_roi\",\n            \"num_shadows_limit\",\n            \"shadow_dimension\",\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomSnow","title":"<code>class  RandomSnow</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Bleach out some pixel values simulating snow.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>snow_point_lower</code> <p>lower_bond of the amount of snow. Should be in [0, 1] range</p> <code>snow_point_upper</code> <p>upper_bond of the amount of snow. Should be in [0, 1] range</p> <code>brightness_coeff</code> <p>larger number will lead to a more snow on the image. Should be &gt;= 0</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomSnow(ImageOnlyTransform):\n    \"\"\"Bleach out some pixel values simulating snow.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        snow_point_lower: lower_bond of the amount of snow. Should be in [0, 1] range\n        snow_point_upper: upper_bond of the amount of snow. Should be in [0, 1] range\n        brightness_coeff: larger number will lead to a more snow on the image. Should be &gt;= 0\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        snow_point_lower: float = Field(default=0.1, description=\"Lower bound of the amount of snow\", ge=0, le=1)\n        snow_point_upper: float = Field(default=0.3, description=\"Upper bound of the amount of snow\", ge=0, le=1)\n        brightness_coeff: float = Field(default=2.5, description=\"Brightness coefficient, must be &gt;= 0\", ge=0)\n\n        @model_validator(mode=\"after\")\n        def validate_snow_points(self) -&gt; Self:\n            if self.snow_point_lower &gt; self.snow_point_upper:\n                msg = \"snow_point_lower must be less than or equal to snow_point_upper.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        snow_point_lower: float = 0.1,\n        snow_point_upper: float = 0.3,\n        brightness_coeff: float = 2.5,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        self.snow_point_lower = snow_point_lower\n        self.snow_point_upper = snow_point_upper\n        self.brightness_coeff = brightness_coeff\n\n    def apply(self, img: np.ndarray, snow_point: float = 0.1, **params: Any) -&gt; np.ndarray:\n        return F.add_snow(img, snow_point, self.brightness_coeff)\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        return {\"snow_point\": random.uniform(self.snow_point_lower, self.snow_point_upper)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"snow_point_lower\", \"snow_point_upper\", \"brightness_coeff\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomSunFlare","title":"<code>class  RandomSunFlare</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Simulates Sun Flare for the image</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>flare_roi</code> <p>region of the image where flare will appear (x_min, y_min, x_max, y_max). All values should be in range [0, 1].</p> <code>angle_lower</code> <p>should be in range [0, <code>angle_upper</code>].</p> <code>angle_upper</code> <p>should be in range [<code>angle_lower</code>, 1].</p> <code>num_flare_circles_lower</code> <p>lower limit for the number of flare circles. Should be in range [0, <code>num_flare_circles_upper</code>].</p> <code>num_flare_circles_upper</code> <p>upper limit for the number of flare circles. Should be in range [<code>num_flare_circles_lower</code>, inf].</p> <code>src_radius</code> <code>src_color</code> <p>color of the flare</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomSunFlare(ImageOnlyTransform):\n    \"\"\"Simulates Sun Flare for the image\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        flare_roi: region of the image where flare will appear (x_min, y_min, x_max, y_max).\n            All values should be in range [0, 1].\n        angle_lower: should be in range [0, `angle_upper`].\n        angle_upper: should be in range [`angle_lower`, 1].\n        num_flare_circles_lower: lower limit for the number of flare circles.\n            Should be in range [0, `num_flare_circles_upper`].\n        num_flare_circles_upper: upper limit for the number of flare circles.\n            Should be in range [`num_flare_circles_lower`, inf].\n        src_radius:\n        src_color: color of the flare\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        flare_roi: Tuple[float, float, float, float] = Field(\n            default=(0, 0, 1, 0.5), description=\"Region of the image where flare will appear\"\n        )\n        angle_lower: float = Field(default=0, description=\"Lower bound for the angle\", ge=0, le=1)\n        angle_upper: float = Field(default=1, description=\"Upper bound for the angle\", ge=0, le=1)\n        num_flare_circles_lower: int = Field(default=6, description=\"Lower limit for the number of flare circles\", ge=0)\n        num_flare_circles_upper: int = Field(\n            default=10, description=\"Upper limit for the number of flare circles\", gt=0\n        )\n        src_radius: int = Field(default=400, description=\"Source radius for the flare\")\n        src_color: Tuple[int, int, int] = Field(default=(255, 255, 255), description=\"Color of the flare\")\n\n        @model_validator(mode=\"after\")\n        def validate_parameters(self) -&gt; Self:\n            flare_center_lower_x, flare_center_lower_y, flare_center_upper_x, flare_center_upper_y = self.flare_roi\n            if (\n                not 0 &lt;= flare_center_lower_x &lt; flare_center_upper_x &lt;= 1\n                or not 0 &lt;= flare_center_lower_y &lt; flare_center_upper_y &lt;= 1\n            ):\n                raise ValueError(f\"Invalid flare_roi. Got: {self.flare_roi}\")\n            if self.angle_lower &gt;= self.angle_upper:\n                raise ValueError(\n                    f\"angle_upper must be greater than angle_lower. Got: {self.angle_lower}, {self.angle_upper}\"\n                )\n            if self.num_flare_circles_lower &gt;= self.num_flare_circles_upper:\n                msg = \"num_flare_circles_upper must be greater than num_flare_circles_lower.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        flare_roi: Tuple[float, float, float, float] = (0, 0, 1, 0.5),\n        angle_lower: float = 0,\n        angle_upper: float = 1,\n        num_flare_circles_lower: int = 6,\n        num_flare_circles_upper: int = 10,\n        src_radius: int = 400,\n        src_color: Tuple[int, int, int] = (255, 255, 255),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        self.angle_lower = angle_lower\n        self.angle_upper = angle_upper\n        self.num_flare_circles_lower = num_flare_circles_lower\n        self.num_flare_circles_upper = num_flare_circles_upper\n        self.src_radius = src_radius\n        self.src_color = src_color\n        self.flare_roi = flare_roi\n\n    def apply(\n        self,\n        img: np.ndarray,\n        flare_center_x: float = 0.5,\n        flare_center_y: float = 0.5,\n        circles: Optional[List[Any]] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if circles is None:\n            circles = []\n        return F.add_sun_flare(\n            img,\n            flare_center_x,\n            flare_center_y,\n            self.src_radius,\n            self.src_color,\n            circles,\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        angle = 2 * math.pi * random.uniform(self.angle_lower, self.angle_upper)\n\n        (flare_center_lower_x, flare_center_lower_y, flare_center_upper_x, flare_center_upper_y) = self.flare_roi\n\n        flare_center_x = random.uniform(flare_center_lower_x, flare_center_upper_x)\n        flare_center_y = random.uniform(flare_center_lower_y, flare_center_upper_y)\n\n        flare_center_x = int(width * flare_center_x)\n        flare_center_y = int(height * flare_center_y)\n\n        num_circles = random_utils.randint(self.num_flare_circles_lower, self.num_flare_circles_upper + 1)\n\n        circles = []\n\n        x = []\n        y = []\n\n        def line(t: float) -&gt; Tuple[float, float]:\n            return (flare_center_x + t * math.cos(angle), flare_center_y + t * math.sin(angle))\n\n        for t_val in range(-flare_center_x, width - flare_center_x, 10):\n            rand_x, rand_y = line(t_val)\n            x.append(rand_x)\n            y.append(rand_y)\n\n        for _ in range(num_circles):\n            alpha = random_utils.uniform(0.05, 0.2)\n            r = random_utils.randint(0, len(x))\n            rad = random.randint(1, max(height // 100 - 2, 2))\n\n            r_color = random.randint(max(self.src_color[0] - 50, 0), self.src_color[0])\n            g_color = random.randint(max(self.src_color[1] - 50, 0), self.src_color[1])\n            b_color = random.randint(max(self.src_color[2] - 50, 0), self.src_color[2])\n\n            circles += [\n                (\n                    alpha,\n                    (int(x[r]), int(y[r])),\n                    pow(rad, 3),\n                    (r_color, g_color, b_color),\n                )\n            ]\n\n        return {\n            \"circles\": circles,\n            \"flare_center_x\": flare_center_x,\n            \"flare_center_y\": flare_center_y,\n        }\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\n            \"flare_roi\": self.flare_roi,\n            \"angle_lower\": self.angle_lower,\n            \"angle_upper\": self.angle_upper,\n            \"num_flare_circles_lower\": self.num_flare_circles_lower,\n            \"num_flare_circles_upper\": self.num_flare_circles_upper,\n            \"src_radius\": self.src_radius,\n            \"src_color\": self.src_color,\n        }\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RandomToneCurve","title":"<code>class  RandomToneCurve</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly change the relationship between bright and dark areas of the image by manipulating its tone curve.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <p>standard deviation of the normal distribution. Used to sample random distances to move two control points that modify the image's curve. Values should be in range [0, 1]. Default: 0.1</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomToneCurve(ImageOnlyTransform):\n    \"\"\"Randomly change the relationship between bright and dark areas of the image by manipulating its tone curve.\n\n    Args:\n        scale: standard deviation of the normal distribution.\n            Used to sample random distances to move two control points that modify the image's curve.\n            Values should be in range [0, 1]. Default: 0.1\n\n    Targets:\n        image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: float = Field(\n            default=0.1,\n            description=\"Standard deviation of the normal distribution used to sample random distances\",\n            ge=0,\n            le=1,\n        )\n\n    def __init__(\n        self,\n        scale: float = 0.1,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.scale = scale\n\n    def apply(self, img: np.ndarray, low_y: float, high_y: float, **params: Any) -&gt; np.ndarray:\n        return F.move_tone_curve(img, low_y, high_y)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"low_y\": np.clip(random_utils.normal(loc=0.25, scale=self.scale), 0, 1),\n            \"high_y\": np.clip(random_utils.normal(loc=0.75, scale=self.scale), 0, 1),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"scale\",)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.RingingOvershoot","title":"<code>class  RingingOvershoot</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Create ringing or overshoot artefacts by conlvolving image with 2D sinc filter.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <p>maximum kernel size for sinc filter. Should be in range [3, inf). Default: (7, 15).</p> <code>cutoff</code> <p>range to choose the cutoff frequency in radians. Should be in range (0, np.pi) Default: (np.pi / 4, np.pi / 2).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Reference</p> <p>dsp.stackexchange.com/questions/58301/2-d-circularly-symmetric-low-pass-filter https://arxiv.org/abs/2107.10833</p> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RingingOvershoot(ImageOnlyTransform):\n    \"\"\"Create ringing or overshoot artefacts by conlvolving image with 2D sinc filter.\n\n    Args:\n        blur_limit: maximum kernel size for sinc filter.\n            Should be in range [3, inf). Default: (7, 15).\n        cutoff: range to choose the cutoff frequency in radians.\n            Should be in range (0, np.pi)\n            Default: (np.pi / 4, np.pi / 2).\n        p: probability of applying the transform. Default: 0.5.\n\n    Reference:\n        dsp.stackexchange.com/questions/58301/2-d-circularly-symmetric-low-pass-filter\n        https://arxiv.org/abs/2107.10833\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BlurInitSchema):\n        blur_limit: ScaleIntType = Field(default=(7, 15), description=\"Maximum kernel size for sinc filter.\")\n        cutoff: ScaleFloatType = Field(default=(np.pi / 4, np.pi / 2), description=\"Cutoff frequency range in radians.\")\n\n        @field_validator(\"cutoff\")\n        @classmethod\n        def check_cutoff(cls, v: ScaleFloatType, info: ValidationInfo) -&gt; Tuple[float, float]:\n            bounds = 0, np.pi\n            result = to_tuple(v, v)\n            check_range(result, *bounds, info.field_name)\n            return result\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = (7, 15),\n        cutoff: ScaleFloatType = (np.pi / 4, np.pi / 2),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n        self.cutoff = cast(Tuple[float, float], cutoff)\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        ksize = random.randrange(self.blur_limit[0], self.blur_limit[1] + 1, 2)\n        if ksize % 2 == 0:\n            raise ValueError(f\"Kernel size must be odd. Got: {ksize}\")\n\n        cutoff = random.uniform(*self.cutoff)\n\n        # From dsp.stackexchange.com/questions/58301/2-d-circularly-symmetric-low-pass-filter\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            kernel = np.fromfunction(\n                lambda x, y: cutoff\n                * special.j1(cutoff * np.sqrt((x - (ksize - 1) / 2) ** 2 + (y - (ksize - 1) / 2) ** 2))\n                / (2 * np.pi * np.sqrt((x - (ksize - 1) / 2) ** 2 + (y - (ksize - 1) / 2) ** 2)),\n                [ksize, ksize],\n            )\n        kernel[(ksize - 1) // 2, (ksize - 1) // 2] = cutoff**2 / (4 * np.pi)\n\n        # Normalize kernel\n        kernel = kernel.astype(np.float32) / np.sum(kernel)\n\n        return {\"kernel\": kernel}\n\n    def apply(self, img: np.ndarray, kernel: Optional[int] = None, **params: Any) -&gt; np.ndarray:\n        return F.convolve(img, kernel)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"blur_limit\", \"cutoff\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Sharpen","title":"<code>class  Sharpen</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Sharpen the input image and overlays the result with the original image.</p> <p>Parameters:</p> Name Type Description <code>alpha</code> <p>range to choose the visibility of the sharpened image. At 0, only the original image is visible, at 1.0 only its sharpened version is visible. Default: (0.2, 0.5).</p> <code>lightness</code> <p>range to choose the lightness of the sharpened image. Default: (0.5, 1.0).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Sharpen(ImageOnlyTransform):\n    \"\"\"Sharpen the input image and overlays the result with the original image.\n\n    Args:\n        alpha: range to choose the visibility of the sharpened image. At 0, only the original image is\n            visible, at 1.0 only its sharpened version is visible. Default: (0.2, 0.5).\n        lightness: range to choose the lightness of the sharpened image. Default: (0.5, 1.0).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        alpha: ZeroOneRangeType = (0.2, 0.5)\n        lightness: NonNegativeFloatRangeType = (0.5, 1.0)\n\n    def __init__(\n        self,\n        alpha: Tuple[float, float] = (0.2, 0.5),\n        lightness: Tuple[float, float] = (0.5, 1.0),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.alpha = alpha\n        self.lightness = lightness\n\n    @staticmethod\n    def __generate_sharpening_matrix(alpha_sample: np.ndarray, lightness_sample: np.ndarray) -&gt; np.ndarray:\n        matrix_nochange = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]], dtype=np.float32)\n        matrix_effect = np.array(\n            [[-1, -1, -1], [-1, 8 + lightness_sample, -1], [-1, -1, -1]],\n            dtype=np.float32,\n        )\n\n        return (1 - alpha_sample) * matrix_nochange + alpha_sample * matrix_effect\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        alpha = random.uniform(*self.alpha)\n        lightness = random.uniform(*self.lightness)\n        sharpening_matrix = self.__generate_sharpening_matrix(alpha_sample=alpha, lightness_sample=lightness)\n        return {\"sharpening_matrix\": sharpening_matrix}\n\n    def apply(self, img: np.ndarray, sharpening_matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.convolve(img, sharpening_matrix)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"alpha\", \"lightness\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Solarize","title":"<code>class  Solarize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Invert all pixel values above a threshold.</p> <p>Parameters:</p> Name Type Description <code>threshold</code> <p>range for solarizing threshold. If threshold is a single value, the range will be [1, threshold]. Default: 128.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     any</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Solarize(ImageOnlyTransform):\n    \"\"\"Invert all pixel values above a threshold.\n\n    Args:\n        threshold: range for solarizing threshold.\n            If threshold is a single value, the range will be [1, threshold]. Default: 128.\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        any\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        threshold: OnePlusFloatRangeType = (128, 128)\n\n    def __init__(self, threshold: ScaleType = (128, 128), always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply=always_apply, p=p)\n        self.threshold = cast(Tuple[float, float], threshold)\n\n    def apply(self, img: np.ndarray, threshold: int = 0, **params: Any) -&gt; np.ndarray:\n        return F.solarize(img, threshold)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"threshold\": random.uniform(self.threshold[0], self.threshold[1])}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"threshold\",)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Spatter","title":"<code>class  Spatter</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply spatter transform. It simulates corruption which can occlude a lens in the form of rain or mud.</p> <p>Parameters:</p> Name Type Description <code>mean</code> <code>float, or tuple of floats</code> <p>Mean value of normal distribution for generating liquid layer. If single float mean will be sampled from <code>(0, mean)</code> If tuple of float mean will be sampled from range <code>(mean[0], mean[1])</code>. If you want constant value use (mean, mean). Default (0.65, 0.65)</p> <code>std</code> <code>float, or tuple of floats</code> <p>Standard deviation value of normal distribution for generating liquid layer. If single float the number will be sampled from <code>(0, std)</code>. If tuple of float std will be sampled from range <code>(std[0], std[1])</code>. If you want constant value use (std, std). Default: (0.3, 0.3).</p> <code>gauss_sigma</code> <code>float, or tuple of floats</code> <p>Sigma value for gaussian filtering of liquid layer. If single float the number will be sampled from <code>(0, gauss_sigma)</code>. If tuple of float gauss_sigma will be sampled from range <code>(gauss_sigma[0], gauss_sigma[1])</code>. If you want constant value use (gauss_sigma, gauss_sigma). Default: (2, 3).</p> <code>cutout_threshold</code> <code>float, or tuple of floats</code> <p>Threshold for filtering liqued layer (determines number of drops). If single float it will used as cutout_threshold. If single float the number will be sampled from <code>(0, cutout_threshold)</code>. If tuple of float cutout_threshold will be sampled from range <code>(cutout_threshold[0], cutout_threshold[1])</code>. If you want constant value use <code>(cutout_threshold, cutout_threshold)</code>. Default: (0.68, 0.68).</p> <code>intensity</code> <code>float, or tuple of floats</code> <p>Intensity of corruption. If single float the number will be sampled from <code>(0, intensity)</code>. If tuple of float intensity will be sampled from range <code>(intensity[0], intensity[1])</code>. If you want constant value use <code>(intensity, intensity)</code>. Default: (0.6, 0.6).</p> <code>mode</code> <code>string, or list of strings</code> <p>Type of corruption. Currently, supported options are 'rain' and 'mud'.  If list is provided type of corruption will be sampled list. Default: (\"rain\").</p> <code>color</code> <code>list of (r, g, b) or dict or None</code> <p>Corruption elements color. If list uses provided list as color for specified mode. If dict uses provided color for specified mode. Color for each specified mode should be provided in dict. If None uses default colors (rain: (238, 238, 175), mud: (20, 42, 63)).</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1903.12261 https://github.com/hendrycks/robustness/blob/master/ImageNet-C/create_c/make_imagenet_c.py</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Spatter(ImageOnlyTransform):\n    \"\"\"Apply spatter transform. It simulates corruption which can occlude a lens in the form of rain or mud.\n\n    Args:\n        mean (float, or tuple of floats): Mean value of normal distribution for generating liquid layer.\n            If single float mean will be sampled from `(0, mean)`\n            If tuple of float mean will be sampled from range `(mean[0], mean[1])`.\n            If you want constant value use (mean, mean).\n            Default (0.65, 0.65)\n        std (float, or tuple of floats): Standard deviation value of normal distribution for generating liquid layer.\n            If single float the number will be sampled from `(0, std)`.\n            If tuple of float std will be sampled from range `(std[0], std[1])`.\n            If you want constant value use (std, std).\n            Default: (0.3, 0.3).\n        gauss_sigma (float, or tuple of floats): Sigma value for gaussian filtering of liquid layer.\n            If single float the number will be sampled from `(0, gauss_sigma)`.\n            If tuple of float gauss_sigma will be sampled from range `(gauss_sigma[0], gauss_sigma[1])`.\n            If you want constant value use (gauss_sigma, gauss_sigma).\n            Default: (2, 3).\n        cutout_threshold (float, or tuple of floats): Threshold for filtering liqued layer\n            (determines number of drops). If single float it will used as cutout_threshold.\n            If single float the number will be sampled from `(0, cutout_threshold)`.\n            If tuple of float cutout_threshold will be sampled from range `(cutout_threshold[0], cutout_threshold[1])`.\n            If you want constant value use `(cutout_threshold, cutout_threshold)`.\n            Default: (0.68, 0.68).\n        intensity (float, or tuple of floats): Intensity of corruption.\n            If single float the number will be sampled from `(0, intensity)`.\n            If tuple of float intensity will be sampled from range `(intensity[0], intensity[1])`.\n            If you want constant value use `(intensity, intensity)`.\n            Default: (0.6, 0.6).\n        mode (string, or list of strings): Type of corruption. Currently, supported options are 'rain' and 'mud'.\n             If list is provided type of corruption will be sampled list. Default: (\"rain\").\n        color (list of (r, g, b) or dict or None): Corruption elements color.\n            If list uses provided list as color for specified mode.\n            If dict uses provided color for specified mode. Color for each specified mode should be provided in dict.\n            If None uses default colors (rain: (238, 238, 175), mud: (20, 42, 63)).\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://arxiv.org/abs/1903.12261\n        https://github.com/hendrycks/robustness/blob/master/ImageNet-C/create_c/make_imagenet_c.py\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        mean: ZeroOneRangeType = (0.65, 0.65)\n        std: ZeroOneRangeType = (0.3, 0.3)\n        gauss_sigma: NonNegativeFloatRangeType = (2, 2)\n        cutout_threshold: ZeroOneRangeType = (0.68, 0.68)\n        intensity: ZeroOneRangeType = (0.6, 0.6)\n        mode: Union[SpatterMode, Sequence[SpatterMode]] = Field(\n            default=\"rain\", description=\"Type of corruption ('rain', 'mud').\"\n        )\n        color: Optional[Union[Sequence[int], Dict[str, Sequence[int]]]] = None\n\n        @field_validator(\"mode\")\n        @classmethod\n        def check_mode(cls, mode: Union[SpatterMode, Sequence[SpatterMode]]) -&gt; Sequence[SpatterMode]:\n            if isinstance(mode, str):\n                return [mode]\n            return mode\n\n        @model_validator(mode=\"after\")\n        def check_color(self) -&gt; Self:\n            if self.color is None:\n                self.color = {\"rain\": [238, 238, 175], \"mud\": [20, 42, 63]}\n\n            elif isinstance(self.color, (list, tuple)) and len(self.mode) == 1:\n                if len(self.color) != NUM_RGB_CHANNELS:\n                    msg = \"Color must be a list of three integers for RGB format.\"\n                    raise ValueError(msg)\n                self.color = {self.mode[0]: self.color}\n            elif isinstance(self.color, dict):\n                result = {}\n                for mode in self.mode:\n                    if mode not in self.color:\n                        raise ValueError(f\"Color for mode {mode} is not specified.\")\n                    if len(self.color[mode]) != NUM_RGB_CHANNELS:\n                        raise ValueError(f\"Color for mode {mode} must be in RGB format.\")\n                    result[mode] = self.color[mode]\n            else:\n                msg = \"Color must be a list of RGB values or a dict mapping mode to RGB values.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        mean: ScaleFloatType = (0.65, 0.65),\n        std: ScaleFloatType = (0.3, 0.3),\n        gauss_sigma: ScaleFloatType = (2, 2),\n        cutout_threshold: ScaleFloatType = (0.68, 0.68),\n        intensity: ScaleFloatType = (0.6, 0.6),\n        mode: Union[SpatterMode, Sequence[SpatterMode]] = \"rain\",\n        color: Optional[Union[Sequence[int], Dict[str, Sequence[int]]]] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.mean = cast(Tuple[float, float], mean)\n        self.std = cast(Tuple[float, float], std)\n        self.gauss_sigma = cast(Tuple[float, float], gauss_sigma)\n        self.cutout_threshold = cast(Tuple[float, float], cutout_threshold)\n        self.intensity = cast(Tuple[float, float], intensity)\n        self.mode = mode\n        self.color = cast(Dict[str, Sequence[int]], color)\n\n    def apply(\n        self,\n        img: np.ndarray,\n        non_mud: Optional[np.ndarray] = None,\n        mud: Optional[np.ndarray] = None,\n        drops: Optional[np.ndarray] = None,\n        mode: SpatterMode = \"mud\",\n        **params: Dict[str, Any],\n    ) -&gt; np.ndarray:\n        return F.spatter(img, non_mud, mud, drops, mode)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        mean = random.uniform(self.mean[0], self.mean[1])\n        std = random.uniform(self.std[0], self.std[1])\n        cutout_threshold = random.uniform(self.cutout_threshold[0], self.cutout_threshold[1])\n        sigma = random.uniform(self.gauss_sigma[0], self.gauss_sigma[1])\n        mode = random.choice(self.mode)\n        intensity = random.uniform(self.intensity[0], self.intensity[1])\n        color = np.array(self.color[mode]) / 255.0\n\n        liquid_layer = random_utils.normal(size=(height, width), loc=mean, scale=std)\n        liquid_layer = gaussian_filter(liquid_layer, sigma=sigma, mode=\"nearest\")\n        liquid_layer[liquid_layer &lt; cutout_threshold] = 0\n\n        if mode == \"rain\":\n            liquid_layer = (liquid_layer * 255).astype(np.uint8)\n            dist = 255 - cv2.Canny(liquid_layer, 50, 150)\n            dist = cv2.distanceTransform(dist, cv2.DIST_L2, 5)\n            _, dist = cv2.threshold(dist, 20, 20, cv2.THRESH_TRUNC)\n            dist = blur(dist, 3).astype(np.uint8)\n            dist = F.equalize(dist)\n\n            ker = np.array([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]])\n            dist = F.convolve(dist, ker)\n            dist = blur(dist, 3).astype(np.float32)\n\n            m = liquid_layer * dist\n            m *= 1 / np.max(m, axis=(0, 1))\n\n            drops = m[:, :, None] * color * intensity\n            mud = None\n            non_mud = None\n        else:\n            m = np.where(liquid_layer &gt; cutout_threshold, 1, 0)\n            m = gaussian_filter(m.astype(np.float32), sigma=sigma, mode=\"nearest\")\n            m[m &lt; 1.2 * cutout_threshold] = 0\n            m = m[..., np.newaxis]\n\n            mud = m * color\n            non_mud = 1 - m\n            drops = None\n\n        return {\n            \"non_mud\": non_mud,\n            \"mud\": mud,\n            \"drops\": drops,\n            \"mode\": mode,\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str, str, str, str]:\n        return \"mean\", \"std\", \"gauss_sigma\", \"intensity\", \"cutout_threshold\", \"mode\", \"color\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.Superpixels","title":"<code>class  Superpixels</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Transform images partially/completely to their superpixel representation. This implementation uses skimage's version of the SLIC algorithm.</p> <p>Parameters:</p> Name Type Description <code>p_replace</code> <code>float or tuple of float</code> <p>Defines for any segment the probability that the pixels within that segment are replaced by their average color (otherwise, the pixels are not changed).</p> <p>Examples:</p> <ul> <li>A probability of <code>0.0</code> would mean, that the pixels in no   segment are replaced by their average color (image is not   changed at all).</li> <li>A probability of <code>0.5</code> would mean, that around half of all   segments are replaced by their average color.</li> <li>A probability of <code>1.0</code> would mean, that all segments are   replaced by their average color (resulting in a voronoi   image).</li> </ul> <pre><code>    Behaviour based on chosen data types for this parameter:\n        * If a ``float``, then that ``flat`` will always be used.\n        * If ``tuple`` ``(a, b)``, then a random probability will be\n          sampled from the interval ``[a, b]`` per image.\nn_segments (tuple of int): Rough target number of how many superpixels to generate (the algorithm\n    may deviate from this number). Lower value will lead to coarser superpixels.\n    Higher values are computationally more intensive and will hence lead to a slowdown\n    Then a value from the discrete interval ``[a..b]`` will be sampled per image.\n    If input is a single integer, the range will be ``(1, n_segments)``.\n    If interested in a fixed number of segments, use ``(n_segments, n_segments)``.\nmax_size (int or None): Maximum image size at which the augmentation is performed.\n    If the width or height of an image exceeds this value, it will be\n    downscaled before the augmentation so that the longest side matches `max_size`.\n    This is done to speed up the process. The final output image has the same size as the input image.\n    Note that in case `p_replace` is below ``1.0``,\n    the down-/upscaling will affect the not-replaced pixels too.\n    Use ``None`` to apply no down-/upscaling.\ninterpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n    cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n    Default: cv2.INTER_LINEAR.\np (float): probability of applying the transform. Default: 0.5.\n</code></pre> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Superpixels(ImageOnlyTransform):\n    \"\"\"Transform images partially/completely to their superpixel representation.\n    This implementation uses skimage's version of the SLIC algorithm.\n\n    Args:\n        p_replace (float or tuple of float): Defines for any segment the probability that the pixels within that\n            segment are replaced by their average color (otherwise, the pixels are not changed).\n\n    Examples:\n                * A probability of ``0.0`` would mean, that the pixels in no\n                  segment are replaced by their average color (image is not\n                  changed at all).\n                * A probability of ``0.5`` would mean, that around half of all\n                  segments are replaced by their average color.\n                * A probability of ``1.0`` would mean, that all segments are\n                  replaced by their average color (resulting in a voronoi\n                  image).\n            Behaviour based on chosen data types for this parameter:\n                * If a ``float``, then that ``flat`` will always be used.\n                * If ``tuple`` ``(a, b)``, then a random probability will be\n                  sampled from the interval ``[a, b]`` per image.\n        n_segments (tuple of int): Rough target number of how many superpixels to generate (the algorithm\n            may deviate from this number). Lower value will lead to coarser superpixels.\n            Higher values are computationally more intensive and will hence lead to a slowdown\n            Then a value from the discrete interval ``[a..b]`` will be sampled per image.\n            If input is a single integer, the range will be ``(1, n_segments)``.\n            If interested in a fixed number of segments, use ``(n_segments, n_segments)``.\n        max_size (int or None): Maximum image size at which the augmentation is performed.\n            If the width or height of an image exceeds this value, it will be\n            downscaled before the augmentation so that the longest side matches `max_size`.\n            This is done to speed up the process. The final output image has the same size as the input image.\n            Note that in case `p_replace` is below ``1.0``,\n            the down-/upscaling will affect the not-replaced pixels too.\n            Use ``None`` to apply no down-/upscaling.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        p_replace: ZeroOneRangeType = (0, 0.1)\n        n_segments: OnePlusIntRangeType = (100, 100)\n        max_size: Optional[int] = Field(default=128, ge=1, description=\"Maximum image size for the transformation.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n    def __init__(\n        self,\n        p_replace: ScaleFloatType = (0, 0.1),\n        n_segments: ScaleIntType = (100, 100),\n        max_size: Optional[int] = 128,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.p_replace = cast(Tuple[float, float], p_replace)\n        self.n_segments = cast(Tuple[int, int], n_segments)\n        self.max_size = max_size\n        self.interpolation = interpolation\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"p_replace\", \"n_segments\", \"max_size\", \"interpolation\")\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        n_segments = random_utils.randint(self.n_segments[0], self.n_segments[1] + 1)\n        p = random.uniform(*self.p_replace)\n        return {\"replace_samples\": random_utils.random(n_segments) &lt; p, \"n_segments\": n_segments}\n\n    def apply(\n        self, img: np.ndarray, replace_samples: Sequence[bool] = (False,), n_segments: int = 1, **kwargs: Any\n    ) -&gt; np.ndarray:\n        return F.superpixels(img, n_segments, replace_samples, self.max_size, cast(int, self.interpolation))\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.TemplateTransform","title":"<code>class  TemplateTransform</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply blending of input image with specified templates</p> <p>Parameters:</p> Name Type Description <code>templates</code> <code>numpy array or list of numpy arrays</code> <p>Images as template for transform.</p> <code>img_weight</code> <p>If single float weight will be sampled from (0, img_weight). If tuple of float img_weight will be in range <code>[img_weight[0], img_weight[1])</code>. If you want fixed weight, use (img_weight, img_weight) Default: (0.5, 0.5).</p> <code>template_weight</code> <p>If single float weight will be sampled from (0, template_weight). If tuple of float template_weight will be in range <code>[template_weight[0], template_weight[1])</code>. If you want fixed weight, use (template_weight, template_weight) Default: (0.5, 0.5).</p> <code>template_transform</code> <p>transformation object which could be applied to template, must produce template the same size as input image.</p> <code>name</code> <p>(Optional) Name of transform, used only for deserialization.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class TemplateTransform(ImageOnlyTransform):\n    \"\"\"Apply blending of input image with specified templates\n    Args:\n        templates (numpy array or list of numpy arrays): Images as template for transform.\n        img_weight: If single float weight will be sampled from (0, img_weight).\n            If tuple of float img_weight will be in range `[img_weight[0], img_weight[1])`.\n            If you want fixed weight, use (img_weight, img_weight)\n            Default: (0.5, 0.5).\n        template_weight: If single float weight will be sampled from (0, template_weight).\n            If tuple of float template_weight will be in range `[template_weight[0], template_weight[1])`.\n            If you want fixed weight, use (template_weight, template_weight)\n            Default: (0.5, 0.5).\n        template_transform: transformation object which could be applied to template,\n            must produce template the same size as input image.\n        name: (Optional) Name of transform, used only for deserialization.\n        p: probability of applying the transform. Default: 0.5.\n    Targets:\n        image\n    Image types:\n        uint8, float32\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        templates: Union[np.ndarray, Sequence[np.ndarray]] = Field(..., description=\"Images as template for transform.\")\n        img_weight: ZeroOneRangeType = (0.5, 0.5)\n        template_weight: ZeroOneRangeType = (0.5, 0.5)\n        template_transform: Optional[Callable[..., Any]] = Field(\n            default=None, description=\"Transformation object applied to template.\"\n        )\n        name: Optional[str] = Field(default=None, description=\"Name of transform, used only for deserialization.\")\n\n        @field_validator(\"templates\")\n        @classmethod\n        def validate_templates(cls, v: Union[np.ndarray, List[np.ndarray]]) -&gt; List[np.ndarray]:\n            if isinstance(v, np.ndarray):\n                return [v]\n            if isinstance(v, list):\n                if not all(isinstance(item, np.ndarray) for item in v):\n                    msg = \"All templates must be numpy arrays.\"\n                    raise ValueError(msg)\n                return v\n            msg = \"Templates must be a numpy array or a list of numpy arrays.\"\n            raise TypeError(msg)\n\n    def __init__(\n        self,\n        templates: Union[np.ndarray, List[np.ndarray]],\n        img_weight: ScaleFloatType = (0.5, 0.5),\n        template_weight: ScaleFloatType = (0.5, 0.5),\n        template_transform: Optional[Callable[..., Any]] = None,\n        name: Optional[str] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.templates = templates\n        self.img_weight = cast(Tuple[float, float], img_weight)\n        self.template_weight = cast(Tuple[float, float], template_weight)\n        self.template_transform = template_transform\n        self.name = name\n\n    def apply(\n        self,\n        img: np.ndarray,\n        template: Optional[np.ndarray] = None,\n        img_weight: float = 0.5,\n        template_weight: float = 0.5,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.add_weighted(img, img_weight, template, template_weight)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"img_weight\": random.uniform(self.img_weight[0], self.img_weight[1]),\n            \"template_weight\": random.uniform(self.template_weight[0], self.template_weight[1]),\n        }\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        template = random.choice(self.templates)\n\n        if self.template_transform is not None:\n            template = self.template_transform(image=template)[\"image\"]\n\n        if get_num_channels(template) not in [1, get_num_channels(img)]:\n            msg = (\n                \"Template must be a single channel or \"\n                \"has the same number of channels as input \"\n                f\"image ({get_num_channels(img)}), got {get_num_channels(template)}\"\n            )\n            raise ValueError(msg)\n\n        if template.dtype != img.dtype:\n            msg = \"Image and template must be the same image type\"\n            raise ValueError(msg)\n\n        if img.shape[:2] != template.shape[:2]:\n            raise ValueError(f\"Image and template must be the same size, got {img.shape[:2]} and {template.shape[:2]}\")\n\n        if get_num_channels(template) == 1 and get_num_channels(img) &gt; 1:\n            template = np.stack((template,) * get_num_channels(img), axis=-1)\n\n        # in order to support grayscale image with dummy dim\n        template = template.reshape(img.shape)\n\n        return {\"template\": template}\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return False\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        if self.name is None:\n            msg = (\n                \"To make a TemplateTransform serializable you should provide the `name` argument, \"\n                \"e.g. `TemplateTransform(name='my_transform', ...)`.\"\n            )\n            raise ValueError(msg)\n        return {\"__class_fullname__\": self.get_class_fullname(), \"__name__\": self.name}\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ToFloat","title":"<code>class  ToFloat</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Divide pixel values by <code>max_value</code> to get a float32 output array where all values lie in the range [0, 1.0]. If <code>max_value</code> is None the transform will try to infer the maximum value by inspecting the data type of the input image.</p> <p>See Also:     :class:<code>~albumentations.augmentations.transforms.FromFloat</code></p> <p>Parameters:</p> Name Type Description <code>max_value</code> <p>maximum possible input value. Default: None.</p> <code>p</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image</p> <p>Image types:     any type</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ToFloat(ImageOnlyTransform):\n    \"\"\"Divide pixel values by `max_value` to get a float32 output array where all values lie in the range [0, 1.0].\n    If `max_value` is None the transform will try to infer the maximum value by inspecting the data type of the input\n    image.\n\n    See Also:\n        :class:`~albumentations.augmentations.transforms.FromFloat`\n\n    Args:\n        max_value: maximum possible input value. Default: None.\n        p: probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image\n\n    Image types:\n        any type\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        max_value: Optional[float] = Field(default=None, description=\"Maximum possible input value.\")\n        p: ProbabilityType = 1\n\n    def __init__(self, max_value: Optional[float] = None, always_apply: bool = False, p: float = 1.0):\n        super().__init__(always_apply, p)\n        self.max_value = max_value\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.to_float(img, self.max_value)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"max_value\",)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ToGray","title":"<code>class  ToGray</code> <code> </code>  [view source on GitHub]","text":"<p>Convert the input RGB image to grayscale. If the mean pixel value for the resulting image is greater than 127, invert the resulting grayscale image.</p> <p>Parameters:</p> Name Type Description <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ToGray(ImageOnlyTransform):\n    \"\"\"Convert the input RGB image to grayscale. If the mean pixel value for the resulting image is greater\n    than 127, invert the resulting grayscale image.\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if is_grayscale_image(img):\n            warnings.warn(\"The image is already gray.\")\n            return img\n        if not is_rgb_image(img):\n            msg = \"ToGray transformation expects 3-channel images.\"\n            raise TypeError(msg)\n\n        return F.to_gray(img)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ToRGB","title":"<code>class  ToRGB</code> <code>       (always_apply=True, p=1.0)                   </code>  [view source on GitHub]","text":"<p>Convert the input grayscale image to RGB.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ToRGB(ImageOnlyTransform):\n    \"\"\"Convert the input grayscale image to RGB.\n\n    Args:\n        p: probability of applying the transform. Default: 1.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def __init__(self, always_apply: bool = True, p: float = 1.0):\n        super().__init__(always_apply=always_apply, p=p)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if is_rgb_image(img):\n            warnings.warn(\"The image is already an RGB.\")\n            return img\n        if not is_grayscale_image(img):\n            msg = \"ToRGB transformation expects 2-dim images or 3-dim with the last dimension equal to 1.\"\n            raise TypeError(msg)\n\n        return F.gray_to_rgb(img)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ToRGB.__init__","title":"<code>__init__ (self, always_apply=True, p=1.0)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>def __init__(self, always_apply: bool = True, p: float = 1.0):\n    super().__init__(always_apply=always_apply, p=p)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ToSepia","title":"<code>class  ToSepia</code> <code>       (always_apply=False, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Applies sepia filter to the input RGB image</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ToSepia(ImageOnlyTransform):\n    \"\"\"Applies sepia filter to the input RGB image\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def __init__(self, always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply, p)\n        self.sepia_transformation_matrix = np.array(\n            [[0.393, 0.769, 0.189], [0.349, 0.686, 0.168], [0.272, 0.534, 0.131]]\n        )\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if not is_rgb_image(img):\n            msg = \"ToSepia transformation expects 3-channel images.\"\n            raise TypeError(msg)\n        return F.linear_transformation_rgb(img, self.sepia_transformation_matrix)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.ToSepia.__init__","title":"<code>__init__ (self, always_apply=False, p=0.5)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>def __init__(self, always_apply: bool = False, p: float = 0.5):\n    super().__init__(always_apply, p)\n    self.sepia_transformation_matrix = np.array(\n        [[0.393, 0.769, 0.189], [0.349, 0.686, 0.168], [0.272, 0.534, 0.131]]\n    )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.transforms.UnsharpMask","title":"<code>class  UnsharpMask</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Sharpen the input image using Unsharp Masking processing and overlays the result with the original image.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <p>maximum Gaussian kernel size for blurring the input image. Must be zero or odd and in range [0, inf). If set to 0 it will be computed from sigma as <code>round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1</code>. If set single value <code>blur_limit</code> will be in range (0, blur_limit). Default: (3, 7).</p> <code>sigma_limit</code> <p>Gaussian kernel standard deviation. Must be in range [0, inf). If set single value <code>sigma_limit</code> will be in range (0, sigma_limit). If set to 0 sigma will be computed as <code>sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8</code>. Default: 0.</p> <code>alpha</code> <p>range to choose the visibility of the sharpened image. At 0, only the original image is visible, at 1.0 only its sharpened version is visible. Default: (0.2, 0.5).</p> <code>threshold</code> <p>Value to limit sharpening only for areas with high pixel difference between original image and it's smoothed version. Higher threshold means less sharpening on flat areas. Must be in range [0, 255]. Default: 10.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Reference</p> <p>arxiv.org/pdf/2107.10833.pdf</p> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class UnsharpMask(ImageOnlyTransform):\n    \"\"\"Sharpen the input image using Unsharp Masking processing and overlays the result with the original image.\n\n    Args:\n        blur_limit: maximum Gaussian kernel size for blurring the input image.\n            Must be zero or odd and in range [0, inf). If set to 0 it will be computed from sigma\n            as `round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1`.\n            If set single value `blur_limit` will be in range (0, blur_limit).\n            Default: (3, 7).\n        sigma_limit: Gaussian kernel standard deviation. Must be in range [0, inf).\n            If set single value `sigma_limit` will be in range (0, sigma_limit).\n            If set to 0 sigma will be computed as `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`. Default: 0.\n        alpha: range to choose the visibility of the sharpened image.\n            At 0, only the original image is visible, at 1.0 only its sharpened version is visible.\n            Default: (0.2, 0.5).\n        threshold: Value to limit sharpening only for areas with high pixel difference between original image\n            and it's smoothed version. Higher threshold means less sharpening on flat areas.\n            Must be in range [0, 255]. Default: 10.\n        p: probability of applying the transform. Default: 0.5.\n\n    Reference:\n        arxiv.org/pdf/2107.10833.pdf\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        sigma_limit: NonNegativeFloatRangeType = 0\n        alpha: ZeroOneRangeType = (0.2, 0.5)\n        threshold: int = Field(default=10, ge=0, le=255, description=\"Threshold for limiting sharpening.\")\n\n        blur_limit: ScaleIntType = Field(\n            default=(3, 7), description=\"Maximum kernel size for blurring the input image.\"\n        )\n\n        @field_validator(\"blur_limit\")\n        @classmethod\n        def process_blur(cls, value: ScaleIntType, info: ValidationInfo) -&gt; Tuple[int, int]:\n            return process_blur_limit(value, info, min_value=3)\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = (3, 7),\n        sigma_limit: ScaleFloatType = 0.0,\n        alpha: ScaleFloatType = (0.2, 0.5),\n        threshold: int = 10,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n        self.sigma_limit = cast(Tuple[float, float], sigma_limit)\n        self.alpha = cast(Tuple[float, float], alpha)\n        self.threshold = threshold\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"ksize\": random.randrange(self.blur_limit[0], self.blur_limit[1] + 1, 2),\n            \"sigma\": random.uniform(*self.sigma_limit),\n            \"alpha\": random.uniform(*self.alpha),\n        }\n\n    def apply(self, img: np.ndarray, ksize: int = 3, sigma: int = 0, alpha: float = 0.2, **params: Any) -&gt; np.ndarray:\n        return F.unsharp_mask(img, ksize, sigma=sigma, alpha=alpha, threshold=self.threshold)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return \"blur_limit\", \"sigma_limit\", \"alpha\", \"threshold\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.utils","title":"<code>utils</code>","text":""},{"location":"api_reference/full_reference/#albumentations.augmentations.utils.check_range","title":"<code>def check_range    (value, lower_bound, upper_bound, name)    </code> [view source on GitHub]","text":"<p>Checks if the given value is within the specified bounds</p> <p>Parameters:</p> Name Type Description <code>value</code> <code>Tuple[float, float]</code> <p>The value to check and convert. Can be a single float or a tuple of floats.</p> <code>lower_bound</code> <code>float</code> <p>The lower bound for the range check.</p> <code>upper_bound</code> <code>float</code> <p>The upper bound for the range check.</p> <code>name</code> <code>Optional[str]</code> <p>The name of the parameter being checked. Used for error messages.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the value is outside the bounds or if the tuple values are not ordered correctly.</p> Source code in <code>albumentations/augmentations/utils.py</code> Python<pre><code>def check_range(value: Tuple[float, float], lower_bound: float, upper_bound: float, name: Optional[str]) -&gt; None:\n    \"\"\"Checks if the given value is within the specified bounds\n\n    Args:\n        value: The value to check and convert. Can be a single float or a tuple of floats.\n        lower_bound: The lower bound for the range check.\n        upper_bound: The upper bound for the range check.\n        name: The name of the parameter being checked. Used for error messages.\n\n    Raises:\n        ValueError: If the value is outside the bounds or if the tuple values are not ordered correctly.\n    \"\"\"\n    if not all(lower_bound &lt;= x &lt;= upper_bound for x in value):\n        raise ValueError(f\"All values in {name} must be within [{lower_bound}, {upper_bound}] for tuple inputs.\")\n    if not value[0] &lt;= value[1]:\n        raise ValueError(f\"{name!s} tuple values must be ordered as (min, max). Got: {value}\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.utils.ensure_contiguous","title":"<code>def ensure_contiguous    (func)    </code> [view source on GitHub]","text":"<p>Ensure that input img is contiguous.</p> Source code in <code>albumentations/augmentations/utils.py</code> Python<pre><code>def ensure_contiguous(\n    func: Callable[Concatenate[np.ndarray, P], np.ndarray],\n) -&gt; Callable[Concatenate[np.ndarray, P], np.ndarray]:\n    \"\"\"Ensure that input img is contiguous.\"\"\"\n\n    @wraps(func)\n    def wrapped_function(img: np.ndarray, *args: P.args, **kwargs: P.kwargs) -&gt; np.ndarray:\n        img = np.require(img, requirements=[\"C_CONTIGUOUS\"])\n        return func(img, *args, **kwargs)\n\n    return wrapped_function\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.utils.get_opencv_dtype_from_numpy","title":"<code>def get_opencv_dtype_from_numpy    (value)    </code> [view source on GitHub]","text":"<p>Return a corresponding OpenCV dtype for a numpy's dtype :param value: Input dtype of numpy array :return: Corresponding dtype for OpenCV</p> Source code in <code>albumentations/augmentations/utils.py</code> Python<pre><code>def get_opencv_dtype_from_numpy(value: Union[np.ndarray, int, np.dtype, object]) -&gt; int:\n    \"\"\"Return a corresponding OpenCV dtype for a numpy's dtype\n    :param value: Input dtype of numpy array\n    :return: Corresponding dtype for OpenCV\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        value = value.dtype\n    return NPDTYPE_TO_OPENCV_DTYPE[value]\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.utils.preserve_channel_dim","title":"<code>def preserve_channel_dim    (func)    </code> [view source on GitHub]","text":"<p>Preserve dummy channel dim.</p> Source code in <code>albumentations/augmentations/utils.py</code> Python<pre><code>def preserve_channel_dim(\n    func: Callable[Concatenate[np.ndarray, P], np.ndarray],\n) -&gt; Callable[Concatenate[np.ndarray, P], np.ndarray]:\n    \"\"\"Preserve dummy channel dim.\"\"\"\n\n    @wraps(func)\n    def wrapped_function(img: np.ndarray, *args: P.args, **kwargs: P.kwargs) -&gt; np.ndarray:\n        shape = img.shape\n        result = func(img, *args, **kwargs)\n        if len(shape) == THREE and shape[-1] == 1 and len(result.shape) == TWO:\n            result = np.expand_dims(result, axis=-1)\n        return result\n\n    return wrapped_function\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.augmentations.utils.preserve_shape","title":"<code>def preserve_shape    (func)    </code> [view source on GitHub]","text":"<p>Preserve shape of the image</p> Source code in <code>albumentations/augmentations/utils.py</code> Python<pre><code>def preserve_shape(\n    func: Callable[Concatenate[np.ndarray, P], np.ndarray],\n) -&gt; Callable[Concatenate[np.ndarray, P], np.ndarray]:\n    \"\"\"Preserve shape of the image\"\"\"\n\n    @wraps(func)\n    def wrapped_function(img: np.ndarray, *args: P.args, **kwargs: P.kwargs) -&gt; np.ndarray:\n        shape = img.shape\n        result = func(img, *args, **kwargs)\n        return result.reshape(shape)\n\n    return wrapped_function\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core","title":"<code>core</code>  <code>special</code>","text":""},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils","title":"<code>bbox_utils</code>","text":""},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.BboxParams","title":"<code>class  BboxParams</code> <code>       (format, label_fields=None, min_area=0.0, min_visibility=0.0, min_width=0.0, min_height=0.0, check_each_transform=True)                   </code>  [view source on GitHub]","text":"<p>Parameters of bounding boxes</p> <p>Parameters:</p> Name Type Description <code>format</code> <code>str</code> <p>format of bounding boxes. Should be 'coco', 'pascal_voc', 'albumentations' or 'yolo'.</p> <p>The <code>coco</code> format     <code>[x_min, y_min, width, height]</code>, e.g. [97, 12, 150, 200]. The <code>pascal_voc</code> format     <code>[x_min, y_min, x_max, y_max]</code>, e.g. [97, 12, 247, 212]. The <code>albumentations</code> format     is like <code>pascal_voc</code>, but normalized,     in other words: <code>[x_min, y_min, x_max, y_max]</code>, e.g. [0.2, 0.3, 0.4, 0.5]. The <code>yolo</code> format     <code>[x, y, width, height]</code>, e.g. [0.1, 0.2, 0.3, 0.4];     <code>x</code>, <code>y</code> - normalized bbox center; <code>width</code>, <code>height</code> - normalized bbox width and height.</p> <code>label_fields</code> <code>list</code> <p>list of fields that are joined with boxes, e.g labels. Should be same type as boxes.</p> <code>min_area</code> <code>float</code> <p>minimum area of a bounding box. All bounding boxes whose visible area in pixels is less than this value will be removed. Default: 0.0.</p> <code>min_visibility</code> <code>float</code> <p>minimum fraction of area for a bounding box to remain this box in list. Default: 0.0.</p> <code>min_width</code> <code>float</code> <p>Minimum width of a bounding box. All bounding boxes whose width is less than this value will be removed. Default: 0.0.</p> <code>min_height</code> <code>float</code> <p>Minimum height of a bounding box. All bounding boxes whose height is less than this value will be removed. Default: 0.0.</p> <code>check_each_transform</code> <code>bool</code> <p>if <code>True</code>, then bboxes will be checked after each dual transform. Default: <code>True</code></p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>class BboxParams(Params):\n    \"\"\"Parameters of bounding boxes\n\n    Args:\n        format (str): format of bounding boxes. Should be 'coco', 'pascal_voc', 'albumentations' or 'yolo'.\n\n            The `coco` format\n                `[x_min, y_min, width, height]`, e.g. [97, 12, 150, 200].\n            The `pascal_voc` format\n                `[x_min, y_min, x_max, y_max]`, e.g. [97, 12, 247, 212].\n            The `albumentations` format\n                is like `pascal_voc`, but normalized,\n                in other words: `[x_min, y_min, x_max, y_max]`, e.g. [0.2, 0.3, 0.4, 0.5].\n            The `yolo` format\n                `[x, y, width, height]`, e.g. [0.1, 0.2, 0.3, 0.4];\n                `x`, `y` - normalized bbox center; `width`, `height` - normalized bbox width and height.\n        label_fields (list): list of fields that are joined with boxes, e.g labels.\n            Should be same type as boxes.\n        min_area (float): minimum area of a bounding box. All bounding boxes whose\n            visible area in pixels is less than this value will be removed. Default: 0.0.\n        min_visibility (float): minimum fraction of area for a bounding box\n            to remain this box in list. Default: 0.0.\n        min_width (float): Minimum width of a bounding box. All bounding boxes whose width is\n            less than this value will be removed. Default: 0.0.\n        min_height (float): Minimum height of a bounding box. All bounding boxes whose height is\n            less than this value will be removed. Default: 0.0.\n        check_each_transform (bool): if `True`, then bboxes will be checked after each dual transform.\n            Default: `True`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        format: str,\n        label_fields: Optional[Sequence[str]] = None,\n        min_area: float = 0.0,\n        min_visibility: float = 0.0,\n        min_width: float = 0.0,\n        min_height: float = 0.0,\n        check_each_transform: bool = True,\n    ):\n        super().__init__(format, label_fields)\n        self.min_area = min_area\n        self.min_visibility = min_visibility\n        self.min_width = min_width\n        self.min_height = min_height\n        self.check_each_transform = check_each_transform\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        data = super().to_dict_private()\n        data.update(\n            {\n                \"min_area\": self.min_area,\n                \"min_visibility\": self.min_visibility,\n                \"min_width\": self.min_width,\n                \"min_height\": self.min_height,\n                \"check_each_transform\": self.check_each_transform,\n            }\n        )\n        return data\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return True\n\n    @classmethod\n    def get_class_fullname(cls) -&gt; str:\n        return \"BboxParams\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.calculate_bbox_area","title":"<code>def calculate_bbox_area    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Calculate the area of a bounding box in (fractional) pixels.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>float</code> <p>Area in (fractional) pixels of the (denormalized) bounding box.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def calculate_bbox_area(bbox: BoxType, rows: int, cols: int) -&gt; float:\n    \"\"\"Calculate the area of a bounding box in (fractional) pixels.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image height.\n        cols: Image width.\n\n    Return:\n        Area in (fractional) pixels of the (denormalized) bounding box.\n\n    \"\"\"\n    bbox = denormalize_bbox(bbox, rows, cols)\n    x_min, y_min, x_max, y_max = bbox[:4]\n    return (x_max - x_min) * (y_max - y_min)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.check_bbox","title":"<code>def check_bbox    (bbox)    </code> [view source on GitHub]","text":"<p>Check if bbox boundaries are in range 0, 1 and minimums are lesser then maximums</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def check_bbox(bbox: BoxType) -&gt; None:\n    \"\"\"Check if bbox boundaries are in range 0, 1 and minimums are lesser then maximums\"\"\"\n    for name, value in zip([\"x_min\", \"y_min\", \"x_max\", \"y_max\"], bbox[:4]):\n        if not 0 &lt;= value &lt;= 1 and not np.isclose(value, 0) and not np.isclose(value, 1):\n            raise ValueError(f\"Expected {name} for bbox {bbox} to be in the range [0.0, 1.0], got {value}.\")\n    x_min, y_min, x_max, y_max = bbox[:4]\n    if x_max &lt;= x_min:\n        raise ValueError(f\"x_max is less than or equal to x_min for bbox {bbox}.\")\n    if y_max &lt;= y_min:\n        raise ValueError(f\"y_max is less than or equal to y_min for bbox {bbox}.\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.check_bboxes","title":"<code>def check_bboxes    (bboxes)    </code> [view source on GitHub]","text":"<p>Check if bboxes boundaries are in range 0, 1 and minimums are lesser then maximums</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def check_bboxes(bboxes: Sequence[BoxType]) -&gt; None:\n    \"\"\"Check if bboxes boundaries are in range 0, 1 and minimums are lesser then maximums\"\"\"\n    for bbox in bboxes:\n        check_bbox(bbox)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.convert_bbox_from_albumentations","title":"<code>def convert_bbox_from_albumentations    (bbox, target_format, rows, cols, check_validity=False)    </code> [view source on GitHub]","text":"<p>Convert a bounding box from the format used by albumentations to a format, specified in <code>target_format</code>.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>An albumentations bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>target_format</code> <code>str</code> <p>required format of the output bounding box. Should be 'coco', 'pascal_voc' or 'yolo'.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <code>check_validity</code> <code>bool</code> <p>Check if all boxes are valid boxes.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box.</p> <p>Note</p> <p>The <code>coco</code> format of a bounding box looks like <code>[x_min, y_min, width, height]</code>, e.g. [97, 12, 150, 200]. The <code>pascal_voc</code> format of a bounding box looks like <code>[x_min, y_min, x_max, y_max]</code>, e.g. [97, 12, 247, 212]. The <code>yolo</code> format of a bounding box looks like <code>[x, y, width, height]</code>, e.g. [0.3, 0.1, 0.05, 0.07].</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if <code>target_format</code> is not equal to <code>coco</code>, <code>pascal_voc</code> or <code>yolo</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def convert_bbox_from_albumentations(\n    bbox: BoxType, target_format: str, rows: int, cols: int, check_validity: bool = False\n) -&gt; BoxType:\n    \"\"\"Convert a bounding box from the format used by albumentations to a format, specified in `target_format`.\n\n    Args:\n        bbox: An albumentations bounding box `(x_min, y_min, x_max, y_max)`.\n        target_format: required format of the output bounding box. Should be 'coco', 'pascal_voc' or 'yolo'.\n        rows: Image height.\n        cols: Image width.\n        check_validity: Check if all boxes are valid boxes.\n\n    Returns:\n        tuple: A bounding box.\n\n    Note:\n        The `coco` format of a bounding box looks like `[x_min, y_min, width, height]`, e.g. [97, 12, 150, 200].\n        The `pascal_voc` format of a bounding box looks like `[x_min, y_min, x_max, y_max]`, e.g. [97, 12, 247, 212].\n        The `yolo` format of a bounding box looks like `[x, y, width, height]`, e.g. [0.3, 0.1, 0.05, 0.07].\n\n    Raises:\n        ValueError: if `target_format` is not equal to `coco`, `pascal_voc` or `yolo`.\n\n    \"\"\"\n    if target_format not in {\"coco\", \"pascal_voc\", \"yolo\"}:\n        raise ValueError(\n            f\"Unknown target_format {target_format}. Supported formats are: 'coco', 'pascal_voc' and 'yolo'\"\n        )\n    if check_validity:\n        check_bbox(bbox)\n\n    if target_format != \"yolo\":\n        bbox = denormalize_bbox(bbox, rows, cols)\n    if target_format == \"coco\":\n        (x_min, y_min, x_max, y_max), tail = bbox[:4], tuple(bbox[4:])\n        width = x_max - x_min\n        height = y_max - y_min\n        bbox = cast(BoxType, (x_min, y_min, width, height, *tail))\n    elif target_format == \"yolo\":\n        (x_min, y_min, x_max, y_max), tail = bbox[:4], bbox[4:]\n        x = (x_min + x_max) / 2.0\n        y = (y_min + y_max) / 2.0\n        w = x_max - x_min\n        h = y_max - y_min\n        bbox = cast(BoxType, (x, y, w, h, *tail))\n    return bbox\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.convert_bbox_to_albumentations","title":"<code>def convert_bbox_to_albumentations    (bbox, source_format, rows, cols, check_validity=False)    </code> [view source on GitHub]","text":"<p>Convert a bounding box from a format specified in <code>source_format</code> to the format used by albumentations: normalized coordinates of top-left and bottom-right corners of the bounding box in a form of <code>(x_min, y_min, x_max, y_max)</code> e.g. <code>(0.15, 0.27, 0.67, 0.5)</code>.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>A bounding box tuple.</p> <code>source_format</code> <code>str</code> <p>format of the bounding box. Should be 'coco', 'pascal_voc', or 'yolo'.</p> <code>check_validity</code> <code>bool</code> <p>Check if all boxes are valid boxes.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Note</p> <p>The <code>coco</code> format of a bounding box looks like <code>(x_min, y_min, width, height)</code>, e.g. (97, 12, 150, 200). The <code>pascal_voc</code> format of a bounding box looks like <code>(x_min, y_min, x_max, y_max)</code>, e.g. (97, 12, 247, 212). The <code>yolo</code> format of a bounding box looks like <code>(x, y, width, height)</code>, e.g. (0.3, 0.1, 0.05, 0.07); where <code>x</code>, <code>y</code> coordinates of the center of the box, all values normalized to 1 by image height and width.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if <code>target_format</code> is not equal to <code>coco</code> or <code>pascal_voc</code>, or <code>yolo</code>.</p> <code>ValueError</code> <p>If in YOLO format all labels not in range (0, 1).</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def convert_bbox_to_albumentations(\n    bbox: BoxType, source_format: str, rows: int, cols: int, check_validity: bool = False\n) -&gt; BoxType:\n    \"\"\"Convert a bounding box from a format specified in `source_format` to the format used by albumentations:\n    normalized coordinates of top-left and bottom-right corners of the bounding box in a form of\n    `(x_min, y_min, x_max, y_max)` e.g. `(0.15, 0.27, 0.67, 0.5)`.\n\n    Args:\n        bbox: A bounding box tuple.\n        source_format: format of the bounding box. Should be 'coco', 'pascal_voc', or 'yolo'.\n        check_validity: Check if all boxes are valid boxes.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        tuple: A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    Note:\n        The `coco` format of a bounding box looks like `(x_min, y_min, width, height)`, e.g. (97, 12, 150, 200).\n        The `pascal_voc` format of a bounding box looks like `(x_min, y_min, x_max, y_max)`, e.g. (97, 12, 247, 212).\n        The `yolo` format of a bounding box looks like `(x, y, width, height)`, e.g. (0.3, 0.1, 0.05, 0.07);\n        where `x`, `y` coordinates of the center of the box, all values normalized to 1 by image height and width.\n\n    Raises:\n        ValueError: if `target_format` is not equal to `coco` or `pascal_voc`, or `yolo`.\n        ValueError: If in YOLO format all labels not in range (0, 1).\n\n    \"\"\"\n    if source_format not in {\"coco\", \"pascal_voc\", \"yolo\"}:\n        raise ValueError(\n            f\"Unknown source_format {source_format}. Supported formats are: 'coco', 'pascal_voc' and 'yolo'\"\n        )\n\n    if source_format == \"coco\":\n        (x_min, y_min, width, height), tail = bbox[:4], bbox[4:]\n        x_max = x_min + width\n        y_max = y_min + height\n    elif source_format == \"yolo\":\n        # https://github.com/pjreddie/darknet/blob/f6d861736038da22c9eb0739dca84003c5a5e275/scripts/voc_label.py#L12\n        _bbox = np.array(bbox[:4])\n        if check_validity and np.any((_bbox &lt;= 0) | (_bbox &gt; 1)):\n            msg = \"In YOLO format all coordinates must be float and in range (0, 1]\"\n            raise ValueError(msg)\n\n        (x, y, w, h), tail = bbox[:4], bbox[4:]\n\n        w_half, h_half = w / 2, h / 2\n        x_min = x - w_half\n        y_min = y - h_half\n        x_max = x_min + w\n        y_max = y_min + h\n    else:\n        (x_min, y_min, x_max, y_max), tail = bbox[:4], bbox[4:]\n\n    bbox = (x_min, y_min, x_max, y_max, *tuple(tail))\n\n    if source_format != \"yolo\":\n        bbox = normalize_bbox(bbox, rows, cols)\n    if check_validity:\n        check_bbox(bbox)\n    return bbox\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.convert_bboxes_from_albumentations","title":"<code>def convert_bboxes_from_albumentations    (bboxes, target_format, rows, cols, check_validity=False)    </code> [view source on GitHub]","text":"<p>Convert a list of bounding boxes from the format used by albumentations to a format, specified in <code>target_format</code>.</p> <p>Parameters:</p> Name Type Description <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>List of albumentations bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>target_format</code> <code>str</code> <p>required format of the output bounding box. Should be 'coco', 'pascal_voc' or 'yolo'.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <code>check_validity</code> <code>bool</code> <p>Check if all boxes are valid boxes.</p> <p>Returns:</p> Type Description <code>List[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>List of bounding boxes.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def convert_bboxes_from_albumentations(\n    bboxes: Sequence[BoxType], target_format: str, rows: int, cols: int, check_validity: bool = False\n) -&gt; List[BoxType]:\n    \"\"\"Convert a list of bounding boxes from the format used by albumentations to a format, specified\n    in `target_format`.\n\n    Args:\n        bboxes: List of albumentations bounding box `(x_min, y_min, x_max, y_max)`.\n        target_format: required format of the output bounding box. Should be 'coco', 'pascal_voc' or 'yolo'.\n        rows: Image height.\n        cols: Image width.\n        check_validity: Check if all boxes are valid boxes.\n\n    Returns:\n        List of bounding boxes.\n\n    \"\"\"\n    return [convert_bbox_from_albumentations(bbox, target_format, rows, cols, check_validity) for bbox in bboxes]\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.convert_bboxes_to_albumentations","title":"<code>def convert_bboxes_to_albumentations    (bboxes, source_format, rows, cols, check_validity=False)    </code> [view source on GitHub]","text":"<p>Convert a list bounding boxes from a format specified in <code>source_format</code> to the format used by albumentations</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def convert_bboxes_to_albumentations(\n    bboxes: Sequence[BoxType], source_format: str, rows: int, cols: int, check_validity: bool = False\n) -&gt; List[BoxType]:\n    \"\"\"Convert a list bounding boxes from a format specified in `source_format` to the format used by albumentations\"\"\"\n    return [convert_bbox_to_albumentations(bbox, source_format, rows, cols, check_validity) for bbox in bboxes]\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.denormalize_bbox","title":"<code>def denormalize_bbox    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Denormalize coordinates of a bounding box. Multiply x-coordinates by image width and y-coordinates by image height. This is an inverse operation for :func:<code>~albumentations.augmentations.bbox.normalize_bbox</code>.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>Normalized bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>Denormalized bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If rows or cols is less or equal zero</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def denormalize_bbox(bbox: BoxType, rows: int, cols: int) -&gt; BoxType:\n    \"\"\"Denormalize coordinates of a bounding box. Multiply x-coordinates by image width and y-coordinates\n    by image height. This is an inverse operation for :func:`~albumentations.augmentations.bbox.normalize_bbox`.\n\n    Args:\n        bbox: Normalized bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        Denormalized bounding box `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: If rows or cols is less or equal zero\n\n    \"\"\"\n    tail: Tuple[Any, ...]\n    (x_min, y_min, x_max, y_max), tail = bbox[:4], tuple(bbox[4:])\n\n    if rows &lt;= 0:\n        msg = \"Argument rows must be positive integer\"\n        raise ValueError(msg)\n    if cols &lt;= 0:\n        msg = \"Argument cols must be positive integer\"\n        raise ValueError(msg)\n\n    x_min, x_max = x_min * cols, x_max * cols\n    y_min, y_max = y_min * rows, y_max * rows\n\n    return cast(BoxType, (x_min, y_min, x_max, y_max, *tail))\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.denormalize_bboxes","title":"<code>def denormalize_bboxes    (bboxes, rows, cols)    </code> [view source on GitHub]","text":"<p>Denormalize a list of bounding boxes.</p> <p>Parameters:</p> Name Type Description <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Normalized bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>List</code> <p>Denormalized bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def denormalize_bboxes(bboxes: Sequence[BoxType], rows: int, cols: int) -&gt; List[BoxType]:\n    \"\"\"Denormalize a list of bounding boxes.\n\n    Args:\n        bboxes: Normalized bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        List: Denormalized bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n\n    \"\"\"\n    return [denormalize_bbox(bbox, rows, cols) for bbox in bboxes]\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.filter_bboxes","title":"<code>def filter_bboxes    (bboxes, rows, cols, min_area=0.0, min_visibility=0.0, min_width=0.0, min_height=0.0)    </code> [view source on GitHub]","text":"<p>Remove bounding boxes that either lie outside of the visible area by more then min_visibility or whose area in pixels is under the threshold set by <code>min_area</code>. Also it crops boxes to final image size.</p> <p>Parameters:</p> Name Type Description <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>List of albumentations bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <code>min_area</code> <code>float</code> <p>Minimum area of a bounding box. All bounding boxes whose visible area in pixels. is less than this value will be removed. Default: 0.0.</p> <code>min_visibility</code> <code>float</code> <p>Minimum fraction of area for a bounding box to remain this box in list. Default: 0.0.</p> <code>min_width</code> <code>float</code> <p>Minimum width of a bounding box. All bounding boxes whose width is less than this value will be removed. Default: 0.0.</p> <code>min_height</code> <code>float</code> <p>Minimum height of a bounding box. All bounding boxes whose height is less than this value will be removed. Default: 0.0.</p> <p>Returns:</p> Type Description <code>List[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>List of bounding boxes.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def filter_bboxes(\n    bboxes: Sequence[BoxType],\n    rows: int,\n    cols: int,\n    min_area: float = 0.0,\n    min_visibility: float = 0.0,\n    min_width: float = 0.0,\n    min_height: float = 0.0,\n) -&gt; List[BoxType]:\n    \"\"\"Remove bounding boxes that either lie outside of the visible area by more then min_visibility\n    or whose area in pixels is under the threshold set by `min_area`. Also it crops boxes to final image size.\n\n    Args:\n        bboxes: List of albumentations bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image height.\n        cols: Image width.\n        min_area: Minimum area of a bounding box. All bounding boxes whose visible area in pixels.\n            is less than this value will be removed. Default: 0.0.\n        min_visibility: Minimum fraction of area for a bounding box to remain this box in list. Default: 0.0.\n        min_width: Minimum width of a bounding box. All bounding boxes whose width is\n            less than this value will be removed. Default: 0.0.\n        min_height: Minimum height of a bounding box. All bounding boxes whose height is\n            less than this value will be removed. Default: 0.0.\n\n    Returns:\n        List of bounding boxes.\n\n    \"\"\"\n    resulting_boxes: List[BoxType] = []\n    for i in range(len(bboxes)):\n        bbox = bboxes[i]\n        # Calculate areas of bounding box before and after clipping.\n        transformed_box_area = calculate_bbox_area(bbox, rows, cols)\n        bbox, tail = cast(BoxType, tuple(np.clip(bbox[:4], 0, 1.0))), tuple(bbox[4:])\n        clipped_box_area = calculate_bbox_area(bbox, rows, cols)\n\n        # Calculate width and height of the clipped bounding box.\n        x_min, y_min, x_max, y_max = denormalize_bbox(bbox, rows, cols)[:4]\n        clipped_width, clipped_height = x_max - x_min, y_max - y_min\n\n        if (\n            clipped_box_area != 0  # to ensure transformed_box_area!=0 and to handle min_area=0 or min_visibility=0\n            and clipped_box_area &gt;= min_area\n            and clipped_box_area / transformed_box_area &gt;= min_visibility\n            and clipped_width &gt;= min_width\n            and clipped_height &gt;= min_height\n        ):\n            resulting_boxes.append(cast(BoxType, bbox + tail))\n    return resulting_boxes\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.filter_bboxes_by_visibility","title":"<code>def filter_bboxes_by_visibility    (original_shape, bboxes, transformed_shape, transformed_bboxes, threshold=0.0, min_area=0.0)    </code> [view source on GitHub]","text":"<p>Filter bounding boxes and return only those boxes whose visibility after transformation is above the threshold and minimal area of bounding box in pixels is more then min_area.</p> <p>Parameters:</p> Name Type Description <code>original_shape</code> <code>Sequence[int]</code> <p>Original image shape <code>(height, width, ...)</code>.</p> <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Original bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>transformed_shape</code> <code>Sequence[int]</code> <p>Transformed image shape <code>(height, width)</code>.</p> <code>transformed_bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Transformed bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>threshold</code> <code>float</code> <p>visibility threshold. Should be a value in the range [0.0, 1.0].</p> <code>min_area</code> <code>float</code> <p>Minimal area threshold.</p> <p>Returns:</p> Type Description <code>List[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Filtered bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def filter_bboxes_by_visibility(\n    original_shape: Sequence[int],\n    bboxes: Sequence[BoxType],\n    transformed_shape: Sequence[int],\n    transformed_bboxes: Sequence[BoxType],\n    threshold: float = 0.0,\n    min_area: float = 0.0,\n) -&gt; List[BoxType]:\n    \"\"\"Filter bounding boxes and return only those boxes whose visibility after transformation is above\n    the threshold and minimal area of bounding box in pixels is more then min_area.\n\n    Args:\n        original_shape: Original image shape `(height, width, ...)`.\n        bboxes: Original bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n        transformed_shape: Transformed image shape `(height, width)`.\n        transformed_bboxes: Transformed bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n        threshold: visibility threshold. Should be a value in the range [0.0, 1.0].\n        min_area: Minimal area threshold.\n\n    Returns:\n        Filtered bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n\n    \"\"\"\n    img_height, img_width = original_shape[:2]\n    transformed_img_height, transformed_img_width = transformed_shape[:2]\n\n    visible_bboxes = []\n    for bbox, transformed_bbox in zip(bboxes, transformed_bboxes):\n        if not all(0.0 &lt;= value &lt;= 1.0 for value in transformed_bbox[:4]):\n            continue\n        bbox_area = calculate_bbox_area(bbox, img_height, img_width)\n        transformed_bbox_area = calculate_bbox_area(transformed_bbox, transformed_img_height, transformed_img_width)\n        if transformed_bbox_area &lt; min_area:\n            continue\n        visibility = transformed_bbox_area / bbox_area\n        if visibility &gt;= threshold:\n            visible_bboxes.append(transformed_bbox)\n    return visible_bboxes\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.normalize_bbox","title":"<code>def normalize_bbox    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Normalize coordinates of a bounding box. Divide x-coordinates by image width and y-coordinates by image height.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>Denormalized bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>Normalized bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If rows or cols is less or equal zero</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def normalize_bbox(bbox: BoxType, rows: int, cols: int) -&gt; BoxType:\n    \"\"\"Normalize coordinates of a bounding box. Divide x-coordinates by image width and y-coordinates\n    by image height.\n\n    Args:\n        bbox: Denormalized bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        Normalized bounding box `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: If rows or cols is less or equal zero\n\n    \"\"\"\n    if rows &lt;= 0:\n        msg = \"Argument rows must be positive integer\"\n        raise ValueError(msg)\n    if cols &lt;= 0:\n        msg = \"Argument cols must be positive integer\"\n        raise ValueError(msg)\n\n    tail: Tuple[Any, ...]\n    (x_min, y_min, x_max, y_max), tail = bbox[:4], tuple(bbox[4:])\n    x_min /= cols\n    x_max /= cols\n    y_min /= rows\n    y_max /= rows\n\n    return cast(BoxType, (x_min, y_min, x_max, y_max, *tail))\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.normalize_bboxes","title":"<code>def normalize_bboxes    (bboxes, rows, cols)    </code> [view source on GitHub]","text":"<p>Normalize a list of bounding boxes.</p> <p>Parameters:</p> Name Type Description <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Denormalized bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>List[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Normalized bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def normalize_bboxes(bboxes: Sequence[BoxType], rows: int, cols: int) -&gt; List[BoxType]:\n    \"\"\"Normalize a list of bounding boxes.\n\n    Args:\n        bboxes: Denormalized bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        Normalized bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n\n    \"\"\"\n    return [normalize_bbox(bbox, rows, cols) for bbox in bboxes]\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.bbox_utils.union_of_bboxes","title":"<code>def union_of_bboxes    (height, width, bboxes, erosion_rate=0.0)    </code> [view source on GitHub]","text":"<p>Calculate union of bounding boxes.</p> <p>Parameters:</p> Name Type Description <code>height</code> <code>float</code> <p>Height of image or space.</p> <code>width</code> <code>float</code> <p>Width of image or space.</p> <code>bboxes</code> <code>List[tuple]</code> <p>List like bounding boxes. Format is <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>erosion_rate</code> <code>float</code> <p>How much each bounding box can be shrunk, useful for erosive cropping. Set this in range [0, 1]. 0 will not be erosive at all, 1.0 can make any bbox to lose its volume.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def union_of_bboxes(height: int, width: int, bboxes: Sequence[BoxType], erosion_rate: float = 0.0) -&gt; BoxInternalType:\n    \"\"\"Calculate union of bounding boxes.\n\n    Args:\n        height (float): Height of image or space.\n        width (float): Width of image or space.\n        bboxes (List[tuple]): List like bounding boxes. Format is `[(x_min, y_min, x_max, y_max)]`.\n        erosion_rate (float): How much each bounding box can be shrunk, useful for erosive cropping.\n            Set this in range [0, 1]. 0 will not be erosive at all, 1.0 can make any bbox to lose its volume.\n\n    Returns:\n        tuple: A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    x1, y1 = width, height\n    x2, y2 = 0, 0\n    for bbox in bboxes:\n        x_min, y_min, x_max, y_max = bbox[:4]\n        w, h = x_max - x_min, y_max - y_min\n        lim_x1, lim_y1 = x_min + erosion_rate * w, y_min + erosion_rate * h\n        lim_x2, lim_y2 = x_max - erosion_rate * w, y_max - erosion_rate * h\n        x1, y1 = np.min([x1, lim_x1]), np.min([y1, lim_y1])\n        x2, y2 = np.max([x2, lim_x2]), np.max([y2, lim_y2])\n    return x1, y1, x2, y2\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.composition","title":"<code>composition</code>","text":""},{"location":"api_reference/full_reference/#albumentations.core.composition.Compose","title":"<code>class  Compose</code> <code>       (transforms, bbox_params=None, keypoint_params=None, additional_targets=None, p=1.0, is_check_shapes=True)                   </code>  [view source on GitHub]","text":"<p>Compose transforms and handle all transformations regarding bounding boxes</p> <p>Parameters:</p> Name Type Description <code>transforms</code> <code>list</code> <p>list of transformations to compose.</p> <code>bbox_params</code> <code>BboxParams</code> <p>Parameters for bounding boxes transforms</p> <code>keypoint_params</code> <code>KeypointParams</code> <p>Parameters for keypoints transforms</p> <code>additional_targets</code> <code>dict</code> <p>Dict with keys - new target name, values - old target name. ex: {'image2': 'image'}</p> <code>p</code> <code>float</code> <p>probability of applying all list of transforms. Default: 1.0.</p> <code>is_check_shapes</code> <code>bool</code> <p>If True shapes consistency of images/mask/masks would be checked on each call. If you would like to disable this check - pass False (do it only if you are sure in your data consistency).</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class Compose(BaseCompose):\n    \"\"\"Compose transforms and handle all transformations regarding bounding boxes\n\n    Args:\n        transforms (list): list of transformations to compose.\n        bbox_params (BboxParams): Parameters for bounding boxes transforms\n        keypoint_params (KeypointParams): Parameters for keypoints transforms\n        additional_targets (dict): Dict with keys - new target name, values - old target name. ex: {'image2': 'image'}\n        p (float): probability of applying all list of transforms. Default: 1.0.\n        is_check_shapes (bool): If True shapes consistency of images/mask/masks would be checked on each call. If you\n            would like to disable this check - pass False (do it only if you are sure in your data consistency).\n\n    \"\"\"\n\n    def __init__(\n        self,\n        transforms: TransformsSeqType,\n        bbox_params: Optional[Union[Dict[str, Any], \"BboxParams\"]] = None,\n        keypoint_params: Optional[Union[Dict[str, Any], \"KeypointParams\"]] = None,\n        additional_targets: Optional[Dict[str, str]] = None,\n        p: float = 1.0,\n        is_check_shapes: bool = True,\n    ):\n        super().__init__(transforms, p)\n\n        self.processors: Dict[str, Union[BboxProcessor, KeypointsProcessor]] = {}\n        if bbox_params:\n            if isinstance(bbox_params, dict):\n                b_params = BboxParams(**bbox_params)\n            elif isinstance(bbox_params, BboxParams):\n                b_params = bbox_params\n            else:\n                msg = \"unknown format of bbox_params, please use `dict` or `BboxParams`\"\n                raise ValueError(msg)\n            self.processors[\"bboxes\"] = BboxProcessor(b_params, additional_targets)\n\n        if keypoint_params:\n            if isinstance(keypoint_params, dict):\n                k_params = KeypointParams(**keypoint_params)\n            elif isinstance(keypoint_params, KeypointParams):\n                k_params = keypoint_params\n            else:\n                msg = \"unknown format of keypoint_params, please use `dict` or `KeypointParams`\"\n                raise ValueError(msg)\n            self.processors[\"keypoints\"] = KeypointsProcessor(k_params, additional_targets)\n\n        if additional_targets is None:\n            additional_targets = {}\n\n        self.additional_targets = additional_targets\n\n        for proc in self.processors.values():\n            proc.ensure_transforms_valid(self.transforms)\n\n        self.add_targets(additional_targets)\n\n        self.is_check_args = True\n        self._disable_check_args_for_transforms(self.transforms)\n\n        self.is_check_shapes = is_check_shapes\n\n    @staticmethod\n    def _disable_check_args_for_transforms(transforms: TransformsSeqType) -&gt; None:\n        for transform in transforms:\n            if isinstance(transform, BaseCompose):\n                Compose._disable_check_args_for_transforms(transform.transforms)\n            if isinstance(transform, Compose):\n                transform.disable_check_args_private()\n\n    def disable_check_args_private(self) -&gt; None:\n        self.is_check_args = False\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if args:\n            msg = \"You have to pass data to augmentations as named arguments, for example: aug(image=image)\"\n            raise KeyError(msg)\n        if self.is_check_args:\n            self._check_args(**data)\n\n        if not isinstance(force_apply, (bool, int)):\n            msg = \"force_apply must have bool or int type\"\n            raise TypeError(msg)\n\n        need_to_run = force_apply or random.random() &lt; self.p\n\n        for p in self.processors.values():\n            p.ensure_data_valid(data)\n        transforms = self.transforms if need_to_run else get_always_apply(self.transforms)\n\n        check_each_transform = any(\n            getattr(item.params, \"check_each_transform\", False) for item in self.processors.values()\n        )\n\n        for p in self.processors.values():\n            p.preprocess(data)\n\n        for t in transforms:\n            data = t(**data)\n\n            if check_each_transform:\n                data = self._check_data_post_transform(data)\n        data = Compose._make_targets_contiguous(data)  # ensure output targets are contiguous\n\n        for p in self.processors.values():\n            p.postprocess(data)\n\n        return data\n\n    def _check_data_post_transform(self, data: Any) -&gt; Dict[str, Any]:\n        rows, cols = get_shape(data[\"image\"])\n\n        for p in self.processors.values():\n            if not getattr(p.params, \"check_each_transform\", False):\n                continue\n\n            for data_name in p.data_fields:\n                data[data_name] = p.filter(data[data_name], rows, cols)\n        return data\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        dictionary = super().to_dict_private()\n        bbox_processor = self.processors.get(\"bboxes\")\n        keypoints_processor = self.processors.get(\"keypoints\")\n        dictionary.update(\n            {\n                \"bbox_params\": bbox_processor.params.to_dict_private() if bbox_processor else None,\n                \"keypoint_params\": (keypoints_processor.params.to_dict_private() if keypoints_processor else None),\n                \"additional_targets\": self.additional_targets,\n                \"is_check_shapes\": self.is_check_shapes,\n            }\n        )\n        return dictionary\n\n    def get_dict_with_id(self) -&gt; Dict[str, Any]:\n        dictionary = super().get_dict_with_id()\n        bbox_processor = self.processors.get(\"bboxes\")\n        keypoints_processor = self.processors.get(\"keypoints\")\n        dictionary.update(\n            {\n                \"bbox_params\": bbox_processor.params.to_dict_private() if bbox_processor else None,\n                \"keypoint_params\": (keypoints_processor.params.to_dict_private() if keypoints_processor else None),\n                \"additional_targets\": self.additional_targets,\n                \"params\": None,\n                \"is_check_shapes\": self.is_check_shapes,\n            }\n        )\n        return dictionary\n\n    def _check_args(self, **kwargs: Any) -&gt; None:\n        checked_single = [\"image\", \"mask\"]\n        checked_multi = [\"masks\"]\n        check_bbox_param = [\"bboxes\"]\n        shapes = []\n        for data_name, data in kwargs.items():\n            internal_data_name = self.additional_targets.get(data_name, data_name)\n            if internal_data_name in checked_single:\n                if not isinstance(data, np.ndarray):\n                    raise TypeError(f\"{data_name} must be numpy array type\")\n                shapes.append(data.shape[:2])\n            if internal_data_name in checked_multi and data is not None and len(data):\n                if not isinstance(data[0], np.ndarray):\n                    raise TypeError(f\"{data_name} must be list of numpy arrays\")\n                shapes.append(data[0].shape[:2])\n            if internal_data_name in check_bbox_param and self.processors.get(\"bboxes\") is None:\n                msg = \"bbox_params must be specified for bbox transformations\"\n                raise ValueError(msg)\n\n        if self.is_check_shapes and shapes and shapes.count(shapes[0]) != len(shapes):\n            msg = (\n                \"Height and Width of image, mask or masks should be equal. You can disable shapes check \"\n                \"by setting a parameter is_check_shapes=False of Compose class (do it only if you are sure \"\n                \"about your data consistency).\"\n            )\n            raise ValueError(msg)\n\n    @staticmethod\n    def _make_targets_contiguous(data: Any) -&gt; Dict[str, Any]:\n        result = {}\n        for key, value in data.items():\n            if isinstance(value, np.ndarray):\n                result[key] = np.ascontiguousarray(value)\n            else:\n                result[key] = value\n\n        return result\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.composition.OneOf","title":"<code>class  OneOf</code> <code>       (transforms, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Select one of transforms to apply. Selected transform will be called with <code>force_apply=True</code>. Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.</p> <p>Parameters:</p> Name Type Description <code>transforms</code> <code>list</code> <p>list of transformations to compose.</p> <code>p</code> <code>float</code> <p>probability of applying selected transform. Default: 0.5.</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class OneOf(BaseCompose):\n    \"\"\"Select one of transforms to apply. Selected transform will be called with `force_apply=True`.\n    Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.\n\n    Args:\n        transforms (list): list of transformations to compose.\n        p (float): probability of applying selected transform. Default: 0.5.\n\n    \"\"\"\n\n    def __init__(self, transforms: TransformsSeqType, p: float = 0.5):\n        super().__init__(transforms, p)\n        transforms_ps = [t.p for t in self.transforms]\n        s = sum(transforms_ps)\n        self.transforms_ps = [t / s for t in transforms_ps]\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if self.replay_mode:\n            for t in self.transforms:\n                data = t(**data)\n            return data\n\n        if self.transforms_ps and (force_apply or random.random() &lt; self.p):\n            idx: int = random_utils.choice(len(self.transforms), p=self.transforms_ps)\n            t = self.transforms[idx]\n            data = t(force_apply=True, **data)\n        return data\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.composition.OneOrOther","title":"<code>class  OneOrOther</code> <code>       (first=None, second=None, transforms=None, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Select one or another transform to apply. Selected transform will be called with <code>force_apply=True</code>.</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class OneOrOther(BaseCompose):\n    \"\"\"Select one or another transform to apply. Selected transform will be called with `force_apply=True`.\"\"\"\n\n    def __init__(\n        self,\n        first: Optional[TransformType] = None,\n        second: Optional[TransformType] = None,\n        transforms: Optional[TransformsSeqType] = None,\n        p: float = 0.5,\n    ):\n        if transforms is None:\n            if first is None or second is None:\n                msg = \"You must set both first and second or set transforms argument.\"\n                raise ValueError(msg)\n            transforms = [first, second]\n        super().__init__(transforms, p)\n        if len(self.transforms) != TWO:\n            warnings.warn(\"Length of transforms is not equal to 2.\")\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if self.replay_mode:\n            for t in self.transforms:\n                data = t(**data)\n            return data\n\n        if random.random() &lt; self.p:\n            return self.transforms[0](force_apply=True, **data)\n\n        return self.transforms[-1](force_apply=True, **data)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.composition.PerChannel","title":"<code>class  PerChannel</code> <code>       (transforms, channels=None, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Apply transformations per-channel</p> <p>Parameters:</p> Name Type Description <code>transforms</code> <code>list</code> <p>list of transformations to compose.</p> <code>channels</code> <code>sequence</code> <p>channels to apply the transform to. Pass None to apply to all.</p> <code>Default</code> <p>None (apply to all)</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class PerChannel(BaseCompose):\n    \"\"\"Apply transformations per-channel\n\n    Args:\n        transforms (list): list of transformations to compose.\n        channels (sequence): channels to apply the transform to. Pass None to apply to all.\n        Default: None (apply to all)\n        p (float): probability of applying the transform. Default: 0.5.\n\n    \"\"\"\n\n    def __init__(self, transforms: TransformsSeqType, channels: Optional[Sequence[int]] = None, p: float = 0.5):\n        super().__init__(transforms, p)\n        self.channels = channels\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if force_apply or random.random() &lt; self.p:\n            image = data[\"image\"]\n\n            # Expand mono images to have a single channel\n            if len(image.shape) == TWO:\n                image = np.expand_dims(image, -1)\n\n            if self.channels is None:\n                self.channels = range(image.shape[2])\n\n            for c in self.channels:\n                for t in self.transforms:\n                    image[:, :, c] = t(image=image[:, :, c])[\"image\"]\n\n            data[\"image\"] = image\n\n        return data\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.composition.Sequential","title":"<code>class  Sequential</code> <code>       (transforms, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Sequentially applies all transforms to targets.</p> <p>Note</p> <p>This transform is not intended to be a replacement for <code>Compose</code>. Instead, it should be used inside <code>Compose</code> the same way <code>OneOf</code> or <code>OneOrOther</code> are used. For instance, you can combine <code>OneOf</code> with <code>Sequential</code> to create an augmentation pipeline that contains multiple sequences of augmentations and applies one randomly chose sequence to input data (see the <code>Example</code> section for an example definition of such pipeline).</p> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; import albumentations as A\n&gt;&gt;&gt; transform = A.Compose([\n&gt;&gt;&gt;    A.OneOf([\n&gt;&gt;&gt;        A.Sequential([\n&gt;&gt;&gt;            A.HorizontalFlip(p=0.5),\n&gt;&gt;&gt;            A.ShiftScaleRotate(p=0.5),\n&gt;&gt;&gt;        ]),\n&gt;&gt;&gt;        A.Sequential([\n&gt;&gt;&gt;            A.VerticalFlip(p=0.5),\n&gt;&gt;&gt;            A.RandomBrightnessContrast(p=0.5),\n&gt;&gt;&gt;        ]),\n&gt;&gt;&gt;    ], p=1)\n&gt;&gt;&gt; ])\n</code></pre> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class Sequential(BaseCompose):\n    \"\"\"Sequentially applies all transforms to targets.\n\n    Note:\n        This transform is not intended to be a replacement for `Compose`. Instead, it should be used inside `Compose`\n        the same way `OneOf` or `OneOrOther` are used. For instance, you can combine `OneOf` with `Sequential` to\n        create an augmentation pipeline that contains multiple sequences of augmentations and applies one randomly\n        chose sequence to input data (see the `Example` section for an example definition of such pipeline).\n\n    Example:\n        &gt;&gt;&gt; import albumentations as A\n        &gt;&gt;&gt; transform = A.Compose([\n        &gt;&gt;&gt;    A.OneOf([\n        &gt;&gt;&gt;        A.Sequential([\n        &gt;&gt;&gt;            A.HorizontalFlip(p=0.5),\n        &gt;&gt;&gt;            A.ShiftScaleRotate(p=0.5),\n        &gt;&gt;&gt;        ]),\n        &gt;&gt;&gt;        A.Sequential([\n        &gt;&gt;&gt;            A.VerticalFlip(p=0.5),\n        &gt;&gt;&gt;            A.RandomBrightnessContrast(p=0.5),\n        &gt;&gt;&gt;        ]),\n        &gt;&gt;&gt;    ], p=1)\n        &gt;&gt;&gt; ])\n\n    \"\"\"\n\n    def __init__(self, transforms: TransformsSeqType, p: float = 0.5):\n        super().__init__(transforms, p)\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        for t in self.transforms:\n            data = t(**data)\n        return data\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.composition.SomeOf","title":"<code>class  SomeOf</code> <code>       (transforms, n, replace=True, p=1)                   </code>  [view source on GitHub]","text":"<p>Select N transforms to apply. Selected transforms will be called with <code>force_apply=True</code>. Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.</p> <p>Parameters:</p> Name Type Description <code>transforms</code> <code>list</code> <p>list of transformations to compose.</p> <code>n</code> <code>int</code> <p>number of transforms to apply.</p> <code>replace</code> <code>bool</code> <p>Whether the sampled transforms are with or without replacement. Default: True.</p> <code>p</code> <code>float</code> <p>probability of applying selected transform. Default: 1.</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class SomeOf(BaseCompose):\n    \"\"\"Select N transforms to apply. Selected transforms will be called with `force_apply=True`.\n    Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.\n\n    Args:\n        transforms (list): list of transformations to compose.\n        n (int): number of transforms to apply.\n        replace (bool): Whether the sampled transforms are with or without replacement. Default: True.\n        p (float): probability of applying selected transform. Default: 1.\n\n    \"\"\"\n\n    def __init__(self, transforms: TransformsSeqType, n: int, replace: bool = True, p: float = 1):\n        super().__init__(transforms, p)\n        self.n = n\n        self.replace = replace\n        transforms_ps = [t.p for t in self.transforms]\n        s = sum(transforms_ps)\n        self.transforms_ps = [t / s for t in transforms_ps]\n\n    def __call__(self, *arg: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if self.replay_mode:\n            for t in self.transforms:\n                data = t(**data)\n            return data\n\n        if self.transforms_ps and (force_apply or random.random() &lt; self.p):\n            idx = random_utils.choice(len(self.transforms), size=self.n, replace=self.replace, p=self.transforms_ps)\n            for i in idx:\n                t = self.transforms[i]\n                data = t(force_apply=True, **data)\n        return data\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        dictionary = super().to_dict_private()\n        dictionary.update({\"n\": self.n, \"replace\": self.replace})\n        return dictionary\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.keypoints_utils","title":"<code>keypoints_utils</code>","text":""},{"location":"api_reference/full_reference/#albumentations.core.keypoints_utils.KeypointParams","title":"<code>class  KeypointParams</code> <code>       (format, label_fields=None, remove_invisible=True, angle_in_degrees=True, check_each_transform=True)                   </code>  [view source on GitHub]","text":"<p>Parameters of keypoints</p> <p>Parameters:</p> Name Type Description <code>format</code> <code>str</code> <p>format of keypoints. Should be 'xy', 'yx', 'xya', 'xys', 'xyas', 'xysa'.</p> <p>x - X coordinate,</p> <p>y - Y coordinate</p> <p>s - Keypoint scale</p> <p>a - Keypoint orientation in radians or degrees (depending on KeypointParams.angle_in_degrees)</p> <code>label_fields</code> <code>list</code> <p>list of fields that are joined with keypoints, e.g labels. Should be same type as keypoints.</p> <code>remove_invisible</code> <code>bool</code> <p>to remove invisible points after transform or not</p> <code>angle_in_degrees</code> <code>bool</code> <p>angle in degrees or radians in 'xya', 'xyas', 'xysa' keypoints</p> <code>check_each_transform</code> <code>bool</code> <p>if <code>True</code>, then keypoints will be checked after each dual transform. Default: <code>True</code></p> Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>class KeypointParams(Params):\n    \"\"\"Parameters of keypoints\n\n    Args:\n        format (str): format of keypoints. Should be 'xy', 'yx', 'xya', 'xys', 'xyas', 'xysa'.\n\n            x - X coordinate,\n\n            y - Y coordinate\n\n            s - Keypoint scale\n\n            a - Keypoint orientation in radians or degrees (depending on KeypointParams.angle_in_degrees)\n        label_fields (list): list of fields that are joined with keypoints, e.g labels.\n            Should be same type as keypoints.\n        remove_invisible (bool): to remove invisible points after transform or not\n        angle_in_degrees (bool): angle in degrees or radians in 'xya', 'xyas', 'xysa' keypoints\n        check_each_transform (bool): if `True`, then keypoints will be checked after each dual transform.\n            Default: `True`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        format: str,\n        label_fields: Optional[Sequence[str]] = None,\n        remove_invisible: bool = True,\n        angle_in_degrees: bool = True,\n        check_each_transform: bool = True,\n    ):\n        super().__init__(format, label_fields)\n        self.remove_invisible = remove_invisible\n        self.angle_in_degrees = angle_in_degrees\n        self.check_each_transform = check_each_transform\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        data = super().to_dict_private()\n        data.update(\n            {\n                \"remove_invisible\": self.remove_invisible,\n                \"angle_in_degrees\": self.angle_in_degrees,\n                \"check_each_transform\": self.check_each_transform,\n            }\n        )\n        return data\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return True\n\n    @classmethod\n    def get_class_fullname(cls) -&gt; str:\n        return \"KeypointParams\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.keypoints_utils.KeypointsProcessor","title":"<code>class  KeypointsProcessor</code> <code>       (params, additional_targets=None)                   </code>  [view source on GitHub]","text":"Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>class KeypointsProcessor(DataProcessor):\n    def __init__(self, params: KeypointParams, additional_targets: Optional[Dict[str, str]] = None):\n        super().__init__(params, additional_targets)\n\n    @property\n    def default_data_name(self) -&gt; str:\n        return \"keypoints\"\n\n    def ensure_data_valid(self, data: Dict[str, Any]) -&gt; None:\n        if self.params.label_fields and not all(i in data for i in self.params.label_fields):\n            msg = \"Your 'label_fields' are not valid - them must have same names as params in \" \"'keypoint_params' dict\"\n            raise ValueError(msg)\n\n    def filter(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; Sequence[KeypointType]:\n        \"\"\"The function filters a sequence of data based on the number of rows and columns, and returns a\n        sequence of keypoints.\n\n        :param data: The `data` parameter is a sequence of sequences. Each inner sequence represents a\n        set of keypoints\n        :type data: Sequence[Sequence]\n        :param rows: The `rows` parameter represents the number of rows in the data matrix. It specifies\n        the number of rows that will be used for filtering the keypoints\n        :type rows: int\n        :param cols: The parameter \"cols\" represents the number of columns in the grid that the\n        keypoints will be filtered on\n        :type cols: int\n        :return: a sequence of KeypointType objects.\n        \"\"\"\n        self.params: KeypointParams\n        return filter_keypoints(data, rows, cols, remove_invisible=self.params.remove_invisible)\n\n    def check(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; None:\n        check_keypoints(data, rows, cols)\n\n    def convert_from_albumentations(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; List[KeypointType]:\n        params = self.params\n        return convert_keypoints_from_albumentations(\n            data,\n            params.format,\n            rows,\n            cols,\n            check_validity=params.remove_invisible,\n            angle_in_degrees=params.angle_in_degrees,\n        )\n\n    def convert_to_albumentations(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; List[KeypointType]:\n        params = self.params\n        return convert_keypoints_to_albumentations(\n            data,\n            params.format,\n            rows,\n            cols,\n            check_validity=params.remove_invisible,\n            angle_in_degrees=params.angle_in_degrees,\n        )\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.keypoints_utils.KeypointsProcessor.filter","title":"<code>filter (self, data, rows, cols)</code>","text":"<p>The function filters a sequence of data based on the number of rows and columns, and returns a sequence of keypoints.</p> <p>:param data: The <code>data</code> parameter is a sequence of sequences. Each inner sequence represents a set of keypoints :type data: Sequence[Sequence] :param rows: The <code>rows</code> parameter represents the number of rows in the data matrix. It specifies the number of rows that will be used for filtering the keypoints :type rows: int :param cols: The parameter \"cols\" represents the number of columns in the grid that the keypoints will be filtered on :type cols: int :return: a sequence of KeypointType objects.</p> Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>def filter(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; Sequence[KeypointType]:\n    \"\"\"The function filters a sequence of data based on the number of rows and columns, and returns a\n    sequence of keypoints.\n\n    :param data: The `data` parameter is a sequence of sequences. Each inner sequence represents a\n    set of keypoints\n    :type data: Sequence[Sequence]\n    :param rows: The `rows` parameter represents the number of rows in the data matrix. It specifies\n    the number of rows that will be used for filtering the keypoints\n    :type rows: int\n    :param cols: The parameter \"cols\" represents the number of columns in the grid that the\n    keypoints will be filtered on\n    :type cols: int\n    :return: a sequence of KeypointType objects.\n    \"\"\"\n    self.params: KeypointParams\n    return filter_keypoints(data, rows, cols, remove_invisible=self.params.remove_invisible)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.keypoints_utils.check_keypoint","title":"<code>def check_keypoint    (kp, rows, cols)    </code> [view source on GitHub]","text":"<p>Check if keypoint coordinates are less than image shapes</p> Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>def check_keypoint(kp: KeypointType, rows: int, cols: int) -&gt; None:\n    \"\"\"Check if keypoint coordinates are less than image shapes\"\"\"\n    for name, value, size in zip([\"x\", \"y\"], kp[:2], [cols, rows]):\n        if not 0 &lt;= value &lt; size:\n            raise ValueError(f\"Expected {name} for keypoint {kp} \" f\"to be in the range [0.0, {size}], got {value}.\")\n\n    angle = kp[2]\n    if not (0 &lt;= angle &lt; 2 * math.pi):\n        raise ValueError(f\"Keypoint angle must be in range [0, 2 * PI). Got: {angle}\")\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.keypoints_utils.check_keypoints","title":"<code>def check_keypoints    (keypoints, rows, cols)    </code> [view source on GitHub]","text":"<p>Check if keypoints boundaries are less than image shapes</p> Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>def check_keypoints(keypoints: Sequence[KeypointType], rows: int, cols: int) -&gt; None:\n    \"\"\"Check if keypoints boundaries are less than image shapes\"\"\"\n    for kp in keypoints:\n        check_keypoint(kp, rows, cols)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization","title":"<code>serialization</code>","text":""},{"location":"api_reference/full_reference/#albumentations.core.serialization.Serializable","title":"<code>class  Serializable</code> <code> </code>  [view source on GitHub]","text":"Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>class Serializable(metaclass=SerializableMeta):\n    @classmethod\n    @abstractmethod\n    def is_serializable(cls) -&gt; bool:\n        raise NotImplementedError\n\n    @classmethod\n    @abstractmethod\n    def get_class_fullname(cls) -&gt; str:\n        raise NotImplementedError\n\n    @abstractmethod\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        raise NotImplementedError\n\n    def to_dict(self, on_not_implemented_error: str = \"raise\") -&gt; Dict[str, Any]:\n        \"\"\"Take a transform pipeline and convert it to a serializable representation that uses only standard\n        python data types: dictionaries, lists, strings, integers, and floats.\n\n        Args:\n            self: A transform that should be serialized. If the transform doesn't implement the `to_dict`\n                method and `on_not_implemented_error` equals to 'raise' then `NotImplementedError` is raised.\n                If `on_not_implemented_error` equals to 'warn' then `NotImplementedError` will be ignored\n                but no transform parameters will be serialized.\n            on_not_implemented_error (str): `raise` or `warn`.\n\n        \"\"\"\n        if on_not_implemented_error not in {\"raise\", \"warn\"}:\n            msg = f\"Unknown on_not_implemented_error value: {on_not_implemented_error}. Supported values are: 'raise' \"\n            \"and 'warn'\"\n            raise ValueError(msg)\n        try:\n            transform_dict = self.to_dict_private()\n        except NotImplementedError:\n            if on_not_implemented_error == \"raise\":\n                raise\n\n            transform_dict = {}\n            warnings.warn(\n                f\"Got NotImplementedError while trying to serialize {self}. Object arguments are not preserved. \"\n                f\"Implement either '{self.__class__.__name__}.get_transform_init_args_names' \"\n                f\"or '{self.__class__.__name__}.get_transform_init_args' \"\n                \"method to make the transform serializable\"\n            )\n        return {\"__version__\": __version__, \"transform\": transform_dict}\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.Serializable.to_dict","title":"<code>to_dict (self, on_not_implemented_error='raise')</code>","text":"<p>Take a transform pipeline and convert it to a serializable representation that uses only standard python data types: dictionaries, lists, strings, integers, and floats.</p> <p>Parameters:</p> Name Type Description <code>self</code> <p>A transform that should be serialized. If the transform doesn't implement the <code>to_dict</code> method and <code>on_not_implemented_error</code> equals to 'raise' then <code>NotImplementedError</code> is raised. If <code>on_not_implemented_error</code> equals to 'warn' then <code>NotImplementedError</code> will be ignored but no transform parameters will be serialized.</p> <code>on_not_implemented_error</code> <code>str</code> <p><code>raise</code> or <code>warn</code>.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def to_dict(self, on_not_implemented_error: str = \"raise\") -&gt; Dict[str, Any]:\n    \"\"\"Take a transform pipeline and convert it to a serializable representation that uses only standard\n    python data types: dictionaries, lists, strings, integers, and floats.\n\n    Args:\n        self: A transform that should be serialized. If the transform doesn't implement the `to_dict`\n            method and `on_not_implemented_error` equals to 'raise' then `NotImplementedError` is raised.\n            If `on_not_implemented_error` equals to 'warn' then `NotImplementedError` will be ignored\n            but no transform parameters will be serialized.\n        on_not_implemented_error (str): `raise` or `warn`.\n\n    \"\"\"\n    if on_not_implemented_error not in {\"raise\", \"warn\"}:\n        msg = f\"Unknown on_not_implemented_error value: {on_not_implemented_error}. Supported values are: 'raise' \"\n        \"and 'warn'\"\n        raise ValueError(msg)\n    try:\n        transform_dict = self.to_dict_private()\n    except NotImplementedError:\n        if on_not_implemented_error == \"raise\":\n            raise\n\n        transform_dict = {}\n        warnings.warn(\n            f\"Got NotImplementedError while trying to serialize {self}. Object arguments are not preserved. \"\n            f\"Implement either '{self.__class__.__name__}.get_transform_init_args_names' \"\n            f\"or '{self.__class__.__name__}.get_transform_init_args' \"\n            \"method to make the transform serializable\"\n        )\n    return {\"__version__\": __version__, \"transform\": transform_dict}\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.SerializableMeta","title":"<code>class  SerializableMeta</code> <code> </code>  [view source on GitHub]","text":"<p>A metaclass that is used to register classes in <code>SERIALIZABLE_REGISTRY</code> or <code>NON_SERIALIZABLE_REGISTRY</code> so they can be found later while deserializing transformation pipeline using classes full names.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>class SerializableMeta(ABCMeta):\n    \"\"\"A metaclass that is used to register classes in `SERIALIZABLE_REGISTRY` or `NON_SERIALIZABLE_REGISTRY`\n    so they can be found later while deserializing transformation pipeline using classes full names.\n    \"\"\"\n\n    def __new__(cls, name: str, bases: Tuple[type, ...], *args: Any, **kwargs: Any) -&gt; \"SerializableMeta\":\n        cls_obj = super().__new__(cls, name, bases, *args, **kwargs)\n        if name != \"Serializable\" and ABC not in bases:\n            if cls_obj.is_serializable():\n                SERIALIZABLE_REGISTRY[cls_obj.get_class_fullname()] = cls_obj\n            else:\n                NON_SERIALIZABLE_REGISTRY[cls_obj.get_class_fullname()] = cls_obj\n        return cls_obj\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return False\n\n    @classmethod\n    def get_class_fullname(cls) -&gt; str:\n        return get_shortest_class_fullname(cls)\n\n    @classmethod\n    def _to_dict(cls) -&gt; Dict[str, Any]:\n        return {}\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.SerializableMeta.__new__","title":"<code>__new__ (cls, name, bases, *args, **kwargs)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def __new__(cls, name: str, bases: Tuple[type, ...], *args: Any, **kwargs: Any) -&gt; \"SerializableMeta\":\n    cls_obj = super().__new__(cls, name, bases, *args, **kwargs)\n    if name != \"Serializable\" and ABC not in bases:\n        if cls_obj.is_serializable():\n            SERIALIZABLE_REGISTRY[cls_obj.get_class_fullname()] = cls_obj\n        else:\n            NON_SERIALIZABLE_REGISTRY[cls_obj.get_class_fullname()] = cls_obj\n    return cls_obj\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.from_dict","title":"<code>def from_dict    (transform_dict, nonserializable=None)    </code> [view source on GitHub]","text":"<p>transform_dict: A dictionary with serialized transform pipeline. nonserializable (dict): A dictionary that contains non-serializable transforms.     This dictionary is required when you are restoring a pipeline that contains non-serializable transforms.     Keys in that dictionary should be named same as <code>name</code> arguments in respective transforms from     a serialized pipeline.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def from_dict(\n    transform_dict: Dict[str, Any], nonserializable: Optional[Dict[str, Any]] = None\n) -&gt; Optional[Serializable]:\n    \"\"\"Args:\n    transform_dict: A dictionary with serialized transform pipeline.\n    nonserializable (dict): A dictionary that contains non-serializable transforms.\n        This dictionary is required when you are restoring a pipeline that contains non-serializable transforms.\n        Keys in that dictionary should be named same as `name` arguments in respective transforms from\n        a serialized pipeline.\n\n    \"\"\"\n    register_additional_transforms()\n    transform = transform_dict[\"transform\"]\n    lmbd = instantiate_nonserializable(transform, nonserializable)\n    if lmbd:\n        return lmbd\n    name = transform[\"__class_fullname__\"]\n    args = {k: v for k, v in transform.items() if k != \"__class_fullname__\"}\n    cls = SERIALIZABLE_REGISTRY[shorten_class_name(name)]\n    if \"transforms\" in args:\n        args[\"transforms\"] = [from_dict({\"transform\": t}, nonserializable=nonserializable) for t in args[\"transforms\"]]\n    return cls(**args)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.get_shortest_class_fullname","title":"<code>def get_shortest_class_fullname    (cls)    </code> [view source on GitHub]","text":"<p>The function <code>get_shortest_class_fullname</code> takes a class object as input and returns its shortened full name.</p> <p>:param cls: The parameter <code>cls</code> is of type <code>Type[BasicCompose]</code>, which means it expects a class that is a subclass of <code>BasicCompose</code> :type cls: Type[BasicCompose] :return: a string, which is the shortened version of the full class name.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def get_shortest_class_fullname(cls: Type[Any]) -&gt; str:\n    \"\"\"The function `get_shortest_class_fullname` takes a class object as input and returns its shortened\n    full name.\n\n    :param cls: The parameter `cls` is of type `Type[BasicCompose]`, which means it expects a class that\n    is a subclass of `BasicCompose`\n    :type cls: Type[BasicCompose]\n    :return: a string, which is the shortened version of the full class name.\n    \"\"\"\n    class_fullname = f\"{cls.__module__}.{cls.__name__}\"\n    return shorten_class_name(class_fullname)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.load","title":"<code>def load    (filepath_or_buffer, data_format='json', nonserializable=None)    </code> [view source on GitHub]","text":"<p>Load a serialized pipeline from a file or file-like object and construct a transform pipeline.</p> <p>Parameters:</p> Name Type Description <code>filepath_or_buffer</code> <code>Union[str, Path, TextIO]</code> <p>The file path or file-like object to read the serialized data from. If a string is provided, it is interpreted as a path to a file. If a file-like object is provided, the serialized data will be read from it directly.</p> <code>data_format</code> <code>str</code> <p>The format of the serialized data. Valid options are 'json' and 'yaml'. Defaults to 'json'.</p> <code>nonserializable</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary that contains non-serializable transforms. This dictionary is required when restoring a pipeline that contains non-serializable transforms. Keys in the dictionary should be named the same as the <code>name</code> arguments in respective transforms from the serialized pipeline. Defaults to None.</p> <p>Returns:</p> Type Description <code>object</code> <p>The deserialized transform pipeline.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If <code>data_format</code> is 'yaml' but PyYAML is not installed.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def load(\n    filepath_or_buffer: Union[str, Path, TextIO],\n    data_format: str = \"json\",\n    nonserializable: Optional[Dict[str, Any]] = None,\n) -&gt; object:\n    \"\"\"Load a serialized pipeline from a file or file-like object and construct a transform pipeline.\n\n    Args:\n        filepath_or_buffer (Union[str, Path, TextIO]): The file path or file-like object to read the serialized\n            data from.\n            If a string is provided, it is interpreted as a path to a file. If a file-like object is provided,\n            the serialized data will be read from it directly.\n        data_format (str): The format of the serialized data. Valid options are 'json' and 'yaml'.\n            Defaults to 'json'.\n        nonserializable (Optional[Dict[str, Any]]): A dictionary that contains non-serializable transforms.\n            This dictionary is required when restoring a pipeline that contains non-serializable transforms.\n            Keys in the dictionary should be named the same as the `name` arguments in respective transforms\n            from the serialized pipeline. Defaults to None.\n\n    Returns:\n        object: The deserialized transform pipeline.\n\n    Raises:\n        ValueError: If `data_format` is 'yaml' but PyYAML is not installed.\n\n    \"\"\"\n    check_data_format(data_format)\n\n    if isinstance(filepath_or_buffer, (str, Path)):  # Assume it's a filepath\n        with open(filepath_or_buffer) as f:\n            if data_format == \"json\":\n                transform_dict = json.load(f)\n            else:\n                if not yaml_available:\n                    msg = \"You need to install PyYAML to load a pipeline in yaml format\"\n                    raise ValueError(msg)\n                transform_dict = yaml.safe_load(f)\n    elif data_format == \"json\":\n        transform_dict = json.load(filepath_or_buffer)\n    else:\n        if not yaml_available:\n            msg = \"You need to install PyYAML to load a pipeline in yaml format\"\n            raise ValueError(msg)\n        transform_dict = yaml.safe_load(filepath_or_buffer)\n\n    return from_dict(transform_dict, nonserializable=nonserializable)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.register_additional_transforms","title":"<code>def register_additional_transforms    ()    </code> [view source on GitHub]","text":"<p>Register transforms that are not imported directly into the <code>albumentations</code> module by checking the availability of optional dependencies.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def register_additional_transforms() -&gt; None:\n    \"\"\"Register transforms that are not imported directly into the `albumentations` module by checking\n    the availability of optional dependencies.\n    \"\"\"\n    if importlib.util.find_spec(\"torch\") is not None:\n        try:\n            # Import `albumentations.pytorch` only if `torch` is installed.\n            import albumentations.pytorch\n\n            # Use a dummy operation to acknowledge the use of the imported module and avoid linting errors.\n            _ = albumentations.pytorch.ToTensorV2\n        except ImportError:\n            pass\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.save","title":"<code>def save    (transform, filepath_or_buffer, data_format='json', on_not_implemented_error='raise')    </code> [view source on GitHub]","text":"<p>Serialize a transform pipeline and save it to either a file specified by a path or a file-like object in either JSON or YAML format.</p> <p>Parameters:</p> Name Type Description <code>transform</code> <code>Serializable</code> <p>The transform pipeline to serialize.</p> <code>filepath_or_buffer</code> <code>Union[str, Path, TextIO]</code> <p>The file path or file-like object to write the serialized data to. If a string is provided, it is interpreted as a path to a file. If a file-like object is provided, the serialized data will be written to it directly.</p> <code>data_format</code> <code>str</code> <p>The format to serialize the data in. Valid options are 'json' and 'yaml'. Defaults to 'json'.</p> <code>on_not_implemented_error</code> <code>str</code> <p>Determines the behavior if a transform does not implement the <code>to_dict</code> method. If set to 'raise', a <code>NotImplementedError</code> is raised. If set to 'warn', the exception is ignored, and no transform arguments are saved. Defaults to 'raise'.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If <code>data_format</code> is 'yaml' but PyYAML is not installed.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def save(\n    transform: \"Serializable\",\n    filepath_or_buffer: Union[str, Path, TextIO],\n    data_format: str = \"json\",\n    on_not_implemented_error: str = \"raise\",\n) -&gt; None:\n    \"\"\"Serialize a transform pipeline and save it to either a file specified by a path or a file-like object\n    in either JSON or YAML format.\n\n    Args:\n        transform (Serializable): The transform pipeline to serialize.\n        filepath_or_buffer (Union[str, Path, TextIO]): The file path or file-like object to write the serialized\n            data to.\n            If a string is provided, it is interpreted as a path to a file. If a file-like object is provided,\n            the serialized data will be written to it directly.\n        data_format (str): The format to serialize the data in. Valid options are 'json' and 'yaml'.\n            Defaults to 'json'.\n        on_not_implemented_error (str): Determines the behavior if a transform does not implement the `to_dict` method.\n            If set to 'raise', a `NotImplementedError` is raised. If set to 'warn', the exception is ignored, and\n            no transform arguments are saved. Defaults to 'raise'.\n\n    Raises:\n        ValueError: If `data_format` is 'yaml' but PyYAML is not installed.\n\n    \"\"\"\n    check_data_format(data_format)\n    transform_dict = transform.to_dict(on_not_implemented_error=on_not_implemented_error)\n    transform_dict = serialize_enum(transform_dict)\n\n    # Determine whether to write to a file or a file-like object\n    if isinstance(filepath_or_buffer, (str, Path)):  # It's a filepath\n        with open(filepath_or_buffer, \"w\") as f:\n            if data_format == \"yaml\":\n                if not yaml_available:\n                    msg = \"You need to install PyYAML to save a pipeline in YAML format\"\n                    raise ValueError(msg)\n                yaml.safe_dump(transform_dict, f, default_flow_style=False)\n            elif data_format == \"json\":\n                json.dump(transform_dict, f)\n    elif data_format == \"yaml\":\n        if not yaml_available:\n            msg = \"You need to install PyYAML to save a pipeline in YAML format\"\n            raise ValueError(msg)\n        yaml.safe_dump(transform_dict, filepath_or_buffer, default_flow_style=False)\n    elif data_format == \"json\":\n        json.dump(transform_dict, filepath_or_buffer)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.serialize_enum","title":"<code>def serialize_enum    (obj)    </code> [view source on GitHub]","text":"<p>Recursively search for Enum objects and convert them to their value. Also handle any Mapping or Sequence types.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def serialize_enum(obj: Any) -&gt; Any:\n    \"\"\"Recursively search for Enum objects and convert them to their value.\n    Also handle any Mapping or Sequence types.\n    \"\"\"\n    if isinstance(obj, Mapping):\n        return {k: serialize_enum(v) for k, v in obj.items()}\n    if isinstance(obj, Sequence) and not isinstance(obj, str):  # exclude strings since they're also sequences\n        return [serialize_enum(v) for v in obj]\n    return obj.value if isinstance(obj, Enum) else obj\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.serialization.to_dict","title":"<code>def to_dict    (transform, on_not_implemented_error='raise')    </code> [view source on GitHub]","text":"<p>Take a transform pipeline and convert it to a serializable representation that uses only standard python data types: dictionaries, lists, strings, integers, and floats.</p> <p>Parameters:</p> Name Type Description <code>transform</code> <code>Serializable</code> <p>A transform that should be serialized. If the transform doesn't implement the <code>to_dict</code> method and <code>on_not_implemented_error</code> equals to 'raise' then <code>NotImplementedError</code> is raised. If <code>on_not_implemented_error</code> equals to 'warn' then <code>NotImplementedError</code> will be ignored but no transform parameters will be serialized.</p> <code>on_not_implemented_error</code> <code>str</code> <p><code>raise</code> or <code>warn</code>.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def to_dict(transform: Serializable, on_not_implemented_error: str = \"raise\") -&gt; Dict[str, Any]:\n    \"\"\"Take a transform pipeline and convert it to a serializable representation that uses only standard\n    python data types: dictionaries, lists, strings, integers, and floats.\n\n    Args:\n        transform: A transform that should be serialized. If the transform doesn't implement the `to_dict`\n            method and `on_not_implemented_error` equals to 'raise' then `NotImplementedError` is raised.\n            If `on_not_implemented_error` equals to 'warn' then `NotImplementedError` will be ignored\n            but no transform parameters will be serialized.\n        on_not_implemented_error (str): `raise` or `warn`.\n\n    \"\"\"\n    return transform.to_dict(on_not_implemented_error)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.transforms_interface","title":"<code>transforms_interface</code>","text":""},{"location":"api_reference/full_reference/#albumentations.core.transforms_interface.BasicTransform","title":"<code>class  BasicTransform</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>class BasicTransform(Serializable, metaclass=CombinedMeta):\n    call_backup = None\n    interpolation: Union[int, Interpolation]\n    fill_value: ColorType\n    mask_fill_value: Optional[ColorType]\n\n    class InitSchema(BaseTransformInitSchema):\n        pass\n\n    def __init__(self, always_apply: bool = False, p: float = 0.5):\n        self.p = p\n        self.always_apply = always_apply\n        self._additional_targets: Dict[str, str] = {}\n\n        # replay mode params\n        self.deterministic = False\n        self.save_key = \"replay\"\n        self.params: Dict[Any, Any] = {}\n        self.replay_mode = False\n        self.applied_in_replay = False\n\n    def __call__(self, *args: Any, force_apply: bool = False, **kwargs: Any) -&gt; Any:\n        if args:\n            msg = \"You have to pass data to augmentations as named arguments, for example: aug(image=image)\"\n            raise KeyError(msg)\n        if self.replay_mode:\n            if self.applied_in_replay:\n                return self.apply_with_params(self.params, **kwargs)\n\n            return kwargs\n\n        if force_apply or self.always_apply or (random.random() &lt; self.p):\n            params = self.get_params()\n\n            if self.targets_as_params:\n                if not all(key in kwargs for key in self.targets_as_params):\n                    msg = f\"{self.__class__.__name__} requires {self.targets_as_params}\"\n                    raise ValueError(msg)\n\n                targets_as_params = {k: kwargs[k] for k in self.targets_as_params}\n                params_dependent_on_targets = self.get_params_dependent_on_targets(targets_as_params)\n                params.update(params_dependent_on_targets)\n            if self.deterministic:\n                if self.targets_as_params:\n                    warn(\n                        self.get_class_fullname() + \" could work incorrectly in ReplayMode for other input data\"\n                        \" because its' params depend on targets.\"\n                    )\n                kwargs[self.save_key][id(self)] = deepcopy(params)\n            return self.apply_with_params(params, **kwargs)\n\n        return kwargs\n\n    def apply_with_params(self, params: Dict[str, Any], *args: Any, **kwargs: Any) -&gt; Dict[str, Any]:\n        if params is None:\n            return kwargs\n        params = self.update_params(params, **kwargs)\n        res = {}\n        for key, arg in kwargs.items():\n            if arg is not None:\n                target_function = self._get_target_function(key)\n                target_dependencies = {k: kwargs[k] for k in self.target_dependence.get(key, [])}\n                res[key] = target_function(arg, **dict(params, **target_dependencies))\n            else:\n                res[key] = None\n        return res\n\n    def set_deterministic(self, flag: bool, save_key: str = \"replay\") -&gt; \"BasicTransform\":\n        if save_key == \"params\":\n            msg = \"params save_key is reserved\"\n            raise KeyError(msg)\n\n        self.deterministic = flag\n        self.save_key = save_key\n        return self\n\n    def __repr__(self) -&gt; str:\n        state = self.get_base_init_args()\n        state.update(self.get_transform_init_args())\n        return f\"{self.__class__.__name__}({format_args(state)})\"\n\n    def _get_target_function(self, key: str) -&gt; Callable[..., Any]:\n        transform_key = key\n        if key in self._additional_targets:\n            transform_key = self._additional_targets.get(key, key)\n\n        return self.targets.get(transform_key, lambda x, **p: x)\n\n    def apply(self, img: np.ndarray, *args: Any, **params: Any) -&gt; np.ndarray:\n        raise NotImplementedError\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {}\n\n    @property\n    def targets(self) -&gt; Dict[str, Callable[..., Any]]:\n        # you must specify targets in subclass\n        # foe example:\n        # &gt;&gt;  ('image', 'mask')\n        # &gt;&gt;  ('image', 'boxes')\n        raise NotImplementedError\n\n    def update_params(self, params: Dict[str, Any], **kwargs: Any) -&gt; Dict[str, Any]:\n        if hasattr(self, \"interpolation\"):\n            params[\"interpolation\"] = self.interpolation\n        if hasattr(self, \"fill_value\"):\n            params[\"fill_value\"] = self.fill_value\n        if hasattr(self, \"mask_fill_value\"):\n            params[\"mask_fill_value\"] = self.mask_fill_value\n        params.update({\"cols\": kwargs[\"image\"].shape[1], \"rows\": kwargs[\"image\"].shape[0]})\n        return params\n\n    @property\n    def target_dependence(self) -&gt; Dict[str, Any]:\n        return {}\n\n    def add_targets(self, additional_targets: Dict[str, str]) -&gt; None:\n        \"\"\"Add targets to transform them the same way as one of existing targets\n        ex: {'target_image': 'image'}\n        ex: {'obj1_mask': 'mask', 'obj2_mask': 'mask'}\n        by the way you must have at least one object with key 'image'\n\n        Args:\n            additional_targets (dict): keys - new target name, values - old target name. ex: {'image2': 'image'}\n\n        \"\"\"\n        self._additional_targets = additional_targets\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return []\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        raise NotImplementedError(\n            \"Method get_params_dependent_on_targets is not implemented in class \" + self.__class__.__name__\n        )\n\n    @classmethod\n    def get_class_fullname(cls) -&gt; str:\n        return get_shortest_class_fullname(cls)\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return True\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        msg = f\"Class {self.get_class_fullname()} is not serializable because the `get_transform_init_args_names` \"\n        \"method is not implemented\"\n        raise NotImplementedError(msg)\n\n    def get_base_init_args(self) -&gt; Dict[str, Any]:\n        return {\"always_apply\": self.always_apply, \"p\": self.p}\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {k: getattr(self, k) for k in self.get_transform_init_args_names()}\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        state = {\"__class_fullname__\": self.get_class_fullname()}\n        state.update(self.get_base_init_args())\n        state.update(self.get_transform_init_args())\n\n        return state\n\n    def get_dict_with_id(self) -&gt; Dict[str, Any]:\n        d = self.to_dict_private()\n        d[\"id\"] = id(self)\n        return d\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.transforms_interface.BasicTransform.add_targets","title":"<code>add_targets (self, additional_targets)</code>","text":"<p>Add targets to transform them the same way as one of existing targets ex: {'target_image': 'image'} ex: {'obj1_mask': 'mask', 'obj2_mask': 'mask'} by the way you must have at least one object with key 'image'</p> <p>Parameters:</p> Name Type Description <code>additional_targets</code> <code>dict</code> <p>keys - new target name, values - old target name. ex: {'image2': 'image'}</p> Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>def add_targets(self, additional_targets: Dict[str, str]) -&gt; None:\n    \"\"\"Add targets to transform them the same way as one of existing targets\n    ex: {'target_image': 'image'}\n    ex: {'obj1_mask': 'mask', 'obj2_mask': 'mask'}\n    by the way you must have at least one object with key 'image'\n\n    Args:\n        additional_targets (dict): keys - new target name, values - old target name. ex: {'image2': 'image'}\n\n    \"\"\"\n    self._additional_targets = additional_targets\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.transforms_interface.DualTransform","title":"<code>class  DualTransform</code> <code> </code>  [view source on GitHub]","text":"<p>A base class for transformations that should be applied both to an image and its corresponding properties such as masks, bounding boxes, and keypoints. This class ensures that when a transform is applied to an image, all associated entities are transformed accordingly to maintain consistency between the image and its annotations.</p> <p>Properties</p> <p>targets (Dict[str, Callable[..., Any]]): Defines the types of targets (e.g., image, mask, bboxes, keypoints)     that the transform should be applied to and maps them to the corresponding methods.</p> <p>Methods</p> <p>apply_to_bbox(bbox: BoxInternalType, args: Any, *params: Any) -&gt; BoxInternalType:     Applies the transform to a single bounding box. Should be implemented in the subclass.</p> <p>apply_to_keypoint(keypoint: KeypointInternalType, args: Any, *params: Any) -&gt; KeypointInternalType:     Applies the transform to a single keypoint. Should be implemented in the subclass.</p> <p>apply_to_bboxes(bboxes: Sequence[BoxType], args: Any, *params: Any) -&gt; Sequence[BoxType]:     Applies the transform to a list of bounding boxes. Delegates to <code>apply_to_bbox</code> for each bounding box.</p> <p>apply_to_keypoints(keypoints: Sequence[KeypointType], args: Any, *params: Any) -&gt; Sequence[KeypointType]:     Applies the transform to a list of keypoints. Delegates to <code>apply_to_keypoint</code> for each keypoint.</p> <p>apply_to_mask(mask: np.ndarray, args: Any, *params: Any) -&gt; np.ndarray:     Applies the transform specifically to a single mask.</p> <p>apply_to_masks(masks: Sequence[np.ndarray], **params: Any) -&gt; List[np.ndarray]:     Applies the transform to a list of masks. Delegates to <code>apply_to_mask</code> for each mask.</p> <p>Note</p> <p>This class is intended to be subclassed and should not be used directly. Subclasses are expected to implement the specific logic for each type of target (e.g., image, mask, bboxes, keypoints) in the corresponding <code>apply_to_*</code> methods.</p> Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>class DualTransform(BasicTransform):\n    \"\"\"A base class for transformations that should be applied both to an image and its corresponding properties\n    such as masks, bounding boxes, and keypoints. This class ensures that when a transform is applied to an image,\n    all associated entities are transformed accordingly to maintain consistency between the image and its annotations.\n\n    Properties:\n        targets (Dict[str, Callable[..., Any]]): Defines the types of targets (e.g., image, mask, bboxes, keypoints)\n            that the transform should be applied to and maps them to the corresponding methods.\n\n    Methods:\n        apply_to_bbox(bbox: BoxInternalType, *args: Any, **params: Any) -&gt; BoxInternalType:\n            Applies the transform to a single bounding box. Should be implemented in the subclass.\n\n        apply_to_keypoint(keypoint: KeypointInternalType, *args: Any, **params: Any) -&gt; KeypointInternalType:\n            Applies the transform to a single keypoint. Should be implemented in the subclass.\n\n        apply_to_bboxes(bboxes: Sequence[BoxType], *args: Any, **params: Any) -&gt; Sequence[BoxType]:\n            Applies the transform to a list of bounding boxes. Delegates to `apply_to_bbox` for each bounding box.\n\n        apply_to_keypoints(keypoints: Sequence[KeypointType], *args: Any, **params: Any) -&gt; Sequence[KeypointType]:\n            Applies the transform to a list of keypoints. Delegates to `apply_to_keypoint` for each keypoint.\n\n        apply_to_mask(mask: np.ndarray, *args: Any, **params: Any) -&gt; np.ndarray:\n            Applies the transform specifically to a single mask.\n\n        apply_to_masks(masks: Sequence[np.ndarray], **params: Any) -&gt; List[np.ndarray]:\n            Applies the transform to a list of masks. Delegates to `apply_to_mask` for each mask.\n\n    Note:\n        This class is intended to be subclassed and should not be used directly. Subclasses are expected to\n        implement the specific logic for each type of target (e.g., image, mask, bboxes, keypoints) in the\n        corresponding `apply_to_*` methods.\n\n    \"\"\"\n\n    @property\n    def targets(self) -&gt; Dict[str, Callable[..., Any]]:\n        return {\n            \"image\": self.apply,\n            \"mask\": self.apply_to_mask,\n            \"masks\": self.apply_to_masks,\n            \"bboxes\": self.apply_to_bboxes,\n            \"keypoints\": self.apply_to_keypoints,\n        }\n\n    def apply_to_bbox(self, bbox: BoxInternalType, *args: Any, **params: Any) -&gt; BoxInternalType:\n        msg = f\"Method apply_to_bbox is not implemented in class {self.__class__.__name__}\"\n        raise NotImplementedError(msg)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, *args: Any, **params: Any) -&gt; KeypointInternalType:\n        msg = f\"Method apply_to_keypoint is not implemented in class {self.__class__.__name__}\"\n        raise NotImplementedError(msg)\n\n    def apply_to_global_label(self, label: np.ndarray, *args: Any, **params: Any) -&gt; np.ndarray:\n        msg = f\"Method apply_to_global_label is not implemented in class {self.__class__.__name__}\"\n        raise NotImplementedError(msg)\n\n    def apply_to_bboxes(self, bboxes: Sequence[BoxType], *args: Any, **params: Any) -&gt; Sequence[BoxType]:\n        return [\n            self.apply_to_bbox(cast(BoxInternalType, tuple(cast(BoxInternalType, bbox[:4]))), **params)\n            + tuple(bbox[4:])\n            for bbox in bboxes\n        ]\n\n    def apply_to_keypoints(\n        self, keypoints: Sequence[KeypointType], *args: Any, **params: Any\n    ) -&gt; Sequence[KeypointType]:\n        return [\n            self.apply_to_keypoint(cast(KeypointInternalType, tuple(keypoint[:4])), **params) + tuple(keypoint[4:])\n            for keypoint in keypoints\n        ]\n\n    def apply_to_mask(self, mask: np.ndarray, *args: Any, **params: Any) -&gt; np.ndarray:\n        return self.apply(mask, **{k: cv2.INTER_NEAREST if k == \"interpolation\" else v for k, v in params.items()})\n\n    def apply_to_masks(self, masks: Sequence[np.ndarray], **params: Any) -&gt; List[np.ndarray]:\n        return [self.apply_to_mask(mask, **params) for mask in masks]\n\n    def apply_to_global_labels(self, labels: Sequence[np.ndarray], **params: Any) -&gt; List[np.ndarray]:\n        return [self.apply_to_global_label(label, **params) for label in labels]\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.transforms_interface.ImageOnlyTransform","title":"<code>class  ImageOnlyTransform</code> <code> </code>  [view source on GitHub]","text":"<p>Transform applied to image only.</p> Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>class ImageOnlyTransform(BasicTransform):\n    \"\"\"Transform applied to image only.\"\"\"\n\n    _targets = Targets.IMAGE\n\n    @property\n    def targets(self) -&gt; Dict[str, Callable[..., Any]]:\n        return {\"image\": self.apply}\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.transforms_interface.NoOp","title":"<code>class  NoOp</code> <code> </code>  [view source on GitHub]","text":"<p>Does nothing</p> <p>Targets</p> <p>image, mask, bboxes, keypoints, global_label</p> Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>class NoOp(DualTransform):\n    \"\"\"Does nothing\n\n    Targets:\n        image, mask, bboxes, keypoints, global_label\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS, Targets.GLOBAL_LABEL)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return keypoint\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return bbox\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return img\n\n    def apply_to_mask(self, mask: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return mask\n\n    def apply_to_global_label(self, label: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return label\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return ()\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.types","title":"<code>types</code>","text":""},{"location":"api_reference/full_reference/#albumentations.core.types.ImageCompressionType","title":"<code>class  ImageCompressionType</code> <code> </code>","text":"<p>Defines the types of image compression.</p> <p>This Enum class is used to specify the image compression format.</p> <p>Attributes:</p> Name Type Description <code>JPEG</code> <code>int</code> <p>Represents the JPEG image compression format.</p> <code>WEBP</code> <code>int</code> <p>Represents the WEBP image compression format.</p> Source code in <code>albumentations/core/types.py</code> Python<pre><code>class ImageCompressionType(IntEnum):\n    \"\"\"Defines the types of image compression.\n\n    This Enum class is used to specify the image compression format.\n\n    Attributes:\n        JPEG (int): Represents the JPEG image compression format.\n        WEBP (int): Represents the WEBP image compression format.\n\n    \"\"\"\n\n    JPEG = 0\n    WEBP = 1\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.types.Targets","title":"<code>class  Targets</code> <code> </code>","text":"<p>An enumeration.</p> Source code in <code>albumentations/core/types.py</code> Python<pre><code>class Targets(Enum):\n    IMAGE = \"Image\"\n    MASK = \"Mask\"\n    BBOXES = \"BBoxes\"\n    KEYPOINTS = \"Keypoints\"\n    GLOBAL_LABEL = \"Global Label\"\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.utils","title":"<code>utils</code>","text":""},{"location":"api_reference/full_reference/#albumentations.core.utils.to_tuple","title":"<code>def to_tuple    (param, low=None, bias=None)    </code> [view source on GitHub]","text":"<p>Convert input argument to a min-max tuple.</p> <p>Parameters:</p> Name Type Description <code>param</code> <code>Union[float, Tuple[float, float], int, Tuple[int, int]]</code> <p>Input value which could be a scalar or a sequence of exactly 2 scalars.</p> <code>low</code> <code>Union[float, Tuple[float, float], int, Tuple[int, int]]</code> <p>Second element of the tuple, provided as an optional argument for when <code>param</code> is a scalar.</p> <code>bias</code> <code>Union[int, float]</code> <p>An offset added to both elements of the tuple.</p> <p>Returns:</p> Type Description <code>Union[Tuple[int, int], Tuple[float, float]]</code> <p>A tuple of two scalars, optionally adjusted by <code>bias</code>. Raises ValueError for invalid combinations or types of arguments.</p> Source code in <code>albumentations/core/utils.py</code> Python<pre><code>def to_tuple(\n    param: ScaleType,\n    low: Optional[ScaleType] = None,\n    bias: Optional[ScalarType] = None,\n) -&gt; Union[Tuple[int, int], Tuple[float, float]]:\n    \"\"\"Convert input argument to a min-max tuple.\n\n    Args:\n        param: Input value which could be a scalar or a sequence of exactly 2 scalars.\n        low: Second element of the tuple, provided as an optional argument for when `param` is a scalar.\n        bias: An offset added to both elements of the tuple.\n\n    Returns:\n        A tuple of two scalars, optionally adjusted by `bias`.\n        Raises ValueError for invalid combinations or types of arguments.\n\n    \"\"\"\n    # Validate mutually exclusive arguments\n    if low is not None and bias is not None:\n        msg = \"Arguments 'low' and 'bias' cannot be used together.\"\n        raise ValueError(msg)\n\n    if isinstance(param, Sequence) and len(param) == PAIR:\n        min_val, max_val = min(param), max(param)\n\n    # Handle scalar input\n    elif isinstance(param, (int, float)):\n        if isinstance(low, (int, float)):\n            # Use low and param to create a tuple\n            min_val, max_val = (low, param) if low &lt; param else (param, low)\n        else:\n            # Create a symmetric tuple around 0\n            min_val, max_val = -param, param\n    else:\n        msg = \"Argument 'param' must be either a scalar or a sequence of 2 elements.\"\n        raise ValueError(msg)\n\n    # Apply bias if provided\n    if bias is not None:\n        return (bias + min_val, bias + max_val)\n\n    return min_val, max_val\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.validation","title":"<code>validation</code>","text":""},{"location":"api_reference/full_reference/#albumentations.core.validation.ValidatedTransformMeta","title":"<code>class  ValidatedTransformMeta</code> <code> </code>  [view source on GitHub]","text":"Source code in <code>albumentations/core/validation.py</code> Python<pre><code>class ValidatedTransformMeta(type):\n    def __new__(cls: Type[Any], name: str, bases: Tuple[type, ...], dct: Dict[str, Any]) -&gt; Type[Any]:\n        if \"InitSchema\" in dct and issubclass(dct[\"InitSchema\"], BaseModel):\n            original_init: Optional[Callable[..., Any]] = dct.get(\"__init__\")\n            if original_init is None:\n                msg = \"__init__ not found in class definition\"\n                raise ValueError(msg)\n\n            def custom_init(self: Any, *args: Any, **kwargs: Any) -&gt; None:\n                init_params = signature(original_init).parameters\n                param_names = list(init_params.keys())[1:]  # Exclude 'self'\n                full_kwargs: Dict[str, Any] = dict(zip(param_names, args))\n                full_kwargs.update(kwargs)\n\n                for name, param in init_params.items():\n                    if name != \"self\" and name not in full_kwargs and param.default is not Parameter.empty:\n                        full_kwargs[name] = param.default\n\n                # No try-except block needed as we want the exception to propagate naturally\n                config = dct[\"InitSchema\"](**full_kwargs)\n\n                validated_kwargs = config.model_dump()\n\n                original_init(self, **validated_kwargs)\n\n            # Rename __init__ to custom_init to avoid the N807 warning\n            dct[\"__init__\"] = custom_init\n\n        return super().__new__(cls, name, bases, dct)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.core.validation.ValidatedTransformMeta.__new__","title":"<code>__new__ (cls, name, bases, dct)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p> Source code in <code>albumentations/core/validation.py</code> Python<pre><code>def __new__(cls: Type[Any], name: str, bases: Tuple[type, ...], dct: Dict[str, Any]) -&gt; Type[Any]:\n    if \"InitSchema\" in dct and issubclass(dct[\"InitSchema\"], BaseModel):\n        original_init: Optional[Callable[..., Any]] = dct.get(\"__init__\")\n        if original_init is None:\n            msg = \"__init__ not found in class definition\"\n            raise ValueError(msg)\n\n        def custom_init(self: Any, *args: Any, **kwargs: Any) -&gt; None:\n            init_params = signature(original_init).parameters\n            param_names = list(init_params.keys())[1:]  # Exclude 'self'\n            full_kwargs: Dict[str, Any] = dict(zip(param_names, args))\n            full_kwargs.update(kwargs)\n\n            for name, param in init_params.items():\n                if name != \"self\" and name not in full_kwargs and param.default is not Parameter.empty:\n                    full_kwargs[name] = param.default\n\n            # No try-except block needed as we want the exception to propagate naturally\n            config = dct[\"InitSchema\"](**full_kwargs)\n\n            validated_kwargs = config.model_dump()\n\n            original_init(self, **validated_kwargs)\n\n        # Rename __init__ to custom_init to avoid the N807 warning\n        dct[\"__init__\"] = custom_init\n\n    return super().__new__(cls, name, bases, dct)\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.pytorch","title":"<code>pytorch</code>  <code>special</code>","text":""},{"location":"api_reference/full_reference/#albumentations.pytorch.transforms","title":"<code>transforms</code>","text":""},{"location":"api_reference/full_reference/#albumentations.pytorch.transforms.ToTensorV2","title":"<code>class  ToTensorV2</code> <code>       (transpose_mask=False, always_apply=True, p=1.0)                   </code>  [view source on GitHub]","text":"<p>Converts images/masks to PyTorch Tensors, inheriting from BasicTransform. Supports images in numpy <code>HWC</code> format and converts them to PyTorch <code>CHW</code> format. If the image is in <code>HW</code> format, it will be converted to PyTorch <code>HW</code>.</p> <p>Attributes:</p> Name Type Description <code>transpose_mask</code> <code>bool</code> <p>If True, transposes 3D input mask dimensions from <code>[height, width, num_channels]</code> to <code>[num_channels, height, width]</code>.</p> <code>always_apply</code> <code>bool</code> <p>Indicates if this transformation should be always applied. Default: True.</p> <code>p</code> <code>float</code> <p>Probability of applying the transform. Default: 1.0.</p> Source code in <code>albumentations/pytorch/transforms.py</code> Python<pre><code>class ToTensorV2(BasicTransform):\n    \"\"\"Converts images/masks to PyTorch Tensors, inheriting from BasicTransform. Supports images in numpy `HWC` format\n    and converts them to PyTorch `CHW` format. If the image is in `HW` format, it will be converted to PyTorch `HW`.\n\n    Attributes:\n        transpose_mask (bool): If True, transposes 3D input mask dimensions from `[height, width, num_channels]` to\n            `[num_channels, height, width]`.\n        always_apply (bool): Indicates if this transformation should be always applied. Default: True.\n        p (float): Probability of applying the transform. Default: 1.0.\n\n    \"\"\"\n\n    def __init__(self, transpose_mask: bool = False, always_apply: bool = True, p: float = 1.0):\n        super().__init__(always_apply=always_apply, p=p)\n        self.transpose_mask = transpose_mask\n\n    @property\n    def targets(self) -&gt; Dict[str, Any]:\n        return {\"image\": self.apply, \"mask\": self.apply_to_mask, \"masks\": self.apply_to_masks}\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; torch.Tensor:\n        if len(img.shape) not in [2, 3]:\n            msg = \"Albumentations only supports images in HW or HWC format\"\n            raise ValueError(msg)\n\n        if len(img.shape) == TWO:\n            img = np.expand_dims(img, 2)\n\n        return torch.from_numpy(img.transpose(2, 0, 1))\n\n    def apply_to_mask(self, mask: np.ndarray, **params: Any) -&gt; torch.Tensor:\n        if self.transpose_mask and mask.ndim == THREE:\n            mask = mask.transpose(2, 0, 1)\n        return torch.from_numpy(mask)\n\n    def apply_to_masks(self, masks: List[np.ndarray], **params: Any) -&gt; List[torch.Tensor]:\n        return [self.apply_to_mask(mask, **params) for mask in masks]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"transpose_mask\",)\n\n    def get_params_dependent_on_targets(self, params: Any) -&gt; Dict[str, Any]:\n        return {}\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.pytorch.transforms.ToTensorV2.__init__","title":"<code>__init__ (self, transpose_mask=False, always_apply=True, p=1.0)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/pytorch/transforms.py</code> Python<pre><code>def __init__(self, transpose_mask: bool = False, always_apply: bool = True, p: float = 1.0):\n    super().__init__(always_apply=always_apply, p=p)\n    self.transpose_mask = transpose_mask\n</code></pre>"},{"location":"api_reference/full_reference/#albumentations.random_utils","title":"<code>random_utils</code>","text":""},{"location":"api_reference/full_reference/#albumentations.random_utils.shuffle","title":"<code>def shuffle    (a, random_state=None)    </code> [view source on GitHub]","text":"<p>Shuffles an array in-place, using a specified random state or creating a new one if not provided.</p> <p>Parameters:</p> Name Type Description <code>a</code> <code>np.ndarray</code> <p>The array to be shuffled.</p> <code>random_state</code> <code>Optional[np.random.RandomState]</code> <p>The random state used for shuffling. Defaults to None.</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The shuffled array (note: the shuffle is in-place, so the original array is modified).</p> Source code in <code>albumentations/random_utils.py</code> Python<pre><code>def shuffle(\n    a: np.ndarray,\n    random_state: Optional[np.random.RandomState] = None,\n) -&gt; np.ndarray:\n    \"\"\"Shuffles an array in-place, using a specified random state or creating a new one if not provided.\n\n    Args:\n        a (np.ndarray): The array to be shuffled.\n        random_state (Optional[np.random.RandomState], optional): The random state used for shuffling. Defaults to None.\n\n    Returns:\n        np.ndarray: The shuffled array (note: the shuffle is in-place, so the original array is modified).\n    \"\"\"\n    if random_state is None:\n        random_state = get_random_state()\n    random_state.shuffle(a)\n    return a\n</code></pre>"},{"location":"api_reference/augmentations/","title":"Index","text":"<ul> <li>Transforms (albumentations.augmentations.transforms)</li> <li>Blur transforms (albumentations.augmentations.blur)</li> <li>Crop transforms (albumentations.augmentations.crops)</li> <li>Dropout transforms (albumentations.augmentations.dropout)</li> <li>Geometric transforms (albumentations.augmentations.geometric)</li> <li>Mixing transforms (albumentations.augmentations.mixing)</li> <li>Domain adaptation transforms (albumentations.augmentations.domain_adaptation)</li> <li>Functional transforms (albumentations.augmentations.functional)</li> </ul>"},{"location":"api_reference/augmentations/domain_adaptation/","title":"Domain adaptation transforms (augmentations.domain_adaptation)","text":""},{"location":"api_reference/augmentations/domain_adaptation/#albumentations.augmentations.domain_adaptation.FDA","title":"<code>class  FDA</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Fourier Domain Adaptation (FDA) for simple \"style transfer\" in the context of unsupervised domain adaptation (UDA). FDA manipulates the frequency components of images to reduce the domain gap between source and target datasets, effectively adapting images from one domain to closely resemble those from another without altering their semantic content.</p> <p>This transform is particularly beneficial in scenarios where the training (source) and testing (target) images come from different distributions, such as synthetic versus real images, or day versus night scenes. Unlike traditional domain adaptation methods that may require complex adversarial training, FDA achieves domain alignment by swapping low-frequency components of the Fourier transform between the source and target images. This technique has shown to improve the performance of models on the target domain, particularly for tasks like semantic segmentation, without additional training for domain invariance.</p> <p>The 'beta_limit' parameter controls the extent of frequency component swapping, with lower values preserving more of the original image's characteristics and higher values leading to more pronounced adaptation effects. It is recommended to use beta values less than 0.3 to avoid introducing artifacts.</p> <p>Parameters:</p> Name Type Description <code>reference_images</code> <code>Sequence[Any]</code> <p>Sequence of objects to be converted into images by <code>read_fn</code>. This typically involves paths to images that serve as target domain examples for adaptation.</p> <code>beta_limit</code> <code>float or tuple of float</code> <p>Coefficient beta from the paper, controlling the swapping extent of frequency components. Values should be less than 0.5.</p> <code>read_fn</code> <code>Callable</code> <p>User-defined function for reading images. It takes an element from <code>reference_images</code> and returns a numpy array of image pixels. By default, it is expected to take a path to an image and return a numpy array.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <ul> <li>https://github.com/YanchaoYang/FDA</li> <li>https://openaccess.thecvf.com/content_CVPR_2020/papers/Yang_FDA_Fourier_Domain_Adaptation_for_Semantic_Segmentation_CVPR_2020_paper.pdf</li> </ul> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import albumentations as A\n&gt;&gt;&gt; image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n&gt;&gt;&gt; target_image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n&gt;&gt;&gt; aug = A.Compose([A.FDA([target_image], p=1, read_fn=lambda x: x)])\n&gt;&gt;&gt; result = aug(image=image)\n</code></pre> <p>Note</p> <p>FDA is a powerful tool for domain adaptation, particularly in unsupervised settings where annotated target domain samples are unavailable. It enables significant improvements in model generalization by aligning the low-level statistics of source and target images through a simple yet effective Fourier-based method.</p> Source code in <code>albumentations/augmentations/domain_adaptation.py</code> Python<pre><code>class FDA(ImageOnlyTransform):\n    \"\"\"Fourier Domain Adaptation (FDA) for simple \"style transfer\" in the context of unsupervised domain adaptation\n    (UDA). FDA manipulates the frequency components of images to reduce the domain gap between source\n    and target datasets, effectively adapting images from one domain to closely resemble those from another without\n    altering their semantic content.\n\n    This transform is particularly beneficial in scenarios where the training (source) and testing (target) images\n    come from different distributions, such as synthetic versus real images, or day versus night scenes.\n    Unlike traditional domain adaptation methods that may require complex adversarial training, FDA achieves domain\n    alignment by swapping low-frequency components of the Fourier transform between the source and target images.\n    This technique has shown to improve the performance of models on the target domain, particularly for tasks\n    like semantic segmentation, without additional training for domain invariance.\n\n    The 'beta_limit' parameter controls the extent of frequency component swapping, with lower values preserving more\n    of the original image's characteristics and higher values leading to more pronounced adaptation effects.\n    It is recommended to use beta values less than 0.3 to avoid introducing artifacts.\n\n    Args:\n        reference_images (Sequence[Any]): Sequence of objects to be converted into images by `read_fn`. This typically\n            involves paths to images that serve as target domain examples for adaptation.\n        beta_limit (float or tuple of float): Coefficient beta from the paper, controlling the swapping extent of\n            frequency components. Values should be less than 0.5.\n        read_fn (Callable): User-defined function for reading images. It takes an element from `reference_images` and\n            returns a numpy array of image pixels. By default, it is expected to take a path to an image and return a\n            numpy array.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        - https://github.com/YanchaoYang/FDA\n        - https://openaccess.thecvf.com/content_CVPR_2020/papers/Yang_FDA_Fourier_Domain_Adaptation_for_Semantic_Segmentation_CVPR_2020_paper.pdf\n\n    Example:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import albumentations as A\n        &gt;&gt;&gt; image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n        &gt;&gt;&gt; target_image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n        &gt;&gt;&gt; aug = A.Compose([A.FDA([target_image], p=1, read_fn=lambda x: x)])\n        &gt;&gt;&gt; result = aug(image=image)\n\n    Note:\n        FDA is a powerful tool for domain adaptation, particularly in unsupervised settings where annotated target\n        domain samples are unavailable. It enables significant improvements in model generalization by aligning\n        the low-level statistics of source and target images through a simple yet effective Fourier-based method.\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        reference_images: Sequence[Any]\n        read_fn: Callable[[Any], np.ndarray]\n        beta_limit: NonNegativeFloatRangeType = (0, 0.1)\n\n        @field_validator(\"beta_limit\")\n        @classmethod\n        def check_ranges(cls, value: Tuple[float, float]) -&gt; Tuple[float, float]:\n            bounds = 0, MAX_BETA_LIMIT\n            if not bounds[0] &lt;= value[0] &lt;= value[1] &lt;= bounds[1]:\n                raise ValueError(f\"Values should be in the range {bounds} got {value} \")\n            return value\n\n    def __init__(\n        self,\n        reference_images: Sequence[Any],\n        beta_limit: ScaleFloatType = (0, 0.1),\n        read_fn: Callable[[Any], np.ndarray] = read_rgb_image,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.reference_images = reference_images\n        self.read_fn = read_fn\n        self.beta_limit = cast(Tuple[float, float], beta_limit)\n\n    def apply(\n        self, img: np.ndarray, target_image: Optional[np.ndarray] = None, beta: float = 0.1, **params: Any\n    ) -&gt; np.ndarray:\n        return fourier_domain_adaptation(img, target_image, beta)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, np.ndarray]:\n        img = params[\"image\"]\n        target_img = self.read_fn(random.choice(self.reference_images))\n        target_img = cv2.resize(target_img, dsize=(img.shape[1], img.shape[0]))\n\n        return {\"target_image\": target_img}\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"beta\": random.uniform(self.beta_limit[0], self.beta_limit[1])}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return \"reference_images\", \"beta_limit\", \"read_fn\"\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        msg = \"FDA can not be serialized.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"api_reference/augmentations/domain_adaptation/#albumentations.augmentations.domain_adaptation.HistogramMatching","title":"<code>class  HistogramMatching</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Implements histogram matching, a technique that adjusts the pixel values of an input image to match the histogram of a reference image. This adjustment ensures that the output image has a similar tone and contrast to the reference. The process is applied independently to each channel of multi-channel images, provided both the input and reference images have the same number of channels.</p> <p>Histogram matching serves as an effective normalization method in image processing tasks such as feature matching. It is particularly useful when images originate from varied sources or are captured under different lighting conditions, helping to standardize the images' appearance before further processing.</p> <p>Parameters:</p> Name Type Description <code>reference_images</code> <code>Sequence[Any]</code> <p>A sequence of objects to be converted into images by <code>read_fn</code>. Typically, this is a sequence of image paths.</p> <code>blend_ratio</code> <code>Tuple[float, float]</code> <p>Specifies the minimum and maximum blend ratio for blending the matched image with the original image. A random blend factor within this range is chosen for each image to increase the diversity of the output images.</p> <code>read_fn</code> <code>Callable[[Any], np.ndarray]</code> <p>A user-defined function for reading images, which accepts an element from <code>reference_images</code> and returns a numpy array of image pixels. By default, this is expected to take a file path and return an image as a numpy array.</p> <code>p</code> <code>float</code> <p>The probability of applying the transform to any given image. Defaults to 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Note</p> <p>This class cannot be serialized directly due to its dynamic nature and dependency on external image data. An attempt to serialize it will raise a NotImplementedError.</p> <p>Reference</p> <p>https://scikit-image.org/docs/dev/auto_examples/color_exposure/plot_histogram_matching.html</p> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import albumentations as A\n&gt;&gt;&gt; image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n&gt;&gt;&gt; target_image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n&gt;&gt;&gt; aug = A.Compose([A.HistogramMatching([target_image], p=1, read_fn=lambda x: x)])\n&gt;&gt;&gt; result = aug(image=image)\n</code></pre> Source code in <code>albumentations/augmentations/domain_adaptation.py</code> Python<pre><code>class HistogramMatching(ImageOnlyTransform):\n    \"\"\"Implements histogram matching, a technique that adjusts the pixel values of an input image\n    to match the histogram of a reference image. This adjustment ensures that the output image\n    has a similar tone and contrast to the reference. The process is applied independently to\n    each channel of multi-channel images, provided both the input and reference images have the\n    same number of channels.\n\n    Histogram matching serves as an effective normalization method in image processing tasks such\n    as feature matching. It is particularly useful when images originate from varied sources or are\n    captured under different lighting conditions, helping to standardize the images' appearance\n    before further processing.\n\n    Args:\n        reference_images (Sequence[Any]): A sequence of objects to be converted into images by `read_fn`.\n            Typically, this is a sequence of image paths.\n        blend_ratio (Tuple[float, float]): Specifies the minimum and maximum blend ratio for blending the matched\n            image with the original image. A random blend factor within this range is chosen for each image to\n            increase the diversity of the output images.\n        read_fn (Callable[[Any], np.ndarray]): A user-defined function for reading images, which accepts an\n            element from `reference_images` and returns a numpy array of image pixels. By default, this is expected\n            to take a file path and return an image as a numpy array.\n        p (float): The probability of applying the transform to any given image. Defaults to 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Note:\n        This class cannot be serialized directly due to its dynamic nature and dependency on external image data.\n        An attempt to serialize it will raise a NotImplementedError.\n\n    Reference:\n        https://scikit-image.org/docs/dev/auto_examples/color_exposure/plot_histogram_matching.html\n\n    Example:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import albumentations as A\n        &gt;&gt;&gt; image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n        &gt;&gt;&gt; target_image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)\n        &gt;&gt;&gt; aug = A.Compose([A.HistogramMatching([target_image], p=1, read_fn=lambda x: x)])\n        &gt;&gt;&gt; result = aug(image=image)\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        reference_images: Sequence[Any]\n        blend_ratio: ZeroOneRangeType = (0.5, 1.0)\n        read_fn: Callable[[Any], np.ndarray]\n\n    def __init__(\n        self,\n        reference_images: Sequence[Any],\n        blend_ratio: Tuple[float, float] = (0.5, 1.0),\n        read_fn: Callable[[Any], np.ndarray] = read_rgb_image,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.reference_images = reference_images\n        self.read_fn = read_fn\n        self.blend_ratio = blend_ratio\n\n    def apply(\n        self: np.ndarray,\n        img: np.ndarray,\n        reference_image: Optional[np.ndarray] = None,\n        blend_ratio: float = 0.5,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return apply_histogram(img, reference_image, blend_ratio)\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        return {\n            \"reference_image\": self.read_fn(random.choice(self.reference_images)),\n            \"blend_ratio\": random.uniform(self.blend_ratio[0], self.blend_ratio[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"reference_images\", \"blend_ratio\", \"read_fn\")\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        msg = \"HistogramMatching can not be serialized.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"api_reference/augmentations/domain_adaptation/#albumentations.augmentations.domain_adaptation.PixelDistributionAdaptation","title":"<code>class  PixelDistributionAdaptation</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Performs pixel-level domain adaptation by aligning the pixel value distribution of an input image with that of a reference image. This process involves fitting a simple statistical transformation (such as PCA, StandardScaler, or MinMaxScaler) to both the original and the reference images, transforming the original image with the transformation trained on it, and then applying the inverse transformation using the transform fitted on the reference image. The result is an adapted image that retains the original content while mimicking the pixel value distribution of the reference domain.</p> <p>The process can be visualized as two main steps: 1. Adjusting the original image to a standard distribution space using a selected transform. 2. Moving the adjusted image into the distribution space of the reference image by applying the inverse    of the transform fitted on the reference image.</p> <p>This technique is especially useful in scenarios where images from different domains (e.g., synthetic vs. real images, day vs. night scenes) need to be harmonized for better consistency or performance in image processing tasks.</p> <p>Parameters:</p> Name Type Description <code>reference_images</code> <code>Sequence[Any]</code> <p>A sequence of objects (typically image paths) that will be converted into images by <code>read_fn</code>. These images serve as references for the domain adaptation.</p> <code>blend_ratio</code> <code>Tuple[float, float]</code> <p>Specifies the minimum and maximum blend ratio for mixing the adapted image with the original, enhancing the diversity of the output images.</p> <code>read_fn</code> <code>Callable</code> <p>A user-defined function for reading and converting the objects in <code>reference_images</code> into numpy arrays. By default, it assumes these objects are image paths.</p> <code>transform_type</code> <code>str</code> <p>Specifies the type of statistical transformation to apply. Supported values are \"pca\" for Principal Component Analysis, \"standard\" for StandardScaler, and \"minmax\" for MinMaxScaler.</p> <code>p</code> <code>float</code> <p>The probability of applying the transform to any given image. Default is 1.0.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>For more information on the underlying approach, see: https://github.com/arsenyinfo/qudida</p> <p>Note</p> <p>The PixelDistributionAdaptation transform is a novel way to perform domain adaptation at the pixel level, suitable for adjusting images across different conditions without complex modeling. It is effective for preparing images before more advanced processing or analysis.</p> Source code in <code>albumentations/augmentations/domain_adaptation.py</code> Python<pre><code>class PixelDistributionAdaptation(ImageOnlyTransform):\n    \"\"\"Performs pixel-level domain adaptation by aligning the pixel value distribution of an input image\n    with that of a reference image. This process involves fitting a simple statistical transformation\n    (such as PCA, StandardScaler, or MinMaxScaler) to both the original and the reference images,\n    transforming the original image with the transformation trained on it, and then applying the inverse\n    transformation using the transform fitted on the reference image. The result is an adapted image\n    that retains the original content while mimicking the pixel value distribution of the reference domain.\n\n    The process can be visualized as two main steps:\n    1. Adjusting the original image to a standard distribution space using a selected transform.\n    2. Moving the adjusted image into the distribution space of the reference image by applying the inverse\n       of the transform fitted on the reference image.\n\n    This technique is especially useful in scenarios where images from different domains (e.g., synthetic\n    vs. real images, day vs. night scenes) need to be harmonized for better consistency or performance in\n    image processing tasks.\n\n    Args:\n        reference_images (Sequence[Any]): A sequence of objects (typically image paths) that will be\n            converted into images by `read_fn`. These images serve as references for the domain adaptation.\n        blend_ratio (Tuple[float, float]): Specifies the minimum and maximum blend ratio for mixing\n            the adapted image with the original, enhancing the diversity of the output images.\n        read_fn (Callable): A user-defined function for reading and converting the objects in\n            `reference_images` into numpy arrays. By default, it assumes these objects are image paths.\n        transform_type (str): Specifies the type of statistical transformation to apply. Supported values\n            are \"pca\" for Principal Component Analysis, \"standard\" for StandardScaler, and \"minmax\" for\n            MinMaxScaler.\n        p (float): The probability of applying the transform to any given image. Default is 1.0.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        For more information on the underlying approach, see: https://github.com/arsenyinfo/qudida\n\n    Note:\n        The PixelDistributionAdaptation transform is a novel way to perform domain adaptation at the pixel level,\n        suitable for adjusting images across different conditions without complex modeling. It is effective\n        for preparing images before more advanced processing or analysis.\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        reference_images: Sequence[Any]\n        blend_ratio: ZeroOneRangeType = (0.25, 1.0)\n        read_fn: Callable[[Any], np.ndarray]\n        transform_type: Literal[\"pca\", \"standard\", \"minmax\"]\n\n    def __init__(\n        self,\n        reference_images: Sequence[Any],\n        blend_ratio: Tuple[float, float] = (0.25, 1.0),\n        read_fn: Callable[[Any], np.ndarray] = read_rgb_image,\n        transform_type: Literal[\"pca\", \"standard\", \"minmax\"] = \"pca\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.reference_images = reference_images\n        self.read_fn = read_fn\n        self.blend_ratio = blend_ratio\n        self.transform_type = transform_type\n\n    @staticmethod\n    def _validate_shape(img: np.ndarray) -&gt; None:\n        if is_grayscale_image(img) or is_multispectral_image(img):\n            raise ValueError(\n                f\"Unexpected image shape: expected 3 dimensions, got {len(img.shape)}.\"\n                f\"Is it a grayscale or multispectral image? It's not supported for now.\"\n            )\n\n    def ensure_uint8(self, img: np.ndarray) -&gt; Tuple[np.ndarray, bool]:\n        if img.dtype == np.float32:\n            if img.min() &lt; 0 or img.max() &gt; 1:\n                message = (\n                    \"PixelDistributionAdaptation uses uint8 under the hood, so float32 should be converted,\"\n                    \"Can not do it automatically when the image is out of [0..1] range.\"\n                )\n                raise TypeError(message)\n            return (img * 255).astype(\"uint8\"), True\n        return img, False\n\n    def apply(self, img: np.ndarray, reference_image: np.ndarray, blend_ratio: float, **params: Any) -&gt; np.ndarray:\n        self._validate_shape(img)\n        reference_image, _ = self.ensure_uint8(reference_image)\n        img, needs_reconvert = self.ensure_uint8(img)\n\n        adapted = adapt_pixel_distribution(\n            img,\n            ref=reference_image,\n            weight=blend_ratio,\n            transform_type=self.transform_type,\n        )\n        if needs_reconvert:\n            adapted = adapted.astype(\"float32\") * (1 / 255)\n        return adapted\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"reference_image\": self.read_fn(random.choice(self.reference_images)),\n            \"blend_ratio\": random.uniform(self.blend_ratio[0], self.blend_ratio[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return \"reference_images\", \"blend_ratio\", \"read_fn\", \"transform_type\"\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        msg = \"PixelDistributionAdaptation can not be serialized.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"api_reference/augmentations/functional/","title":"Functional transforms (augmentations.functional)","text":""},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.add_fog","title":"<code>def add_fog    (img, fog_coef, alpha_coef, haze_list)    </code> [view source on GitHub]","text":"<p>Add fog to the image.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>Image.</p> <code>fog_coef</code> <code>float</code> <p>Fog coefficient.</p> <code>alpha_coef</code> <code>float</code> <p>Alpha coefficient.</p> <code>haze_list</code> <code>List[Tuple[int, int]]</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef add_fog(img: np.ndarray, fog_coef: float, alpha_coef: float, haze_list: List[Tuple[int, int]]) -&gt; np.ndarray:\n    \"\"\"Add fog to the image.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img: Image.\n        fog_coef: Fog coefficient.\n        alpha_coef: Alpha coefficient.\n        haze_list:\n\n    Returns:\n        Image.\n\n    \"\"\"\n    non_rgb_warning(img)\n\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomFog augmentation\")\n\n    width = img.shape[1]\n\n    hw = max(int(width // 3 * fog_coef), 10)\n\n    for haze_points in haze_list:\n        x, y = haze_points\n        overlay = img.copy()\n        output = img.copy()\n        alpha = alpha_coef * fog_coef\n        rad = hw // 2\n        point = (x + hw // 2, y + hw // 2)\n        cv2.circle(overlay, point, int(rad), (255, 255, 255), -1)\n        cv2.addWeighted(overlay, alpha, output, 1 - alpha, 0, output)\n\n        img = output.copy()\n\n    image_rgb = cv2.blur(img, (hw // 10, hw // 10))\n\n    if needs_float:\n        image_rgb = to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.add_gravel","title":"<code>def add_gravel    (img, gravels)    </code> [view source on GitHub]","text":"<p>Add gravel to the image.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>numpy.ndarray</code> <p>image to add gravel to</p> <code>gravels</code> <code>list</code> <p>list of gravel parameters. (float, float, float, float): (top-left x, top-left y, bottom-right x, bottom right y)</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@ensure_contiguous\n@preserve_shape\ndef add_gravel(img: np.ndarray, gravels: List[Any]) -&gt; np.ndarray:\n    \"\"\"Add gravel to the image.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img (numpy.ndarray): image to add gravel to\n        gravels (list): list of gravel parameters. (float, float, float, float):\n            (top-left x, top-left y, bottom-right x, bottom right y)\n\n    Returns:\n        numpy.ndarray:\n\n    \"\"\"\n    non_rgb_warning(img)\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for AddGravel augmentation\")\n\n    image_hls = cv2.cvtColor(img, cv2.COLOR_RGB2HLS)\n\n    for gravel in gravels:\n        y1, y2, x1, x2, sat = gravel\n        image_hls[x1:x2, y1:y2, 1] = sat\n\n    image_rgb = cv2.cvtColor(image_hls, cv2.COLOR_HLS2RGB)\n\n    if needs_float:\n        image_rgb = to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.add_rain","title":"<code>def add_rain    (img, slant, drop_length, drop_width, drop_color, blur_value, brightness_coefficient, rain_drops)    </code> [view source on GitHub]","text":"<p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>Image.</p> <code>slant</code> <code>int</code> <code>drop_length</code> <code>int</code> <code>drop_width</code> <code>int</code> <code>drop_color</code> <code>Tuple[int, int, int]</code> <code>blur_value</code> <code>int</code> <p>Rainy view are blurry.</p> <code>brightness_coefficient</code> <code>float</code> <p>Rainy days are usually shady.</p> <code>rain_drops</code> <code>List[Tuple[int, int]]</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef add_rain(\n    img: np.ndarray,\n    slant: int,\n    drop_length: int,\n    drop_width: int,\n    drop_color: Tuple[int, int, int],\n    blur_value: int,\n    brightness_coefficient: float,\n    rain_drops: List[Tuple[int, int]],\n) -&gt; np.ndarray:\n    \"\"\"From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img: Image.\n        slant:\n        drop_length:\n        drop_width:\n        drop_color:\n        blur_value: Rainy view are blurry.\n        brightness_coefficient: Rainy days are usually shady.\n        rain_drops:\n\n    Returns:\n        Image\n\n    \"\"\"\n    non_rgb_warning(img)\n\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomRain augmentation\")\n\n    image = img.copy()\n\n    for rain_drop_x0, rain_drop_y0 in rain_drops:\n        rain_drop_x1 = rain_drop_x0 + slant\n        rain_drop_y1 = rain_drop_y0 + drop_length\n\n        cv2.line(\n            image,\n            (rain_drop_x0, rain_drop_y0),\n            (rain_drop_x1, rain_drop_y1),\n            drop_color,\n            drop_width,\n        )\n\n    image = cv2.blur(image, (blur_value, blur_value))  # rainy view are blurry\n    image_hsv = cv2.cvtColor(image, cv2.COLOR_RGB2HSV).astype(np.float32)\n    image_hsv[:, :, 2] *= brightness_coefficient\n\n    image_rgb = cv2.cvtColor(image_hsv.astype(np.uint8), cv2.COLOR_HSV2RGB)\n\n    if needs_float:\n        return to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.add_shadow","title":"<code>def add_shadow    (img, vertices_list)    </code> [view source on GitHub]","text":"<p>Add shadows to the image.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>numpy.ndarray</code> <code>vertices_list</code> <code>list[numpy.ndarray]</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Reference</p> <p>https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@ensure_contiguous\n@preserve_shape\ndef add_shadow(img: np.ndarray, vertices_list: List[np.ndarray]) -&gt; np.ndarray:\n    \"\"\"Add shadows to the image.\n\n    Args:\n        img (numpy.ndarray):\n        vertices_list (list[numpy.ndarray]):\n\n    Returns:\n        numpy.ndarray:\n\n    Reference:\n        https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n    \"\"\"\n    non_rgb_warning(img)\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomShadow augmentation\")\n\n    image_hls = cv2.cvtColor(img, cv2.COLOR_RGB2HLS)\n    mask = np.zeros_like(img)\n\n    # adding all shadow polygons on empty mask, single 255 denotes only red channel\n    cv2.fillPoly(mask, vertices_list, 255)\n\n    # if red channel is hot, image's \"Lightness\" channel's brightness is lowered\n    red_max_value_ind = mask[:, :, 0] == MAX_VALUES_BY_DTYPE[np.dtype(\"uint8\")]\n    image_hls[:, :, 1][red_max_value_ind] = image_hls[:, :, 1][red_max_value_ind] * 0.5\n\n    image_rgb = cv2.cvtColor(image_hls, cv2.COLOR_HLS2RGB)\n\n    if needs_float:\n        return to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.add_snow","title":"<code>def add_snow    (img, snow_point, brightness_coeff)    </code> [view source on GitHub]","text":"<p>Bleaches out pixels, imitation snow.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>Image.</p> <code>snow_point</code> <code>float</code> <p>Number of show points.</p> <code>brightness_coeff</code> <code>float</code> <p>Brightness coefficient.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef add_snow(img: np.ndarray, snow_point: float, brightness_coeff: float) -&gt; np.ndarray:\n    \"\"\"Bleaches out pixels, imitation snow.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img: Image.\n        snow_point: Number of show points.\n        brightness_coeff: Brightness coefficient.\n\n    Returns:\n        Image.\n\n    \"\"\"\n    non_rgb_warning(img)\n\n    input_dtype = img.dtype\n    needs_float = False\n\n    snow_point *= 127.5  # = 255 / 2\n    snow_point += 85  # = 255 / 3\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomSnow augmentation\")\n\n    image_hls = cv2.cvtColor(img, cv2.COLOR_RGB2HLS)\n    image_hls = np.array(image_hls, dtype=np.float32)\n\n    image_hls[:, :, 1][image_hls[:, :, 1] &lt; snow_point] *= brightness_coeff\n\n    image_hls[:, :, 1] = clip(image_hls[:, :, 1], np.uint8, 255)\n\n    image_hls = np.array(image_hls, dtype=np.uint8)\n\n    image_rgb = cv2.cvtColor(image_hls, cv2.COLOR_HLS2RGB)\n\n    if needs_float:\n        image_rgb = to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.add_sun_flare","title":"<code>def add_sun_flare    (img, flare_center_x, flare_center_y, src_radius, src_color, circles)    </code> [view source on GitHub]","text":"<p>Add sun flare.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>numpy.ndarray</code> <code>flare_center_x</code> <code>float</code> <code>flare_center_y</code> <code>float</code> <code>src_radius</code> <code>int</code> <code>src_color</code> <code>int, int, int</code> <code>circles</code> <code>list</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef add_sun_flare(\n    img: np.ndarray,\n    flare_center_x: float,\n    flare_center_y: float,\n    src_radius: int,\n    src_color: ColorType,\n    circles: List[Any],\n) -&gt; np.ndarray:\n    \"\"\"Add sun flare.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        img (numpy.ndarray):\n        flare_center_x (float):\n        flare_center_y (float):\n        src_radius:\n        src_color (int, int, int):\n        circles (list):\n\n    Returns:\n        numpy.ndarray:\n\n    \"\"\"\n    non_rgb_warning(img)\n\n    input_dtype = img.dtype\n    needs_float = False\n\n    if input_dtype == np.float32:\n        img = from_float(img, dtype=np.dtype(\"uint8\"))\n        needs_float = True\n    elif input_dtype not in (np.uint8, np.float32):\n        raise ValueError(f\"Unexpected dtype {input_dtype} for RandomSunFlareaugmentation\")\n\n    overlay = img.copy()\n    output = img.copy()\n\n    for alpha, (x, y), rad3, (r_color, g_color, b_color) in circles:\n        cv2.circle(overlay, (x, y), rad3, (r_color, g_color, b_color), -1)\n\n        cv2.addWeighted(overlay, alpha, output, 1 - alpha, 0, output)\n\n    point = (int(flare_center_x), int(flare_center_y))\n\n    overlay = output.copy()\n    num_times = src_radius // 10\n    alpha = np.linspace(0.0, 1, num=num_times)\n    rad = np.linspace(1, src_radius, num=num_times)\n    for i in range(num_times):\n        cv2.circle(overlay, point, int(rad[i]), src_color, -1)\n        alp = alpha[num_times - i - 1] * alpha[num_times - i - 1] * alpha[num_times - i - 1]\n        cv2.addWeighted(overlay, alp, output, 1 - alp, 0, output)\n\n    image_rgb = output\n\n    if needs_float:\n        image_rgb = to_float(image_rgb, max_value=255)\n\n    return image_rgb\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.bbox_from_mask","title":"<code>def bbox_from_mask    (mask)    </code> [view source on GitHub]","text":"<p>Create bounding box from binary mask (fast version)</p> <p>Parameters:</p> Name Type Description <code>mask</code> <code>numpy.ndarray</code> <p>binary mask.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box tuple <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def bbox_from_mask(mask: np.ndarray) -&gt; Tuple[int, int, int, int]:\n    \"\"\"Create bounding box from binary mask (fast version)\n\n    Args:\n        mask (numpy.ndarray): binary mask.\n\n    Returns:\n        tuple: A bounding box tuple `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    rows = np.any(mask, axis=1)\n    if not rows.any():\n        return -1, -1, -1, -1\n    cols = np.any(mask, axis=0)\n    y_min, y_max = np.where(rows)[0][[0, -1]]\n    x_min, x_max = np.where(cols)[0][[0, -1]]\n    return x_min, y_min, x_max + 1, y_max + 1\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.fancy_pca","title":"<code>def fancy_pca    (img, alpha=0.1)    </code> [view source on GitHub]","text":"<p>Perform 'Fancy PCA' augmentation from: http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>numpy array with (h, w, rgb) shape, as ints between 0-255</p> <code>alpha</code> <code>float</code> <p>how much to perturb/scale the eigen vecs and vals     the paper used std=0.1</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy image-like array as uint8 range(0, 255)</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def fancy_pca(img: np.ndarray, alpha: float = 0.1) -&gt; np.ndarray:\n    \"\"\"Perform 'Fancy PCA' augmentation from:\n    http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf\n\n    Args:\n        img: numpy array with (h, w, rgb) shape, as ints between 0-255\n        alpha: how much to perturb/scale the eigen vecs and vals\n                the paper used std=0.1\n\n    Returns:\n        numpy image-like array as uint8 range(0, 255)\n\n    \"\"\"\n    if not is_rgb_image(img) or img.dtype != np.uint8:\n        msg = \"Image must be RGB image in uint8 format.\"\n        raise TypeError(msg)\n\n    orig_img = img.astype(float).copy()\n\n    img = img / 255.0  # rescale to 0 to 1 range\n\n    # flatten image to columns of RGB\n    img_rs = img.reshape(-1, 3)\n    # img_rs shape (640000, 3)\n\n    # center mean\n    img_centered = img_rs - np.mean(img_rs, axis=0)\n\n    # paper says 3x3 covariance matrix\n    img_cov = np.cov(img_centered, rowvar=False)\n\n    # eigen values and eigen vectors\n    eig_vals, eig_vecs = np.linalg.eigh(img_cov)\n\n    # sort values and vector\n    sort_perm = eig_vals[::-1].argsort()\n    eig_vals[::-1].sort()\n    eig_vecs = eig_vecs[:, sort_perm]\n\n    # &gt; get [p1, p2, p3]\n    m1 = np.column_stack(eig_vecs)\n\n    # get 3x1 matrix of eigen values multiplied by random variable draw from normal\n    # distribution with mean of 0 and standard deviation of 0.1\n    m2 = np.zeros((3, 1))\n    # according to the paper alpha should only be draw once per augmentation (not once per channel)\n    # &gt; alpha = np.random.normal(0, alpha_std)\n\n    # broad cast to speed things up\n    m2[:, 0] = alpha * eig_vals[:]\n\n    # this is the vector that we're going to add to each pixel in a moment\n    add_vect = np.array(m1) @ np.array(m2)\n\n    for idx in range(3):  # RGB\n        orig_img[..., idx] += add_vect[idx] * 255\n\n    # for image processing it was found that working with float 0.0 to 1.0\n    # was easier than integers between 0-255\n    # &gt; orig_img /= 255.0\n    orig_img = np.clip(orig_img, 0.0, 255.0)\n\n    # &gt; orig_img *= 255\n    return orig_img.astype(np.uint8)\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.iso_noise","title":"<code>def iso_noise    (image, color_shift=0.05, intensity=0.5, random_state=None, ** kwargs)    </code> [view source on GitHub]","text":"<p>Apply poisson noise to image to simulate camera sensor noise.</p> <p>Parameters:</p> Name Type Description <code>image</code> <code>numpy.ndarray</code> <p>Input image, currently, only RGB, uint8 images are supported.</p> <code>color_shift</code> <code>float</code> <code>intensity</code> <code>float</code> <p>Multiplication factor for noise values. Values of ~0.5 are produce noticeable,        yet acceptable level of noise.</p> <code>random_state</code> <code>Optional[int]</code> <code>**kwargs</code> <code>Any</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Noised image</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@clipped\ndef iso_noise(\n    image: np.ndarray,\n    color_shift: float = 0.05,\n    intensity: float = 0.5,\n    random_state: Optional[int] = None,\n    **kwargs: Any,\n) -&gt; np.ndarray:\n    \"\"\"Apply poisson noise to image to simulate camera sensor noise.\n\n    Args:\n        image (numpy.ndarray): Input image, currently, only RGB, uint8 images are supported.\n        color_shift (float):\n        intensity (float): Multiplication factor for noise values. Values of ~0.5 are produce noticeable,\n                   yet acceptable level of noise.\n        random_state:\n        **kwargs:\n\n    Returns:\n        numpy.ndarray: Noised image\n\n    \"\"\"\n    if image.dtype != np.uint8:\n        msg = \"Image must have uint8 channel type\"\n        raise TypeError(msg)\n    if not is_rgb_image(image):\n        msg = \"Image must be RGB\"\n        raise TypeError(msg)\n\n    one_over_255 = float(1.0 / 255.0)\n    image = np.multiply(image, one_over_255, dtype=np.float32)\n    hls = cv2.cvtColor(image, cv2.COLOR_RGB2HLS)\n    _, stddev = cv2.meanStdDev(hls)\n\n    luminance_noise = random_utils.poisson(stddev[1] * intensity * 255, size=hls.shape[:2], random_state=random_state)\n    color_noise = random_utils.normal(0, color_shift * 360 * intensity, size=hls.shape[:2], random_state=random_state)\n\n    hue = hls[..., 0]\n    hue += color_noise\n    hue %= 360\n\n    luminance = hls[..., 1]\n    luminance += (luminance_noise / 255) * (1.0 - luminance)\n\n    image = cv2.cvtColor(hls, cv2.COLOR_HLS2RGB) * 255\n    return image.astype(np.uint8)\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.mask_from_bbox","title":"<code>def mask_from_bbox    (img, bbox)    </code> [view source on GitHub]","text":"<p>Create binary mask from bounding box</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>input image</p> <code>bbox</code> <code>Tuple[int, int, int, int]</code> <p>A bounding box tuple <code>(x_min, y_min, x_max, y_max)</code></p> <p>Returns:</p> Type Description <code>mask</code> <p>binary mask</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def mask_from_bbox(img: np.ndarray, bbox: Tuple[int, int, int, int]) -&gt; np.ndarray:\n    \"\"\"Create binary mask from bounding box\n\n    Args:\n        img: input image\n        bbox: A bounding box tuple `(x_min, y_min, x_max, y_max)`\n\n    Returns:\n        mask: binary mask\n\n    \"\"\"\n    mask = np.zeros(img.shape[:2], dtype=np.uint8)\n    x_min, y_min, x_max, y_max = bbox\n    mask[y_min:y_max, x_min:x_max] = 1\n    return mask\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.move_tone_curve","title":"<code>def move_tone_curve    (img, low_y, high_y)    </code> [view source on GitHub]","text":"<p>Rescales the relationship between bright and dark areas of the image by manipulating its tone curve.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>RGB or grayscale image.</p> <code>low_y</code> <code>float</code> <p>y-position of a Bezier control point used to adjust the tone curve, must be in range [0, 1]</p> <code>high_y</code> <code>float</code> <p>y-position of a Bezier control point used to adjust image tone curve, must be in range [0, 1]</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef move_tone_curve(img: np.ndarray, low_y: float, high_y: float) -&gt; np.ndarray:\n    \"\"\"Rescales the relationship between bright and dark areas of the image by manipulating its tone curve.\n\n    Args:\n        img: RGB or grayscale image.\n        low_y: y-position of a Bezier control point used\n            to adjust the tone curve, must be in range [0, 1]\n        high_y: y-position of a Bezier control point used\n            to adjust image tone curve, must be in range [0, 1]\n\n    \"\"\"\n    input_dtype = img.dtype\n\n    if not 0 &lt;= low_y &lt;= 1:\n        msg = \"low_shift must be in range [0, 1]\"\n        raise ValueError(msg)\n    if not 0 &lt;= high_y &lt;= 1:\n        msg = \"high_shift must be in range [0, 1]\"\n        raise ValueError(msg)\n\n    if input_dtype != np.uint8:\n        raise ValueError(f\"Unsupported image type {input_dtype}\")\n\n    t = np.linspace(0.0, 1.0, 256)\n\n    # Defines response of a four-point Bezier curve\n    def evaluate_bez(t: np.ndarray) -&gt; np.ndarray:\n        return 3 * (1 - t) ** 2 * t * low_y + 3 * (1 - t) * t**2 * high_y + t**3\n\n    evaluate_bez = np.vectorize(evaluate_bez)\n    remapping = np.rint(evaluate_bez(t) * 255).astype(np.uint8)\n\n    lut_fn = _maybe_process_in_chunks(cv2.LUT, lut=remapping)\n    return lut_fn(img)\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.multiply","title":"<code>def multiply    (img, multiplier)    </code> [view source on GitHub]","text":"<p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>Image.</p> <code>multiplier</code> <code>ndarray</code> <p>Multiplier coefficient.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image multiplied by <code>multiplier</code> coefficient.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def multiply(img: np.ndarray, multiplier: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Args:\n\n        img: Image.\n        multiplier: Multiplier coefficient.\n\n    Returns:\n        Image multiplied by `multiplier` coefficient.\n\n    \"\"\"\n    if img.dtype == np.uint8:\n        if len(multiplier.shape) == 1:\n            return _multiply_uint8_optimized(img, multiplier)\n\n        return _multiply_uint8(img, multiplier)\n\n    return _multiply_non_uint8(img, multiplier)\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.normalize_per_image","title":"<code>def normalize_per_image    (img, normalization)    </code> [view source on GitHub]","text":"<p>Apply per-image normalization based on the specified strategy.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>np.ndarray</code> <p>The image to be normalized, expected to be in HWC format.</p> <code>normalization</code> <code>str</code> <p>The normalization strategy to apply. Options include:                  \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\".</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The normalized image.</p> <p>Reference</p> <p>https://github.com/ChristofHenkel/kaggle-landmark-2021-1st-place/blob/main/data/ch_ds_1.py</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef normalize_per_image(\n    img: np.ndarray, normalization: Literal[\"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\"]\n) -&gt; np.ndarray:\n    \"\"\"Apply per-image normalization based on the specified strategy.\n\n    Args:\n        img (np.ndarray): The image to be normalized, expected to be in HWC format.\n        normalization (str): The normalization strategy to apply. Options include:\n                             \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\".\n\n    Returns:\n        np.ndarray: The normalized image.\n\n    Reference:\n        https://github.com/ChristofHenkel/kaggle-landmark-2021-1st-place/blob/main/data/ch_ds_1.py\n    \"\"\"\n    img = img.astype(np.float32)\n\n    if img.ndim == GRAYSCALE_SHAPE_LENGTH:\n        img = np.expand_dims(img, axis=-1)  # Ensure the image is at least 3D\n\n    if normalization == \"image\":\n        # Normalize the whole image based on its global mean and std\n        mean = img.mean()\n        std = img.std() + 1e-4  # Adding a small epsilon to avoid division by zero\n        normalized_img = (img - mean) / std\n        normalized_img = normalized_img.clip(-20, 20)  # Clipping outliers\n\n    elif normalization == \"image_per_channel\":\n        # Normalize the image per channel based on each channel's mean and std\n        pixel_mean = img.mean(axis=(0, 1))\n        pixel_std = img.std(axis=(0, 1)) + 1e-4\n        normalized_img = (img - pixel_mean[None, None, :]) / pixel_std[None, None, :]\n        normalized_img = normalized_img.clip(-20, 20)\n\n    elif normalization == \"min_max\":\n        # Apply min-max normalization to the whole image\n        img_min = img.min()\n        img_max = img.max()\n        normalized_img = (img - img_min) / (img_max - img_min)\n\n    elif normalization == \"min_max_per_channel\":\n        # Apply min-max normalization per channel\n        img_min = img.min(axis=(0, 1), keepdims=True)\n        img_max = img.max(axis=(0, 1), keepdims=True)\n        normalized_img = (img - img_min) / (img_max - img_min)\n\n    else:\n        raise ValueError(f\"Unknown normalization method: {normalization}\")\n\n    return normalized_img\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.posterize","title":"<code>def posterize    (img, bits)    </code> [view source on GitHub]","text":"<p>Reduce the number of bits for each color channel.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>image to posterize.</p> <code>bits</code> <code>int</code> <p>number of high bits. Must be in range [0, 8]</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Image with reduced color channels.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>@preserve_shape\ndef posterize(img: np.ndarray, bits: int) -&gt; np.ndarray:\n    \"\"\"Reduce the number of bits for each color channel.\n\n    Args:\n        img: image to posterize.\n        bits: number of high bits. Must be in range [0, 8]\n\n    Returns:\n        Image with reduced color channels.\n\n    \"\"\"\n    bits_array = np.uint8(bits)\n\n    if img.dtype != np.uint8:\n        msg = \"Image must have uint8 channel type\"\n        raise TypeError(msg)\n    if np.any((bits_array &lt; 0) | (bits_array &gt; EIGHT)):\n        msg = \"bits must be in range [0, 8]\"\n        raise ValueError(msg)\n\n    if not bits_array.shape or len(bits_array) == 1:\n        if bits_array == 0:\n            return np.zeros_like(img)\n        if bits_array == EIGHT:\n            return img.copy()\n\n        lut = np.arange(0, 256, dtype=np.uint8)\n        mask = ~np.uint8(2 ** (8 - bits_array) - 1)\n        lut &amp;= mask\n\n        return cv2.LUT(img, lut)\n\n    if not is_rgb_image(img):\n        msg = \"If bits is iterable image must be RGB\"\n        raise TypeError(msg)\n\n    result_img = np.empty_like(img)\n    for i, channel_bits in enumerate(bits_array):\n        if channel_bits == 0:\n            result_img[..., i] = np.zeros_like(img[..., i])\n        elif channel_bits == EIGHT:\n            result_img[..., i] = img[..., i].copy()\n        else:\n            lut = np.arange(0, 256, dtype=np.uint8)\n            mask = ~np.uint8(2 ** (8 - channel_bits) - 1)\n            lut &amp;= mask\n\n            result_img[..., i] = cv2.LUT(img[..., i], lut)\n\n    return result_img\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.solarize","title":"<code>def solarize    (img, threshold=128)    </code> [view source on GitHub]","text":"<p>Invert all pixel values above a threshold.</p> <p>Parameters:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>The image to solarize.</p> <code>threshold</code> <code>int</code> <p>All pixels above this grayscale level are inverted.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Solarized image.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def solarize(img: np.ndarray, threshold: int = 128) -&gt; np.ndarray:\n    \"\"\"Invert all pixel values above a threshold.\n\n    Args:\n        img: The image to solarize.\n        threshold: All pixels above this grayscale level are inverted.\n\n    Returns:\n        Solarized image.\n\n    \"\"\"\n    dtype = img.dtype\n    max_val = MAX_VALUES_BY_DTYPE[dtype]\n\n    if dtype == np.dtype(\"uint8\"):\n        lut = [(i if i &lt; threshold else max_val - i) for i in range(int(max_val) + 1)]\n\n        prev_shape = img.shape\n        img = cv2.LUT(img, np.array(lut, dtype=dtype))\n\n        if len(prev_shape) != len(img.shape):\n            img = np.expand_dims(img, -1)\n        return img\n\n    result_img = img.copy()\n    cond = img &gt;= threshold\n    result_img[cond] = max_val - result_img[cond]\n    return result_img\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.split_uniform_grid","title":"<code>def split_uniform_grid    (image_shape, grid)    </code> [view source on GitHub]","text":"<p>Splits an image shape into a uniform grid specified by the grid dimensions.</p> <p>Parameters:</p> Name Type Description <code>image_shape</code> <code>Tuple[int, int]</code> <p>The shape of the image as (height, width).</p> <code>grid</code> <code>Tuple[int, int]</code> <p>The grid size as (rows, columns).</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>An array containing the tiles' coordinates in the format (start_y, start_x, end_y, end_x).</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def split_uniform_grid(image_shape: Tuple[int, int], grid: Tuple[int, int]) -&gt; np.ndarray:\n    \"\"\"Splits an image shape into a uniform grid specified by the grid dimensions.\n\n    Args:\n        image_shape (Tuple[int, int]): The shape of the image as (height, width).\n        grid (Tuple[int, int]): The grid size as (rows, columns).\n\n    Returns:\n        np.ndarray: An array containing the tiles' coordinates in the format (start_y, start_x, end_y, end_x).\n    \"\"\"\n    height, width = image_shape\n    n_rows, n_cols = (int(x) for x in grid)\n\n    # Compute split points for the grid\n    height_splits = np.linspace(0, height, n_rows + 1, dtype=int)\n    width_splits = np.linspace(0, width, n_cols + 1, dtype=int)\n\n    # Calculate tiles coordinates\n    tiles = [\n        (height_splits[i], width_splits[j], height_splits[i + 1], width_splits[j + 1])\n        for i in range(n_rows)\n        for j in range(n_cols)\n    ]\n\n    return np.array(tiles)\n</code></pre>"},{"location":"api_reference/augmentations/functional/#albumentations.augmentations.functional.swap_tiles_on_image","title":"<code>def swap_tiles_on_image    (image, tiles, mapping=None)    </code> [view source on GitHub]","text":"<p>Swap tiles on the image according to the new format.</p> <p>Parameters:</p> Name Type Description <code>image</code> <code>ndarray</code> <p>Input image.</p> <code>tiles</code> <code>ndarray</code> <p>Array of tiles with each tile as [start_y, start_x, end_y, end_x].</p> <code>mapping</code> <code>Optional[List[int]]</code> <p>List of new tile indices.</p> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Output image with tiles swapped according to the random shuffle.</p> Source code in <code>albumentations/augmentations/functional.py</code> Python<pre><code>def swap_tiles_on_image(image: np.ndarray, tiles: np.ndarray, mapping: Optional[List[int]] = None) -&gt; np.ndarray:\n    \"\"\"Swap tiles on the image according to the new format.\n\n    Args:\n        image: Input image.\n        tiles: Array of tiles with each tile as [start_y, start_x, end_y, end_x].\n        mapping: List of new tile indices.\n\n    Returns:\n        np.ndarray: Output image with tiles swapped according to the random shuffle.\n    \"\"\"\n    # If no tiles are provided, return a copy of the original image\n    if tiles.size == 0 or mapping is None:\n        return image.copy()\n\n    # Create a copy of the image to retain original for reference\n    new_image = np.empty_like(image)\n    for num, new_index in enumerate(mapping):\n        start_y, start_x, end_y, end_x = tiles[new_index]\n        start_y_orig, start_x_orig, end_y_orig, end_x_orig = tiles[num]\n        # Assign the corresponding tile from the original image to the new image\n        new_image[start_y:end_y, start_x:end_x] = image[start_y_orig:end_y_orig, start_x_orig:end_x_orig]\n\n    return new_image\n</code></pre>"},{"location":"api_reference/augmentations/geometric/","title":"Geometric augmentations (augmentations.geometric)","text":""},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional","title":"<code>functional</code>","text":""},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.bbox_flip","title":"<code>def bbox_flip    (bbox, d, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a bounding box either vertically, horizontally or both depending on the value of <code>d</code>.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>d</code> <code>int</code> <p>dimension. 0 for vertical flip, 1 for horizontal, -1 for transpose</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if value of <code>d</code> is not -1, 0 or 1.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_flip(bbox: BoxInternalType, d: int, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Flip a bounding box either vertically, horizontally or both depending on the value of `d`.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        d: dimension. 0 for vertical flip, 1 for horizontal, -1 for transpose\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: if value of `d` is not -1, 0 or 1.\n\n    \"\"\"\n    if d == 0:\n        bbox = bbox_vflip(bbox, rows, cols)\n    elif d == 1:\n        bbox = bbox_hflip(bbox, rows, cols)\n    elif d == -1:\n        bbox = bbox_hflip(bbox, rows, cols)\n        bbox = bbox_vflip(bbox, rows, cols)\n    else:\n        raise ValueError(f\"Invalid d value {d}. Valid values are -1, 0 and 1\")\n    return bbox\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.bbox_hflip","title":"<code>def bbox_hflip    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a bounding box horizontally around the y-axis.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_hflip(bbox: BoxInternalType, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Flip a bounding box horizontally around the y-axis.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    return 1 - x_max, y_min, 1 - x_min, y_max\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.bbox_rot90","title":"<code>def bbox_rot90    (bbox, factor, rows, cols)    </code> [view source on GitHub]","text":"<p>Rotates a bounding box by 90 degrees CCW (see np.rot90)</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box tuple (x_min, y_min, x_max, y_max).</p> <code>factor</code> <code>int</code> <p>Number of CCW rotations. Must be in set {0, 1, 2, 3} See np.rot90.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box tuple (x_min, y_min, x_max, y_max).</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_rot90(bbox: BoxInternalType, factor: int, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Rotates a bounding box by 90 degrees CCW (see np.rot90)\n\n    Args:\n        bbox: A bounding box tuple (x_min, y_min, x_max, y_max).\n        factor: Number of CCW rotations. Must be in set {0, 1, 2, 3} See np.rot90.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        tuple: A bounding box tuple (x_min, y_min, x_max, y_max).\n\n    \"\"\"\n    if factor not in {0, 1, 2, 3}:\n        msg = \"Parameter n must be in set {0, 1, 2, 3}\"\n        raise ValueError(msg)\n    x_min, y_min, x_max, y_max = bbox[:4]\n    if factor == 1:\n        bbox = y_min, 1 - x_max, y_max, 1 - x_min\n    elif factor == TWO:\n        bbox = 1 - x_max, 1 - y_max, 1 - x_min, 1 - y_min\n    elif factor == THREE:\n        bbox = 1 - y_max, x_min, 1 - y_min, x_max\n    return bbox\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.bbox_rotate","title":"<code>def bbox_rotate    (bbox, angle, method, rows, cols)    </code> [view source on GitHub]","text":"<p>Rotates a bounding box by angle degrees.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>angle</code> <code>float</code> <p>Angle of rotation in degrees.</p> <code>method</code> <code>str</code> <p>Rotation method used. Should be one of: \"largest_box\", \"ellipse\". Default: \"largest_box\".</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>References</p> <p>https://arxiv.org/abs/2109.13488</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_rotate(bbox: BoxInternalType, angle: float, method: str, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Rotates a bounding box by angle degrees.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        angle: Angle of rotation in degrees.\n        method: Rotation method used. Should be one of: \"largest_box\", \"ellipse\". Default: \"largest_box\".\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    References:\n        https://arxiv.org/abs/2109.13488\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    scale = cols / float(rows)\n    if method == \"largest_box\":\n        x = np.array([x_min, x_max, x_max, x_min]) - 0.5\n        y = np.array([y_min, y_min, y_max, y_max]) - 0.5\n    elif method == \"ellipse\":\n        w = (x_max - x_min) / 2\n        h = (y_max - y_min) / 2\n        data = np.arange(0, 360, dtype=np.float32)\n        x = w * np.sin(np.radians(data)) + (w + x_min - 0.5)\n        y = h * np.cos(np.radians(data)) + (h + y_min - 0.5)\n    else:\n        raise ValueError(f\"Method {method} is not a valid rotation method.\")\n    angle = np.deg2rad(angle)\n    x_t = (np.cos(angle) * x * scale + np.sin(angle) * y) / scale\n    y_t = -np.sin(angle) * x * scale + np.cos(angle) * y\n    x_t = x_t + 0.5\n    y_t = y_t + 0.5\n\n    x_min, x_max = min(x_t), max(x_t)\n    y_min, y_max = min(y_t), max(y_t)\n\n    return x_min, y_min, x_max, y_max\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.bbox_transpose","title":"<code>def bbox_transpose    (bbox, axis, rows, cols)    </code> [view source on GitHub]","text":"<p>Transposes a bounding box along given axis.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>axis</code> <code>int</code> <p>0 - main axis, 1 - secondary axis.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box tuple <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If axis not equal to 0 or 1.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_transpose(bbox: KeypointInternalType, axis: int, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Transposes a bounding box along given axis.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        axis: 0 - main axis, 1 - secondary axis.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box tuple `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: If axis not equal to 0 or 1.\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    if axis not in {0, 1}:\n        msg = \"Axis must be either 0 or 1.\"\n        raise ValueError(msg)\n    if axis == 0:\n        bbox = (y_min, x_min, y_max, x_max)\n    if axis == 1:\n        bbox = (1 - y_max, 1 - x_max, 1 - y_min, 1 - x_min)\n    return bbox\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.bbox_vflip","title":"<code>def bbox_vflip    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a bounding box vertically around the x-axis.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_vflip(bbox: BoxInternalType, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Flip a bounding box vertically around the x-axis.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        tuple: A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    return x_min, 1 - y_max, x_max, 1 - y_min\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.elastic_transform","title":"<code>def elastic_transform    (img, alpha, sigma, alpha_affine, interpolation=1, border_mode=4, value=None, random_state=None, approximate=False, same_dxdy=False)    </code> [view source on GitHub]","text":"<p>Elastic deformation of images as described in [Simard2003]_ (with modifications). Based on https://gist.github.com/ernestum/601cdf56d2b424757de5</p> <p>.. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for      Convolutional Neural Networks applied to Visual Document Analysis\", in      Proc. of the International Conference on Document Analysis and      Recognition, 2003.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef elastic_transform(\n    img: np.ndarray,\n    alpha: float,\n    sigma: float,\n    alpha_affine: float,\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n    random_state: Optional[np.random.RandomState] = None,\n    approximate: bool = False,\n    same_dxdy: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications).\n    Based on https://gist.github.com/ernestum/601cdf56d2b424757de5\n\n    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for\n         Convolutional Neural Networks applied to Visual Document Analysis\", in\n         Proc. of the International Conference on Document Analysis and\n         Recognition, 2003.\n    \"\"\"\n    height, width = img.shape[:2]\n\n    # Random affine\n    center_square = np.array((height, width), dtype=np.float32) // 2\n    square_size = min((height, width)) // 3\n    alpha = float(alpha)\n    sigma = float(sigma)\n    alpha_affine = float(alpha_affine)\n\n    pts1 = np.array(\n        [\n            center_square + square_size,\n            [center_square[0] + square_size, center_square[1] - square_size],\n            center_square - square_size,\n        ],\n        dtype=np.float32,\n    )\n    pts2 = pts1 + random_utils.uniform(-alpha_affine, alpha_affine, size=pts1.shape, random_state=random_state).astype(\n        np.float32\n    )\n    matrix = cv2.getAffineTransform(pts1, pts2)\n\n    warp_fn = _maybe_process_in_chunks(\n        cv2.warpAffine, M=matrix, dsize=(width, height), flags=interpolation, borderMode=border_mode, borderValue=value\n    )\n    img = warp_fn(img)\n\n    if approximate:\n        # Approximate computation smooth displacement map with a large enough kernel.\n        # On large images (512+) this is approximately 2X times faster\n        dx = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n        cv2.GaussianBlur(dx, (17, 17), sigma, dst=dx)\n        dx *= alpha\n        if same_dxdy:\n            # Speed up even more\n            dy = dx\n        else:\n            dy = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n            cv2.GaussianBlur(dy, (17, 17), sigma, dst=dy)\n            dy *= alpha\n    else:\n        dx = np.float32(\n            gaussian_filter((random_utils.rand(height, width, random_state=random_state) * 2 - 1), sigma) * alpha\n        )\n        if same_dxdy:\n            # Speed up\n            dy = dx\n        else:\n            dy = np.float32(\n                gaussian_filter((random_utils.rand(height, width, random_state=random_state) * 2 - 1), sigma) * alpha\n            )\n\n    x, y = np.meshgrid(np.arange(width), np.arange(height))\n\n    map_x = np.float32(x + dx)\n    map_y = np.float32(y + dy)\n\n    remap_fn = _maybe_process_in_chunks(\n        cv2.remap, map1=map_x, map2=map_y, interpolation=interpolation, borderMode=border_mode, borderValue=value\n    )\n    return remap_fn(img)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.elastic_transform_approx","title":"<code>def elastic_transform_approx    (img, alpha, sigma, alpha_affine, interpolation=1, border_mode=4, value=None, random_state=None)    </code> [view source on GitHub]","text":"<p>Elastic deformation of images as described in [Simard2003]_ (with modifications for speed). Based on https://gist.github.com/ernestum/601cdf56d2b424757de5</p> <p>.. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for      Convolutional Neural Networks applied to Visual Document Analysis\", in      Proc. of the International Conference on Document Analysis and      Recognition, 2003.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef elastic_transform_approx(\n    img: np.ndarray,\n    alpha: float,\n    sigma: float,\n    alpha_affine: float,\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n    random_state: Optional[np.random.RandomState] = None,\n) -&gt; np.ndarray:\n    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications for speed).\n    Based on https://gist.github.com/ernestum/601cdf56d2b424757de5\n\n    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for\n         Convolutional Neural Networks applied to Visual Document Analysis\", in\n         Proc. of the International Conference on Document Analysis and\n         Recognition, 2003.\n    \"\"\"\n    height, width = img.shape[:2]\n\n    # Random affine\n    center_square = np.array((height, width), dtype=np.float32) // 2\n    square_size = min((height, width)) // 3\n    alpha = float(alpha)\n    sigma = float(sigma)\n    alpha_affine = float(alpha_affine)\n\n    pts1 = np.array(\n        [\n            center_square + square_size,\n            [center_square[0] + square_size, center_square[1] - square_size],\n            center_square - square_size,\n        ],\n        dtype=np.float32,\n    )\n    pts2 = pts1 + random_utils.uniform(-alpha_affine, alpha_affine, size=pts1.shape, random_state=random_state).astype(\n        np.float32\n    )\n    matrix = cv2.getAffineTransform(pts1, pts2)\n\n    warp_fn = _maybe_process_in_chunks(\n        cv2.warpAffine,\n        M=matrix,\n        dsize=(width, height),\n        flags=interpolation,\n        borderMode=border_mode,\n        borderValue=value,\n    )\n    img = warp_fn(img)\n\n    dx = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n    cv2.GaussianBlur(dx, (17, 17), sigma, dst=dx)\n    dx *= alpha\n\n    dy = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n    cv2.GaussianBlur(dy, (17, 17), sigma, dst=dy)\n    dy *= alpha\n\n    x, y = np.meshgrid(np.arange(width), np.arange(height))\n\n    map_x = np.float32(x + dx)\n    map_y = np.float32(y + dy)\n\n    remap_fn = _maybe_process_in_chunks(\n        cv2.remap,\n        map1=map_x,\n        map2=map_y,\n        interpolation=interpolation,\n        borderMode=border_mode,\n        borderValue=value,\n    )\n    return remap_fn(img)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.find_keypoint","title":"<code>def find_keypoint    (position, distance_map, threshold, inverted)    </code> [view source on GitHub]","text":"<p>Determine if a valid keypoint can be found at the given position.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def find_keypoint(\n    position: Tuple[int, int], distance_map: np.ndarray, threshold: Optional[float], inverted: bool\n) -&gt; Optional[Tuple[float, float]]:\n    \"\"\"Determine if a valid keypoint can be found at the given position.\"\"\"\n    y, x = position\n    value = distance_map[y, x]\n    if not inverted and threshold is not None and value &gt;= threshold:\n        return None\n    if inverted and threshold is not None and value &lt; threshold:\n        return None\n    return float(x), float(y)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.from_distance_maps","title":"<code>def from_distance_maps    (distance_maps, inverted, if_not_found_coords, threshold=None)    </code> [view source on GitHub]","text":"<p>Convert outputs of <code>to_distance_maps</code> to <code>KeypointsOnImage</code>. This is the inverse of <code>to_distance_maps</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def from_distance_maps(\n    distance_maps: np.ndarray,\n    inverted: bool,\n    if_not_found_coords: Optional[Union[Sequence[int], Dict[str, Any]]],\n    threshold: Optional[float] = None,\n) -&gt; List[Tuple[float, float]]:\n    \"\"\"Convert outputs of `to_distance_maps` to `KeypointsOnImage`.\n    This is the inverse of `to_distance_maps`.\n    \"\"\"\n    if distance_maps.ndim != THREE:\n        msg = f\"Expected three-dimensional input, got {distance_maps.ndim} dimensions and shape {distance_maps.shape}.\"\n        raise ValueError(msg)\n    height, width, nb_keypoints = distance_maps.shape\n\n    drop_if_not_found, if_not_found_x, if_not_found_y = validate_if_not_found_coords(if_not_found_coords)\n\n    keypoints = []\n    for i in range(nb_keypoints):\n        hitidx_flat = np.argmax(distance_maps[..., i]) if inverted else np.argmin(distance_maps[..., i])\n        hitidx_ndim = np.unravel_index(hitidx_flat, (height, width))\n        keypoint = find_keypoint(hitidx_ndim, distance_maps[:, :, i], threshold, inverted)\n        if keypoint:\n            keypoints.append(keypoint)\n        elif not drop_if_not_found:\n            keypoints.append((if_not_found_x, if_not_found_y))\n\n    return keypoints\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.grid_distortion","title":"<code>def grid_distortion    (img, num_steps=10, xsteps=(), ysteps=(), interpolation=1, border_mode=4, value=None)    </code> [view source on GitHub]","text":"<p>Perform a grid distortion of an input image.</p> <p>Reference</p> <p>http://pythology.blogspot.sg/2014/03/interpolation-on-regular-distorted-grid.html</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef grid_distortion(\n    img: np.ndarray,\n    num_steps: int = 10,\n    xsteps: Tuple[()] = (),\n    ysteps: Tuple[()] = (),\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n) -&gt; np.ndarray:\n    \"\"\"Perform a grid distortion of an input image.\n\n    Reference:\n        http://pythology.blogspot.sg/2014/03/interpolation-on-regular-distorted-grid.html\n    \"\"\"\n    height, width = img.shape[:2]\n\n    x_step = width // num_steps\n    xx = np.zeros(width, np.float32)\n    prev = 0\n    for idx in range(num_steps + 1):\n        x = idx * x_step\n        start = int(x)\n        end = int(x) + x_step\n        if end &gt; width:\n            end = width\n            cur = width\n        else:\n            cur = prev + x_step * xsteps[idx]\n\n        xx[start:end] = np.linspace(prev, cur, end - start)\n        prev = cur\n\n    y_step = height // num_steps\n    yy = np.zeros(height, np.float32)\n    prev = 0\n    for idx in range(num_steps + 1):\n        y = idx * y_step\n        start = int(y)\n        end = int(y) + y_step\n        if end &gt; height:\n            end = height\n            cur = height\n        else:\n            cur = prev + y_step * ysteps[idx]\n\n        yy[start:end] = np.linspace(prev, cur, end - start)\n        prev = cur\n\n    map_x, map_y = np.meshgrid(xx, yy)\n    map_x = map_x.astype(np.float32)\n    map_y = map_y.astype(np.float32)\n\n    remap_fn = _maybe_process_in_chunks(\n        cv2.remap,\n        map1=map_x,\n        map2=map_y,\n        interpolation=interpolation,\n        borderMode=border_mode,\n        borderValue=value,\n    )\n    return remap_fn(img)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.keypoint_flip","title":"<code>def keypoint_flip    (keypoint, d, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a keypoint either vertically, horizontally or both depending on the value of <code>d</code>.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>d</code> <code>int</code> <p>Number of flip. Must be -1, 0 or 1: * 0 - vertical flip, * 1 - horizontal flip, * -1 - vertical and horizontal flip.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if value of <code>d</code> is not -1, 0 or 1.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def keypoint_flip(keypoint: KeypointInternalType, d: int, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Flip a keypoint either vertically, horizontally or both depending on the value of `d`.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        d: Number of flip. Must be -1, 0 or 1:\n            * 0 - vertical flip,\n            * 1 - horizontal flip,\n            * -1 - vertical and horizontal flip.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    Raises:\n        ValueError: if value of `d` is not -1, 0 or 1.\n\n    \"\"\"\n    if d == 0:\n        keypoint = keypoint_vflip(keypoint, rows, cols)\n    elif d == 1:\n        keypoint = keypoint_hflip(keypoint, rows, cols)\n    elif d == -1:\n        keypoint = keypoint_hflip(keypoint, rows, cols)\n        keypoint = keypoint_vflip(keypoint, rows, cols)\n    else:\n        raise ValueError(f\"Invalid d value {d}. Valid values are -1, 0 and 1\")\n    return keypoint\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.keypoint_hflip","title":"<code>def keypoint_hflip    (keypoint, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a keypoint horizontally around the y-axis.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_hflip(keypoint: KeypointInternalType, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Flip a keypoint horizontally around the y-axis.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    angle = math.pi - angle\n    return (cols - 1) - x, y, angle, scale\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.keypoint_rot90","title":"<code>def keypoint_rot90    (keypoint, factor, rows, cols, ** params)    </code> [view source on GitHub]","text":"<p>Rotates a keypoint by 90 degrees CCW (see np.rot90)</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>factor</code> <code>int</code> <p>Number of CCW rotations. Must be in range [0;3] See np.rot90.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if factor not in set {0, 1, 2, 3}</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_rot90(\n    keypoint: KeypointInternalType, factor: int, rows: int, cols: int, **params: Any\n) -&gt; KeypointInternalType:\n    \"\"\"Rotates a keypoint by 90 degrees CCW (see np.rot90)\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        factor: Number of CCW rotations. Must be in range [0;3] See np.rot90.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        tuple: A keypoint `(x, y, angle, scale)`.\n\n    Raises:\n        ValueError: if factor not in set {0, 1, 2, 3}\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n\n    if factor not in {0, 1, 2, 3}:\n        msg = \"Parameter n must be in set {0, 1, 2, 3}\"\n        raise ValueError(msg)\n\n    if factor == 1:\n        x, y, angle = y, (cols - 1) - x, angle - math.pi / 2\n    elif factor == TWO:\n        x, y, angle = (cols - 1) - x, (rows - 1) - y, angle - math.pi\n    elif factor == THREE:\n        x, y, angle = (rows - 1) - y, x, angle + math.pi / 2\n\n    return x, y, angle, scale\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.keypoint_rotate","title":"<code>def keypoint_rotate    (keypoint, angle, rows, cols, ** params)    </code> [view source on GitHub]","text":"<p>Rotate a keypoint by angle.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>angle</code> <code>float</code> <p>Rotation angle.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_rotate(\n    keypoint: KeypointInternalType, angle: float, rows: int, cols: int, **params: Any\n) -&gt; KeypointInternalType:\n    \"\"\"Rotate a keypoint by angle.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        angle: Rotation angle.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    center = (cols - 1) * 0.5, (rows - 1) * 0.5\n    matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n    x, y, a, s = keypoint[:4]\n    x, y = cv2.transform(np.array([[[x, y]]]), matrix).squeeze()\n    return x, y, a + math.radians(angle), s\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.keypoint_scale","title":"<code>def keypoint_scale    (keypoint, scale_x, scale_y)    </code> [view source on GitHub]","text":"<p>Scales a keypoint by scale_x and scale_y.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>scale_x</code> <code>float</code> <p>Scale coefficient x-axis.</p> <code>scale_y</code> <code>float</code> <p>Scale coefficient y-axis.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def keypoint_scale(keypoint: KeypointInternalType, scale_x: float, scale_y: float) -&gt; KeypointInternalType:\n    \"\"\"Scales a keypoint by scale_x and scale_y.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        scale_x: Scale coefficient x-axis.\n        scale_y: Scale coefficient y-axis.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    return x * scale_x, y * scale_y, angle, scale * max(scale_x, scale_y)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.keypoint_transpose","title":"<code>def keypoint_transpose    (keypoint)    </code> [view source on GitHub]","text":"<p>Rotate a keypoint by angle.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def keypoint_transpose(keypoint: KeypointInternalType) -&gt; KeypointInternalType:\n    \"\"\"Rotate a keypoint by angle.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n\n    angle = np.pi - angle if angle &lt;= np.pi else 3 * np.pi - angle\n\n    return y, x, angle, scale\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.keypoint_vflip","title":"<code>def keypoint_vflip    (keypoint, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a keypoint vertically around the x-axis.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_vflip(keypoint: KeypointInternalType, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Flip a keypoint vertically around the x-axis.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        tuple: A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    angle = -angle\n    return x, (rows - 1) - y, angle, scale\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.optical_distortion","title":"<code>def optical_distortion    (img, k=0, dx=0, dy=0, interpolation=1, border_mode=4, value=None)    </code> [view source on GitHub]","text":"<p>Barrel / pincushion distortion. Unconventional augment.</p> <p>Reference</p> <p>|  https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion |  https://stackoverflow.com/questions/10364201/image-transformation-in-opencv |  https://stackoverflow.com/questions/2477774/correcting-fisheye-distortion-programmatically |  http://www.coldvision.io/2017/03/02/advanced-lane-finding-using-opencv/</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef optical_distortion(\n    img: np.ndarray,\n    k: int = 0,\n    dx: int = 0,\n    dy: int = 0,\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n) -&gt; np.ndarray:\n    \"\"\"Barrel / pincushion distortion. Unconventional augment.\n\n    Reference:\n        |  https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion\n        |  https://stackoverflow.com/questions/10364201/image-transformation-in-opencv\n        |  https://stackoverflow.com/questions/2477774/correcting-fisheye-distortion-programmatically\n        |  http://www.coldvision.io/2017/03/02/advanced-lane-finding-using-opencv/\n    \"\"\"\n    height, width = img.shape[:2]\n\n    fx = width\n    fy = height\n\n    cx = width * 0.5 + dx\n    cy = height * 0.5 + dy\n\n    camera_matrix = np.array([[fx, 0, cx], [0, fy, cy], [0, 0, 1]], dtype=np.float32)\n\n    distortion = np.array([k, k, 0, 0, 0], dtype=np.float32)\n    map1, map2 = cv2.initUndistortRectifyMap(camera_matrix, distortion, None, None, (width, height), cv2.CV_32FC1)\n    return cv2.remap(img, map1, map2, interpolation=interpolation, borderMode=border_mode, borderValue=value)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.rotation2d_matrix_to_euler_angles","title":"<code>def rotation2d_matrix_to_euler_angles    (matrix, y_up=False)    </code> [view source on GitHub]","text":"<p>matrix (np.ndarray): Rotation matrix y_up (bool): is Y axis looks up or down</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def rotation2d_matrix_to_euler_angles(matrix: np.ndarray, y_up: bool = False) -&gt; float:\n    \"\"\"Args:\n    matrix (np.ndarray): Rotation matrix\n    y_up (bool): is Y axis looks up or down\n\n    \"\"\"\n    if y_up:\n        return np.arctan2(matrix[1, 0], matrix[0, 0])\n    return np.arctan2(-matrix[1, 0], matrix[0, 0])\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.to_distance_maps","title":"<code>def to_distance_maps    (keypoints, height, width, inverted=False)    </code> [view source on GitHub]","text":"<p>Generate a <code>(H,W,N)</code> array of distance maps for <code>N</code> keypoints.</p> <p>The <code>n</code>-th distance map contains at every location <code>(y, x)</code> the euclidean distance to the <code>n</code>-th keypoint.</p> <p>This function can be used as a helper when augmenting keypoints with a method that only supports the augmentation of images.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <p>keypoint coordinates</p> <code>height</code> <code>int</code> <p>image height</p> <code>width</code> <code>int</code> <p>image width</p> <code>inverted</code> <code>bool</code> <p>If <code>True</code>, inverted distance maps are returned where each distance value d is replaced by <code>d/(d+1)</code>, i.e. the distance maps have values in the range <code>(0.0, 1.0]</code> with <code>1.0</code> denoting exactly the position of the respective keypoint.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(H, W, N) ndarray     A <code>float32</code> array containing <code>N</code> distance maps for <code>N</code>     keypoints. Each location <code>(y, x, n)</code> in the array denotes the     euclidean distance at <code>(y, x)</code> to the <code>n</code>-th keypoint.     If <code>inverted</code> is <code>True</code>, the distance <code>d</code> is replaced     by <code>d/(d+1)</code>. The height and width of the array match the     height and width in <code>KeypointsOnImage.shape</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def to_distance_maps(\n    keypoints: Sequence[Tuple[float, float]], height: int, width: int, inverted: bool = False\n) -&gt; np.ndarray:\n    \"\"\"Generate a ``(H,W,N)`` array of distance maps for ``N`` keypoints.\n\n    The ``n``-th distance map contains at every location ``(y, x)`` the\n    euclidean distance to the ``n``-th keypoint.\n\n    This function can be used as a helper when augmenting keypoints with a\n    method that only supports the augmentation of images.\n\n    Args:\n        keypoint: keypoint coordinates\n        height: image height\n        width: image width\n        inverted (bool): If ``True``, inverted distance maps are returned where each\n            distance value d is replaced by ``d/(d+1)``, i.e. the distance\n            maps have values in the range ``(0.0, 1.0]`` with ``1.0`` denoting\n            exactly the position of the respective keypoint.\n\n    Returns:\n        (H, W, N) ndarray\n            A ``float32`` array containing ``N`` distance maps for ``N``\n            keypoints. Each location ``(y, x, n)`` in the array denotes the\n            euclidean distance at ``(y, x)`` to the ``n``-th keypoint.\n            If `inverted` is ``True``, the distance ``d`` is replaced\n            by ``d/(d+1)``. The height and width of the array match the\n            height and width in ``KeypointsOnImage.shape``.\n\n    \"\"\"\n    distance_maps = np.zeros((height, width, len(keypoints)), dtype=np.float32)\n\n    yy = np.arange(0, height)\n    xx = np.arange(0, width)\n    grid_xx, grid_yy = np.meshgrid(xx, yy)\n\n    for i, (x, y) in enumerate(keypoints):\n        distance_maps[:, :, i] = (grid_xx - x) ** 2 + (grid_yy - y) ** 2\n\n    distance_maps = np.sqrt(distance_maps)\n    if inverted:\n        return 1 / (distance_maps + 1)\n    return distance_maps\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.functional.validate_if_not_found_coords","title":"<code>def validate_if_not_found_coords    (if_not_found_coords)    </code> [view source on GitHub]","text":"<p>Validate and process <code>if_not_found_coords</code> parameter.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def validate_if_not_found_coords(\n    if_not_found_coords: Optional[Union[Sequence[int], Dict[str, Any]]],\n) -&gt; Tuple[bool, int, int]:\n    \"\"\"Validate and process `if_not_found_coords` parameter.\"\"\"\n    if if_not_found_coords is None:\n        return True, -1, -1\n    if isinstance(if_not_found_coords, (tuple, list)):\n        if len(if_not_found_coords) != TWO:\n            msg = \"Expected tuple/list 'if_not_found_coords' to contain exactly two entries.\"\n            raise ValueError(msg)\n        return False, if_not_found_coords[0], if_not_found_coords[1]\n    if isinstance(if_not_found_coords, dict):\n        return False, if_not_found_coords[\"x\"], if_not_found_coords[\"y\"]\n\n    msg = \"Expected if_not_found_coords to be None, tuple, list, or dict.\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.resize","title":"<code>resize</code>","text":""},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.resize.LongestMaxSize","title":"<code>class  LongestMaxSize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rescale an image so that maximum side is equal to max_size, keeping the aspect ratio of the initial image.</p> <p>Parameters:</p> Name Type Description <code>max_size</code> <code>int, list of int</code> <p>maximum size of the image after the transformation. When using a list, max size will be randomly selected from the values in the list.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>interpolation method. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class LongestMaxSize(DualTransform):\n    \"\"\"Rescale an image so that maximum side is equal to max_size, keeping the aspect ratio of the initial image.\n\n    Args:\n        max_size (int, list of int): maximum size of the image after the transformation. When using a list, max size\n            will be randomly selected from the values in the list.\n        interpolation (OpenCV flag): interpolation method. Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(MaxSizeInitSchema):\n        pass\n\n    def __init__(\n        self,\n        max_size: Union[int, Sequence[int]] = 1024,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1,\n    ):\n        super().__init__(always_apply, p)\n        self.interpolation = interpolation\n        self.max_size = max_size\n\n    def apply(\n        self, img: np.ndarray, max_size: int = 1024, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.longest_max_size(img, max_size=max_size, interpolation=interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        # Bounding box coordinates are scale invariant\n        return bbox\n\n    def apply_to_keypoint(\n        self, keypoint: KeypointInternalType, max_size: int = 1024, **params: Any\n    ) -&gt; KeypointInternalType:\n        height = params[\"rows\"]\n        width = params[\"cols\"]\n\n        scale = max_size / max([height, width])\n        return F.keypoint_scale(keypoint, scale, scale)\n\n    def get_params(self) -&gt; Dict[str, int]:\n        return {\"max_size\": self.max_size if isinstance(self.max_size, int) else random.choice(self.max_size)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"max_size\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.resize.RandomScale","title":"<code>class  RandomScale</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly resize the input. Output image size is different from the input image size.</p> <p>Parameters:</p> Name Type Description <code>scale_limit</code> <code>float, float) or float</code> <p>scaling factor range. If scale_limit is a single float value, the range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1. If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high). Default: (-0.1, 0.1).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class RandomScale(DualTransform):\n    \"\"\"Randomly resize the input. Output image size is different from the input image size.\n\n    Args:\n        scale_limit ((float, float) or float): scaling factor range. If scale_limit is a single float value, the\n            range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1.\n            If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high).\n            Default: (-0.1, 0.1).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale_limit: ScaleFloatType = Field(\n            default=0.1,\n            description=\"Scaling factor range. If a single float value =&gt; (1-scale_limit, 1 + scale_limit).\",\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n        @field_validator(\"scale_limit\")\n        @classmethod\n        def check_scale_limit(cls, v: ScaleFloatType) -&gt; Tuple[float, float]:\n            return to_tuple(v, bias=1.0)\n\n    def __init__(\n        self,\n        scale_limit: ScaleFloatType = 0.1,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.scale_limit = cast(Tuple[float, float], scale_limit)\n        self.interpolation = interpolation\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"scale\": random.uniform(self.scale_limit[0], self.scale_limit[1])}\n\n    def apply(\n        self, img: np.ndarray, scale: float = 0, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.scale(img, scale, interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        # Bounding box coordinates are scale invariant\n        return bbox\n\n    def apply_to_keypoint(\n        self, keypoint: KeypointInternalType, scale: float = 0, **params: Any\n    ) -&gt; KeypointInternalType:\n        return F.keypoint_scale(keypoint, scale, scale)\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\"interpolation\": self.interpolation, \"scale_limit\": to_tuple(self.scale_limit, bias=-1.0)}\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.resize.Resize","title":"<code>class  Resize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Resize the input to the given height and width.</p> <p>Parameters:</p> Name Type Description <code>height</code> <code>int</code> <p>desired height of the output.</p> <code>width</code> <code>int</code> <p>desired width of the output.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class Resize(DualTransform):\n    \"\"\"Resize the input to the given height and width.\n\n    Args:\n        height (int): desired height of the output.\n        width (int): desired width of the output.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        height: int = Field(ge=1, description=\"Desired height of the output.\")\n        width: int = Field(ge=1, description=\"Desired width of the output.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        p: ProbabilityType = 1\n\n    def __init__(\n        self, height: int, width: int, interpolation: int = cv2.INTER_LINEAR, always_apply: bool = False, p: float = 1\n    ):\n        super().__init__(always_apply, p)\n        self.height = height\n        self.width = width\n        self.interpolation = interpolation\n\n    def apply(self, img: np.ndarray, interpolation: int = cv2.INTER_LINEAR, **params: Any) -&gt; np.ndarray:\n        return F.resize(img, height=self.height, width=self.width, interpolation=interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        # Bounding box coordinates are scale invariant\n        return bbox\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        height = params[\"rows\"]\n        width = params[\"cols\"]\n        scale_x = self.width / width\n        scale_y = self.height / height\n        return F.keypoint_scale(keypoint, scale_x, scale_y)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"height\", \"width\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.resize.SmallestMaxSize","title":"<code>class  SmallestMaxSize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rescale an image so that minimum side is equal to max_size, keeping the aspect ratio of the initial image.</p> <p>Parameters:</p> Name Type Description <code>max_size</code> <code>int, list of int</code> <p>maximum size of smallest side of the image after the transformation. When using a list, max size will be randomly selected from the values in the list.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>interpolation method. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class SmallestMaxSize(DualTransform):\n    \"\"\"Rescale an image so that minimum side is equal to max_size, keeping the aspect ratio of the initial image.\n\n    Args:\n        max_size (int, list of int): maximum size of smallest side of the image after the transformation. When using a\n            list, max size will be randomly selected from the values in the list.\n        interpolation (OpenCV flag): interpolation method. Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(MaxSizeInitSchema):\n        pass\n\n    def __init__(\n        self,\n        max_size: Union[int, Sequence[int]] = 1024,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1,\n    ):\n        super().__init__(always_apply, p)\n        self.interpolation = interpolation\n        self.max_size = max_size\n\n    def apply(\n        self, img: np.ndarray, max_size: int = 1024, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.smallest_max_size(img, max_size=max_size, interpolation=interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return bbox\n\n    def apply_to_keypoint(\n        self, keypoint: KeypointInternalType, max_size: int = 1024, **params: Any\n    ) -&gt; KeypointInternalType:\n        height = params[\"rows\"]\n        width = params[\"cols\"]\n\n        scale = max_size / min([height, width])\n        return F.keypoint_scale(keypoint, scale, scale)\n\n    def get_params(self) -&gt; Dict[str, int]:\n        return {\"max_size\": self.max_size if isinstance(self.max_size, int) else random.choice(self.max_size)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"max_size\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.rotate","title":"<code>rotate</code>","text":""},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.rotate.RandomRotate90","title":"<code>class  RandomRotate90</code> <code> </code>  [view source on GitHub]","text":"<p>Randomly rotate the input by 90 degrees zero or more times.</p> <p>Parameters:</p> Name Type Description <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>class RandomRotate90(DualTransform):\n    \"\"\"Randomly rotate the input by 90 degrees zero or more times.\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, factor: float = 0, **params: Any) -&gt; np.ndarray:\n        \"\"\"Args:\n        factor (int): number of times the input will be rotated by 90 degrees.\n\n        \"\"\"\n        return np.ascontiguousarray(np.rot90(img, factor))\n\n    def get_params(self) -&gt; Dict[str, int]:\n        # Random int in the range [0, 3]\n        return {\"factor\": random.randint(0, 3)}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, factor: int = 0, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_rot90(bbox, factor, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, factor: int = 0, **params: Any) -&gt; BoxInternalType:\n        return F.keypoint_rot90(keypoint, factor, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.rotate.RandomRotate90.apply","title":"<code>apply (self, img, factor=0, **params)</code>","text":"<p>factor (int): number of times the input will be rotated by 90 degrees.</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>def apply(self, img: np.ndarray, factor: float = 0, **params: Any) -&gt; np.ndarray:\n    \"\"\"Args:\n    factor (int): number of times the input will be rotated by 90 degrees.\n\n    \"\"\"\n    return np.ascontiguousarray(np.rot90(img, factor))\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.rotate.Rotate","title":"<code>class  Rotate</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rotate the input by an angle selected randomly from the uniform distribution.</p> <p>Parameters:</p> Name Type Description <code>limit</code> <p>range from which a random angle is picked. If limit is a single int an angle is picked from (-limit, limit). Default: (-90, 90)</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>rotate_method</code> <code>str</code> <p>rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\". Default: \"largest_box\"</p> <code>crop_border</code> <code>bool</code> <p>If True would make a largest possible crop within rotated image</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>class Rotate(DualTransform):\n    \"\"\"Rotate the input by an angle selected randomly from the uniform distribution.\n\n    Args:\n        limit: range from which a random angle is picked. If limit is a single int\n            an angle is picked from (-limit, limit). Default: (-90, 90)\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        rotate_method (str): rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\".\n            Default: \"largest_box\"\n        crop_border (bool): If True would make a largest possible crop within rotated image\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(RotateInitSchema):\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\"\n        crop_border: bool = Field(\n            default=False, description=\"If True, makes a largest possible crop within the rotated image.\"\n        )\n\n    def __init__(\n        self,\n        limit: ScaleFloatType = 90,\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\",\n        crop_border: bool = False,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.limit = cast(Tuple[float, float], limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n        self.rotate_method = rotate_method\n        self.crop_border = crop_border\n\n    def apply(\n        self,\n        img: np.ndarray,\n        angle: float = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        img_out = F.rotate(img, angle, interpolation, self.border_mode, self.value)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.crop(img_out, x_min, y_min, x_max, y_max)\n        return img_out\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        angle: float,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        img_out = F.rotate(mask, angle, cv2.INTER_NEAREST, self.border_mode, self.mask_value)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.crop(img_out, x_min, y_min, x_max, y_max)\n        return img_out\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        angle: float = 0,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        cols: int = 0,\n        rows: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        bbox_out = F.bbox_rotate(bbox, angle, self.rotate_method, rows, cols)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.bbox_crop(bbox_out, x_min, y_min, x_max, y_max, rows, cols)\n        return bbox_out\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        angle: float = 0,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        cols: int = 0,\n        rows: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        keypoint_out = F.keypoint_rotate(keypoint, angle, rows, cols, **params)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.crop_keypoint_by_coords(keypoint_out, (x_min, y_min, x_max, y_max))\n        return keypoint_out\n\n    @staticmethod\n    def _rotated_rect_with_max_area(height: int, width: int, angle: float) -&gt; Dict[str, int]:\n        \"\"\"Given a rectangle of size wxh that has been rotated by 'angle' (in\n        degrees), computes the width and height of the largest possible\n        axis-aligned rectangle (maximal area) within the rotated rectangle.\n\n        Reference:\n            https://stackoverflow.com/questions/16702966/rotate-image-and-crop-out-black-borders\n        \"\"\"\n        angle = math.radians(angle)\n        width_is_longer = width &gt;= height\n        side_long, side_short = (width, height) if width_is_longer else (height, width)\n\n        # since the solutions for angle, -angle and 180-angle are all the same,\n        # it is sufficient to look at the first quadrant and the absolute values of sin,cos:\n        sin_a, cos_a = abs(math.sin(angle)), abs(math.cos(angle))\n        if side_short &lt;= 2.0 * sin_a * cos_a * side_long or abs(sin_a - cos_a) &lt; SMALL_NUMBER:\n            # half constrained case: two crop corners touch the longer side,\n            # the other two corners are on the mid-line parallel to the longer line\n            x = 0.5 * side_short\n            wr, hr = (x / sin_a, x / cos_a) if width_is_longer else (x / cos_a, x / sin_a)\n        else:\n            # fully constrained case: crop touches all 4 sides\n            cos_2a = cos_a * cos_a - sin_a * sin_a\n            wr, hr = (width * cos_a - height * sin_a) / cos_2a, (height * cos_a - width * sin_a) / cos_2a\n\n        return {\n            \"x_min\": max(0, int(width / 2 - wr / 2)),\n            \"x_max\": min(width, int(width / 2 + wr / 2)),\n            \"y_min\": max(0, int(height / 2 - hr / 2)),\n            \"y_max\": min(height, int(height / 2 + hr / 2)),\n        }\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        out_params = {\"angle\": random.uniform(self.limit[0], self.limit[1])}\n        if self.crop_border:\n            height, width = params[\"image\"].shape[:2]\n            out_params.update(self._rotated_rect_with_max_area(height, width, out_params[\"angle\"]))\n        return out_params\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"limit\", \"interpolation\", \"border_mode\", \"value\", \"mask_value\", \"rotate_method\", \"crop_border\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.rotate.SafeRotate","title":"<code>class  SafeRotate</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rotate the input inside the input's frame by an angle selected randomly from the uniform distribution.</p> <p>The resulting image may have artifacts in it. After rotation, the image may have a different aspect ratio, and after resizing, it returns to its original shape with the original aspect ratio of the image. For these reason we may see some artifacts.</p> <p>Parameters:</p> Name Type Description <code>limit</code> <code>int, int) or int</code> <p>range from which a random angle is picked. If limit is a single int an angle is picked from (-limit, limit). Default: (-90, 90)</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>class SafeRotate(DualTransform):\n    \"\"\"Rotate the input inside the input's frame by an angle selected randomly from the uniform distribution.\n\n    The resulting image may have artifacts in it. After rotation, the image may have a different aspect ratio, and\n    after resizing, it returns to its original shape with the original aspect ratio of the image. For these reason we\n    may see some artifacts.\n\n    Args:\n        limit ((int, int) or int): range from which a random angle is picked. If limit is a single int\n            an angle is picked from (-limit, limit). Default: (-90, 90)\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(RotateInitSchema):\n        pass\n\n    def __init__(\n        self,\n        limit: ScaleFloatType = (-90, 90),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.limit = cast(Tuple[float, float], limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def apply(self, img: np.ndarray, matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.safe_rotate(img, matrix, cast(int, self.interpolation), self.value, self.border_mode)\n\n    def apply_to_mask(self, mask: np.ndarray, matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.safe_rotate(mask, matrix, cv2.INTER_NEAREST, self.mask_value, self.border_mode)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, cols: int = 0, rows: int = 0, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_safe_rotate(bbox, params[\"matrix\"], cols, rows)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        angle: float = 0,\n        scale_x: float = 0,\n        scale_y: float = 0,\n        cols: int = 0,\n        rows: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.keypoint_safe_rotate(keypoint, params[\"matrix\"], angle, scale_x, scale_y, cols, rows)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        angle = random.uniform(self.limit[0], self.limit[1])\n\n        image = params[\"image\"]\n        height, width = image.shape[:2]\n\n        # https://stackoverflow.com/questions/43892506/opencv-python-rotate-image-without-cropping-sides\n        image_center = (width / 2, height / 2)\n\n        # Rotation Matrix\n        rotation_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n\n        # rotation calculates the cos and sin, taking absolutes of those.\n        abs_cos = abs(rotation_mat[0, 0])\n        abs_sin = abs(rotation_mat[0, 1])\n\n        # find the new width and height bounds\n        new_w = math.ceil(height * abs_sin + width * abs_cos)\n        new_h = math.ceil(height * abs_cos + width * abs_sin)\n\n        scale_x = width / new_w\n        scale_y = height / new_h\n\n        # Shift the image to create padding\n        rotation_mat[0, 2] += new_w / 2 - image_center[0]\n        rotation_mat[1, 2] += new_h / 2 - image_center[1]\n\n        # Rescale to original size\n        scale_mat = np.diag(np.ones(3))\n        scale_mat[0, 0] *= scale_x\n        scale_mat[1, 1] *= scale_y\n        _tmp = np.diag(np.ones(3))\n        _tmp[:2] = rotation_mat\n        _tmp = scale_mat @ _tmp\n        rotation_mat = _tmp[:2]\n\n        return {\"matrix\": rotation_mat, \"angle\": angle, \"scale_x\": scale_x, \"scale_y\": scale_y}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str, str]:\n        return (\"limit\", \"interpolation\", \"border_mode\", \"value\", \"mask_value\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms","title":"<code>transforms</code>","text":""},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.Affine","title":"<code>class  Affine</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Augmentation to apply affine transformations to images. This is mostly a wrapper around the corresponding classes and functions in OpenCV.</p> <p>Affine transformations involve:</p> <pre><code>- Translation (\"move\" image on the x-/y-axis)\n- Rotation\n- Scaling (\"zoom\" in/out)\n- Shear (move one side of the image, turning a square into a trapezoid)\n</code></pre> <p>All such transformations can create \"new\" pixels in the image without a defined content, e.g. if the image is translated to the left, pixels are created on the right. A method has to be defined to deal with these pixel values. The parameters <code>cval</code> and <code>mode</code> of this class deal with this.</p> <p>Some transformations involve interpolations between several pixels of the input image to generate output pixel values. The parameters <code>interpolation</code> and <code>mask_interpolation</code> deals with the method of interpolation used for this.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <code>number, tuple of number or dict</code> <p>Scaling factor to use, where <code>1.0</code> denotes \"no change\" and <code>0.5</code> is zoomed out to <code>50</code> percent of the original size.     * If a single number, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from the interval <code>[a, b]</code>.       That the same range will be used for both x- and y-axis. To keep the aspect ratio, set       <code>keep_ratio=True</code>, then the same value will be used for both x- and y-axis.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes. Note that when       the <code>keep_ratio=True</code>, the x- and y-axis ranges should be the same.</p> <code>translate_percent</code> <code>None, number, tuple of number or dict</code> <p>Translation as a fraction of the image height/width (x-translation, y-translation), where <code>0</code> denotes \"no change\" and <code>0.5</code> denotes \"half of the axis size\".     * If <code>None</code> then equivalent to <code>0.0</code> unless <code>translate_px</code> has a value other than <code>None</code>.     * If a single number, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from the interval <code>[a, b]</code>.       That sampled fraction value will be used identically for both x- and y-axis.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes.</p> <code>translate_px</code> <code>None, int, tuple of int or dict</code> <p>Translation in pixels.     * If <code>None</code> then equivalent to <code>0</code> unless <code>translate_percent</code> has a value other than <code>None</code>.     * If a single int, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from       the discrete interval <code>[a..b]</code>. That number will be used identically for both x- and y-axis.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes.</p> <code>rotate</code> <code>number or tuple of number</code> <p>Rotation in degrees (NOT radians), i.e. expected value range is around <code>[-360, 360]</code>. Rotation happens around the center of the image, not the top left corner as in some other frameworks.     * If a number, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from the interval <code>[a, b]</code>       and used as the rotation value.</p> <code>shear</code> <code>number, tuple of number or dict</code> <p>Shear in degrees (NOT radians), i.e. expected value range is around <code>[-360, 360]</code>, with reasonable values being in the range of <code>[-45, 45]</code>.     * If a number, then that value will be used for all images as       the shear on the x-axis (no shear on the y-axis will be done).     * If a tuple <code>(a, b)</code>, then two value will be uniformly sampled per image       from the interval <code>[a, b]</code> and be used as the x- and y-shear value.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes.</p> <code>interpolation</code> <code>int</code> <p>OpenCV interpolation flag.</p> <code>mask_interpolation</code> <code>int</code> <p>OpenCV interpolation flag.</p> <code>cval</code> <code>number or sequence of number</code> <p>The constant value to use when filling in newly created pixels. (E.g. translating by 1px to the right will create a new 1px-wide column of pixels on the left of the image). The value is only used when <code>mode=constant</code>. The expected value range is <code>[0, 255]</code> for <code>uint8</code> images.</p> <code>cval_mask</code> <code>number or tuple of number</code> <p>Same as cval but only for masks.</p> <code>mode</code> <code>int</code> <p>OpenCV border flag.</p> <code>fit_output</code> <code>bool</code> <p>If True, the image plane size and position will be adjusted to tightly capture the whole image after affine transformation (<code>translate_percent</code> and <code>translate_px</code> are ignored). Otherwise (<code>False</code>),  parts of the transformed image may end up outside the image plane. Fitting the output shape can be useful to avoid corners of the image being outside the image plane after applying rotations. Default: False</p> <code>keep_ratio</code> <code>bool</code> <p>When True, the original aspect ratio will be kept when the random scale is applied.                Default: False.</p> <code>rotate_method</code> <code>str</code> <p>rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\"[1]. Default: \"largest_box\"</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>[1] https://arxiv.org/abs/2109.13488</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Affine(DualTransform):\n    \"\"\"Augmentation to apply affine transformations to images.\n    This is mostly a wrapper around the corresponding classes and functions in OpenCV.\n\n    Affine transformations involve:\n\n        - Translation (\"move\" image on the x-/y-axis)\n        - Rotation\n        - Scaling (\"zoom\" in/out)\n        - Shear (move one side of the image, turning a square into a trapezoid)\n\n    All such transformations can create \"new\" pixels in the image without a defined content, e.g.\n    if the image is translated to the left, pixels are created on the right.\n    A method has to be defined to deal with these pixel values.\n    The parameters `cval` and `mode` of this class deal with this.\n\n    Some transformations involve interpolations between several pixels\n    of the input image to generate output pixel values. The parameters `interpolation` and\n    `mask_interpolation` deals with the method of interpolation used for this.\n\n    Args:\n        scale (number, tuple of number or dict): Scaling factor to use, where ``1.0`` denotes \"no change\" and\n            ``0.5`` is zoomed out to ``50`` percent of the original size.\n                * If a single number, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from the interval ``[a, b]``.\n                  That the same range will be used for both x- and y-axis. To keep the aspect ratio, set\n                  ``keep_ratio=True``, then the same value will be used for both x- and y-axis.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes. Note that when\n                  the ``keep_ratio=True``, the x- and y-axis ranges should be the same.\n        translate_percent (None, number, tuple of number or dict): Translation as a fraction of the image height/width\n            (x-translation, y-translation), where ``0`` denotes \"no change\"\n            and ``0.5`` denotes \"half of the axis size\".\n                * If ``None`` then equivalent to ``0.0`` unless `translate_px` has a value other than ``None``.\n                * If a single number, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from the interval ``[a, b]``.\n                  That sampled fraction value will be used identically for both x- and y-axis.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes.\n        translate_px (None, int, tuple of int or dict): Translation in pixels.\n                * If ``None`` then equivalent to ``0`` unless `translate_percent` has a value other than ``None``.\n                * If a single int, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from\n                  the discrete interval ``[a..b]``. That number will be used identically for both x- and y-axis.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes.\n        rotate (number or tuple of number): Rotation in degrees (**NOT** radians), i.e. expected value range is\n            around ``[-360, 360]``. Rotation happens around the *center* of the image,\n            not the top left corner as in some other frameworks.\n                * If a number, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from the interval ``[a, b]``\n                  and used as the rotation value.\n        shear (number, tuple of number or dict): Shear in degrees (**NOT** radians), i.e. expected value range is\n            around ``[-360, 360]``, with reasonable values being in the range of ``[-45, 45]``.\n                * If a number, then that value will be used for all images as\n                  the shear on the x-axis (no shear on the y-axis will be done).\n                * If a tuple ``(a, b)``, then two value will be uniformly sampled per image\n                  from the interval ``[a, b]`` and be used as the x- and y-shear value.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes.\n        interpolation (int): OpenCV interpolation flag.\n        mask_interpolation (int): OpenCV interpolation flag.\n        cval (number or sequence of number): The constant value to use when filling in newly created pixels.\n            (E.g. translating by 1px to the right will create a new 1px-wide column of pixels\n            on the left of the image).\n            The value is only used when `mode=constant`. The expected value range is ``[0, 255]`` for ``uint8`` images.\n        cval_mask (number or tuple of number): Same as cval but only for masks.\n        mode (int): OpenCV border flag.\n        fit_output (bool): If True, the image plane size and position will be adjusted to tightly capture\n            the whole image after affine transformation (`translate_percent` and `translate_px` are ignored).\n            Otherwise (``False``),  parts of the transformed image may end up outside the image plane.\n            Fitting the output shape can be useful to avoid corners of the image being outside the image plane\n            after applying rotations. Default: False\n        keep_ratio (bool): When True, the original aspect ratio will be kept when the random scale is applied.\n                           Default: False.\n        rotate_method (str): rotation method used for the bounding boxes. Should be one of \"largest_box\" or\n            \"ellipse\"[1].\n            Default: \"largest_box\"\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        [1] https://arxiv.org/abs/2109.13488\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: Optional[Union[ScaleFloatType, Dict[str, Any]]] = Field(\n            default=None, description=\"Scaling factor or dictionary for independent axis scaling.\"\n        )\n        translate_percent: Optional[Union[ScaleFloatType, Dict[str, Any]]] = Field(\n            default=None, description=\"Translation as a fraction of the image dimension.\"\n        )\n        translate_px: Optional[Union[ScaleIntType, Dict[str, Any]]] = Field(\n            default=None, description=\"Translation in pixels.\"\n        )\n        rotate: Optional[ScaleFloatType] = Field(default=None, description=\"Rotation angle in degrees.\")\n        shear: Optional[Union[ScaleFloatType, Dict[str, Any]]] = Field(\n            default=None, description=\"Shear angle in degrees.\"\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        mask_interpolation: InterpolationType = cv2.INTER_NEAREST\n\n        cval: ColorType = Field(default=0, description=\"Value used for constant padding.\")\n        cval_mask: ColorType = Field(default=0, description=\"Value used for mask constant padding.\")\n        mode: BorderModeType = cv2.BORDER_CONSTANT\n        fit_output: Annotated[bool, Field(default=False, description=\"Adjust output to capture whole image.\")]\n        keep_ratio: Annotated[bool, Field(default=False, description=\"Maintain aspect ratio when scaling.\")]\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\"\n\n    def __init__(\n        self,\n        scale: Optional[Union[ScaleFloatType, Dict[str, Any]]] = None,\n        translate_percent: Optional[Union[ScaleFloatType, Dict[str, Any]]] = None,\n        translate_px: Optional[Union[ScaleIntType, Dict[str, Any]]] = None,\n        rotate: Optional[ScaleFloatType] = None,\n        shear: Optional[Union[ScaleFloatType, Dict[str, Any]]] = None,\n        interpolation: int = cv2.INTER_LINEAR,\n        mask_interpolation: int = cv2.INTER_NEAREST,\n        cval: ColorType = 0,\n        cval_mask: ColorType = 0,\n        mode: int = cv2.BORDER_CONSTANT,\n        fit_output: bool = False,\n        keep_ratio: bool = False,\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        params = [scale, translate_percent, translate_px, rotate, shear]\n        if all(p is None for p in params):\n            scale = {\"x\": (0.9, 1.1), \"y\": (0.9, 1.1)}\n            translate_percent = {\"x\": (-0.1, 0.1), \"y\": (-0.1, 0.1)}\n            rotate = (-15, 15)\n            shear = {\"x\": (-10, 10), \"y\": (-10, 10)}\n        else:\n            scale = scale if scale is not None else 1.0\n            rotate = rotate if rotate is not None else 0.0\n            shear = shear if shear is not None else 0.0\n\n        self.interpolation = interpolation\n        self.mask_interpolation = mask_interpolation\n        self.cval = cval\n        self.cval_mask = cval_mask\n        self.mode = mode\n        self.scale = self._handle_dict_arg(scale, \"scale\")\n        self.translate_percent, self.translate_px = self._handle_translate_arg(translate_px, translate_percent)\n        self.rotate = to_tuple(rotate, rotate)\n        self.fit_output = fit_output\n        self.shear = self._handle_dict_arg(shear, \"shear\")\n        self.keep_ratio = keep_ratio\n        self.rotate_method = rotate_method\n\n        if self.keep_ratio and self.scale[\"x\"] != self.scale[\"y\"]:\n            raise ValueError(f\"When keep_ratio is True, the x and y scale range should be identical. got {self.scale}\")\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"interpolation\",\n            \"mask_interpolation\",\n            \"cval\",\n            \"mode\",\n            \"scale\",\n            \"translate_percent\",\n            \"translate_px\",\n            \"rotate\",\n            \"fit_output\",\n            \"shear\",\n            \"cval_mask\",\n            \"keep_ratio\",\n            \"rotate_method\",\n        )\n\n    @staticmethod\n    def _handle_dict_arg(\n        val: Union[float, Tuple[float, float], Dict[str, Any]], name: str, default: float = 1.0\n    ) -&gt; Dict[str, Any]:\n        if isinstance(val, dict):\n            if \"x\" not in val and \"y\" not in val:\n                raise ValueError(\n                    f'Expected {name} dictionary to contain at least key \"x\" or ' 'key \"y\". Found neither of them.'\n                )\n            x = val.get(\"x\", default)\n            y = val.get(\"y\", default)\n            return {\"x\": to_tuple(x, x), \"y\": to_tuple(y, y)}\n        return {\"x\": to_tuple(val, val), \"y\": to_tuple(val, val)}\n\n    @classmethod\n    def _handle_translate_arg(\n        cls,\n        translate_px: Optional[Union[ScaleFloatType, Dict[str, Any]]],\n        translate_percent: Optional[Union[ScaleFloatType, Dict[str, Any]]],\n    ) -&gt; Any:\n        if translate_percent is None and translate_px is None:\n            translate_px = 0\n\n        if translate_percent is not None and translate_px is not None:\n            msg = \"Expected either translate_percent or translate_px to be \" \"provided, \" \"but neither of them was.\"\n            raise ValueError(msg)\n\n        if translate_percent is not None:\n            # translate by percent\n            return cls._handle_dict_arg(translate_percent, \"translate_percent\", default=0.0), translate_px\n\n        if translate_px is None:\n            msg = \"translate_px is None.\"\n            raise ValueError(msg)\n        # translate by pixels\n        return translate_percent, cls._handle_dict_arg(translate_px, \"translate_px\")\n\n    def apply(\n        self,\n        img: np.ndarray,\n        matrix: skimage.transform.ProjectiveTransform = None,\n        output_shape: Sequence[int] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.warp_affine(\n            img,\n            matrix,\n            interpolation=cast(int, self.interpolation),\n            cval=self.cval,\n            mode=self.mode,\n            output_shape=output_shape,\n        )\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        matrix: skimage.transform.ProjectiveTransform = None,\n        output_shape: Sequence[int] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.warp_affine(\n            mask,\n            matrix,\n            interpolation=self.mask_interpolation,\n            cval=self.cval_mask,\n            mode=self.mode,\n            output_shape=output_shape,\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        matrix: skimage.transform.ProjectiveTransform = None,\n        rows: int = 0,\n        cols: int = 0,\n        output_shape: Sequence[int] = (),\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.bbox_affine(bbox, matrix, self.rotate_method, rows, cols, output_shape)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        matrix: Optional[skimage.transform.ProjectiveTransform] = None,\n        scale: Optional[Dict[str, Any]] = None,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        if scale is None:\n            msg = \"Expected scale to be provided, but got None.\"\n            raise ValueError(msg)\n        if matrix is None:\n            msg = \"Expected matrix to be provided, but got None.\"\n            raise ValueError(msg)\n\n        return F.keypoint_affine(keypoint, matrix=matrix, scale=scale)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        translate: Dict[str, Union[int, float]]\n        if self.translate_px is not None:\n            translate = {key: random.randint(*value) for key, value in self.translate_px.items()}\n        elif self.translate_percent is not None:\n            translate = {key: random.uniform(*value) for key, value in self.translate_percent.items()}\n            translate[\"x\"] = translate[\"x\"] * width\n            translate[\"y\"] = translate[\"y\"] * height\n        else:\n            translate = {\"x\": 0, \"y\": 0}\n\n        # Look to issue https://github.com/albumentations-team/albumentations/issues/1079\n        shear = {key: -random.uniform(*value) for key, value in self.shear.items()}\n        scale = {key: random.uniform(*value) for key, value in self.scale.items()}\n        if self.keep_ratio:\n            scale[\"y\"] = scale[\"x\"]\n\n        # Look to issue https://github.com/albumentations-team/albumentations/issues/1079\n        rotate = -random.uniform(*self.rotate)\n\n        # for images we use additional shifts of (0.5, 0.5) as otherwise\n        # we get an ugly black border for 90deg rotations\n        shift_x = width / 2 - 0.5\n        shift_y = height / 2 - 0.5\n\n        matrix_to_topleft = skimage.transform.SimilarityTransform(translation=[-shift_x, -shift_y])\n        matrix_shear_y_rot = skimage.transform.AffineTransform(rotation=-np.pi / 2)\n        matrix_shear_y = skimage.transform.AffineTransform(shear=np.deg2rad(shear[\"y\"]))\n        matrix_shear_y_rot_inv = skimage.transform.AffineTransform(rotation=np.pi / 2)\n        matrix_transforms = skimage.transform.AffineTransform(\n            scale=(scale[\"x\"], scale[\"y\"]),\n            translation=(translate[\"x\"], translate[\"y\"]),\n            rotation=np.deg2rad(rotate),\n            shear=np.deg2rad(shear[\"x\"]),\n        )\n        matrix_to_center = skimage.transform.SimilarityTransform(translation=[shift_x, shift_y])\n        matrix = (\n            matrix_to_topleft\n            + matrix_shear_y_rot\n            + matrix_shear_y\n            + matrix_shear_y_rot_inv\n            + matrix_transforms\n            + matrix_to_center\n        )\n        if self.fit_output:\n            matrix, output_shape = self._compute_affine_warp_output_shape(matrix, params[\"image\"].shape)\n        else:\n            output_shape = params[\"image\"].shape\n\n        return {\n            \"rotate\": rotate,\n            \"scale\": scale,\n            \"matrix\": matrix,\n            \"output_shape\": output_shape,\n        }\n\n    @staticmethod\n    def _compute_affine_warp_output_shape(\n        matrix: skimage.transform.ProjectiveTransform, input_shape: Sequence[int]\n    ) -&gt; Tuple[skimage.transform.ProjectiveTransform, Sequence[int]]:\n        height, width = input_shape[:2]\n\n        if height == 0 or width == 0:\n            return matrix, input_shape\n\n        # determine shape of output image\n        corners = np.array([[0, 0], [0, height - 1], [width - 1, height - 1], [width - 1, 0]])\n        corners = matrix(corners)\n        minc = corners[:, 0].min()\n        minr = corners[:, 1].min()\n        maxc = corners[:, 0].max()\n        maxr = corners[:, 1].max()\n        out_height = maxr - minr + 1\n        out_width = maxc - minc + 1\n        if len(input_shape) == THREE:\n            output_shape = np.ceil((out_height, out_width, input_shape[2]))\n        else:\n            output_shape = np.ceil((out_height, out_width))\n        output_shape_tuple = tuple([int(v) for v in output_shape.tolist()])\n        # fit output image in new shape\n        translation = (-minc, -minr)\n        matrix_to_fit = skimage.transform.SimilarityTransform(translation=translation)\n        matrix = matrix + matrix_to_fit\n        return matrix, output_shape_tuple\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.ElasticTransform","title":"<code>class  ElasticTransform</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Elastic deformation of images as described in [Simard2003]_ (with modifications).</p> <p>.. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for      Convolutional Neural Networks applied to Visual Document Analysis\", in      Proc. of the International Conference on Document Analysis and      Recognition, 2003.</p> <p>Parameters:</p> Name Type Description <code>alpha</code> <code>float</code> <code>sigma</code> <code>float</code> <p>Gaussian filter parameter.</p> <code>alpha_affine</code> <code>float</code> <p>The range will be (-alpha_affine, alpha_affine)</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>approximate</code> <code>boolean</code> <p>Whether to smooth displacement map with fixed kernel size.                    Enabling this option gives ~2X speedup on large images.</p> <code>same_dxdy</code> <code>boolean</code> <p>Whether to use same random generated shift for x and y.                  Enabling this option gives ~2X speedup.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://gist.github.com/ernestum/601cdf56d2b424757de5</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class ElasticTransform(DualTransform):\n    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications).\n\n    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for\n         Convolutional Neural Networks applied to Visual Document Analysis\", in\n         Proc. of the International Conference on Document Analysis and\n         Recognition, 2003.\n\n    Args:\n        alpha (float):\n        sigma (float): Gaussian filter parameter.\n        alpha_affine (float): The range will be (-alpha_affine, alpha_affine)\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        approximate (boolean): Whether to smooth displacement map with fixed kernel size.\n                               Enabling this option gives ~2X speedup on large images.\n        same_dxdy (boolean): Whether to use same random generated shift for x and y.\n                             Enabling this option gives ~2X speedup.\n\n    Targets:\n        image, mask, bboxes\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://gist.github.com/ernestum/601cdf56d2b424757de5\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        alpha: Annotated[float, Field(default=1, description=\"Alpha parameter.\", ge=0)]\n        sigma: Annotated[float, Field(default=50, description=\"Sigma parameter for Gaussian filter.\", ge=0)]\n        alpha_affine: Annotated[float, Field(default=50, description=\"Alpha affine parameter.\", ge=0)]\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[Union[int, float, List[int], List[float]]] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        mask_value: Optional[Union[float, List[int], List[float]]] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\"\n        )\n        approximate: Annotated[bool, Field(default=False, description=\"Approximate displacement map smoothing.\")]\n        same_dxdy: Annotated[bool, Field(default=False, description=\"Use same shift for x and y.\")]\n\n    def __init__(\n        self,\n        alpha: float = 1,\n        sigma: float = 50,\n        alpha_affine: float = 50,\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[Union[int, float, List[int], List[float]]] = None,\n        mask_value: Optional[Union[int, float, List[int], List[float]]] = None,\n        always_apply: bool = False,\n        approximate: bool = False,\n        same_dxdy: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.alpha = alpha\n        self.alpha_affine = alpha_affine\n        self.sigma = sigma\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n        self.approximate = approximate\n        self.same_dxdy = same_dxdy\n\n    def apply(\n        self, img: np.ndarray, random_state: Optional[int] = None, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.elastic_transform(\n            img,\n            self.alpha,\n            self.sigma,\n            self.alpha_affine,\n            interpolation,\n            self.border_mode,\n            self.value,\n            np.random.RandomState(random_state),\n            self.approximate,\n            self.same_dxdy,\n        )\n\n    def apply_to_mask(self, mask: np.ndarray, random_state: Optional[int] = None, **params: Any) -&gt; np.ndarray:\n        return F.elastic_transform(\n            mask,\n            self.alpha,\n            self.sigma,\n            self.alpha_affine,\n            cv2.INTER_NEAREST,\n            self.border_mode,\n            self.mask_value,\n            np.random.RandomState(random_state),\n            self.approximate,\n            self.same_dxdy,\n        )\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, random_state: Optional[int] = None, **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        mask = np.zeros((rows, cols), dtype=np.uint8)\n        bbox_denorm = F.denormalize_bbox(bbox, rows, cols)\n        x_min, y_min, x_max, y_max = bbox_denorm[:4]\n        x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)\n        mask[y_min:y_max, x_min:x_max] = 1\n        mask = F.elastic_transform(\n            mask,\n            self.alpha,\n            self.sigma,\n            self.alpha_affine,\n            cv2.INTER_NEAREST,\n            self.border_mode,\n            self.mask_value,\n            np.random.RandomState(random_state),\n            self.approximate,\n        )\n        bbox_returned = bbox_from_mask(mask)\n        return cast(BoxInternalType, F.normalize_bbox(bbox_returned, rows, cols))\n\n    def get_params(self) -&gt; Dict[str, int]:\n        return {\"random_state\": random.randint(0, 10000)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"alpha\",\n            \"sigma\",\n            \"alpha_affine\",\n            \"interpolation\",\n            \"border_mode\",\n            \"value\",\n            \"mask_value\",\n            \"approximate\",\n            \"same_dxdy\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.Flip","title":"<code>class  Flip</code> <code> </code>  [view source on GitHub]","text":"<p>Flip the input either horizontally, vertically or both horizontally and vertically.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Flip(DualTransform):\n    \"\"\"Flip the input either horizontally, vertically or both horizontally and vertically.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, d: int = 0, **params: Any) -&gt; np.ndarray:\n        \"\"\"Args:\n        d (int): code that specifies how to flip the input. 0 for vertical flipping, 1 for horizontal flipping,\n                -1 for both vertical and horizontal flipping (which is also could be seen as rotating the input by\n                180 degrees).\n        \"\"\"\n        return F.random_flip(img, d)\n\n    def get_params(self) -&gt; Dict[str, int]:\n        # Random int in the range [-1, 1]\n        return {\"d\": random.randint(-1, 1)}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_flip(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_flip(keypoint, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.Flip.apply","title":"<code>apply (self, img, d=0, **params)</code>","text":"<p>d (int): code that specifies how to flip the input. 0 for vertical flipping, 1 for horizontal flipping,         -1 for both vertical and horizontal flipping (which is also could be seen as rotating the input by         180 degrees).</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>def apply(self, img: np.ndarray, d: int = 0, **params: Any) -&gt; np.ndarray:\n    \"\"\"Args:\n    d (int): code that specifies how to flip the input. 0 for vertical flipping, 1 for horizontal flipping,\n            -1 for both vertical and horizontal flipping (which is also could be seen as rotating the input by\n            180 degrees).\n    \"\"\"\n    return F.random_flip(img, d)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.GridDistortion","title":"<code>class  GridDistortion</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Parameters:</p> Name Type Description <code>num_steps</code> <code>int</code> <p>count of grid cells on each side.</p> <code>distort_limit</code> <code>float, (float, float</code> <p>If distort_limit is a single float, the range will be (-distort_limit, distort_limit). Default: (-0.03, 0.03).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>normalized</code> <code>bool</code> <p>if true, distortion will be normalized to do not go outside the image. Default: False See for more information: https://github.com/albumentations-team/albumentations/pull/722</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class GridDistortion(DualTransform):\n    \"\"\"Args:\n        num_steps (int): count of grid cells on each side.\n        distort_limit (float, (float, float)): If distort_limit is a single float, the range\n            will be (-distort_limit, distort_limit). Default: (-0.03, 0.03).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        normalized (bool): if true, distortion will be normalized to do not go outside the image. Default: False\n            See for more information: https://github.com/albumentations-team/albumentations/pull/722\n\n    Targets:\n        image, mask, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        num_steps: Annotated[int, Field(ge=1, description=\"Count of grid cells on each side.\")]\n        distort_limit: SymmetricRangeType = (-0.03, 0.03)\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        mask_value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value for mask if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        normalized: bool = Field(\n            default=False, description=\"If true, distortion will be normalized to not go outside the image.\"\n        )\n\n        @field_validator(\"distort_limit\")\n        @classmethod\n        def check_limits(cls, v: Tuple[float, float], info: ValidationInfo) -&gt; Tuple[float, float]:\n            bounds = -1, 1\n            result = to_tuple(v)\n            check_range(result, *bounds, info.field_name)\n            return result\n\n    def __init__(\n        self,\n        num_steps: int = 5,\n        distort_limit: ScaleFloatType = (-0.3, 0.3),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        normalized: bool = False,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        self.num_steps = num_steps\n        self.distort_limit = cast(Tuple[float, float], distort_limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n        self.normalized = normalized\n\n    def apply(\n        self,\n        img: np.ndarray,\n        stepsx: Tuple[()] = (),\n        stepsy: Tuple[()] = (),\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.grid_distortion(img, self.num_steps, stepsx, stepsy, interpolation, self.border_mode, self.value)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, stepsx: Tuple[()] = (), stepsy: Tuple[()] = (), **params: Any\n    ) -&gt; np.ndarray:\n        return F.grid_distortion(\n            mask, self.num_steps, stepsx, stepsy, cv2.INTER_NEAREST, self.border_mode, self.mask_value\n        )\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, stepsx: Tuple[()] = (), stepsy: Tuple[()] = (), **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        mask = np.zeros((rows, cols), dtype=np.uint8)\n        bbox_denorm = F.denormalize_bbox(bbox, rows, cols)\n        x_min, y_min, x_max, y_max = bbox_denorm[:4]\n        x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)\n        mask[y_min:y_max, x_min:x_max] = 1\n        mask = F.grid_distortion(\n            mask, self.num_steps, stepsx, stepsy, cv2.INTER_NEAREST, self.border_mode, self.mask_value\n        )\n        bbox_returned = bbox_from_mask(mask)\n        return cast(BoxInternalType, F.normalize_bbox(bbox_returned, rows, cols))\n\n    def _normalize(self, h: int, w: int, xsteps: List[float], ysteps: List[float]) -&gt; Dict[str, Any]:\n        # compensate for smaller last steps in source image.\n        x_step = w // self.num_steps\n        last_x_step = min(w, ((self.num_steps + 1) * x_step)) - (self.num_steps * x_step)\n        xsteps[-1] *= last_x_step / x_step\n\n        y_step = h // self.num_steps\n        last_y_step = min(h, ((self.num_steps + 1) * y_step)) - (self.num_steps * y_step)\n        ysteps[-1] *= last_y_step / y_step\n\n        # now normalize such that distortion never leaves image bounds.\n        tx = w / math.floor(w / self.num_steps)\n        ty = h / math.floor(h / self.num_steps)\n        xsteps = np.array(xsteps) * (tx / np.sum(xsteps))\n        ysteps = np.array(ysteps) * (ty / np.sum(ysteps))\n\n        return {\"stepsx\": xsteps, \"stepsy\": ysteps}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        stepsx = [\n            1 + random_utils.uniform(self.distort_limit[0], self.distort_limit[1]) for _ in range(self.num_steps + 1)\n        ]\n        stepsy = [\n            1 + random_utils.uniform(self.distort_limit[0], self.distort_limit[1]) for _ in range(self.num_steps + 1)\n        ]\n\n        if self.normalized:\n            return self._normalize(height, width, stepsx, stepsy)\n\n        return {\"stepsx\": stepsx, \"stepsy\": stepsy}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"num_steps\", \"distort_limit\", \"interpolation\", \"border_mode\", \"value\", \"mask_value\", \"normalized\"\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.HorizontalFlip","title":"<code>class  HorizontalFlip</code> <code> </code>  [view source on GitHub]","text":"<p>Flip the input horizontally around the y-axis.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class HorizontalFlip(DualTransform):\n    \"\"\"Flip the input horizontally around the y-axis.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if img.ndim == THREE and img.shape[2] &gt; 1 and img.dtype == np.uint8:\n            # Opencv is faster than numpy only in case of\n            # non-gray scale 8bits images\n            return F.hflip_cv2(img)\n\n        return F.hflip(img)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_hflip(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_hflip(keypoint, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.OpticalDistortion","title":"<code>class  OpticalDistortion</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Parameters:</p> Name Type Description <code>distort_limit</code> <code>float, (float, float</code> <p>If distort_limit is a single float, the range will be (-distort_limit, distort_limit). Default: (-0.05, 0.05).</p> <code>shift_limit</code> <code>float, (float, float</code> <p>If shift_limit is a single float, the range will be (-shift_limit, shift_limit). Default: (-0.05, 0.05).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class OpticalDistortion(DualTransform):\n    \"\"\"Args:\n        distort_limit (float, (float, float)): If distort_limit is a single float, the range\n            will be (-distort_limit, distort_limit). Default: (-0.05, 0.05).\n        shift_limit (float, (float, float))): If shift_limit is a single float, the range\n            will be (-shift_limit, shift_limit). Default: (-0.05, 0.05).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n\n    Targets:\n        image, mask, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        distort_limit: SymmetricRangeType = (-0.05, 0.05)\n        shift_limit: SymmetricRangeType = (-0.05, 0.05)\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        mask_value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value for mask if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n\n    def __init__(\n        self,\n        distort_limit: ScaleFloatType = (-0.05, 0.05),\n        shift_limit: ScaleFloatType = (-0.05, 0.05),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.shift_limit = cast(Tuple[float, float], shift_limit)\n        self.distort_limit = cast(Tuple[float, float], distort_limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def apply(\n        self,\n        img: np.ndarray,\n        k: int = 0,\n        dx: int = 0,\n        dy: int = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.optical_distortion(img, k, dx, dy, interpolation, self.border_mode, self.value)\n\n    def apply_to_mask(self, mask: np.ndarray, k: int = 0, dx: int = 0, dy: int = 0, **params: Any) -&gt; np.ndarray:\n        return F.optical_distortion(mask, k, dx, dy, cv2.INTER_NEAREST, self.border_mode, self.mask_value)\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, k: int = 0, dx: int = 0, dy: int = 0, **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        mask = np.zeros((rows, cols), dtype=np.uint8)\n        bbox_denorm = F.denormalize_bbox(bbox, rows, cols)\n        x_min, y_min, x_max, y_max = bbox_denorm[:4]\n        x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)\n        mask[y_min:y_max, x_min:x_max] = 1\n        mask = F.optical_distortion(mask, k, dx, dy, cv2.INTER_NEAREST, self.border_mode, self.mask_value)\n        bbox_returned = bbox_from_mask(mask)\n        return cast(BoxInternalType, F.normalize_bbox(bbox_returned, rows, cols))\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"k\": random.uniform(self.distort_limit[0], self.distort_limit[1]),\n            \"dx\": round(random.uniform(self.shift_limit[0], self.shift_limit[1])),\n            \"dy\": round(random.uniform(self.shift_limit[0], self.shift_limit[1])),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"distort_limit\",\n            \"shift_limit\",\n            \"interpolation\",\n            \"border_mode\",\n            \"value\",\n            \"mask_value\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.PadIfNeeded","title":"<code>class  PadIfNeeded</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Pad side of the image / max if side is less than desired number.</p> <p>Parameters:</p> Name Type Description <code>min_height</code> <code>int</code> <p>minimal result image height.</p> <code>min_width</code> <code>int</code> <p>minimal result image width.</p> <code>pad_height_divisor</code> <code>int</code> <p>if not None, ensures image height is dividable by value of this argument.</p> <code>pad_width_divisor</code> <code>int</code> <p>if not None, ensures image width is dividable by value of this argument.</p> <code>position</code> <code>Union[str, PositionType]</code> <p>Position of the image. should be PositionType.CENTER or PositionType.TOP_LEFT or PositionType.TOP_RIGHT or PositionType.BOTTOM_LEFT or PositionType.BOTTOM_RIGHT. or PositionType.RANDOM. Default: PositionType.CENTER.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>OpenCV border mode.</p> <code>value</code> <code>int, float, list of int, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of int,         list of float</code> <p>padding value for mask if border_mode is cv2.BORDER_CONSTANT.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class PadIfNeeded(DualTransform):\n    \"\"\"Pad side of the image / max if side is less than desired number.\n\n    Args:\n        min_height (int): minimal result image height.\n        min_width (int): minimal result image width.\n        pad_height_divisor (int): if not None, ensures image height is dividable by value of this argument.\n        pad_width_divisor (int): if not None, ensures image width is dividable by value of this argument.\n        position (Union[str, PositionType]): Position of the image. should be PositionType.CENTER or\n            PositionType.TOP_LEFT or PositionType.TOP_RIGHT or PositionType.BOTTOM_LEFT or PositionType.BOTTOM_RIGHT.\n            or PositionType.RANDOM. Default: PositionType.CENTER.\n        border_mode (OpenCV flag): OpenCV border mode.\n        value (int, float, list of int, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of int,\n                    list of float): padding value for mask if border_mode is cv2.BORDER_CONSTANT.\n        p (float): probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class PositionType(Enum):\n        \"\"\"Enumerates the types of positions for placing an object within a container.\n\n        This Enum class is utilized to define specific anchor positions that an object can\n        assume relative to a container. It's particularly useful in image processing, UI layout,\n        and graphic design to specify the alignment and positioning of elements.\n\n        Attributes:\n            CENTER (str): Specifies that the object should be placed at the center.\n            TOP_LEFT (str): Specifies that the object should be placed at the top-left corner.\n            TOP_RIGHT (str): Specifies that the object should be placed at the top-right corner.\n            BOTTOM_LEFT (str): Specifies that the object should be placed at the bottom-left corner.\n            BOTTOM_RIGHT (str): Specifies that the object should be placed at the bottom-right corner.\n            RANDOM (str): Indicates that the object's position should be determined randomly.\n\n        \"\"\"\n\n        CENTER = \"center\"\n        TOP_LEFT = \"top_left\"\n        TOP_RIGHT = \"top_right\"\n        BOTTOM_LEFT = \"bottom_left\"\n        BOTTOM_RIGHT = \"bottom_right\"\n        RANDOM = \"random\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        min_height: Optional[int] = Field(default=None, ge=1, description=\"Minimal result image height.\")\n        min_width: Optional[int] = Field(default=None, ge=1, description=\"Minimal result image width.\")\n        pad_height_divisor: Optional[int] = Field(\n            default=None, ge=1, description=\"Ensures image height is divisible by this value.\"\n        )\n        pad_width_divisor: Optional[int] = Field(\n            default=None, ge=1, description=\"Ensures image width is divisible by this value.\"\n        )\n        position: str = Field(default=\"center\", description=\"Position of the padded image.\")\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[ColorType] = Field(default=None, description=\"Value for border if BORDER_CONSTANT is used.\")\n        mask_value: Optional[ColorType] = Field(\n            default=None, description=\"Value for mask border if BORDER_CONSTANT is used.\"\n        )\n        p: ProbabilityType = 1.0\n\n        @model_validator(mode=\"after\")\n        def validate_divisibility(self) -&gt; Self:\n            if (self.min_height is None) == (self.pad_height_divisor is None):\n                msg = \"Only one of 'min_height' and 'pad_height_divisor' parameters must be set\"\n                raise ValueError(msg)\n            if (self.min_width is None) == (self.pad_width_divisor is None):\n                msg = \"Only one of 'min_width' and 'pad_width_divisor' parameters must be set\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        min_height: Optional[int] = 1024,\n        min_width: Optional[int] = 1024,\n        pad_height_divisor: Optional[int] = None,\n        pad_width_divisor: Optional[int] = None,\n        position: Union[PositionType, str] = PositionType.CENTER,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n        self.min_height = min_height\n        self.min_width = min_width\n        self.pad_width_divisor = pad_width_divisor\n        self.pad_height_divisor = pad_height_divisor\n        self.position = PadIfNeeded.PositionType(position)\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def update_params(self, params: Dict[str, Any], **kwargs: Any) -&gt; Dict[str, Any]:\n        params = super().update_params(params, **kwargs)\n        rows = params[\"rows\"]\n        cols = params[\"cols\"]\n\n        if self.min_height is not None:\n            if rows &lt; self.min_height:\n                h_pad_top = int((self.min_height - rows) / 2.0)\n                h_pad_bottom = self.min_height - rows - h_pad_top\n            else:\n                h_pad_top = 0\n                h_pad_bottom = 0\n        else:\n            pad_remained = rows % self.pad_height_divisor\n            pad_rows = self.pad_height_divisor - pad_remained if pad_remained &gt; 0 else 0\n\n            h_pad_top = pad_rows // 2\n            h_pad_bottom = pad_rows - h_pad_top\n\n        if self.min_width is not None:\n            if cols &lt; self.min_width:\n                w_pad_left = int((self.min_width - cols) / 2.0)\n                w_pad_right = self.min_width - cols - w_pad_left\n            else:\n                w_pad_left = 0\n                w_pad_right = 0\n        else:\n            pad_remainder = cols % self.pad_width_divisor\n            pad_cols = self.pad_width_divisor - pad_remainder if pad_remainder &gt; 0 else 0\n\n            w_pad_left = pad_cols // 2\n            w_pad_right = pad_cols - w_pad_left\n\n        h_pad_top, h_pad_bottom, w_pad_left, w_pad_right = self.__update_position_params(\n            h_top=h_pad_top, h_bottom=h_pad_bottom, w_left=w_pad_left, w_right=w_pad_right\n        )\n\n        params.update(\n            {\n                \"pad_top\": h_pad_top,\n                \"pad_bottom\": h_pad_bottom,\n                \"pad_left\": w_pad_left,\n                \"pad_right\": w_pad_right,\n            }\n        )\n        return params\n\n    def apply(\n        self,\n        img: np.ndarray,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.pad_with_params(\n            img,\n            pad_top,\n            pad_bottom,\n            pad_left,\n            pad_right,\n            border_mode=self.border_mode,\n            value=self.value,\n        )\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.pad_with_params(\n            mask,\n            pad_top,\n            pad_bottom,\n            pad_left,\n            pad_right,\n            border_mode=self.border_mode,\n            value=self.mask_value,\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        rows: int = 0,\n        cols: int = 0,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        x_min, y_min, x_max, y_max = denormalize_bbox(bbox, rows, cols)[:4]\n        bbox = x_min + pad_left, y_min + pad_top, x_max + pad_left, y_max + pad_top\n        return cast(BoxInternalType, normalize_bbox(bbox, rows + pad_top + pad_bottom, cols + pad_left + pad_right))\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        x, y, angle, scale = keypoint[:4]\n        return x + pad_left, y + pad_top, angle, scale\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"min_height\",\n            \"min_width\",\n            \"pad_height_divisor\",\n            \"pad_width_divisor\",\n            \"position\",\n            \"border_mode\",\n            \"value\",\n            \"mask_value\",\n        )\n\n    def __update_position_params(\n        self, h_top: int, h_bottom: int, w_left: int, w_right: int\n    ) -&gt; Tuple[int, int, int, int]:\n        if self.position == PadIfNeeded.PositionType.TOP_LEFT:\n            h_bottom += h_top\n            w_right += w_left\n            h_top = 0\n            w_left = 0\n\n        elif self.position == PadIfNeeded.PositionType.TOP_RIGHT:\n            h_bottom += h_top\n            w_left += w_right\n            h_top = 0\n            w_right = 0\n\n        elif self.position == PadIfNeeded.PositionType.BOTTOM_LEFT:\n            h_top += h_bottom\n            w_right += w_left\n            h_bottom = 0\n            w_left = 0\n\n        elif self.position == PadIfNeeded.PositionType.BOTTOM_RIGHT:\n            h_top += h_bottom\n            w_left += w_right\n            h_bottom = 0\n            w_right = 0\n\n        elif self.position == PadIfNeeded.PositionType.RANDOM:\n            h_pad = h_top + h_bottom\n            w_pad = w_left + w_right\n            h_top = random.randint(0, h_pad)\n            h_bottom = h_pad - h_top\n            w_left = random.randint(0, w_pad)\n            w_right = w_pad - w_left\n\n        return h_top, h_bottom, w_left, w_right\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.PadIfNeeded.PositionType","title":"<code>class  PositionType</code> <code> </code>","text":"<p>Enumerates the types of positions for placing an object within a container.</p> <p>This Enum class is utilized to define specific anchor positions that an object can assume relative to a container. It's particularly useful in image processing, UI layout, and graphic design to specify the alignment and positioning of elements.</p> <p>Attributes:</p> Name Type Description <code>CENTER</code> <code>str</code> <p>Specifies that the object should be placed at the center.</p> <code>TOP_LEFT</code> <code>str</code> <p>Specifies that the object should be placed at the top-left corner.</p> <code>TOP_RIGHT</code> <code>str</code> <p>Specifies that the object should be placed at the top-right corner.</p> <code>BOTTOM_LEFT</code> <code>str</code> <p>Specifies that the object should be placed at the bottom-left corner.</p> <code>BOTTOM_RIGHT</code> <code>str</code> <p>Specifies that the object should be placed at the bottom-right corner.</p> <code>RANDOM</code> <code>str</code> <p>Indicates that the object's position should be determined randomly.</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class PositionType(Enum):\n    \"\"\"Enumerates the types of positions for placing an object within a container.\n\n    This Enum class is utilized to define specific anchor positions that an object can\n    assume relative to a container. It's particularly useful in image processing, UI layout,\n    and graphic design to specify the alignment and positioning of elements.\n\n    Attributes:\n        CENTER (str): Specifies that the object should be placed at the center.\n        TOP_LEFT (str): Specifies that the object should be placed at the top-left corner.\n        TOP_RIGHT (str): Specifies that the object should be placed at the top-right corner.\n        BOTTOM_LEFT (str): Specifies that the object should be placed at the bottom-left corner.\n        BOTTOM_RIGHT (str): Specifies that the object should be placed at the bottom-right corner.\n        RANDOM (str): Indicates that the object's position should be determined randomly.\n\n    \"\"\"\n\n    CENTER = \"center\"\n    TOP_LEFT = \"top_left\"\n    TOP_RIGHT = \"top_right\"\n    BOTTOM_LEFT = \"bottom_left\"\n    BOTTOM_RIGHT = \"bottom_right\"\n    RANDOM = \"random\"\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.Perspective","title":"<code>class  Perspective</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Perform a random four point perspective transform of the input.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <p>standard deviation of the normal distributions. These are used to sample the random distances of the subimage's corners from the full image's corners. If scale is a single float value, the range will be (0, scale). Default: (0.05, 0.1).</p> <code>keep_size</code> <p>Whether to resize image back to their original size after applying the perspective transform. If set to False, the resulting images may end up having different shapes and will always be a list, never an array. Default: True</p> <code>pad_mode</code> <code>OpenCV flag</code> <p>OpenCV border mode.</p> <code>pad_val</code> <code>int, float, list of int, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT. Default: 0</p> <code>mask_pad_val</code> <code>int, float, list of int, list of float</code> <p>padding value for mask if border_mode is cv2.BORDER_CONSTANT. Default: 0</p> <code>fit_output</code> <code>bool</code> <p>If True, the image plane size and position will be adjusted to still capture the whole image after perspective transformation. (Followed by image resizing if keep_size is set to True.) Otherwise, parts of the transformed image may be outside of the image plane. This setting should not be set to True when using large scale values as it could lead to very large images. Default: False</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Perspective(DualTransform):\n    \"\"\"Perform a random four point perspective transform of the input.\n\n    Args:\n        scale: standard deviation of the normal distributions. These are used to sample\n            the random distances of the subimage's corners from the full image's corners.\n            If scale is a single float value, the range will be (0, scale). Default: (0.05, 0.1).\n        keep_size: Whether to resize image back to their original size after applying the perspective\n            transform. If set to False, the resulting images may end up having different shapes\n            and will always be a list, never an array. Default: True\n        pad_mode (OpenCV flag): OpenCV border mode.\n        pad_val (int, float, list of int, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n            Default: 0\n        mask_pad_val (int, float, list of int, list of float): padding value for mask\n            if border_mode is cv2.BORDER_CONSTANT. Default: 0\n        fit_output (bool): If True, the image plane size and position will be adjusted to still capture\n            the whole image after perspective transformation. (Followed by image resizing if keep_size is set to True.)\n            Otherwise, parts of the transformed image may be outside of the image plane.\n            This setting should not be set to True when using large scale values as it could lead to very large images.\n            Default: False\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: NonNegativeFloatRangeType = (0.05, 0.1)\n        keep_size: Annotated[bool, Field(default=True, description=\"Keep size after transform.\")]\n        pad_mode: BorderModeType = cv2.BORDER_CONSTANT\n        pad_val: Optional[ColorType] = Field(\n            default=0,\n            description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\",\n        )\n        mask_pad_val: Optional[ColorType] = Field(\n            default=0,\n            description=\"Mask padding value if border_mode is cv2.BORDER_CONSTANT.\",\n        )\n        fit_output: Annotated[bool, Field(default=False, description=\"Adjust image plane to capture whole image.\")]\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n    def __init__(\n        self,\n        scale: ScaleFloatType = (0.05, 0.1),\n        keep_size: bool = True,\n        pad_mode: int = cv2.BORDER_CONSTANT,\n        pad_val: Union[ColorType] = 0,\n        mask_pad_val: Union[ColorType] = 0,\n        fit_output: bool = False,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.scale = cast(Tuple[float, float], scale)\n        self.keep_size = keep_size\n        self.pad_mode = pad_mode\n        self.pad_val = pad_val\n        self.mask_pad_val = mask_pad_val\n        self.fit_output = fit_output\n        self.interpolation = interpolation\n\n    def apply(\n        self,\n        img: np.ndarray,\n        matrix: np.ndarray,\n        max_height: int,\n        max_width: int,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.perspective(\n            img, matrix, max_width, max_height, self.pad_val, self.pad_mode, self.keep_size, params[\"interpolation\"]\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        matrix: np.ndarray,\n        max_height: int,\n        max_width: int,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.perspective_bbox(bbox, params[\"rows\"], params[\"cols\"], matrix, max_width, max_height, self.keep_size)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        matrix: np.ndarray,\n        max_height: int,\n        max_width: int,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.perspective_keypoint(\n            keypoint, params[\"rows\"], params[\"cols\"], matrix, max_width, max_height, self.keep_size\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        scale = random_utils.uniform(*self.scale)\n        points = random_utils.normal(0, scale, [4, 2])\n        points = np.mod(np.abs(points), 0.32)\n\n        # top left -- no changes needed, just use jitter\n        # top right\n        points[1, 0] = 1.0 - points[1, 0]  # w = 1.0 - jitter\n        # bottom right\n        points[2] = 1.0 - points[2]  # w = 1.0 - jitt\n        # bottom left\n        points[3, 1] = 1.0 - points[3, 1]  # h = 1.0 - jitter\n\n        points[:, 0] *= width\n        points[:, 1] *= height\n\n        # Obtain a consistent order of the points and unpack them individually.\n        # Warning: don't just do (tl, tr, br, bl) = _order_points(...)\n        # here, because the reordered points is used further below.\n        points = self._order_points(points)\n        tl, tr, br, bl = points\n\n        # compute the width of the new image, which will be the\n        # maximum distance between bottom-right and bottom-left\n        # x-coordiates or the top-right and top-left x-coordinates\n        min_width = None\n        max_width = None\n        while min_width is None or min_width &lt; TWO:\n            width_top = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))\n            width_bottom = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))\n            max_width = int(max(width_top, width_bottom))\n            min_width = int(min(width_top, width_bottom))\n            if min_width &lt; TWO:\n                step_size = (2 - min_width) / 2\n                tl[0] -= step_size\n                tr[0] += step_size\n                bl[0] -= step_size\n                br[0] += step_size\n\n        # compute the height of the new image, which will be the maximum distance between the top-right\n        # and bottom-right y-coordinates or the top-left and bottom-left y-coordinates\n        min_height = None\n        max_height = None\n        while min_height is None or min_height &lt; TWO:\n            height_right = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))\n            height_left = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))\n            max_height = int(max(height_right, height_left))\n            min_height = int(min(height_right, height_left))\n            if min_height &lt; TWO:\n                step_size = (2 - min_height) / 2\n                tl[1] -= step_size\n                tr[1] -= step_size\n                bl[1] += step_size\n                br[1] += step_size\n\n        # now that we have the dimensions of the new image, construct\n        # the set of destination points to obtain a \"birds eye view\",\n        # (i.e. top-down view) of the image, again specifying points\n        # in the top-left, top-right, bottom-right, and bottom-left order\n        # do not use width-1 or height-1 here, as for e.g. width=3, height=2\n        # the bottom right coordinate is at (3.0, 2.0) and not (2.0, 1.0)\n        dst = np.array([[0, 0], [max_width, 0], [max_width, max_height], [0, max_height]], dtype=np.float32)\n\n        # compute the perspective transform matrix and then apply it\n        m = cv2.getPerspectiveTransform(points, dst)\n\n        if self.fit_output:\n            m, max_width, max_height = self._expand_transform(m, (height, width))\n\n        return {\"matrix\": m, \"max_height\": max_height, \"max_width\": max_width, \"interpolation\": self.interpolation}\n\n    @classmethod\n    def _expand_transform(cls, matrix: np.ndarray, shape: SizeType) -&gt; Tuple[np.ndarray, int, int]:\n        height, width = shape[:2]\n        # do not use width-1 or height-1 here, as for e.g. width=3, height=2, max_height\n        # the bottom right coordinate is at (3.0, 2.0) and not (2.0, 1.0)\n        rect = np.array([[0, 0], [width, 0], [width, height], [0, height]], dtype=np.float32)\n        dst = cv2.perspectiveTransform(np.array([rect]), matrix)[0]\n\n        # get min x, y over transformed 4 points\n        # then modify target points by subtracting these minima  =&gt; shift to (0, 0)\n        dst -= dst.min(axis=0, keepdims=True)\n        dst = np.around(dst, decimals=0)\n\n        matrix_expanded = cv2.getPerspectiveTransform(rect, dst)\n        max_width, max_height = dst.max(axis=0)\n        return matrix_expanded, int(max_width), int(max_height)\n\n    @staticmethod\n    def _order_points(pts: np.ndarray) -&gt; np.ndarray:\n        pts = np.array(sorted(pts, key=lambda x: x[0]))\n        left = pts[:2]  # points with smallest x coordinate - left points\n        right = pts[2:]  # points with greatest x coordinate - right points\n\n        if left[0][1] &lt; left[1][1]:\n            tl, bl = left\n        else:\n            bl, tl = left\n\n        if right[0][1] &lt; right[1][1]:\n            tr, br = right\n        else:\n            br, tr = right\n\n        return np.array([tl, tr, br, bl], dtype=np.float32)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"scale\", \"keep_size\", \"pad_mode\", \"pad_val\", \"mask_pad_val\", \"fit_output\", \"interpolation\"\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.PiecewiseAffine","title":"<code>class  PiecewiseAffine</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply affine transformations that differ between local neighborhoods. This augmentation places a regular grid of points on an image and randomly moves the neighborhood of these point around via affine transformations. This leads to local distortions.</p> <p>This is mostly a wrapper around scikit-image's <code>PiecewiseAffine</code>. See also <code>Affine</code> for a similar technique.</p> <p>Note</p> <p>This augmenter is very slow. Try to use <code>ElasticTransformation</code> instead, which is at least 10x faster.</p> <p>Note</p> <p>For coordinate-based inputs (keypoints, bounding boxes, polygons, ...), this augmenter still has to perform an image-based augmentation, which will make it significantly slower and not fully correct for such inputs than other transforms.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <code>float, tuple of float</code> <p>Each point on the regular grid is moved around via a normal distribution. This scale factor is equivalent to the normal distribution's sigma. Note that the jitter (how far each point is moved in which direction) is multiplied by the height/width of the image if <code>absolute_scale=False</code> (default), so this scale can be the same for different sized images. Recommended values are in the range <code>0.01</code> to <code>0.05</code> (weak to strong augmentations).     * If a single <code>float</code>, then that value will always be used as the scale.     * If a tuple <code>(a, b)</code> of <code>float</code> s, then a random value will       be uniformly sampled per image from the interval <code>[a, b]</code>.</p> <code>nb_rows</code> <code>int, tuple of int</code> <p>Number of rows of points that the regular grid should have. Must be at least <code>2</code>. For large images, you might want to pick a higher value than <code>4</code>. You might have to then adjust scale to lower values.     * If a single <code>int</code>, then that value will always be used as the number of rows.     * If a tuple <code>(a, b)</code>, then a value from the discrete interval       <code>[a..b]</code> will be uniformly sampled per image.</p> <code>nb_cols</code> <code>int, tuple of int</code> <p>Number of columns. Analogous to <code>nb_rows</code>.</p> <code>interpolation</code> <code>int</code> <p>The order of interpolation. The order has to be in the range 0-5:  - 0: Nearest-neighbor  - 1: Bi-linear (default)  - 2: Bi-quadratic  - 3: Bi-cubic  - 4: Bi-quartic  - 5: Bi-quintic</p> <code>mask_interpolation</code> <code>int</code> <p>same as interpolation but for mask.</p> <code>cval</code> <code>number</code> <p>The constant value to use when filling in newly created pixels.</p> <code>cval_mask</code> <code>number</code> <p>Same as cval but only for masks.</p> <code>mode</code> <code>str</code> <p>{'constant', 'edge', 'symmetric', 'reflect', 'wrap'}, optional Points outside the boundaries of the input are filled according to the given mode.  Modes match the behaviour of <code>numpy.pad</code>.</p> <code>absolute_scale</code> <code>bool</code> <p>Take <code>scale</code> as an absolute value rather than a relative value.</p> <code>keypoints_threshold</code> <code>float</code> <p>Used as threshold in conversion from distance maps to keypoints. The search for keypoints works by searching for the argmin (non-inverted) or argmax (inverted) in each channel. This parameters contains the maximum (non-inverted) or minimum (inverted) value to accept in order to view a hit as a keypoint. Use <code>None</code> to use no min/max. Default: 0.01</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class PiecewiseAffine(DualTransform):\n    \"\"\"Apply affine transformations that differ between local neighborhoods.\n    This augmentation places a regular grid of points on an image and randomly moves the neighborhood of these point\n    around via affine transformations. This leads to local distortions.\n\n    This is mostly a wrapper around scikit-image's ``PiecewiseAffine``.\n    See also ``Affine`` for a similar technique.\n\n    Note:\n        This augmenter is very slow. Try to use ``ElasticTransformation`` instead, which is at least 10x faster.\n\n    Note:\n        For coordinate-based inputs (keypoints, bounding boxes, polygons, ...),\n        this augmenter still has to perform an image-based augmentation,\n        which will make it significantly slower and not fully correct for such inputs than other transforms.\n\n    Args:\n        scale (float, tuple of float): Each point on the regular grid is moved around via a normal distribution.\n            This scale factor is equivalent to the normal distribution's sigma.\n            Note that the jitter (how far each point is moved in which direction) is multiplied by the height/width of\n            the image if ``absolute_scale=False`` (default), so this scale can be the same for different sized images.\n            Recommended values are in the range ``0.01`` to ``0.05`` (weak to strong augmentations).\n                * If a single ``float``, then that value will always be used as the scale.\n                * If a tuple ``(a, b)`` of ``float`` s, then a random value will\n                  be uniformly sampled per image from the interval ``[a, b]``.\n        nb_rows (int, tuple of int): Number of rows of points that the regular grid should have.\n            Must be at least ``2``. For large images, you might want to pick a higher value than ``4``.\n            You might have to then adjust scale to lower values.\n                * If a single ``int``, then that value will always be used as the number of rows.\n                * If a tuple ``(a, b)``, then a value from the discrete interval\n                  ``[a..b]`` will be uniformly sampled per image.\n        nb_cols (int, tuple of int): Number of columns. Analogous to `nb_rows`.\n        interpolation (int): The order of interpolation. The order has to be in the range 0-5:\n             - 0: Nearest-neighbor\n             - 1: Bi-linear (default)\n             - 2: Bi-quadratic\n             - 3: Bi-cubic\n             - 4: Bi-quartic\n             - 5: Bi-quintic\n        mask_interpolation (int): same as interpolation but for mask.\n        cval (number): The constant value to use when filling in newly created pixels.\n        cval_mask (number): Same as cval but only for masks.\n        mode (str): {'constant', 'edge', 'symmetric', 'reflect', 'wrap'}, optional\n            Points outside the boundaries of the input are filled according\n            to the given mode.  Modes match the behaviour of `numpy.pad`.\n        absolute_scale (bool): Take `scale` as an absolute value rather than a relative value.\n        keypoints_threshold (float): Used as threshold in conversion from distance maps to keypoints.\n            The search for keypoints works by searching for the\n            argmin (non-inverted) or argmax (inverted) in each channel. This\n            parameters contains the maximum (non-inverted) or minimum (inverted) value to accept in order to view a hit\n            as a keypoint. Use ``None`` to use no min/max. Default: 0.01\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: NonNegativeFloatRangeType = (0.03, 0.05)\n        nb_rows: ScaleIntType = Field(default=4, description=\"Number of rows in the regular grid.\")\n        nb_cols: ScaleIntType = Field(default=4, description=\"Number of columns in the regular grid.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        mask_interpolation: InterpolationType = cv2.INTER_NEAREST\n        cval: int = Field(default=0, description=\"Constant value used for newly created pixels.\")\n        cval_mask: int = Field(default=0, description=\"Constant value used for newly created mask pixels.\")\n        mode: Literal[\"constant\", \"edge\", \"symmetric\", \"reflect\", \"wrap\"] = \"constant\"\n        absolute_scale: bool = Field(\n            default=False, description=\"Whether scale is an absolute value rather than relative.\"\n        )\n        keypoints_threshold: float = Field(\n            default=0.01, description=\"Threshold for conversion from distance maps to keypoints.\"\n        )\n\n        @field_validator(\"nb_rows\", \"nb_cols\")\n        @classmethod\n        def process_range(cls, value: ScaleFloatType, info: ValidationInfo) -&gt; Tuple[float, float]:\n            bounds = 2, BIG_INTEGER\n            result = to_tuple(value, value)\n            check_range(result, *bounds, info.field_name)\n            return result\n\n    def __init__(\n        self,\n        scale: ScaleFloatType = (0.03, 0.05),\n        nb_rows: ScaleIntType = 4,\n        nb_cols: ScaleIntType = 4,\n        interpolation: int = cv2.INTER_LINEAR,\n        mask_interpolation: int = cv2.INTER_NEAREST,\n        cval: int = 0,\n        cval_mask: int = 0,\n        mode: Literal[\"constant\", \"edge\", \"symmetric\", \"reflect\", \"wrap\"] = \"constant\",\n        absolute_scale: bool = False,\n        always_apply: bool = False,\n        keypoints_threshold: float = 0.01,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        warn(\"This augmenter is very slow. Try to use ``ElasticTransformation`` instead, which is at least 10x faster.\")\n\n        self.scale = cast(Tuple[float, float], scale)\n        self.nb_rows = cast(Tuple[int, int], nb_rows)\n        self.nb_cols = cast(Tuple[int, int], nb_cols)\n        self.interpolation = interpolation\n        self.mask_interpolation = mask_interpolation\n        self.cval = cval\n        self.cval_mask = cval_mask\n        self.mode = mode\n        self.absolute_scale = absolute_scale\n        self.keypoints_threshold = keypoints_threshold\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"scale\",\n            \"nb_rows\",\n            \"nb_cols\",\n            \"interpolation\",\n            \"mask_interpolation\",\n            \"cval\",\n            \"cval_mask\",\n            \"mode\",\n            \"absolute_scale\",\n            \"keypoints_threshold\",\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        nb_rows = np.clip(random.randint(*self.nb_rows), 2, None)\n        nb_cols = np.clip(random.randint(*self.nb_cols), 2, None)\n        nb_cells = nb_cols * nb_rows\n        scale = random.uniform(*self.scale)\n\n        jitter: np.ndarray = random_utils.normal(0, scale, (nb_cells, 2))\n        if not np.any(jitter &gt; 0):\n            for _ in range(10):  # See: https://github.com/albumentations-team/albumentations/issues/1442\n                jitter = random_utils.normal(0, scale, (nb_cells, 2))\n                if np.any(jitter &gt; 0):\n                    break\n            if not np.any(jitter &gt; 0):\n                return {\"matrix\": None}\n\n        y = np.linspace(0, height, nb_rows)\n        x = np.linspace(0, width, nb_cols)\n\n        # (H, W) and (H, W) for H=rows, W=cols\n        xx_src, yy_src = np.meshgrid(x, y)\n\n        # (1, HW, 2) =&gt; (HW, 2) for H=rows, W=cols\n        points_src = np.dstack([yy_src.flat, xx_src.flat])[0]\n\n        if self.absolute_scale:\n            jitter[:, 0] = jitter[:, 0] / height if height &gt; 0 else 0.0\n            jitter[:, 1] = jitter[:, 1] / width if width &gt; 0 else 0.0\n\n        jitter[:, 0] = jitter[:, 0] * height\n        jitter[:, 1] = jitter[:, 1] * width\n\n        points_dest = np.copy(points_src)\n        points_dest[:, 0] = points_dest[:, 0] + jitter[:, 0]\n        points_dest[:, 1] = points_dest[:, 1] + jitter[:, 1]\n\n        # Restrict all destination points to be inside the image plane.\n        # This is necessary, as otherwise keypoints could be augmented\n        # outside of the image plane and these would be replaced by\n        # (-1, -1), which would not conform with the behaviour of the other augmenters.\n        points_dest[:, 0] = np.clip(points_dest[:, 0], 0, height - 1)\n        points_dest[:, 1] = np.clip(points_dest[:, 1], 0, width - 1)\n\n        matrix = skimage.transform.PiecewiseAffineTransform()\n        matrix.estimate(points_src[:, ::-1], points_dest[:, ::-1])\n\n        return {\n            \"matrix\": matrix,\n        }\n\n    def apply(\n        self, img: np.ndarray, matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None, **params: Any\n    ) -&gt; np.ndarray:\n        return F.piecewise_affine(img, matrix, cast(int, self.interpolation), self.mode, self.cval)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None, **params: Any\n    ) -&gt; np.ndarray:\n        return F.piecewise_affine(mask, matrix, self.mask_interpolation, self.mode, self.cval_mask)\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        rows: int = 0,\n        cols: int = 0,\n        matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.bbox_piecewise_affine(bbox, matrix, rows, cols, self.keypoints_threshold)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        rows: int = 0,\n        cols: int = 0,\n        matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.keypoint_piecewise_affine(keypoint, matrix, rows, cols, self.keypoints_threshold)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.ShiftScaleRotate","title":"<code>class  ShiftScaleRotate</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly apply affine transforms: translate, scale and rotate the input.</p> <p>Parameters:</p> Name Type Description <code>shift_limit</code> <code>float, float) or float</code> <p>shift factor range for both height and width. If shift_limit is a single float value, the range will be (-shift_limit, shift_limit). Absolute values for lower and upper bounds should lie in range [-1, 1]. Default: (-0.0625, 0.0625).</p> <code>scale_limit</code> <code>float, float) or float</code> <p>scaling factor range. If scale_limit is a single float value, the range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1. If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high). Default: (-0.1, 0.1).</p> <code>rotate_limit</code> <code>int, int) or int</code> <p>rotation range. If rotate_limit is a single int value, the range will be (-rotate_limit, rotate_limit). Default: (-45, 45).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of int, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of int,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>shift_limit_x</code> <code>float, float) or float</code> <p>shift factor range for width. If it is set then this value instead of shift_limit will be used for shifting width.  If shift_limit_x is a single float value, the range will be (-shift_limit_x, shift_limit_x). Absolute values for lower and upper bounds should lie in the range [-1, 1]. Default: None.</p> <code>shift_limit_y</code> <code>float, float) or float</code> <p>shift factor range for height. If it is set then this value instead of shift_limit will be used for shifting height.  If shift_limit_y is a single float value, the range will be (-shift_limit_y, shift_limit_y). Absolute values for lower and upper bounds should lie in the range [-, 1]. Default: None.</p> <code>rotate_method</code> <code>str</code> <p>rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\". Default: \"largest_box\"</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class ShiftScaleRotate(Affine):\n    \"\"\"Randomly apply affine transforms: translate, scale and rotate the input.\n\n    Args:\n        shift_limit ((float, float) or float): shift factor range for both height and width. If shift_limit\n            is a single float value, the range will be (-shift_limit, shift_limit). Absolute values for lower and\n            upper bounds should lie in range [-1, 1]. Default: (-0.0625, 0.0625).\n        scale_limit ((float, float) or float): scaling factor range. If scale_limit is a single float value, the\n            range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1.\n            If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high).\n            Default: (-0.1, 0.1).\n        rotate_limit ((int, int) or int): rotation range. If rotate_limit is a single int value, the\n            range will be (-rotate_limit, rotate_limit). Default: (-45, 45).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of int, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of int,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        shift_limit_x ((float, float) or float): shift factor range for width. If it is set then this value\n            instead of shift_limit will be used for shifting width.  If shift_limit_x is a single float value,\n            the range will be (-shift_limit_x, shift_limit_x). Absolute values for lower and upper bounds should lie in\n            the range [-1, 1]. Default: None.\n        shift_limit_y ((float, float) or float): shift factor range for height. If it is set then this value\n            instead of shift_limit will be used for shifting height.  If shift_limit_y is a single float value,\n            the range will be (-shift_limit_y, shift_limit_y). Absolute values for lower and upper bounds should lie\n            in the range [-, 1]. Default: None.\n        rotate_method (str): rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\".\n            Default: \"largest_box\"\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        shift_limit: SymmetricRangeType = (-0.0625, 0.0625)\n        scale_limit: SymmetricRangeType = (-0.1, 0.1)\n        rotate_limit: SymmetricRangeType = (-45, 45)\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: ColorType = 0\n        mask_value: ColorType = 0\n        shift_limit_x: Optional[ScaleFloatType] = Field(default=None)\n        shift_limit_y: Optional[ScaleFloatType] = Field(default=None)\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\"\n\n        @model_validator(mode=\"after\")\n        def check_shift_limit(self) -&gt; Self:\n            bounds = -1, 1\n            self.shift_limit_x = to_tuple(self.shift_limit_x if self.shift_limit_x is not None else self.shift_limit)\n            check_range(self.shift_limit_x, *bounds, \"shift_limit_x\")\n            self.shift_limit_y = to_tuple(self.shift_limit_y if self.shift_limit_y is not None else self.shift_limit)\n            check_range(self.shift_limit_y, *bounds, \"shift_limit_y\")\n            return self\n\n        @field_validator(\"scale_limit\")\n        @classmethod\n        def check_scale_limit(cls, value: ScaleFloatType, info: ValidationInfo) -&gt; ScaleFloatType:\n            bounds = 0, float(\"inf\")\n            result = to_tuple(value, bias=1.0)\n            check_range(result, *bounds, str(info.field_name))\n            return result\n\n    def __init__(\n        self,\n        shift_limit: ScaleFloatType = (-0.0625, 0.0625),\n        scale_limit: ScaleFloatType = (-0.1, 0.1),\n        rotate_limit: ScaleFloatType = (-45, 45),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: ColorType = 0,\n        mask_value: ColorType = 0,\n        shift_limit_x: Optional[ScaleFloatType] = None,\n        shift_limit_y: Optional[ScaleFloatType] = None,\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(\n            scale=scale_limit,\n            translate_percent={\"x\": shift_limit_x, \"y\": shift_limit_y},\n            rotate=rotate_limit,\n            shear=(0, 0),\n            interpolation=interpolation,\n            mask_interpolation=cv2.INTER_NEAREST,\n            cval=value,\n            cval_mask=mask_value,\n            mode=border_mode,\n            fit_output=False,\n            keep_ratio=False,\n            rotate_method=rotate_method,\n            always_apply=always_apply,\n            p=p,\n        )\n        warn(\n            \"ShiftScaleRotate is deprecated. Please use Affine transform instead .\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.shift_limit_x = cast(Tuple[float, float], shift_limit_x)\n        self.shift_limit_y = cast(Tuple[float, float], shift_limit_y)\n        self.scale_limit = cast(Tuple[float, float], scale_limit)\n        self.rotate_limit = cast(Tuple[int, int], rotate_limit)\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\n            \"shift_limit_x\": self.shift_limit_x,\n            \"shift_limit_y\": self.shift_limit_y,\n            \"scale_limit\": to_tuple(self.scale_limit, bias=-1.0),\n            \"rotate_limit\": self.rotate_limit,\n            \"interpolation\": self.interpolation,\n            \"border_mode\": self.border_mode,\n            \"value\": self.value,\n            \"mask_value\": self.mask_value,\n            \"rotate_method\": self.rotate_method,\n        }\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.Transpose","title":"<code>class  Transpose</code> <code> </code>  [view source on GitHub]","text":"<p>Transpose the input by swapping rows and columns.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Transpose(DualTransform):\n    \"\"\"Transpose the input by swapping rows and columns.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.transpose(img)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_transpose(bbox, 0, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_transpose(keypoint)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/geometric/#albumentations.augmentations.geometric.transforms.VerticalFlip","title":"<code>class  VerticalFlip</code> <code> </code>  [view source on GitHub]","text":"<p>Flip the input vertically around the x-axis.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class VerticalFlip(DualTransform):\n    \"\"\"Flip the input vertically around the x-axis.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.vflip(img)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_vflip(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_vflip(keypoint, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/transforms/","title":"Transforms (augmentations.transforms)","text":""},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.CLAHE","title":"<code>class  CLAHE</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply Contrast Limited Adaptive Histogram Equalization to the input image.</p> <p>Parameters:</p> Name Type Description <code>clip_limit</code> <p>upper threshold value for contrast limiting. If clip_limit is a single float value, the range will be (1, clip_limit). Default: (1, 4).</p> <code>tile_grid_size</code> <p>size of grid for histogram equalization. Default: (8, 8).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class CLAHE(ImageOnlyTransform):\n    \"\"\"Apply Contrast Limited Adaptive Histogram Equalization to the input image.\n\n    Args:\n        clip_limit: upper threshold value for contrast limiting.\n            If clip_limit is a single float value, the range will be (1, clip_limit). Default: (1, 4).\n        tile_grid_size: size of grid for histogram equalization. Default: (8, 8).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        clip_limit: OnePlusFloatRangeType = (1.0, 4.0)\n        tile_grid_size: OnePlusIntRangeType = (8, 8)\n\n    def __init__(\n        self,\n        clip_limit: ScaleFloatType = 4.0,\n        tile_grid_size: Tuple[int, int] = (8, 8),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.clip_limit = cast(Tuple[float, float], clip_limit)\n        self.tile_grid_size = tile_grid_size\n\n    def apply(self, img: np.ndarray, clip_limit: float = 2, **params: Any) -&gt; np.ndarray:\n        if not is_rgb_image(img) and not is_grayscale_image(img):\n            msg = \"CLAHE transformation expects 1-channel or 3-channel images.\"\n            raise TypeError(msg)\n\n        return F.clahe(img, clip_limit, self.tile_grid_size)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"clip_limit\": random.uniform(self.clip_limit[0], self.clip_limit[1])}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"clip_limit\", \"tile_grid_size\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ChannelShuffle","title":"<code>class  ChannelShuffle</code> <code> </code>  [view source on GitHub]","text":"<p>Randomly rearrange channels of the input RGB image.</p> <p>Parameters:</p> Name Type Description <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ChannelShuffle(ImageOnlyTransform):\n    \"\"\"Randomly rearrange channels of the input RGB image.\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def apply(self, img: np.ndarray, channels_shuffled: Tuple[int, int, int] = (0, 1, 2), **params: Any) -&gt; np.ndarray:\n        return F.channel_shuffle(img, channels_shuffled)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        ch_arr = list(range(img.shape[2]))\n        random.shuffle(ch_arr)\n        return {\"channels_shuffled\": ch_arr}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ChromaticAberration","title":"<code>class  ChromaticAberration</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Add lateral chromatic aberration by distorting the red and blue channels of the input image.</p> <p>Parameters:</p> Name Type Description <code>primary_distortion_limit</code> <p>range of the primary radial distortion coefficient. If primary_distortion_limit is a single float value, the range will be (-primary_distortion_limit, primary_distortion_limit). Controls the distortion in the center of the image (positive values result in pincushion distortion, negative values result in barrel distortion). Default: 0.02.</p> <code>secondary_distortion_limit</code> <p>range of the secondary radial distortion coefficient. If secondary_distortion_limit is a single float value, the range will be (-secondary_distortion_limit, secondary_distortion_limit). Controls the distortion in the corners of the image (positive values result in pincushion distortion, negative values result in barrel distortion). Default: 0.05.</p> <code>mode</code> <p>type of color fringing. Supported modes are 'green_purple', 'red_blue' and 'random'. 'random' will choose one of the modes 'green_purple' or 'red_blue' randomly. Default: 'green_purple'.</p> <code>interpolation</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ChromaticAberration(ImageOnlyTransform):\n    \"\"\"Add lateral chromatic aberration by distorting the red and blue channels of the input image.\n\n    Args:\n        primary_distortion_limit: range of the primary radial distortion coefficient.\n            If primary_distortion_limit is a single float value, the range will be\n            (-primary_distortion_limit, primary_distortion_limit).\n            Controls the distortion in the center of the image (positive values result in pincushion distortion,\n            negative values result in barrel distortion).\n            Default: 0.02.\n        secondary_distortion_limit: range of the secondary radial distortion coefficient.\n            If secondary_distortion_limit is a single float value, the range will be\n            (-secondary_distortion_limit, secondary_distortion_limit).\n            Controls the distortion in the corners of the image (positive values result in pincushion distortion,\n            negative values result in barrel distortion).\n            Default: 0.05.\n        mode: type of color fringing.\n            Supported modes are 'green_purple', 'red_blue' and 'random'.\n            'random' will choose one of the modes 'green_purple' or 'red_blue' randomly.\n            Default: 'green_purple'.\n        interpolation: flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p: probability of applying the transform.\n            Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        primary_distortion_limit: SymmetricRangeType = (-0.02, 0.02)\n        secondary_distortion_limit: SymmetricRangeType = (-0.05, 0.05)\n        mode: ChromaticAberrationMode = Field(default=\"green_purple\", description=\"Type of color fringing.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n    def __init__(\n        self,\n        primary_distortion_limit: ScaleFloatType = (-0.02, 0.02),\n        secondary_distortion_limit: ScaleFloatType = (-0.05, 0.05),\n        mode: ChromaticAberrationMode = \"green_purple\",\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.primary_distortion_limit = cast(Tuple[float, float], primary_distortion_limit)\n        self.secondary_distortion_limit = cast(Tuple[float, float], secondary_distortion_limit)\n        self.mode = mode\n        self.interpolation = interpolation\n\n    def apply(\n        self,\n        img: np.ndarray,\n        primary_distortion_red: float = -0.02,\n        secondary_distortion_red: float = -0.05,\n        primary_distortion_blue: float = -0.02,\n        secondary_distortion_blue: float = -0.05,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.chromatic_aberration(\n            img,\n            primary_distortion_red,\n            secondary_distortion_red,\n            primary_distortion_blue,\n            secondary_distortion_blue,\n            cast(int, self.interpolation),\n        )\n\n    def get_params(self) -&gt; Dict[str, float]:\n        primary_distortion_red = random_utils.uniform(*self.primary_distortion_limit)\n        secondary_distortion_red = random_utils.uniform(*self.secondary_distortion_limit)\n        primary_distortion_blue = random_utils.uniform(*self.primary_distortion_limit)\n        secondary_distortion_blue = random_utils.uniform(*self.secondary_distortion_limit)\n\n        secondary_distortion_red = self._match_sign(primary_distortion_red, secondary_distortion_red)\n        secondary_distortion_blue = self._match_sign(primary_distortion_blue, secondary_distortion_blue)\n\n        if self.mode == \"green_purple\":\n            # distortion coefficients of the red and blue channels have the same sign\n            primary_distortion_blue = self._match_sign(primary_distortion_red, primary_distortion_blue)\n            secondary_distortion_blue = self._match_sign(secondary_distortion_red, secondary_distortion_blue)\n        if self.mode == \"red_blue\":\n            # distortion coefficients of the red and blue channels have the opposite sign\n            primary_distortion_blue = self._unmatch_sign(primary_distortion_red, primary_distortion_blue)\n            secondary_distortion_blue = self._unmatch_sign(secondary_distortion_red, secondary_distortion_blue)\n\n        return {\n            \"primary_distortion_red\": primary_distortion_red,\n            \"secondary_distortion_red\": secondary_distortion_red,\n            \"primary_distortion_blue\": primary_distortion_blue,\n            \"secondary_distortion_blue\": secondary_distortion_blue,\n        }\n\n    @staticmethod\n    def _match_sign(a: float, b: float) -&gt; float:\n        # Match the sign of b to a\n        if (a &lt; 0 &lt; b) or (a &gt; 0 &gt; b):\n            return -b\n        return b\n\n    @staticmethod\n    def _unmatch_sign(a: float, b: float) -&gt; float:\n        # Unmatch the sign of b to a\n        if (a &lt; 0 and b &lt; 0) or (a &gt; 0 and b &gt; 0):\n            return -b\n        return b\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return \"primary_distortion_limit\", \"secondary_distortion_limit\", \"mode\", \"interpolation\"\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ColorJitter","title":"<code>class  ColorJitter</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly changes the brightness, contrast, and saturation of an image. Compared to ColorJitter from torchvision, this transform gives a little bit different results because Pillow (used in torchvision) and OpenCV (used in Albumentations) transform an image to HSV format by different formulas. Another difference - Pillow uses uint8 overflow, but we use value saturation.</p> <p>Parameters:</p> Name Type Description <code>brightness</code> <code>float or tuple of float (min, max</code> <p>How much to jitter brightness. If float:     brightness_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness] If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.</p> <code>contrast</code> <code>float or tuple of float (min, max</code> <p>How much to jitter contrast. If float:     contrast_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness] If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.</p> <code>saturation</code> <code>float or tuple of float (min, max</code> <p>How much to jitter saturation. If float:    saturation_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness] If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.</p> <code>hue</code> <code>float or tuple of float (min, max</code> <p>How much to jitter hue. If float:    saturation_factor is chosen uniformly from [-hue, hue]. Should have 0 &lt;= hue &lt;= 0.5. If Tuple[float, float]] will be sampled from that range. Both values should be in range [-0.5, 0.5].</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ColorJitter(ImageOnlyTransform):\n    \"\"\"Randomly changes the brightness, contrast, and saturation of an image. Compared to ColorJitter from torchvision,\n    this transform gives a little bit different results because Pillow (used in torchvision) and OpenCV (used in\n    Albumentations) transform an image to HSV format by different formulas. Another difference - Pillow uses uint8\n    overflow, but we use value saturation.\n\n    Args:\n        brightness (float or tuple of float (min, max)): How much to jitter brightness.\n            If float:\n                brightness_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness]\n            If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.\n        contrast (float or tuple of float (min, max)): How much to jitter contrast.\n            If float:\n                contrast_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness]\n            If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.\n        saturation (float or tuple of float (min, max)): How much to jitter saturation.\n            If float:\n               saturation_factor is chosen uniformly from [max(0, 1 - brightness), 1 + brightness]\n            If Tuple[float, float]] will be sampled from that range. Both values should be non negative numbers.\n        hue (float or tuple of float (min, max)): How much to jitter hue.\n            If float:\n               saturation_factor is chosen uniformly from [-hue, hue]. Should have 0 &lt;= hue &lt;= 0.5.\n            If Tuple[float, float]] will be sampled from that range. Both values should be in range [-0.5, 0.5].\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        brightness: Annotated[ScaleFloatType, Field(default=0.2, description=\"Range for jittering brightness.\")]\n        contrast: Annotated[ScaleFloatType, Field(default=0.2, description=\"Range for jittering contrast.\")]\n        saturation: Annotated[ScaleFloatType, Field(default=0.2, description=\"Range for jittering saturation.\")]\n        hue: Annotated[ScaleFloatType, Field(default=0.2, description=\"Range for jittering hue.\")]\n\n        @field_validator(\"brightness\", \"contrast\", \"saturation\", \"hue\")\n        @classmethod\n        def check_ranges(cls, value: ScaleFloatType, info: ValidationInfo) -&gt; Tuple[float, float]:\n            if info.field_name == \"hue\":\n                bounds = -0.5, 0.5\n                bias = 0\n                clip = False\n            elif info.field_name in [\"brightness\", \"contrast\", \"saturation\"]:\n                bounds = 0, float(\"inf\")\n                bias = 1\n                clip = True\n\n            if isinstance(value, numbers.Number):\n                if value &lt; 0:\n                    raise ValueError(f\"If {info.field_name} is a single number, it must be non negative.\")\n                value = [bias - value, bias + value]\n                if clip:\n                    value[0] = max(value[0], 0)\n            elif isinstance(value, (tuple, list)) and len(value) == PAIR:\n                check_range(value, *bounds, info.field_name)\n\n            return cast(Tuple[float, float], value)\n\n    def __init__(\n        self,\n        brightness: ScaleFloatType = (0.8, 1),\n        contrast: ScaleFloatType = (0.8, 1),\n        saturation: ScaleFloatType = (0.8, 1),\n        hue: ScaleFloatType = (-0.5, 0.5),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        self.brightness = cast(Tuple[float, float], brightness)\n        self.contrast = cast(Tuple[float, float], contrast)\n        self.saturation = cast(Tuple[float, float], saturation)\n        self.hue = cast(Tuple[float, float], hue)\n\n        self.transforms = [\n            F.adjust_brightness_torchvision,\n            F.adjust_contrast_torchvision,\n            F.adjust_saturation_torchvision,\n            F.adjust_hue_torchvision,\n        ]\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        brightness = random.uniform(self.brightness[0], self.brightness[1])\n        contrast = random.uniform(self.contrast[0], self.contrast[1])\n        saturation = random.uniform(self.saturation[0], self.saturation[1])\n        hue = random.uniform(self.hue[0], self.hue[1])\n\n        order = [0, 1, 2, 3]\n        random_utils.shuffle(order)\n\n        return {\n            \"brightness\": brightness,\n            \"contrast\": contrast,\n            \"saturation\": saturation,\n            \"hue\": hue,\n            \"order\": order,\n        }\n\n    def apply(\n        self,\n        img: np.ndarray,\n        brightness: float = 1.0,\n        contrast: float = 1.0,\n        saturation: float = 1.0,\n        hue: float = 0,\n        order: Optional[List[int]] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if order is None:\n            order = [0, 1, 2, 3]\n        if not is_rgb_image(img) and not is_grayscale_image(img):\n            msg = \"ColorJitter transformation expects 1-channel or 3-channel images.\"\n            raise TypeError(msg)\n        color_transforms = [brightness, contrast, saturation, hue]\n        for i in order:\n            img = self.transforms[i](img, color_transforms[i])  # type: ignore[operator]\n        return img\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"brightness\", \"contrast\", \"saturation\", \"hue\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Downscale","title":"<code>class  Downscale</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Decreases image quality by downscaling and upscaling back.</p> <p>Parameters:</p> Name Type Description <code>scale_min</code> <p>lower bound on the image scale. Should be &lt;= scale_max.</p> <code>scale_max</code> <p>upper bound on the image scale. Should be &lt; 1.</p> <code>interpolation</code> <p>cv2 interpolation method. Could be: - single cv2 interpolation flag - selected method will be used for downscale and upscale. - dict(downscale=flag, upscale=flag) - Downscale.Interpolation(downscale=flag, upscale=flag) - Default: Interpolation(downscale=cv2.INTER_NEAREST, upscale=cv2.INTER_NEAREST)</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Downscale(ImageOnlyTransform):\n    \"\"\"Decreases image quality by downscaling and upscaling back.\n\n    Args:\n        scale_min: lower bound on the image scale. Should be &lt;= scale_max.\n        scale_max: upper bound on the image scale. Should be &lt; 1.\n        interpolation: cv2 interpolation method. Could be:\n            - single cv2 interpolation flag - selected method will be used for downscale and upscale.\n            - dict(downscale=flag, upscale=flag)\n            - Downscale.Interpolation(downscale=flag, upscale=flag) -\n            Default: Interpolation(downscale=cv2.INTER_NEAREST, upscale=cv2.INTER_NEAREST)\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        scale_min: float = Field(default=0.25, ge=0, le=1, description=\"Lower bound on the image scale.\")\n        scale_max: float = Field(default=0.25, ge=0, lt=1, description=\"Upper bound on the image scale.\")\n        interpolation: Optional[Union[int, Interpolation, Dict[str, int]]] = Field(\n            default_factory=lambda: Interpolation(downscale=cv2.INTER_NEAREST, upscale=cv2.INTER_NEAREST),\n            description=\"CV2 interpolation method or a dictionary specifying downscale and upscale methods.\",\n        )\n\n        @model_validator(mode=\"after\")\n        def validate_scale(self) -&gt; Self:\n            if self.scale_min &gt; self.scale_max:\n                msg = \"scale_min must be less than or equal to scale_max\"\n                raise ValueError(msg)\n            return self\n\n        @field_validator(\"interpolation\")\n        @classmethod\n        def set_interpolation(cls, v: Any) -&gt; Interpolation:\n            if isinstance(v, dict):\n                return Interpolation(**v)\n            if isinstance(v, int):\n                return Interpolation(downscale=v, upscale=v)\n            if isinstance(v, Interpolation):\n                return v\n            if v is None:\n                return Interpolation(downscale=cv2.INTER_NEAREST, upscale=cv2.INTER_NEAREST)\n\n            msg = (\n                \"Interpolation must be an int, Interpolation instance, \"\n                \"or dict specifying downscale and upscale methods.\"\n            )\n            raise ValueError(msg)\n\n    def __init__(\n        self,\n        scale_min: float = 0.25,\n        scale_max: float = 0.25,\n        interpolation: Optional[Union[int, Interpolation, Dict[str, int]]] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.scale_min = scale_min\n        self.scale_max = scale_max\n        self.interpolation = cast(Interpolation, interpolation)\n\n    def apply(self, img: np.ndarray, scale: float, **params: Any) -&gt; np.ndarray:\n        if isinstance(self.interpolation, int):\n            msg = \"Should not be here, added for typing purposes. Please report this issue.\"\n            raise TypeError(msg)\n        return F.downscale(\n            img,\n            scale=scale,\n            down_interpolation=self.interpolation.downscale,\n            up_interpolation=self.interpolation.upscale,\n        )\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\"scale\": random.uniform(self.scale_min, self.scale_max)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return \"scale_min\", \"scale_max\"\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        if isinstance(self.interpolation, int):\n            msg = \"Should not be here, added for typing purposes. Please report this issue.\"\n            raise TypeError(msg)\n        result = super().to_dict_private()\n        result[\"interpolation\"] = {\"upscale\": self.interpolation.upscale, \"downscale\": self.interpolation.downscale}\n        return result\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Emboss","title":"<code>class  Emboss</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Emboss the input image and overlays the result with the original image.</p> <p>Parameters:</p> Name Type Description <code>alpha</code> <p>range to choose the visibility of the embossed image. At 0, only the original image is visible,at 1.0 only its embossed version is visible. Default: (0.2, 0.5).</p> <code>strength</code> <p>strength range of the embossing. Default: (0.2, 0.7).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Emboss(ImageOnlyTransform):\n    \"\"\"Emboss the input image and overlays the result with the original image.\n\n    Args:\n        alpha: range to choose the visibility of the embossed image. At 0, only the original image is\n            visible,at 1.0 only its embossed version is visible. Default: (0.2, 0.5).\n        strength: strength range of the embossing. Default: (0.2, 0.7).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        alpha: ZeroOneRangeType = (0.2, 0.5)\n        strength: NonNegativeFloatRangeType = (0.2, 0.7)\n\n    def __init__(\n        self,\n        alpha: Tuple[float, float] = (0.2, 0.5),\n        strength: Tuple[float, float] = (0.2, 0.7),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.alpha = alpha\n        self.strength = strength\n\n    @staticmethod\n    def __generate_emboss_matrix(alpha_sample: np.ndarray, strength_sample: np.ndarray) -&gt; np.ndarray:\n        matrix_nochange = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]], dtype=np.float32)\n        matrix_effect = np.array(\n            [\n                [-1 - strength_sample, 0 - strength_sample, 0],\n                [0 - strength_sample, 1, 0 + strength_sample],\n                [0, 0 + strength_sample, 1 + strength_sample],\n            ],\n            dtype=np.float32,\n        )\n        return (1 - alpha_sample) * matrix_nochange + alpha_sample * matrix_effect\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        alpha = random.uniform(*self.alpha)\n        strength = random.uniform(*self.strength)\n        emboss_matrix = self.__generate_emboss_matrix(alpha_sample=alpha, strength_sample=strength)\n        return {\"emboss_matrix\": emboss_matrix}\n\n    def apply(self, img: np.ndarray, emboss_matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.convolve(img, emboss_matrix)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"alpha\", \"strength\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Equalize","title":"<code>class  Equalize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Equalize the image histogram.</p> <p>Parameters:</p> Name Type Description <code>mode</code> <code>str</code> <p>{'cv', 'pil'}. Use OpenCV or Pillow equalization method.</p> <code>by_channels</code> <code>bool</code> <p>If True, use equalization by channels separately, else convert image to YCbCr representation and use equalization by <code>Y</code> channel.</p> <code>mask</code> <code>np.ndarray, callable</code> <p>If given, only the pixels selected by the mask are included in the analysis. Maybe 1 channel or 3 channel array or callable. Function signature must include <code>image</code> argument.</p> <code>mask_params</code> <code>list of str</code> <p>Params for mask function.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Equalize(ImageOnlyTransform):\n    \"\"\"Equalize the image histogram.\n\n    Args:\n        mode (str): {'cv', 'pil'}. Use OpenCV or Pillow equalization method.\n        by_channels (bool): If True, use equalization by channels separately,\n            else convert image to YCbCr representation and use equalization by `Y` channel.\n        mask (np.ndarray, callable): If given, only the pixels selected by\n            the mask are included in the analysis. Maybe 1 channel or 3 channel array or callable.\n            Function signature must include `image` argument.\n        mask_params (list of str): Params for mask function.\n\n    Targets:\n        image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        mode: ImageMode = \"cv\"\n        by_channels: Annotated[bool, Field(default=True, description=\"Equalize channels separately if True\")]\n        mask: Annotated[\n            Optional[Union[np.ndarray, Callable[..., Any]]],\n            Field(default=None, description=\"Mask to apply for equalization\"),\n        ]\n        mask_params: Annotated[Sequence[str], Field(default=[], description=\"Parameters for mask function\")]\n\n    def __init__(\n        self,\n        mode: ImageMode = \"cv\",\n        by_channels: bool = True,\n        mask: Optional[Union[np.ndarray, Callable[..., Any]]] = None,\n        mask_params: Sequence[str] = (),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        self.mode = mode\n        self.by_channels = by_channels\n        self.mask = mask\n        self.mask_params = mask_params\n\n    def apply(self, img: np.ndarray, mask: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.equalize(img, mode=self.mode, by_channels=self.by_channels, mask=mask)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        if not callable(self.mask):\n            return {\"mask\": self.mask}\n\n        return {\"mask\": self.mask(**params)}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\", *list(self.mask_params)]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"mode\", \"by_channels\", \"mask\", \"mask_params\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.FancyPCA","title":"<code>class  FancyPCA</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Augment RGB image using FancyPCA from Krizhevsky's paper \"ImageNet Classification with Deep Convolutional Neural Networks\"</p> <p>Parameters:</p> Name Type Description <code>alpha</code> <p>how much to perturb/scale the eigen vecs and vals. scale is samples from gaussian distribution (mu=0, sigma=alpha)</p> <p>Targets</p> <p>image</p> <p>Image types:     3-channel uint8 images only</p> <p>Credit</p> <p>http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf https://deshanadesai.github.io/notes/Fancy-PCA-with-Scikit-Image https://pixelatedbrian.github.io/2018-04-29-fancy_pca/</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class FancyPCA(ImageOnlyTransform):\n    \"\"\"Augment RGB image using FancyPCA from Krizhevsky's paper\n    \"ImageNet Classification with Deep Convolutional Neural Networks\"\n\n    Args:\n        alpha:  how much to perturb/scale the eigen vecs and vals.\n            scale is samples from gaussian distribution (mu=0, sigma=alpha)\n\n    Targets:\n        image\n\n    Image types:\n        3-channel uint8 images only\n\n    Credit:\n        http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf\n        https://deshanadesai.github.io/notes/Fancy-PCA-with-Scikit-Image\n        https://pixelatedbrian.github.io/2018-04-29-fancy_pca/\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        alpha: float = Field(default=0.1, description=\"Scale for perturbing the eigen vectors and values\", ge=0)\n\n    def __init__(self, alpha: float = 0.1, always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply=always_apply, p=p)\n        self.alpha = alpha\n\n    def apply(self, img: np.ndarray, alpha: float = 0.1, **params: Any) -&gt; np.ndarray:\n        return F.fancy_pca(img, alpha)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"alpha\": random.gauss(0, self.alpha)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"alpha\",)\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.FromFloat","title":"<code>class  FromFloat</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Take an input array where all values should lie in the range [0, 1.0], multiply them by <code>max_value</code> and then cast the resulted value to a type specified by <code>dtype</code>. If <code>max_value</code> is None the transform will try to infer the maximum value for the data type from the <code>dtype</code> argument.</p> <p>This is the inverse transform for :class:<code>~albumentations.augmentations.transforms.ToFloat</code>.</p> <p>Parameters:</p> Name Type Description <code>max_value</code> <p>maximum possible input value. Default: None.</p> <code>dtype</code> <p>data type of the output. See the <code>'Data types' page from the NumPy docs</code>_. Default: 'uint16'.</p> <code>p</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image</p> <p>Image types:     float32</p> <p>.. _'Data types' page from the NumPy docs:    https://docs.scipy.org/doc/numpy/user/basics.types.html</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class FromFloat(ImageOnlyTransform):\n    \"\"\"Take an input array where all values should lie in the range [0, 1.0], multiply them by `max_value` and then\n    cast the resulted value to a type specified by `dtype`. If `max_value` is None the transform will try to infer\n    the maximum value for the data type from the `dtype` argument.\n\n    This is the inverse transform for :class:`~albumentations.augmentations.transforms.ToFloat`.\n\n    Args:\n        max_value: maximum possible input value. Default: None.\n        dtype: data type of the output. See the `'Data types' page from the NumPy docs`_.\n            Default: 'uint16'.\n        p: probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image\n\n    Image types:\n        float32\n\n    .. _'Data types' page from the NumPy docs:\n       https://docs.scipy.org/doc/numpy/user/basics.types.html\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        dtype: Literal[\"uint8\", \"uint16\", \"float32\", \"float64\"]\n        max_value: Optional[float] = Field(default=None, description=\"Maximum possible input value.\")\n        p: ProbabilityType = 1\n\n    def __init__(\n        self,\n        dtype: Literal[\"uint8\", \"uint16\", \"float32\", \"float64\"] = \"uint16\",\n        max_value: Optional[float] = None,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.dtype = np.dtype(dtype)\n        self.max_value = max_value\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.from_float(img, self.dtype, self.max_value)\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\"dtype\": self.dtype.name, \"max_value\": self.max_value}\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.GaussNoise","title":"<code>class  GaussNoise</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply gaussian noise to the input image.</p> <p>Parameters:</p> Name Type Description <code>var_limit</code> <p>variance range for noise. If var_limit is a single float, the range will be (0, var_limit). Default: (10.0, 50.0).</p> <code>mean</code> <p>mean of the noise. Default: 0</p> <code>per_channel</code> <p>if set to True, noise will be sampled for each channel independently. Otherwise, the noise will be sampled once for all channels. Default: True</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class GaussNoise(ImageOnlyTransform):\n    \"\"\"Apply gaussian noise to the input image.\n\n    Args:\n        var_limit: variance range for noise. If var_limit is a single float, the range\n            will be (0, var_limit). Default: (10.0, 50.0).\n        mean: mean of the noise. Default: 0\n        per_channel: if set to True, noise will be sampled for each channel independently.\n            Otherwise, the noise will be sampled once for all channels. Default: True\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        var_limit: NonNegativeFloatRangeType = Field(default=(10.0, 50.0), description=\"Variance range for noise.\")\n        mean: float = Field(default=0, description=\"Mean of the noise.\")\n        per_channel: bool = Field(default=True, description=\"Apply noise per channel.\")\n\n    def __init__(\n        self,\n        var_limit: ScaleFloatType = (10.0, 50.0),\n        mean: float = 0,\n        per_channel: bool = True,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.var_limit = cast(Tuple[float, float], var_limit)\n        self.mean = mean\n        self.per_channel = per_channel\n\n    def apply(self, img: np.ndarray, gauss: Optional[float] = None, **params: Any) -&gt; np.ndarray:\n        return F.gauss_noise(img, gauss=gauss)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, float]:\n        image = params[\"image\"]\n        var = random.uniform(self.var_limit[0], self.var_limit[1])\n        sigma = var**0.5\n\n        if self.per_channel:\n            gauss = random_utils.normal(self.mean, sigma, image.shape)\n        else:\n            gauss = random_utils.normal(self.mean, sigma, image.shape[:2])\n            if len(image.shape) &gt; GRAYSCALE_SHAPE_LEN:\n                gauss = np.expand_dims(gauss, -1)\n\n        return {\"gauss\": gauss}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"var_limit\", \"per_channel\", \"mean\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.HueSaturationValue","title":"<code>class  HueSaturationValue</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly change hue, saturation and value of the input image.</p> <p>Parameters:</p> Name Type Description <code>hue_shift_limit</code> <p>range for changing hue. If hue_shift_limit is a single int, the range will be (-hue_shift_limit, hue_shift_limit). Default: (-20, 20).</p> <code>sat_shift_limit</code> <p>range for changing saturation. If sat_shift_limit is a single int, the range will be (-sat_shift_limit, sat_shift_limit). Default: (-30, 30).</p> <code>val_shift_limit</code> <p>range for changing value. If val_shift_limit is a single int, the range will be (-val_shift_limit, val_shift_limit). Default: (-20, 20).</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class HueSaturationValue(ImageOnlyTransform):\n    \"\"\"Randomly change hue, saturation and value of the input image.\n\n    Args:\n        hue_shift_limit: range for changing hue. If hue_shift_limit is a single int, the range\n            will be (-hue_shift_limit, hue_shift_limit). Default: (-20, 20).\n        sat_shift_limit: range for changing saturation. If sat_shift_limit is a single int,\n            the range will be (-sat_shift_limit, sat_shift_limit). Default: (-30, 30).\n        val_shift_limit: range for changing value. If val_shift_limit is a single int, the range\n            will be (-val_shift_limit, val_shift_limit). Default: (-20, 20).\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        hue_shift_limit: SymmetricRangeType = (-20, 20)\n        sat_shift_limit: SymmetricRangeType = (-30, 30)\n        val_shift_limit: SymmetricRangeType = (-20, 20)\n\n    def __init__(\n        self,\n        hue_shift_limit: ScaleIntType = 20,\n        sat_shift_limit: ScaleIntType = 30,\n        val_shift_limit: ScaleIntType = 20,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.hue_shift_limit = cast(Tuple[float, float], hue_shift_limit)\n        self.sat_shift_limit = cast(Tuple[float, float], sat_shift_limit)\n        self.val_shift_limit = cast(Tuple[float, float], val_shift_limit)\n\n    def apply(\n        self, img: np.ndarray, hue_shift: int = 0, sat_shift: int = 0, val_shift: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        if not is_rgb_image(img) and not is_grayscale_image(img):\n            msg = \"HueSaturationValue transformation expects 1-channel or 3-channel images.\"\n            raise TypeError(msg)\n        return F.shift_hsv(img, hue_shift, sat_shift, val_shift)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"hue_shift\": random.uniform(self.hue_shift_limit[0], self.hue_shift_limit[1]),\n            \"sat_shift\": random.uniform(self.sat_shift_limit[0], self.sat_shift_limit[1]),\n            \"val_shift\": random.uniform(self.val_shift_limit[0], self.val_shift_limit[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"hue_shift_limit\", \"sat_shift_limit\", \"val_shift_limit\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ISONoise","title":"<code>class  ISONoise</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply camera sensor noise.</p> <p>Parameters:</p> Name Type Description <code>color_shift</code> <code>float, float</code> <p>variance range for color hue change. Measured as a fraction of 360 degree Hue angle in HLS colorspace.</p> <code>intensity</code> <code>float, float</code> <p>Multiplicative factor that control strength of color and luminace noise.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ISONoise(ImageOnlyTransform):\n    \"\"\"Apply camera sensor noise.\n\n    Args:\n        color_shift (float, float): variance range for color hue change.\n            Measured as a fraction of 360 degree Hue angle in HLS colorspace.\n        intensity ((float, float): Multiplicative factor that control strength\n            of color and luminace noise.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        color_shift: Tuple[float, float] = Field(\n            default=(0.01, 0.05),\n            description=(\n                \"Variance range for color hue change. Measured as a fraction of 360 degree Hue angle in HLS colorspace.\"\n            ),\n        )\n        intensity: Tuple[float, float] = Field(\n            default=(0.1, 0.5), description=\"Multiplicative factor that control strength of color and luminance noise.\"\n        )\n\n    def __init__(\n        self,\n        color_shift: Tuple[float, float] = (0.01, 0.05),\n        intensity: Tuple[float, float] = (0.1, 0.5),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.intensity = intensity\n        self.color_shift = color_shift\n\n    def apply(\n        self,\n        img: np.ndarray,\n        color_shift: float = 0.05,\n        intensity: float = 1.0,\n        random_state: Optional[int] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.iso_noise(img, color_shift, intensity, np.random.RandomState(random_state))\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"color_shift\": random_utils.uniform(self.color_shift[0], self.color_shift[1]),\n            \"intensity\": random_utils.uniform(self.intensity[0], self.intensity[1]),\n            \"random_state\": random_utils.randint(0, 65536),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"intensity\", \"color_shift\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ImageCompression","title":"<code>class  ImageCompression</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Decreases image quality by Jpeg, WebP compression of an image.</p> <p>Parameters:</p> Name Type Description <code>quality_lower</code> <p>lower bound on the image quality. Should be in [0, 100] range for jpeg and [1, 100] for webp.</p> <code>quality_upper</code> <p>upper bound on the image quality. Should be in [0, 100] range for jpeg and [1, 100] for webp.</p> <code>compression_type</code> <code>ImageCompressionType</code> <p>should be ImageCompressionType.JPEG or ImageCompressionType.WEBP. Default: ImageCompressionType.JPEG</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ImageCompression(ImageOnlyTransform):\n    \"\"\"Decreases image quality by Jpeg, WebP compression of an image.\n\n    Args:\n        quality_lower: lower bound on the image quality. Should be in [0, 100] range for jpeg and [1, 100] for webp.\n        quality_upper: upper bound on the image quality. Should be in [0, 100] range for jpeg and [1, 100] for webp.\n        compression_type (ImageCompressionType): should be ImageCompressionType.JPEG or ImageCompressionType.WEBP.\n            Default: ImageCompressionType.JPEG\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        quality_lower: int = Field(default=99, description=\"Lower bound on the image quality\", ge=1, le=100)\n        quality_upper: int = Field(default=100, description=\"Upper bound on the image quality\", ge=1, le=100)\n        compression_type: ImageCompressionType = Field(\n            default=ImageCompressionType.JPEG, description=\"Image compression format\"\n        )\n\n        @model_validator(mode=\"after\")\n        def validate_quality(self) -&gt; Self:\n            if self.quality_lower &gt;= self.quality_upper:\n                msg = \"quality_lower must be less than quality_upper\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        quality_lower: int = 99,\n        quality_upper: int = 100,\n        compression_type: ImageCompressionType = ImageCompressionType.JPEG,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        self.quality_lower = quality_lower\n        self.quality_upper = quality_upper\n        self.compression_type = compression_type\n\n    def apply(self, img: np.ndarray, quality: int = 100, image_type: str = \".jpg\", **params: Any) -&gt; np.ndarray:\n        if img.ndim != GRAYSCALE_SHAPE_LEN and img.shape[-1] not in (1, 3, 4):\n            msg = \"ImageCompression transformation expects 1, 3 or 4 channel images.\"\n            raise TypeError(msg)\n        return F.image_compression(img, quality, image_type)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        image_type = \".jpg\"\n\n        if self.compression_type == ImageCompressionType.WEBP:\n            image_type = \".webp\"\n\n        return {\n            \"quality\": random_utils.randint(self.quality_lower, self.quality_upper + 1),\n            \"image_type\": image_type,\n        }\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\n            \"quality_lower\": self.quality_lower,\n            \"quality_upper\": self.quality_upper,\n            \"compression_type\": self.compression_type.value,\n        }\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.InvertImg","title":"<code>class  InvertImg</code> <code> </code>  [view source on GitHub]","text":"<p>Invert the input image by subtracting pixel values from max values of the image types, i.e., 255 for uint8 and 1.0 for float32.</p> <p>Parameters:</p> Name Type Description <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class InvertImg(ImageOnlyTransform):\n    \"\"\"Invert the input image by subtracting pixel values from max values of the image types,\n    i.e., 255 for uint8 and 1.0 for float32.\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.invert(img)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Lambda","title":"<code>class  Lambda</code> <code>       (image=None, mask=None, keypoint=None, bbox=None, global_label=None, name=None, always_apply=False, p=1.0)                   </code>  [view source on GitHub]","text":"<p>A flexible transformation class for using user-defined transformation functions per targets. Function signature must include **kwargs to accept optional arguments like interpolation method, image size, etc:</p> <p>Parameters:</p> Name Type Description <code>image</code> <code>Optional[Callable[..., Any]]</code> <p>Image transformation function.</p> <code>mask</code> <code>Optional[Callable[..., Any]]</code> <p>Mask transformation function.</p> <code>keypoint</code> <code>Optional[Callable[..., Any]]</code> <p>Keypoint transformation function.</p> <code>bbox</code> <code>Optional[Callable[..., Any]]</code> <p>BBox transformation function.</p> <code>global_label</code> <code>Optional[Callable[..., Any]]</code> <p>Global label transformation function.</p> <code>always_apply</code> <code>bool</code> <p>Indicates whether this transformation should be always applied.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints, global_label</p> <p>Image types:     Any</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Lambda(NoOp):\n    \"\"\"A flexible transformation class for using user-defined transformation functions per targets.\n    Function signature must include **kwargs to accept optional arguments like interpolation method, image size, etc:\n\n    Args:\n        image: Image transformation function.\n        mask: Mask transformation function.\n        keypoint: Keypoint transformation function.\n        bbox: BBox transformation function.\n        global_label: Global label transformation function.\n        always_apply: Indicates whether this transformation should be always applied.\n        p: probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image, mask, bboxes, keypoints, global_label\n\n    Image types:\n        Any\n\n    \"\"\"\n\n    def __init__(\n        self,\n        image: Optional[Callable[..., Any]] = None,\n        mask: Optional[Callable[..., Any]] = None,\n        keypoint: Optional[Callable[..., Any]] = None,\n        bbox: Optional[Callable[..., Any]] = None,\n        global_label: Optional[Callable[..., Any]] = None,\n        name: Optional[str] = None,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n\n        self.name = name\n        self.custom_apply_fns = {\n            target_name: F.noop for target_name in (\"image\", \"mask\", \"keypoint\", \"bbox\", \"global_label\")\n        }\n        for target_name, custom_apply_fn in {\n            \"image\": image,\n            \"mask\": mask,\n            \"keypoint\": keypoint,\n            \"bbox\": bbox,\n            \"global_label\": global_label,\n        }.items():\n            if custom_apply_fn is not None:\n                if isinstance(custom_apply_fn, LambdaType) and custom_apply_fn.__name__ == \"&lt;lambda&gt;\":\n                    warnings.warn(\n                        \"Using lambda is incompatible with multiprocessing. \"\n                        \"Consider using regular functions or partial().\"\n                    )\n\n                self.custom_apply_fns[target_name] = custom_apply_fn\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        fn = self.custom_apply_fns[\"image\"]\n        return fn(img, **params)\n\n    def apply_to_mask(self, mask: np.ndarray, **params: Any) -&gt; np.ndarray:\n        fn = self.custom_apply_fns[\"mask\"]\n        return fn(mask, **params)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        fn = self.custom_apply_fns[\"bbox\"]\n        return fn(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        fn = self.custom_apply_fns[\"keypoint\"]\n        return fn(keypoint, **params)\n\n    def apply_to_global_label(self, label: np.ndarray, **params: Any) -&gt; np.ndarray:\n        fn = self.custom_apply_fns[\"global_label\"]\n        return fn(label, **params)\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return False\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        if self.name is None:\n            msg = (\n                \"To make a Lambda transform serializable you should provide the `name` argument, \"\n                \"e.g. `Lambda(name='my_transform', image=&lt;some func&gt;, ...)`.\"\n            )\n            raise ValueError(msg)\n        return {\"__class_fullname__\": self.get_class_fullname(), \"__name__\": self.name}\n\n    def __repr__(self) -&gt; str:\n        state = {\"name\": self.name}\n        state.update(self.custom_apply_fns.items())  # type: ignore[arg-type]\n        state.update(self.get_base_init_args())\n        return f\"{self.__class__.__name__}({format_args(state)})\"\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Lambda.__init__","title":"<code>__init__ (self, image=None, mask=None, keypoint=None, bbox=None, global_label=None, name=None, always_apply=False, p=1.0)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>def __init__(\n    self,\n    image: Optional[Callable[..., Any]] = None,\n    mask: Optional[Callable[..., Any]] = None,\n    keypoint: Optional[Callable[..., Any]] = None,\n    bbox: Optional[Callable[..., Any]] = None,\n    global_label: Optional[Callable[..., Any]] = None,\n    name: Optional[str] = None,\n    always_apply: bool = False,\n    p: float = 1.0,\n):\n    super().__init__(always_apply, p)\n\n    self.name = name\n    self.custom_apply_fns = {\n        target_name: F.noop for target_name in (\"image\", \"mask\", \"keypoint\", \"bbox\", \"global_label\")\n    }\n    for target_name, custom_apply_fn in {\n        \"image\": image,\n        \"mask\": mask,\n        \"keypoint\": keypoint,\n        \"bbox\": bbox,\n        \"global_label\": global_label,\n    }.items():\n        if custom_apply_fn is not None:\n            if isinstance(custom_apply_fn, LambdaType) and custom_apply_fn.__name__ == \"&lt;lambda&gt;\":\n                warnings.warn(\n                    \"Using lambda is incompatible with multiprocessing. \"\n                    \"Consider using regular functions or partial().\"\n                )\n\n            self.custom_apply_fns[target_name] = custom_apply_fn\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Morphological","title":"<code>class  Morphological</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply a morphological operation (dilation or erosion) to an image, with particular value for enhancing document scans.</p> <p>Morphological operations modify the structure of the image. Dilation expands the white (foreground) regions in a binary or grayscale image, while erosion shrinks them. These operations are beneficial in document processing, for example: - Dilation helps in closing up gaps within text or making thin lines thicker,     enhancing legibility for OCR (Optical Character Recognition). - Erosion can remove small white noise and detach connected objects,     making the structure of larger objects more pronounced.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <code>int or tuple/list of int</code> <p>Specifies the size of the structuring element (kernel) used for the operation. - If an integer is provided, a square kernel of that size will be used. - If a tuple or list is provided, it should contain two integers representing the minimum     and maximum sizes for the dilation kernel.</p> <code>operation</code> <code>str</code> <p>The morphological operation to apply. Options are 'dilation' or 'erosion'. Default is 'dilation'.</p> <code>always_apply</code> <code>bool</code> <p>Whether to always apply this transformation. Default is False.</p> <code>p</code> <code>float</code> <p>The probability of applying this transformation. Default is 0.5.</p> <p>Targets</p> <p>image, mask</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://github.com/facebookresearch/nougat</p> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; import albumentations as A\n&gt;&gt;&gt; transform = A.Compose([\n&gt;&gt;&gt;     A.Morphological(scale=(2, 3), operation='dilation', p=0.5)\n&gt;&gt;&gt; ])\n&gt;&gt;&gt; image = transform(image=image)[\"image\"]\n</code></pre> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Morphological(DualTransform):\n    \"\"\"Apply a morphological operation (dilation or erosion) to an image,\n    with particular value for enhancing document scans.\n\n    Morphological operations modify the structure of the image.\n    Dilation expands the white (foreground) regions in a binary or grayscale image, while erosion shrinks them.\n    These operations are beneficial in document processing, for example:\n    - Dilation helps in closing up gaps within text or making thin lines thicker,\n        enhancing legibility for OCR (Optical Character Recognition).\n    - Erosion can remove small white noise and detach connected objects,\n        making the structure of larger objects more pronounced.\n\n    Args:\n        scale (int or tuple/list of int): Specifies the size of the structuring element (kernel) used for the operation.\n            - If an integer is provided, a square kernel of that size will be used.\n            - If a tuple or list is provided, it should contain two integers representing the minimum\n                and maximum sizes for the dilation kernel.\n        operation (str, optional): The morphological operation to apply. Options are 'dilation' or 'erosion'.\n            Default is 'dilation'.\n        always_apply (bool, optional): Whether to always apply this transformation. Default is False.\n        p (float, optional): The probability of applying this transformation. Default is 0.5.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://github.com/facebookresearch/nougat\n\n    Example:\n        &gt;&gt;&gt; import albumentations as A\n        &gt;&gt;&gt; transform = A.Compose([\n        &gt;&gt;&gt;     A.Morphological(scale=(2, 3), operation='dilation', p=0.5)\n        &gt;&gt;&gt; ])\n        &gt;&gt;&gt; image = transform(image=image)[\"image\"]\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: OnePlusIntRangeType = (2, 3)\n        operation: MorphologyMode = \"dilation\"\n\n    def __init__(\n        self,\n        scale: ScaleIntType = (2, 3),\n        operation: MorphologyMode = \"dilation\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.scale = cast(Tuple[int, int], scale)\n        self.operation = operation\n\n    def apply(self, img: np.ndarray, kernel: Tuple[int, int], **params: Any) -&gt; np.ndarray:\n        return F.morphology(img, kernel, self.operation)\n\n    def apply_to_mask(self, mask: np.ndarray, kernel: Tuple[int, int], **params: Any) -&gt; np.ndarray:\n        return F.morphology(mask, kernel, self.operation)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"kernel\": cv2.getStructuringElement(cv2.MORPH_ELLIPSE, self.scale),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"scale\", \"operation\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.MultiplicativeNoise","title":"<code>class  MultiplicativeNoise</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Multiply image to random number or array of numbers.</p> <p>Parameters:</p> Name Type Description <code>multiplier</code> <p>If single float image will be multiplied to this number. If tuple of float multiplier will be in range <code>[multiplier[0], multiplier[1])</code>. Default: (0.9, 1.1).</p> <code>per_channel</code> <p>If <code>False</code>, same values for all channels will be used. If <code>True</code> use sample values for each channels. Default False.</p> <code>elementwise</code> <p>If <code>False</code> multiply multiply all pixels in an image with a random value sampled once. If <code>True</code> Multiply image pixels with values that are pixelwise randomly sampled. Default: False.</p> <p>Targets</p> <p>image</p> <p>Image types:     Any</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class MultiplicativeNoise(ImageOnlyTransform):\n    \"\"\"Multiply image to random number or array of numbers.\n\n    Args:\n        multiplier: If single float image will be multiplied to this number.\n            If tuple of float multiplier will be in range `[multiplier[0], multiplier[1])`. Default: (0.9, 1.1).\n        per_channel: If `False`, same values for all channels will be used.\n            If `True` use sample values for each channels. Default False.\n        elementwise: If `False` multiply multiply all pixels in an image with a random value sampled once.\n            If `True` Multiply image pixels with values that are pixelwise randomly sampled. Default: False.\n\n    Targets:\n        image\n\n    Image types:\n        Any\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        multiplier: NonNegativeFloatRangeType = (0.9, 1.1)\n        per_channel: bool = Field(default=False, description=\"Apply multiplier per channel.\")\n        elementwise: bool = Field(default=False, description=\"Apply multiplier element-wise to pixels.\")\n\n    def __init__(\n        self,\n        multiplier: ScaleFloatType = (0.9, 1.1),\n        per_channel: bool = False,\n        elementwise: bool = False,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.multiplier = cast(Tuple[float, float], multiplier)\n        self.per_channel = per_channel\n        self.elementwise = elementwise\n\n    def apply(self, img: np.ndarray, multiplier: float = np.array([1]), **kwargs: Any) -&gt; np.ndarray:\n        return F.multiply(img, multiplier)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        if self.multiplier[0] == self.multiplier[1]:\n            return {\"multiplier\": np.array([self.multiplier[0]])}\n\n        img = params[\"image\"]\n\n        height, width = img.shape[:2]\n\n        num_channels = (1 if is_grayscale_image(img) else img.shape[-1]) if self.per_channel else 1\n\n        shape = [height, width, num_channels] if self.elementwise else [num_channels]\n\n        multiplier = random_utils.uniform(self.multiplier[0], self.multiplier[1], tuple(shape))\n        if is_grayscale_image(img) and img.ndim == GRAYSCALE_SHAPE_LEN:\n            multiplier = np.squeeze(multiplier)\n\n        return {\"multiplier\": multiplier}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return \"multiplier\", \"per_channel\", \"elementwise\"\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Normalize","title":"<code>class  Normalize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Applies various normalization techniques to an image. The specific normalization technique can be selected     with the <code>normalization</code> parameter.</p> <p>Standard normalization is applied using the formula:     <code>img = (img - mean * max_pixel_value) / (std * max_pixel_value)</code>.     Other normalization techniques adjust the image based on global or per-channel statistics,     or scale pixel values to a specified range.</p> <p>Parameters:</p> Name Type Description <code>mean</code> <code>Optional[ColorType]</code> <p>Mean values for standard normalization. For \"standard\" normalization, the default values are ImageNet mean values: (0.485, 0.456, 0.406). For \"inception\" normalization, use mean values of (0.5, 0.5, 0.5).</p> <code>std</code> <code>Optional[ColorType]</code> <p>Standard deviation values for standard normalization. For \"standard\" normalization, the default values are ImageNet standard deviation :(0.229, 0.224, 0.225). For \"inception\" normalization, use standard deviation values of (0.5, 0.5, 0.5).</p> <code>max_pixel_value</code> <code>Optional[float]</code> <p>Maximum possible pixel value, used for scaling in standard normalization. Defaults to 255.0.</p> <code>normalization</code> <code>Literal[\"standard\", \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\", \"inception\"]) Specifies the normalization technique to apply. Defaults to \"standard\". - \"standard\"</code> <p>Applies the formula <code>(img - mean * max_pixel_value) / (std * max_pixel_value)</code>.     The default mean and std are based on ImageNet. - \"image\": Normalizes the whole image based on its global mean and standard deviation. - \"image_per_channel\": Normalizes the image per channel based on each channel's mean and standard deviation. - \"min_max\": Scales the image pixel values to a [0, 1] range based on the global     minimum and maximum pixel values. - \"min_max_per_channel\": Scales each channel of the image pixel values to a [0, 1]     range based on the per-channel minimum and maximum pixel values. - \"inception\": Applies normalization suitable for Inception models     with mean and std values of (0.5, 0.5, 0.5) respectively.</p> <code>p</code> <code>float</code> <p>Probability of applying the transform. Defaults to 1.0.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Note</p> <p>For \"standard\" normalization, <code>mean</code>, <code>std</code>, and <code>max_pixel_value</code> must be provided. For \"inception\" normalization, the specific mean and std values should be used. For other normalization types, these parameters are ignored.</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Normalize(ImageOnlyTransform):\n    \"\"\"Applies various normalization techniques to an image. The specific normalization technique can be selected\n        with the `normalization` parameter.\n\n    Standard normalization is applied using the formula:\n        `img = (img - mean * max_pixel_value) / (std * max_pixel_value)`.\n        Other normalization techniques adjust the image based on global or per-channel statistics,\n        or scale pixel values to a specified range.\n\n    Args:\n        mean (Optional[ColorType]): Mean values for standard normalization.\n            For \"standard\" normalization, the default values are ImageNet mean values: (0.485, 0.456, 0.406).\n            For \"inception\" normalization, use mean values of (0.5, 0.5, 0.5).\n        std (Optional[ColorType]): Standard deviation values for standard normalization.\n            For \"standard\" normalization, the default values are ImageNet standard deviation :(0.229, 0.224, 0.225).\n            For \"inception\" normalization, use standard deviation values of (0.5, 0.5, 0.5).\n        max_pixel_value (Optional[float]): Maximum possible pixel value, used for scaling in standard normalization.\n            Defaults to 255.0.\n        normalization (Literal[\"standard\", \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\", \"inception\"])\n            Specifies the normalization technique to apply. Defaults to \"standard\".\n            - \"standard\": Applies the formula `(img - mean * max_pixel_value) / (std * max_pixel_value)`.\n                The default mean and std are based on ImageNet.\n            - \"image\": Normalizes the whole image based on its global mean and standard deviation.\n            - \"image_per_channel\": Normalizes the image per channel based on each channel's mean and standard deviation.\n            - \"min_max\": Scales the image pixel values to a [0, 1] range based on the global\n                minimum and maximum pixel values.\n            - \"min_max_per_channel\": Scales each channel of the image pixel values to a [0, 1]\n                range based on the per-channel minimum and maximum pixel values.\n            - \"inception\": Applies normalization suitable for Inception models\n                with mean and std values of (0.5, 0.5, 0.5) respectively.\n\n        p (float): Probability of applying the transform. Defaults to 1.0.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Note:\n        For \"standard\" normalization, `mean`, `std`, and `max_pixel_value` must be provided.\n        For \"inception\" normalization, the specific mean and std values should be used.\n        For other normalization types, these parameters are ignored.\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        mean: Optional[ColorType] = Field(\n            default=(0.485, 0.456, 0.406),\n            description=\"Mean values for normalization, defaulting to ImageNet mean values.\",\n        )\n        std: Optional[ColorType] = Field(\n            default=(0.229, 0.224, 0.225),\n            description=\"Standard deviation values for normalization, defaulting to ImageNet std values.\",\n        )\n        max_pixel_value: Optional[float] = Field(default=255.0, description=\"Maximum possible pixel value.\")\n        normalization: Literal[\n            \"standard\", \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\", \"inception\"\n        ] = \"standard\"\n        p: ProbabilityType = 1\n\n        @model_validator(mode=\"after\")\n        def validate_normalization(self) -&gt; Self:\n            if (\n                self.mean is None\n                or self.std is None\n                or self.max_pixel_value is None\n                and self.normalization == \"standard\"\n            ):\n                raise ValueError(\"mean, std, and max_pixel_value must be provided for standard normalization.\")\n            return self\n\n    def __init__(\n        self,\n        mean: Optional[ColorType] = (0.485, 0.456, 0.406),\n        std: Optional[ColorType] = (0.229, 0.224, 0.225),\n        max_pixel_value: Optional[float] = 255.0,\n        normalization: Literal[\"standard\", \"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\"] = \"standard\",\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.mean = mean\n        self.std = std\n        self.max_pixel_value = max_pixel_value\n        self.normalization = normalization\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if self.normalization == \"standard\":\n            return F.normalize(\n                img, cast(ColorType, self.mean), cast(ColorType, self.std), cast(float, self.max_pixel_value)\n            )\n        if self.normalization in {\"image\", \"image_per_channel\", \"min_max\", \"min_max_per_channel\"}:\n            return F.normalize_per_image(img, self.normalization)\n        raise ValueError(f\"Unknown normalization type: {self.normalization}\")\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"mean\", \"std\", \"max_pixel_value\", \"normalization\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.PixelDropout","title":"<code>class  PixelDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Set pixels to 0 with some probability.</p> <p>Parameters:</p> Name Type Description <code>dropout_prob</code> <code>float</code> <p>pixel drop probability. Default: 0.01</p> <code>per_channel</code> <code>bool</code> <p>if set to <code>True</code> drop mask will be sampled for each channel, otherwise the same mask will be sampled for all channels. Default: False</p> <code>drop_value</code> <code>number or sequence of numbers or None</code> <p>Value that will be set in dropped place. If set to None value will be sampled randomly, default ranges will be used:     - uint8 - [0, 255]     - uint16 - [0, 65535]     - uint32 - [0, 4294967295]     - float, double - [0, 1] Default: 0</p> <code>mask_drop_value</code> <code>number or sequence of numbers or None</code> <p>Value that will be set in dropped place in masks. If set to None masks will be unchanged. Default: 0</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask</p> <p>Image types:     any</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class PixelDropout(DualTransform):\n    \"\"\"Set pixels to 0 with some probability.\n\n    Args:\n        dropout_prob (float): pixel drop probability. Default: 0.01\n        per_channel (bool): if set to `True` drop mask will be sampled for each channel,\n            otherwise the same mask will be sampled for all channels. Default: False\n        drop_value (number or sequence of numbers or None): Value that will be set in dropped place.\n            If set to None value will be sampled randomly, default ranges will be used:\n                - uint8 - [0, 255]\n                - uint16 - [0, 65535]\n                - uint32 - [0, 4294967295]\n                - float, double - [0, 1]\n            Default: 0\n        mask_drop_value (number or sequence of numbers or None): Value that will be set in dropped place in masks.\n            If set to None masks will be unchanged. Default: 0\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask\n    Image types:\n        any\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        dropout_prob: ProbabilityType = 0.01\n        per_channel: bool = Field(default=False, description=\"Sample drop mask per channel.\")\n        drop_value: Optional[ScaleFloatType] = Field(\n            default=0, description=\"Value to set in dropped pixels. None for random sampling.\"\n        )\n        mask_drop_value: Optional[ScaleFloatType] = Field(\n            default=None, description=\"Value to set in dropped pixels in masks. None to leave masks unchanged.\"\n        )\n\n        @model_validator(mode=\"after\")\n        def validate_mask_drop_value(self) -&gt; Self:\n            if self.mask_drop_value is not None and self.per_channel:\n                msg = \"PixelDropout supports mask only with per_channel=False.\"\n                raise ValueError(msg)\n            return self\n\n    _targets = (Targets.IMAGE, Targets.MASK)\n\n    def __init__(\n        self,\n        dropout_prob: float = 0.01,\n        per_channel: bool = False,\n        drop_value: Optional[ScaleFloatType] = 0,\n        mask_drop_value: Optional[ScaleFloatType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.dropout_prob = dropout_prob\n        self.per_channel = per_channel\n        self.drop_value = drop_value\n        self.mask_drop_value = mask_drop_value\n\n    def apply(\n        self,\n        img: np.ndarray,\n        drop_mask: Optional[np.ndarray] = None,\n        drop_value: Union[float, Sequence[float]] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.pixel_dropout(img, drop_mask, drop_value)\n\n    def apply_to_mask(self, mask: np.ndarray, drop_mask: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        if self.mask_drop_value is None:\n            return mask\n\n        if mask.ndim == GRAYSCALE_SHAPE_LEN:\n            drop_mask = np.squeeze(drop_mask)\n\n        return F.pixel_dropout(mask, drop_mask, self.mask_drop_value)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return bbox\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return keypoint\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        shape = img.shape if self.per_channel else img.shape[:2]\n\n        rnd = np.random.RandomState(random.randint(0, 1 &lt;&lt; 31))\n        # Use choice to create boolean matrix, if we will use binomial after that we will need type conversion\n        drop_mask = rnd.choice([True, False], shape, p=[self.dropout_prob, 1 - self.dropout_prob])\n\n        drop_value: Union[float, Sequence[float], np.ndarray]\n        if drop_mask.ndim != img.ndim:\n            drop_mask = np.expand_dims(drop_mask, -1)\n        if self.drop_value is None:\n            drop_shape = 1 if is_grayscale_image(img) else int(img.shape[-1])\n\n            if img.dtype in (np.uint8, np.uint16, np.uint32):\n                drop_value = rnd.randint(0, int(F.MAX_VALUES_BY_DTYPE[img.dtype]), drop_shape, img.dtype)\n            elif img.dtype in [np.float32, np.double]:\n                drop_value = rnd.uniform(0, 1, drop_shape).astype(img.dtype)\n            else:\n                raise ValueError(f\"Unsupported dtype: {img.dtype}\")\n        else:\n            drop_value = self.drop_value\n\n        return {\"drop_mask\": drop_mask, \"drop_value\": drop_value}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"dropout_prob\", \"per_channel\", \"drop_value\", \"mask_drop_value\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Posterize","title":"<code>class  Posterize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Reduce the number of bits for each color channel.</p> <p>Parameters:</p> Name Type Description <code>num_bits</code> <code>int, int) or int,       or list of ints [r, g, b],       or list of ints [[r1, r1], [g1, g2], [b1, b2]]</code> <p>number of high bits. If num_bits is a single value, the range will be [num_bits, num_bits]. Must be in range [0, 8]. Default: 4.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets: image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Posterize(ImageOnlyTransform):\n    \"\"\"Reduce the number of bits for each color channel.\n\n    Args:\n        num_bits ((int, int) or int,\n                  or list of ints [r, g, b],\n                  or list of ints [[r1, r1], [g1, g2], [b1, b2]]): number of high bits.\n            If num_bits is a single value, the range will be [num_bits, num_bits].\n            Must be in range [0, 8]. Default: 4.\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n    image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        num_bits: Annotated[\n            Union[int, Tuple[int, int], Tuple[int, int, int]], Field(default=4, description=\"Number of high bits\")\n        ]\n\n        @field_validator(\"num_bits\")\n        @classmethod\n        def validate_num_bits(cls, num_bits: Any) -&gt; Union[Tuple[int, int], List[Tuple[int, int]]]:\n            if isinstance(num_bits, int):\n                return cast(Tuple[int, int], to_tuple(num_bits, num_bits))\n            if isinstance(num_bits, Sequence) and len(num_bits) == NUM_BITS_ARRAY_LENGTH:\n                return [cast(Tuple[int, int], to_tuple(i, 0)) for i in num_bits]\n            return cast(Tuple[int, int], to_tuple(num_bits, 0))\n\n    def __init__(\n        self,\n        num_bits: Union[int, Tuple[int, int], Tuple[int, int, int]] = 4,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.num_bits = cast(Union[Tuple[int, ...], List[Tuple[int, ...]]], num_bits)\n\n    def apply(self, img: np.ndarray, num_bits: int = 1, **params: Any) -&gt; np.ndarray:\n        return F.posterize(img, num_bits)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        if len(self.num_bits) == NUM_BITS_ARRAY_LENGTH:\n            return {\"num_bits\": [random.randint(int(i[0]), int(i[1])) for i in self.num_bits]}  # type: ignore[index]\n        num_bits = self.num_bits\n        return {\"num_bits\": random.randint(int(num_bits[0]), int(num_bits[1]))}  # type: ignore[arg-type]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"num_bits\",)\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RGBShift","title":"<code>class  RGBShift</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly shift values for each channel of the input RGB image.</p> <p>Parameters:</p> Name Type Description <code>r_shift_limit</code> <p>range for changing values for the red channel. If r_shift_limit is a single int, the range will be (-r_shift_limit, r_shift_limit). Default: (-20, 20).</p> <code>g_shift_limit</code> <p>range for changing values for the green channel. If g_shift_limit is a single int, the range  will be (-g_shift_limit, g_shift_limit). Default: (-20, 20).</p> <code>b_shift_limit</code> <p>range for changing values for the blue channel. If b_shift_limit is a single int, the range will be (-b_shift_limit, b_shift_limit). Default: (-20, 20).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RGBShift(ImageOnlyTransform):\n    \"\"\"Randomly shift values for each channel of the input RGB image.\n\n    Args:\n        r_shift_limit: range for changing values for the red channel. If r_shift_limit is a single\n            int, the range will be (-r_shift_limit, r_shift_limit). Default: (-20, 20).\n        g_shift_limit: range for changing values for the green channel. If g_shift_limit is a\n            single int, the range  will be (-g_shift_limit, g_shift_limit). Default: (-20, 20).\n        b_shift_limit: range for changing values for the blue channel. If b_shift_limit is a single\n            int, the range will be (-b_shift_limit, b_shift_limit). Default: (-20, 20).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        r_shift_limit: SymmetricRangeType = (-20, 20)\n        g_shift_limit: SymmetricRangeType = (-20, 20)\n        b_shift_limit: SymmetricRangeType = (-20, 20)\n\n    def __init__(\n        self,\n        r_shift_limit: ScaleIntType = (-20, 20),\n        g_shift_limit: ScaleIntType = (-20, 20),\n        b_shift_limit: ScaleIntType = (-20, 20),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.r_shift_limit = cast(Tuple[float, float], r_shift_limit)\n        self.g_shift_limit = cast(Tuple[float, float], g_shift_limit)\n        self.b_shift_limit = cast(Tuple[float, float], b_shift_limit)\n\n    def apply(self, img: np.ndarray, r_shift: int = 0, g_shift: int = 0, b_shift: int = 0, **params: Any) -&gt; np.ndarray:\n        if not is_rgb_image(img):\n            msg = \"RGBShift transformation expects 3-channel images.\"\n            raise TypeError(msg)\n        return F.shift_rgb(img, r_shift, g_shift, b_shift)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"r_shift\": random.uniform(self.r_shift_limit[0], self.r_shift_limit[1]),\n            \"g_shift\": random.uniform(self.g_shift_limit[0], self.g_shift_limit[1]),\n            \"b_shift\": random.uniform(self.b_shift_limit[0], self.b_shift_limit[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"r_shift_limit\", \"g_shift_limit\", \"b_shift_limit\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomBrightnessContrast","title":"<code>class  RandomBrightnessContrast</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly change brightness and contrast of the input image.</p> <p>Parameters:</p> Name Type Description <code>brightness_limit</code> <p>factor range for changing brightness. If limit is a single float, the range will be (-limit, limit). Default: (-0.2, 0.2).</p> <code>contrast_limit</code> <p>factor range for changing contrast. If limit is a single float, the range will be (-limit, limit). Default: (-0.2, 0.2).</p> <code>brightness_by_max</code> <p>If True adjust contrast by image dtype maximum, else adjust contrast by image mean.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomBrightnessContrast(ImageOnlyTransform):\n    \"\"\"Randomly change brightness and contrast of the input image.\n\n    Args:\n        brightness_limit: factor range for changing brightness.\n            If limit is a single float, the range will be (-limit, limit). Default: (-0.2, 0.2).\n        contrast_limit: factor range for changing contrast.\n            If limit is a single float, the range will be (-limit, limit). Default: (-0.2, 0.2).\n        brightness_by_max: If True adjust contrast by image dtype maximum,\n            else adjust contrast by image mean.\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        brightness_limit: SymmetricRangeType = (-0.2, 0.2)\n        contrast_limit: SymmetricRangeType = (-0.2, 0.2)\n        brightness_by_max: bool = Field(default=True, description=\"Adjust brightness by image dtype maximum if True.\")\n\n    def __init__(\n        self,\n        brightness_limit: ScaleFloatType = (-0.2, 0.2),\n        contrast_limit: ScaleFloatType = (-0.2, 0.2),\n        brightness_by_max: bool = True,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.brightness_limit = cast(Tuple[float, float], brightness_limit)\n        self.contrast_limit = cast(Tuple[float, float], contrast_limit)\n        self.brightness_by_max = brightness_by_max\n\n    def apply(self, img: np.ndarray, alpha: float = 1.0, beta: float = 0.0, **params: Any) -&gt; np.ndarray:\n        return F.brightness_contrast_adjust(img, alpha, beta, self.brightness_by_max)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"alpha\": 1.0 + random.uniform(self.contrast_limit[0], self.contrast_limit[1]),\n            \"beta\": 0.0 + random.uniform(self.brightness_limit[0], self.brightness_limit[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"brightness_limit\", \"contrast_limit\", \"brightness_by_max\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomFog","title":"<code>class  RandomFog</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Simulates fog for the image</p> <p>Parameters:</p> Name Type Description <code>fog_coef_lower</code> <p>lower limit for fog intensity coefficient. Should be in [0, 1] range.</p> <code>fog_coef_upper</code> <p>upper limit for fog intensity coefficient. Should be in [0, 1] range.</p> <code>alpha_coef</code> <p>transparency of the fog circles. Should be in [0, 1] range.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomFog(ImageOnlyTransform):\n    \"\"\"Simulates fog for the image\n\n    Args:\n        fog_coef_lower: lower limit for fog intensity coefficient. Should be in [0, 1] range.\n        fog_coef_upper: upper limit for fog intensity coefficient. Should be in [0, 1] range.\n        alpha_coef: transparency of the fog circles. Should be in [0, 1] range.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        fog_coef_lower: float = Field(default=0.3, description=\"Lower limit for fog intensity coefficient\", ge=0, le=1)\n        fog_coef_upper: float = Field(default=1, description=\"Upper limit for fog intensity coefficient\", ge=0, le=1)\n        alpha_coef: float = Field(default=0.08, description=\"Transparency of the fog circles\", ge=0, le=1)\n\n        @model_validator(mode=\"after\")\n        def validate_fog_coefficients(self) -&gt; Self:\n            if self.fog_coef_lower &gt; self.fog_coef_upper:\n                msg = \"fog_coef_upper must be greater than or equal to fog_coef_lower.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        fog_coef_lower: float = 0.3,\n        fog_coef_upper: float = 1,\n        alpha_coef: float = 0.08,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.fog_coef_lower = fog_coef_lower\n        self.fog_coef_upper = fog_coef_upper\n        self.alpha_coef = alpha_coef\n\n    def apply(\n        self,\n        img: np.ndarray,\n        fog_coef: np.ndarray = 0.1,\n        haze_list: Optional[List[Tuple[int, int]]] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if haze_list is None:\n            haze_list = []\n        return F.add_fog(img, fog_coef, self.alpha_coef, haze_list)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        fog_coef = random.uniform(self.fog_coef_lower, self.fog_coef_upper)\n\n        height, width = imshape = img.shape[:2]\n\n        hw = max(1, int(width // 3 * fog_coef))\n\n        haze_list = []\n        midx = width // 2 - 2 * hw\n        midy = height // 2 - hw\n        index = 1\n\n        while midx &gt; -hw or midy &gt; -hw:\n            for _ in range(hw // 10 * index):\n                x = random_utils.randint(midx, width - midx - hw + 1)\n                y = random_utils.randint(midy, height - midy - hw + 1)\n                haze_list.append((x, y))\n\n            midx -= 3 * hw * width // sum(imshape)\n            midy -= 3 * hw * height // sum(imshape)\n            index += 1\n\n        return {\"haze_list\": haze_list, \"fog_coef\": fog_coef}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"fog_coef_lower\", \"fog_coef_upper\", \"alpha_coef\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomGamma","title":"<code>class  RandomGamma</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Applies random gamma correction to an image as a form of data augmentation.</p> <p>This class adjusts the luminance of an image by applying gamma correction with a randomly selected gamma value from a specified range. Gamma correction can simulate various lighting conditions, potentially enhancing model generalization.</p> <p>Attributes:</p> Name Type Description <code>gamma_limit</code> <code>Union[int, Tuple[int, int]]</code> <p>The range for gamma adjustment. If <code>gamma_limit</code> is a single int, the range will be interpreted as (-gamma_limit, gamma_limit), defining how much to adjust the image's gamma. Default is (80, 120).</p> <code>always_apply</code> <code>bool</code> <p>If <code>True</code>, the transform will always be applied, regardless of <code>p</code>. Default is <code>False</code>.</p> <code>p</code> <code>float</code> <p>The probability that the transform will be applied. Default is 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://en.wikipedia.org/wiki/Gamma_correction</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomGamma(ImageOnlyTransform):\n    \"\"\"Applies random gamma correction to an image as a form of data augmentation.\n\n    This class adjusts the luminance of an image by applying gamma correction with a randomly\n    selected gamma value from a specified range. Gamma correction can simulate various lighting\n    conditions, potentially enhancing model generalization.\n\n    Attributes:\n        gamma_limit (Union[int, Tuple[int, int]]): The range for gamma adjustment. If `gamma_limit` is a single\n            int, the range will be interpreted as (-gamma_limit, gamma_limit), defining how much\n            to adjust the image's gamma. Default is (80, 120).\n        always_apply (bool): If `True`, the transform will always be applied, regardless of `p`.\n            Default is `False`.\n        p (float): The probability that the transform will be applied. Default is 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n         https://en.wikipedia.org/wiki/Gamma_correction\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        gamma_limit: OnePlusFloatRangeType = (80, 120)\n\n    def __init__(\n        self,\n        gamma_limit: ScaleIntType = (80, 120),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.gamma_limit = cast(Tuple[float, float], gamma_limit)\n\n    def apply(self, img: np.ndarray, gamma: float = 1, **params: Any) -&gt; np.ndarray:\n        return F.gamma_transform(img, gamma=gamma)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"gamma\": random.uniform(self.gamma_limit[0], self.gamma_limit[1]) / 100.0}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"gamma_limit\",)\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomGravel","title":"<code>class  RandomGravel</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Add gravels.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>gravel_roi</code> <p>(top-left x, top-left y, bottom-right x, bottom right y). Should be in [0, 1] range</p> <code>number_of_patches</code> <p>no. of gravel patches required</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomGravel(ImageOnlyTransform):\n    \"\"\"Add gravels.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        gravel_roi: (top-left x, top-left y,\n            bottom-right x, bottom right y). Should be in [0, 1] range\n        number_of_patches: no. of gravel patches required\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        gravel_roi: Tuple[float, float, float, float] = Field(\n            default=(0.1, 0.4, 0.9, 0.9), description=\"Region of interest for gravel placement\"\n        )\n        number_of_patches: int = Field(default=2, description=\"Number of gravel patches\", ge=1)\n\n        @model_validator(mode=\"after\")\n        def validate_gravel_roi(self) -&gt; Self:\n            gravel_lower_x, gravel_lower_y, gravel_upper_x, gravel_upper_y = self.gravel_roi\n            if not 0 &lt;= gravel_lower_x &lt; gravel_upper_x &lt;= 1 or not 0 &lt;= gravel_lower_y &lt; gravel_upper_y &lt;= 1:\n                raise ValueError(f\"Invalid gravel_roi. Got: {self.gravel_roi}.\")\n            return self\n\n    def __init__(\n        self,\n        gravel_roi: Tuple[float, float, float, float] = (0.1, 0.4, 0.9, 0.9),\n        number_of_patches: int = 2,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.gravel_roi = gravel_roi\n        self.number_of_patches = number_of_patches\n\n    def generate_gravel_patch(self, rectangular_roi: Tuple[int, int, int, int]) -&gt; np.ndarray:\n        x1, y1, x2, y2 = rectangular_roi\n        area = abs((x2 - x1) * (y2 - y1))\n        count = area // 10\n        gravels = np.empty([count, 2], dtype=np.int64)\n        gravels[:, 0] = random_utils.randint(x1, x2, count)\n        gravels[:, 1] = random_utils.randint(y1, y2, count)\n        return gravels\n\n    def apply(self, img: np.ndarray, gravels_infos: Optional[List[Any]] = None, **params: Any) -&gt; np.ndarray:\n        if gravels_infos is None:\n            gravels_infos = []\n        return F.add_gravel(img, gravels_infos)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, np.ndarray]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        x_min, y_min, x_max, y_max = self.gravel_roi\n        x_min = int(x_min * width)\n        x_max = int(x_max * width)\n        y_min = int(y_min * height)\n        y_max = int(y_max * height)\n\n        max_height = 200\n        max_width = 30\n\n        rectangular_rois = np.zeros([self.number_of_patches, 4], dtype=np.int64)\n        xx1 = random_utils.randint(x_min + 1, x_max, self.number_of_patches)  # xmax\n        xx2 = random_utils.randint(x_min, xx1)  # xmin\n        yy1 = random_utils.randint(y_min + 1, y_max, self.number_of_patches)  # ymax\n        yy2 = random_utils.randint(y_min, yy1)  # ymin\n\n        rectangular_rois[:, 0] = xx2\n        rectangular_rois[:, 1] = yy2\n        rectangular_rois[:, 2] = [min(tup) for tup in zip(xx1, xx2 + max_height)]\n        rectangular_rois[:, 3] = [min(tup) for tup in zip(yy1, yy2 + max_width)]\n\n        minx = []\n        maxx = []\n        miny = []\n        maxy = []\n        val = []\n        for roi in rectangular_rois:\n            gravels = self.generate_gravel_patch(roi)\n            x = gravels[:, 0]\n            y = gravels[:, 1]\n            r = random_utils.randint(1, 4, len(gravels))\n            sat = random_utils.randint(0, 255, len(gravels))\n            miny.append(np.maximum(y - r, 0))\n            maxy.append(np.minimum(y + r, y))\n            minx.append(np.maximum(x - r, 0))\n            maxx.append(np.minimum(x + r, x))\n            val.append(sat)\n\n        return {\n            \"gravels_infos\": np.stack(\n                [\n                    np.concatenate(miny),\n                    np.concatenate(maxy),\n                    np.concatenate(minx),\n                    np.concatenate(maxx),\n                    np.concatenate(val),\n                ],\n                1,\n            )\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return \"gravel_roi\", \"number_of_patches\"\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomGridShuffle","title":"<code>class  RandomGridShuffle</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Random shuffle grid's cells on image.</p> <p>Parameters:</p> Name Type Description <code>grid</code> <code>int, int</code> <p>size of grid for splitting image.</p> <p>Targets</p> <p>image, mask, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomGridShuffle(DualTransform):\n    \"\"\"Random shuffle grid's cells on image.\n\n    Args:\n        grid ((int, int)): size of grid for splitting image.\n\n    Targets:\n        image, mask, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        grid: OnePlusIntRangeType = (3, 3)\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS)\n\n    def __init__(self, grid: Tuple[int, int] = (3, 3), always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply=always_apply, p=p)\n        self.grid = grid\n\n    def apply(self, img: np.ndarray, tiles: np.ndarray, mapping: List[int], **params: Any) -&gt; np.ndarray:\n        return F.swap_tiles_on_image(img, tiles, mapping)\n\n    def apply_to_mask(self, mask: np.ndarray, tiles: np.ndarray, mapping: List[int], **params: Any) -&gt; np.ndarray:\n        return F.swap_tiles_on_image(mask, tiles, mapping)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        tiles: np.ndarray,\n        mapping: List[int],\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        x, y = keypoint[:2]\n\n        # Find which original tile the keypoint belongs to\n        for original_index, new_index in enumerate(mapping):\n            start_y, start_x, end_y, end_x = tiles[original_index]\n            # check if the keypoint is in this tile\n            if start_y &lt;= y &lt; end_y and start_x &lt;= x &lt; end_x:\n                # Get the new tile's coordinates\n                new_start_y, new_start_x = tiles[new_index][:2]\n\n                # Map the keypoint to the new tile's position\n                new_x = (x - start_x) + new_start_x\n                new_y = (y - start_y) + new_start_y\n\n                return (new_x, new_y, *keypoint[2:])\n\n        # If the keypoint wasn't in any tile (shouldn't happen), log a warning for debugging purposes\n        warn(\n            \"Keypoint not in any tile, returning it unchanged. This is unexpected and should be investigated.\",\n            RuntimeWarning,\n        )\n        return keypoint\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, weight = params[\"image\"].shape[:2]\n        # check if image size is divisible by grid\n        # if not, warn and return empty dict -&gt; no changes will be applied\n        if height % self.grid[0] != 0 or weight % self.grid[1] != 0:\n            warn(\"Image size must be divisible by grid size\")\n            return {\"tiles\": np.array([]), \"mapping\": []}\n        # Generate the original grid\n        original_tiles = F.split_uniform_grid((height, weight), self.grid)\n        # Shuffle order of tiles\n        mapping = random_utils.shuffle(list(range(len(original_tiles))))\n        return {\"tiles\": original_tiles, \"mapping\": mapping}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"grid\",)\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomRain","title":"<code>class  RandomRain</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Adds rain effects.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>slant_lower</code> <p>should be in range [-20, 20].</p> <code>slant_upper</code> <p>should be in range [-20, 20].</p> <code>drop_length</code> <p>should be in range [0, 100].</p> <code>drop_width</code> <p>should be in range [1, 5].</p> <code>drop_color</code> <code>list of (r, g, b</code> <p>rain lines color.</p> <code>blur_value</code> <code>int</code> <p>rainy view are blurry</p> <code>brightness_coefficient</code> <code>float</code> <p>rainy days are usually shady. Should be in range [0, 1].</p> <code>rain_type</code> <p>One of [None, \"drizzle\", \"heavy\", \"torrential\"]</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomRain(ImageOnlyTransform):\n    \"\"\"Adds rain effects.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        slant_lower: should be in range [-20, 20].\n        slant_upper: should be in range [-20, 20].\n        drop_length: should be in range [0, 100].\n        drop_width: should be in range [1, 5].\n        drop_color (list of (r, g, b)): rain lines color.\n        blur_value (int): rainy view are blurry\n        brightness_coefficient (float): rainy days are usually shady. Should be in range [0, 1].\n        rain_type: One of [None, \"drizzle\", \"heavy\", \"torrential\"]\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        slant_lower: int = Field(default=-10, description=\"Lower bound for rain slant angle\", ge=-20, le=20)\n        slant_upper: int = Field(default=10, description=\"Upper bound for rain slant angle\", ge=-20, le=20)\n        drop_length: int = Field(default=20, description=\"Length of raindrops\", ge=0, le=100)\n        drop_width: int = Field(default=1, description=\"Width of raindrops\", ge=1, le=5)\n        drop_color: Tuple[int, int, int] = Field(default=(200, 200, 200), description=\"Color of raindrops\")\n        blur_value: int = Field(default=7, description=\"Blur value for simulating rain effect\", ge=0)\n        brightness_coefficient: float = Field(\n            default=0.7, description=\"Brightness coefficient for rainy effect\", ge=0, le=1\n        )\n        rain_type: Optional[RainMode] = Field(default=None, description=\"Type of rain to simulate\")\n\n        @model_validator(mode=\"after\")\n        def validate_slant_range_and_rain_type(self) -&gt; Self:\n            if self.slant_lower &gt;= self.slant_upper:\n                msg = \"slant_upper must be greater than or equal to slant_lower.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        slant_lower: int = -10,\n        slant_upper: int = 10,\n        drop_length: int = 20,\n        drop_width: int = 1,\n        drop_color: Tuple[int, int, int] = (200, 200, 200),\n        blur_value: int = 7,\n        brightness_coefficient: float = 0.7,\n        rain_type: Optional[RainMode] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.slant_lower = slant_lower\n        self.slant_upper = slant_upper\n        self.drop_length = drop_length\n        self.drop_width = drop_width\n        self.drop_color = drop_color\n        self.blur_value = blur_value\n        self.brightness_coefficient = brightness_coefficient\n        self.rain_type = rain_type\n\n    def apply(\n        self,\n        img: np.ndarray,\n        slant: int = 10,\n        drop_length: int = 20,\n        rain_drops: Optional[List[Tuple[int, int]]] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if rain_drops is None:\n            rain_drops = []\n        return F.add_rain(\n            img,\n            slant,\n            drop_length,\n            self.drop_width,\n            self.drop_color,\n            self.blur_value,\n            self.brightness_coefficient,\n            rain_drops,\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        slant = int(random.uniform(self.slant_lower, self.slant_upper))\n\n        height, width = img.shape[:2]\n        area = height * width\n\n        if self.rain_type == \"drizzle\":\n            num_drops = area // 770\n            drop_length = 10\n        elif self.rain_type == \"heavy\":\n            num_drops = width * height // 600\n            drop_length = 30\n        elif self.rain_type == \"torrential\":\n            num_drops = area // 500\n            drop_length = 60\n        else:\n            drop_length = self.drop_length\n            num_drops = area // 600\n\n        rain_drops = []\n\n        for _ in range(num_drops):  # If You want heavy rain, try increasing this\n            x = random_utils.randint(slant, width + 1) if slant &lt; 0 else random_utils.randint(0, width - slant + 1)\n\n            y = random_utils.randint(0, height - drop_length + 1)\n\n            rain_drops.append((x, y))\n\n        return {\"drop_length\": drop_length, \"slant\": slant, \"rain_drops\": rain_drops}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"slant_lower\",\n            \"slant_upper\",\n            \"drop_length\",\n            \"drop_width\",\n            \"drop_color\",\n            \"blur_value\",\n            \"brightness_coefficient\",\n            \"rain_type\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomShadow","title":"<code>class  RandomShadow</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Simulates shadows for the image</p> <p>Parameters:</p> Name Type Description <code>shadow_roi</code> <p>region of the image where shadows will appear. All values should be in range [0, 1].</p> <code>num_shadows_limit</code> <p>Lower and upper limits for the possible number of shadows.</p> <code>shadow_dimension</code> <p>number of edges in the shadow polygons</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomShadow(ImageOnlyTransform):\n    \"\"\"Simulates shadows for the image\n\n    Args:\n        shadow_roi: region of the image where shadows\n            will appear. All values should be in range [0, 1].\n        num_shadows_limit: Lower and upper limits for the possible number of shadows.\n        shadow_dimension: number of edges in the shadow polygons\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        shadow_roi: Tuple[float, float, float, float] = Field(\n            default=(0, 0.5, 1, 1), description=\"Region of the image where shadows will appear\"\n        )\n        num_shadows_limit: Tuple[int, int] = Field(default=(1, 2))\n        num_shadows_lower: Optional[int] = Field(\n            default=None, description=\"Lower limit for the possible number of shadows\"\n        )\n        num_shadows_upper: Optional[int] = Field(\n            default=None, description=\"Upper limit for the possible number of shadows\"\n        )\n        shadow_dimension: int = Field(default=5, description=\"Number of edges in the shadow polygons\", gt=0)\n\n        @model_validator(mode=\"after\")\n        def validate_shadows(self) -&gt; Self:\n            if self.num_shadows_limit[0] &gt; self.num_shadows_limit[1]:\n                msg = \"num_shadows_limit[0] must be less than or equal to num_shadows_limit[1].\"\n                raise ValueError(msg)\n\n            shadow_lower_x, shadow_lower_y, shadow_upper_x, shadow_upper_y = self.shadow_roi\n\n            if not 0 &lt;= shadow_lower_x &lt;= shadow_upper_x &lt;= 1 or not 0 &lt;= shadow_lower_y &lt;= shadow_upper_y &lt;= 1:\n                raise ValueError(f\"Invalid shadow_roi. Got: {self.shadow_roi}\")\n\n            if self.num_shadows_lower is not None or self.num_shadows_upper is not None:\n                warn(\n                    \"`num_shadows_lower` and `num_shadows_upper` are deprecated. \"\n                    \"Use `num_shadows_limit` as tuple (num_shadows_lower, num_shadows_upper) instead.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n                self.num_shadows_limit = cast(Tuple[int, int], (self.num_shadows_lower, self.num_shadows_upper))\n                self.num_shadows_lower = None\n                self.num_shadows_upper = None\n\n            return self\n\n    def __init__(\n        self,\n        shadow_roi: Tuple[float, float, float, float] = (0, 0.5, 1, 1),\n        num_shadows_limit: Tuple[int, int] = (1, 2),\n        num_shadows_lower: Optional[int] = None,\n        num_shadows_upper: Optional[int] = None,\n        shadow_dimension: int = 5,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        self.shadow_roi = shadow_roi\n        self.shadow_dimension = shadow_dimension\n        self.num_shadows_limit = num_shadows_limit\n\n    def apply(self, img: np.ndarray, vertices_list: Optional[List[np.ndarray]] = None, **params: Any) -&gt; np.ndarray:\n        if vertices_list is None:\n            vertices_list = []\n        return F.add_shadow(img, vertices_list)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, List[np.ndarray]]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        num_shadows = random_utils.randint(self.num_shadows_limit[0], self.num_shadows_limit[1] + 1)\n\n        x_min, y_min, x_max, y_max = self.shadow_roi\n\n        x_min = int(x_min * width)\n        x_max = int(x_max * width)\n        y_min = int(y_min * height)\n        y_max = int(y_max * height)\n\n        vertices_list = [\n            np.stack(\n                [\n                    random_utils.randint(x_min, x_max, size=5),\n                    random_utils.randint(y_min, y_max, size=5),\n                ],\n                axis=1,\n            )\n            for _ in range(num_shadows)\n        ]\n\n        return {\"vertices_list\": vertices_list}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"shadow_roi\",\n            \"num_shadows_limit\",\n            \"shadow_dimension\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomSnow","title":"<code>class  RandomSnow</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Bleach out some pixel values simulating snow.</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>snow_point_lower</code> <p>lower_bond of the amount of snow. Should be in [0, 1] range</p> <code>snow_point_upper</code> <p>upper_bond of the amount of snow. Should be in [0, 1] range</p> <code>brightness_coeff</code> <p>larger number will lead to a more snow on the image. Should be &gt;= 0</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomSnow(ImageOnlyTransform):\n    \"\"\"Bleach out some pixel values simulating snow.\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        snow_point_lower: lower_bond of the amount of snow. Should be in [0, 1] range\n        snow_point_upper: upper_bond of the amount of snow. Should be in [0, 1] range\n        brightness_coeff: larger number will lead to a more snow on the image. Should be &gt;= 0\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        snow_point_lower: float = Field(default=0.1, description=\"Lower bound of the amount of snow\", ge=0, le=1)\n        snow_point_upper: float = Field(default=0.3, description=\"Upper bound of the amount of snow\", ge=0, le=1)\n        brightness_coeff: float = Field(default=2.5, description=\"Brightness coefficient, must be &gt;= 0\", ge=0)\n\n        @model_validator(mode=\"after\")\n        def validate_snow_points(self) -&gt; Self:\n            if self.snow_point_lower &gt; self.snow_point_upper:\n                msg = \"snow_point_lower must be less than or equal to snow_point_upper.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        snow_point_lower: float = 0.1,\n        snow_point_upper: float = 0.3,\n        brightness_coeff: float = 2.5,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        self.snow_point_lower = snow_point_lower\n        self.snow_point_upper = snow_point_upper\n        self.brightness_coeff = brightness_coeff\n\n    def apply(self, img: np.ndarray, snow_point: float = 0.1, **params: Any) -&gt; np.ndarray:\n        return F.add_snow(img, snow_point, self.brightness_coeff)\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        return {\"snow_point\": random.uniform(self.snow_point_lower, self.snow_point_upper)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str]:\n        return (\"snow_point_lower\", \"snow_point_upper\", \"brightness_coeff\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomSunFlare","title":"<code>class  RandomSunFlare</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Simulates Sun Flare for the image</p> <p>From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library</p> <p>Parameters:</p> Name Type Description <code>flare_roi</code> <p>region of the image where flare will appear (x_min, y_min, x_max, y_max). All values should be in range [0, 1].</p> <code>angle_lower</code> <p>should be in range [0, <code>angle_upper</code>].</p> <code>angle_upper</code> <p>should be in range [<code>angle_lower</code>, 1].</p> <code>num_flare_circles_lower</code> <p>lower limit for the number of flare circles. Should be in range [0, <code>num_flare_circles_upper</code>].</p> <code>num_flare_circles_upper</code> <p>upper limit for the number of flare circles. Should be in range [<code>num_flare_circles_lower</code>, inf].</p> <code>src_radius</code> <code>src_color</code> <p>color of the flare</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomSunFlare(ImageOnlyTransform):\n    \"\"\"Simulates Sun Flare for the image\n\n    From https://github.com/UjjwalSaxena/Automold--Road-Augmentation-Library\n\n    Args:\n        flare_roi: region of the image where flare will appear (x_min, y_min, x_max, y_max).\n            All values should be in range [0, 1].\n        angle_lower: should be in range [0, `angle_upper`].\n        angle_upper: should be in range [`angle_lower`, 1].\n        num_flare_circles_lower: lower limit for the number of flare circles.\n            Should be in range [0, `num_flare_circles_upper`].\n        num_flare_circles_upper: upper limit for the number of flare circles.\n            Should be in range [`num_flare_circles_lower`, inf].\n        src_radius:\n        src_color: color of the flare\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        flare_roi: Tuple[float, float, float, float] = Field(\n            default=(0, 0, 1, 0.5), description=\"Region of the image where flare will appear\"\n        )\n        angle_lower: float = Field(default=0, description=\"Lower bound for the angle\", ge=0, le=1)\n        angle_upper: float = Field(default=1, description=\"Upper bound for the angle\", ge=0, le=1)\n        num_flare_circles_lower: int = Field(default=6, description=\"Lower limit for the number of flare circles\", ge=0)\n        num_flare_circles_upper: int = Field(\n            default=10, description=\"Upper limit for the number of flare circles\", gt=0\n        )\n        src_radius: int = Field(default=400, description=\"Source radius for the flare\")\n        src_color: Tuple[int, int, int] = Field(default=(255, 255, 255), description=\"Color of the flare\")\n\n        @model_validator(mode=\"after\")\n        def validate_parameters(self) -&gt; Self:\n            flare_center_lower_x, flare_center_lower_y, flare_center_upper_x, flare_center_upper_y = self.flare_roi\n            if (\n                not 0 &lt;= flare_center_lower_x &lt; flare_center_upper_x &lt;= 1\n                or not 0 &lt;= flare_center_lower_y &lt; flare_center_upper_y &lt;= 1\n            ):\n                raise ValueError(f\"Invalid flare_roi. Got: {self.flare_roi}\")\n            if self.angle_lower &gt;= self.angle_upper:\n                raise ValueError(\n                    f\"angle_upper must be greater than angle_lower. Got: {self.angle_lower}, {self.angle_upper}\"\n                )\n            if self.num_flare_circles_lower &gt;= self.num_flare_circles_upper:\n                msg = \"num_flare_circles_upper must be greater than num_flare_circles_lower.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        flare_roi: Tuple[float, float, float, float] = (0, 0, 1, 0.5),\n        angle_lower: float = 0,\n        angle_upper: float = 1,\n        num_flare_circles_lower: int = 6,\n        num_flare_circles_upper: int = 10,\n        src_radius: int = 400,\n        src_color: Tuple[int, int, int] = (255, 255, 255),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        self.angle_lower = angle_lower\n        self.angle_upper = angle_upper\n        self.num_flare_circles_lower = num_flare_circles_lower\n        self.num_flare_circles_upper = num_flare_circles_upper\n        self.src_radius = src_radius\n        self.src_color = src_color\n        self.flare_roi = flare_roi\n\n    def apply(\n        self,\n        img: np.ndarray,\n        flare_center_x: float = 0.5,\n        flare_center_y: float = 0.5,\n        circles: Optional[List[Any]] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if circles is None:\n            circles = []\n        return F.add_sun_flare(\n            img,\n            flare_center_x,\n            flare_center_y,\n            self.src_radius,\n            self.src_color,\n            circles,\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        angle = 2 * math.pi * random.uniform(self.angle_lower, self.angle_upper)\n\n        (flare_center_lower_x, flare_center_lower_y, flare_center_upper_x, flare_center_upper_y) = self.flare_roi\n\n        flare_center_x = random.uniform(flare_center_lower_x, flare_center_upper_x)\n        flare_center_y = random.uniform(flare_center_lower_y, flare_center_upper_y)\n\n        flare_center_x = int(width * flare_center_x)\n        flare_center_y = int(height * flare_center_y)\n\n        num_circles = random_utils.randint(self.num_flare_circles_lower, self.num_flare_circles_upper + 1)\n\n        circles = []\n\n        x = []\n        y = []\n\n        def line(t: float) -&gt; Tuple[float, float]:\n            return (flare_center_x + t * math.cos(angle), flare_center_y + t * math.sin(angle))\n\n        for t_val in range(-flare_center_x, width - flare_center_x, 10):\n            rand_x, rand_y = line(t_val)\n            x.append(rand_x)\n            y.append(rand_y)\n\n        for _ in range(num_circles):\n            alpha = random_utils.uniform(0.05, 0.2)\n            r = random_utils.randint(0, len(x))\n            rad = random.randint(1, max(height // 100 - 2, 2))\n\n            r_color = random.randint(max(self.src_color[0] - 50, 0), self.src_color[0])\n            g_color = random.randint(max(self.src_color[1] - 50, 0), self.src_color[1])\n            b_color = random.randint(max(self.src_color[2] - 50, 0), self.src_color[2])\n\n            circles += [\n                (\n                    alpha,\n                    (int(x[r]), int(y[r])),\n                    pow(rad, 3),\n                    (r_color, g_color, b_color),\n                )\n            ]\n\n        return {\n            \"circles\": circles,\n            \"flare_center_x\": flare_center_x,\n            \"flare_center_y\": flare_center_y,\n        }\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\n            \"flare_roi\": self.flare_roi,\n            \"angle_lower\": self.angle_lower,\n            \"angle_upper\": self.angle_upper,\n            \"num_flare_circles_lower\": self.num_flare_circles_lower,\n            \"num_flare_circles_upper\": self.num_flare_circles_upper,\n            \"src_radius\": self.src_radius,\n            \"src_color\": self.src_color,\n        }\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RandomToneCurve","title":"<code>class  RandomToneCurve</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly change the relationship between bright and dark areas of the image by manipulating its tone curve.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <p>standard deviation of the normal distribution. Used to sample random distances to move two control points that modify the image's curve. Values should be in range [0, 1]. Default: 0.1</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RandomToneCurve(ImageOnlyTransform):\n    \"\"\"Randomly change the relationship between bright and dark areas of the image by manipulating its tone curve.\n\n    Args:\n        scale: standard deviation of the normal distribution.\n            Used to sample random distances to move two control points that modify the image's curve.\n            Values should be in range [0, 1]. Default: 0.1\n\n    Targets:\n        image\n\n    Image types:\n        uint8\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: float = Field(\n            default=0.1,\n            description=\"Standard deviation of the normal distribution used to sample random distances\",\n            ge=0,\n            le=1,\n        )\n\n    def __init__(\n        self,\n        scale: float = 0.1,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.scale = scale\n\n    def apply(self, img: np.ndarray, low_y: float, high_y: float, **params: Any) -&gt; np.ndarray:\n        return F.move_tone_curve(img, low_y, high_y)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"low_y\": np.clip(random_utils.normal(loc=0.25, scale=self.scale), 0, 1),\n            \"high_y\": np.clip(random_utils.normal(loc=0.75, scale=self.scale), 0, 1),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"scale\",)\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.RingingOvershoot","title":"<code>class  RingingOvershoot</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Create ringing or overshoot artefacts by conlvolving image with 2D sinc filter.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <p>maximum kernel size for sinc filter. Should be in range [3, inf). Default: (7, 15).</p> <code>cutoff</code> <p>range to choose the cutoff frequency in radians. Should be in range (0, np.pi) Default: (np.pi / 4, np.pi / 2).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Reference</p> <p>dsp.stackexchange.com/questions/58301/2-d-circularly-symmetric-low-pass-filter https://arxiv.org/abs/2107.10833</p> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class RingingOvershoot(ImageOnlyTransform):\n    \"\"\"Create ringing or overshoot artefacts by conlvolving image with 2D sinc filter.\n\n    Args:\n        blur_limit: maximum kernel size for sinc filter.\n            Should be in range [3, inf). Default: (7, 15).\n        cutoff: range to choose the cutoff frequency in radians.\n            Should be in range (0, np.pi)\n            Default: (np.pi / 4, np.pi / 2).\n        p: probability of applying the transform. Default: 0.5.\n\n    Reference:\n        dsp.stackexchange.com/questions/58301/2-d-circularly-symmetric-low-pass-filter\n        https://arxiv.org/abs/2107.10833\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BlurInitSchema):\n        blur_limit: ScaleIntType = Field(default=(7, 15), description=\"Maximum kernel size for sinc filter.\")\n        cutoff: ScaleFloatType = Field(default=(np.pi / 4, np.pi / 2), description=\"Cutoff frequency range in radians.\")\n\n        @field_validator(\"cutoff\")\n        @classmethod\n        def check_cutoff(cls, v: ScaleFloatType, info: ValidationInfo) -&gt; Tuple[float, float]:\n            bounds = 0, np.pi\n            result = to_tuple(v, v)\n            check_range(result, *bounds, info.field_name)\n            return result\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = (7, 15),\n        cutoff: ScaleFloatType = (np.pi / 4, np.pi / 2),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n        self.cutoff = cast(Tuple[float, float], cutoff)\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        ksize = random.randrange(self.blur_limit[0], self.blur_limit[1] + 1, 2)\n        if ksize % 2 == 0:\n            raise ValueError(f\"Kernel size must be odd. Got: {ksize}\")\n\n        cutoff = random.uniform(*self.cutoff)\n\n        # From dsp.stackexchange.com/questions/58301/2-d-circularly-symmetric-low-pass-filter\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            kernel = np.fromfunction(\n                lambda x, y: cutoff\n                * special.j1(cutoff * np.sqrt((x - (ksize - 1) / 2) ** 2 + (y - (ksize - 1) / 2) ** 2))\n                / (2 * np.pi * np.sqrt((x - (ksize - 1) / 2) ** 2 + (y - (ksize - 1) / 2) ** 2)),\n                [ksize, ksize],\n            )\n        kernel[(ksize - 1) // 2, (ksize - 1) // 2] = cutoff**2 / (4 * np.pi)\n\n        # Normalize kernel\n        kernel = kernel.astype(np.float32) / np.sum(kernel)\n\n        return {\"kernel\": kernel}\n\n    def apply(self, img: np.ndarray, kernel: Optional[int] = None, **params: Any) -&gt; np.ndarray:\n        return F.convolve(img, kernel)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"blur_limit\", \"cutoff\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Sharpen","title":"<code>class  Sharpen</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Sharpen the input image and overlays the result with the original image.</p> <p>Parameters:</p> Name Type Description <code>alpha</code> <p>range to choose the visibility of the sharpened image. At 0, only the original image is visible, at 1.0 only its sharpened version is visible. Default: (0.2, 0.5).</p> <code>lightness</code> <p>range to choose the lightness of the sharpened image. Default: (0.5, 1.0).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Sharpen(ImageOnlyTransform):\n    \"\"\"Sharpen the input image and overlays the result with the original image.\n\n    Args:\n        alpha: range to choose the visibility of the sharpened image. At 0, only the original image is\n            visible, at 1.0 only its sharpened version is visible. Default: (0.2, 0.5).\n        lightness: range to choose the lightness of the sharpened image. Default: (0.5, 1.0).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        alpha: ZeroOneRangeType = (0.2, 0.5)\n        lightness: NonNegativeFloatRangeType = (0.5, 1.0)\n\n    def __init__(\n        self,\n        alpha: Tuple[float, float] = (0.2, 0.5),\n        lightness: Tuple[float, float] = (0.5, 1.0),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.alpha = alpha\n        self.lightness = lightness\n\n    @staticmethod\n    def __generate_sharpening_matrix(alpha_sample: np.ndarray, lightness_sample: np.ndarray) -&gt; np.ndarray:\n        matrix_nochange = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]], dtype=np.float32)\n        matrix_effect = np.array(\n            [[-1, -1, -1], [-1, 8 + lightness_sample, -1], [-1, -1, -1]],\n            dtype=np.float32,\n        )\n\n        return (1 - alpha_sample) * matrix_nochange + alpha_sample * matrix_effect\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        alpha = random.uniform(*self.alpha)\n        lightness = random.uniform(*self.lightness)\n        sharpening_matrix = self.__generate_sharpening_matrix(alpha_sample=alpha, lightness_sample=lightness)\n        return {\"sharpening_matrix\": sharpening_matrix}\n\n    def apply(self, img: np.ndarray, sharpening_matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.convolve(img, sharpening_matrix)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"alpha\", \"lightness\")\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Solarize","title":"<code>class  Solarize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Invert all pixel values above a threshold.</p> <p>Parameters:</p> Name Type Description <code>threshold</code> <p>range for solarizing threshold. If threshold is a single value, the range will be [1, threshold]. Default: 128.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     any</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Solarize(ImageOnlyTransform):\n    \"\"\"Invert all pixel values above a threshold.\n\n    Args:\n        threshold: range for solarizing threshold.\n            If threshold is a single value, the range will be [1, threshold]. Default: 128.\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        any\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        threshold: OnePlusFloatRangeType = (128, 128)\n\n    def __init__(self, threshold: ScaleType = (128, 128), always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply=always_apply, p=p)\n        self.threshold = cast(Tuple[float, float], threshold)\n\n    def apply(self, img: np.ndarray, threshold: int = 0, **params: Any) -&gt; np.ndarray:\n        return F.solarize(img, threshold)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"threshold\": random.uniform(self.threshold[0], self.threshold[1])}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"threshold\",)\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Spatter","title":"<code>class  Spatter</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply spatter transform. It simulates corruption which can occlude a lens in the form of rain or mud.</p> <p>Parameters:</p> Name Type Description <code>mean</code> <code>float, or tuple of floats</code> <p>Mean value of normal distribution for generating liquid layer. If single float mean will be sampled from <code>(0, mean)</code> If tuple of float mean will be sampled from range <code>(mean[0], mean[1])</code>. If you want constant value use (mean, mean). Default (0.65, 0.65)</p> <code>std</code> <code>float, or tuple of floats</code> <p>Standard deviation value of normal distribution for generating liquid layer. If single float the number will be sampled from <code>(0, std)</code>. If tuple of float std will be sampled from range <code>(std[0], std[1])</code>. If you want constant value use (std, std). Default: (0.3, 0.3).</p> <code>gauss_sigma</code> <code>float, or tuple of floats</code> <p>Sigma value for gaussian filtering of liquid layer. If single float the number will be sampled from <code>(0, gauss_sigma)</code>. If tuple of float gauss_sigma will be sampled from range <code>(gauss_sigma[0], gauss_sigma[1])</code>. If you want constant value use (gauss_sigma, gauss_sigma). Default: (2, 3).</p> <code>cutout_threshold</code> <code>float, or tuple of floats</code> <p>Threshold for filtering liqued layer (determines number of drops). If single float it will used as cutout_threshold. If single float the number will be sampled from <code>(0, cutout_threshold)</code>. If tuple of float cutout_threshold will be sampled from range <code>(cutout_threshold[0], cutout_threshold[1])</code>. If you want constant value use <code>(cutout_threshold, cutout_threshold)</code>. Default: (0.68, 0.68).</p> <code>intensity</code> <code>float, or tuple of floats</code> <p>Intensity of corruption. If single float the number will be sampled from <code>(0, intensity)</code>. If tuple of float intensity will be sampled from range <code>(intensity[0], intensity[1])</code>. If you want constant value use <code>(intensity, intensity)</code>. Default: (0.6, 0.6).</p> <code>mode</code> <code>string, or list of strings</code> <p>Type of corruption. Currently, supported options are 'rain' and 'mud'.  If list is provided type of corruption will be sampled list. Default: (\"rain\").</p> <code>color</code> <code>list of (r, g, b) or dict or None</code> <p>Corruption elements color. If list uses provided list as color for specified mode. If dict uses provided color for specified mode. Color for each specified mode should be provided in dict. If None uses default colors (rain: (238, 238, 175), mud: (20, 42, 63)).</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1903.12261 https://github.com/hendrycks/robustness/blob/master/ImageNet-C/create_c/make_imagenet_c.py</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Spatter(ImageOnlyTransform):\n    \"\"\"Apply spatter transform. It simulates corruption which can occlude a lens in the form of rain or mud.\n\n    Args:\n        mean (float, or tuple of floats): Mean value of normal distribution for generating liquid layer.\n            If single float mean will be sampled from `(0, mean)`\n            If tuple of float mean will be sampled from range `(mean[0], mean[1])`.\n            If you want constant value use (mean, mean).\n            Default (0.65, 0.65)\n        std (float, or tuple of floats): Standard deviation value of normal distribution for generating liquid layer.\n            If single float the number will be sampled from `(0, std)`.\n            If tuple of float std will be sampled from range `(std[0], std[1])`.\n            If you want constant value use (std, std).\n            Default: (0.3, 0.3).\n        gauss_sigma (float, or tuple of floats): Sigma value for gaussian filtering of liquid layer.\n            If single float the number will be sampled from `(0, gauss_sigma)`.\n            If tuple of float gauss_sigma will be sampled from range `(gauss_sigma[0], gauss_sigma[1])`.\n            If you want constant value use (gauss_sigma, gauss_sigma).\n            Default: (2, 3).\n        cutout_threshold (float, or tuple of floats): Threshold for filtering liqued layer\n            (determines number of drops). If single float it will used as cutout_threshold.\n            If single float the number will be sampled from `(0, cutout_threshold)`.\n            If tuple of float cutout_threshold will be sampled from range `(cutout_threshold[0], cutout_threshold[1])`.\n            If you want constant value use `(cutout_threshold, cutout_threshold)`.\n            Default: (0.68, 0.68).\n        intensity (float, or tuple of floats): Intensity of corruption.\n            If single float the number will be sampled from `(0, intensity)`.\n            If tuple of float intensity will be sampled from range `(intensity[0], intensity[1])`.\n            If you want constant value use `(intensity, intensity)`.\n            Default: (0.6, 0.6).\n        mode (string, or list of strings): Type of corruption. Currently, supported options are 'rain' and 'mud'.\n             If list is provided type of corruption will be sampled list. Default: (\"rain\").\n        color (list of (r, g, b) or dict or None): Corruption elements color.\n            If list uses provided list as color for specified mode.\n            If dict uses provided color for specified mode. Color for each specified mode should be provided in dict.\n            If None uses default colors (rain: (238, 238, 175), mud: (20, 42, 63)).\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://arxiv.org/abs/1903.12261\n        https://github.com/hendrycks/robustness/blob/master/ImageNet-C/create_c/make_imagenet_c.py\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        mean: ZeroOneRangeType = (0.65, 0.65)\n        std: ZeroOneRangeType = (0.3, 0.3)\n        gauss_sigma: NonNegativeFloatRangeType = (2, 2)\n        cutout_threshold: ZeroOneRangeType = (0.68, 0.68)\n        intensity: ZeroOneRangeType = (0.6, 0.6)\n        mode: Union[SpatterMode, Sequence[SpatterMode]] = Field(\n            default=\"rain\", description=\"Type of corruption ('rain', 'mud').\"\n        )\n        color: Optional[Union[Sequence[int], Dict[str, Sequence[int]]]] = None\n\n        @field_validator(\"mode\")\n        @classmethod\n        def check_mode(cls, mode: Union[SpatterMode, Sequence[SpatterMode]]) -&gt; Sequence[SpatterMode]:\n            if isinstance(mode, str):\n                return [mode]\n            return mode\n\n        @model_validator(mode=\"after\")\n        def check_color(self) -&gt; Self:\n            if self.color is None:\n                self.color = {\"rain\": [238, 238, 175], \"mud\": [20, 42, 63]}\n\n            elif isinstance(self.color, (list, tuple)) and len(self.mode) == 1:\n                if len(self.color) != NUM_RGB_CHANNELS:\n                    msg = \"Color must be a list of three integers for RGB format.\"\n                    raise ValueError(msg)\n                self.color = {self.mode[0]: self.color}\n            elif isinstance(self.color, dict):\n                result = {}\n                for mode in self.mode:\n                    if mode not in self.color:\n                        raise ValueError(f\"Color for mode {mode} is not specified.\")\n                    if len(self.color[mode]) != NUM_RGB_CHANNELS:\n                        raise ValueError(f\"Color for mode {mode} must be in RGB format.\")\n                    result[mode] = self.color[mode]\n            else:\n                msg = \"Color must be a list of RGB values or a dict mapping mode to RGB values.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        mean: ScaleFloatType = (0.65, 0.65),\n        std: ScaleFloatType = (0.3, 0.3),\n        gauss_sigma: ScaleFloatType = (2, 2),\n        cutout_threshold: ScaleFloatType = (0.68, 0.68),\n        intensity: ScaleFloatType = (0.6, 0.6),\n        mode: Union[SpatterMode, Sequence[SpatterMode]] = \"rain\",\n        color: Optional[Union[Sequence[int], Dict[str, Sequence[int]]]] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.mean = cast(Tuple[float, float], mean)\n        self.std = cast(Tuple[float, float], std)\n        self.gauss_sigma = cast(Tuple[float, float], gauss_sigma)\n        self.cutout_threshold = cast(Tuple[float, float], cutout_threshold)\n        self.intensity = cast(Tuple[float, float], intensity)\n        self.mode = mode\n        self.color = cast(Dict[str, Sequence[int]], color)\n\n    def apply(\n        self,\n        img: np.ndarray,\n        non_mud: Optional[np.ndarray] = None,\n        mud: Optional[np.ndarray] = None,\n        drops: Optional[np.ndarray] = None,\n        mode: SpatterMode = \"mud\",\n        **params: Dict[str, Any],\n    ) -&gt; np.ndarray:\n        return F.spatter(img, non_mud, mud, drops, mode)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        mean = random.uniform(self.mean[0], self.mean[1])\n        std = random.uniform(self.std[0], self.std[1])\n        cutout_threshold = random.uniform(self.cutout_threshold[0], self.cutout_threshold[1])\n        sigma = random.uniform(self.gauss_sigma[0], self.gauss_sigma[1])\n        mode = random.choice(self.mode)\n        intensity = random.uniform(self.intensity[0], self.intensity[1])\n        color = np.array(self.color[mode]) / 255.0\n\n        liquid_layer = random_utils.normal(size=(height, width), loc=mean, scale=std)\n        liquid_layer = gaussian_filter(liquid_layer, sigma=sigma, mode=\"nearest\")\n        liquid_layer[liquid_layer &lt; cutout_threshold] = 0\n\n        if mode == \"rain\":\n            liquid_layer = (liquid_layer * 255).astype(np.uint8)\n            dist = 255 - cv2.Canny(liquid_layer, 50, 150)\n            dist = cv2.distanceTransform(dist, cv2.DIST_L2, 5)\n            _, dist = cv2.threshold(dist, 20, 20, cv2.THRESH_TRUNC)\n            dist = blur(dist, 3).astype(np.uint8)\n            dist = F.equalize(dist)\n\n            ker = np.array([[-2, -1, 0], [-1, 1, 1], [0, 1, 2]])\n            dist = F.convolve(dist, ker)\n            dist = blur(dist, 3).astype(np.float32)\n\n            m = liquid_layer * dist\n            m *= 1 / np.max(m, axis=(0, 1))\n\n            drops = m[:, :, None] * color * intensity\n            mud = None\n            non_mud = None\n        else:\n            m = np.where(liquid_layer &gt; cutout_threshold, 1, 0)\n            m = gaussian_filter(m.astype(np.float32), sigma=sigma, mode=\"nearest\")\n            m[m &lt; 1.2 * cutout_threshold] = 0\n            m = m[..., np.newaxis]\n\n            mud = m * color\n            non_mud = 1 - m\n            drops = None\n\n        return {\n            \"non_mud\": non_mud,\n            \"mud\": mud,\n            \"drops\": drops,\n            \"mode\": mode,\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str, str, str, str]:\n        return \"mean\", \"std\", \"gauss_sigma\", \"intensity\", \"cutout_threshold\", \"mode\", \"color\"\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.Superpixels","title":"<code>class  Superpixels</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Transform images partially/completely to their superpixel representation. This implementation uses skimage's version of the SLIC algorithm.</p> <p>Parameters:</p> Name Type Description <code>p_replace</code> <code>float or tuple of float</code> <p>Defines for any segment the probability that the pixels within that segment are replaced by their average color (otherwise, the pixels are not changed).</p> <p>Examples:</p> <ul> <li>A probability of <code>0.0</code> would mean, that the pixels in no   segment are replaced by their average color (image is not   changed at all).</li> <li>A probability of <code>0.5</code> would mean, that around half of all   segments are replaced by their average color.</li> <li>A probability of <code>1.0</code> would mean, that all segments are   replaced by their average color (resulting in a voronoi   image).</li> </ul> <pre><code>    Behaviour based on chosen data types for this parameter:\n        * If a ``float``, then that ``flat`` will always be used.\n        * If ``tuple`` ``(a, b)``, then a random probability will be\n          sampled from the interval ``[a, b]`` per image.\nn_segments (tuple of int): Rough target number of how many superpixels to generate (the algorithm\n    may deviate from this number). Lower value will lead to coarser superpixels.\n    Higher values are computationally more intensive and will hence lead to a slowdown\n    Then a value from the discrete interval ``[a..b]`` will be sampled per image.\n    If input is a single integer, the range will be ``(1, n_segments)``.\n    If interested in a fixed number of segments, use ``(n_segments, n_segments)``.\nmax_size (int or None): Maximum image size at which the augmentation is performed.\n    If the width or height of an image exceeds this value, it will be\n    downscaled before the augmentation so that the longest side matches `max_size`.\n    This is done to speed up the process. The final output image has the same size as the input image.\n    Note that in case `p_replace` is below ``1.0``,\n    the down-/upscaling will affect the not-replaced pixels too.\n    Use ``None`` to apply no down-/upscaling.\ninterpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n    cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n    Default: cv2.INTER_LINEAR.\np (float): probability of applying the transform. Default: 0.5.\n</code></pre> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class Superpixels(ImageOnlyTransform):\n    \"\"\"Transform images partially/completely to their superpixel representation.\n    This implementation uses skimage's version of the SLIC algorithm.\n\n    Args:\n        p_replace (float or tuple of float): Defines for any segment the probability that the pixels within that\n            segment are replaced by their average color (otherwise, the pixels are not changed).\n\n    Examples:\n                * A probability of ``0.0`` would mean, that the pixels in no\n                  segment are replaced by their average color (image is not\n                  changed at all).\n                * A probability of ``0.5`` would mean, that around half of all\n                  segments are replaced by their average color.\n                * A probability of ``1.0`` would mean, that all segments are\n                  replaced by their average color (resulting in a voronoi\n                  image).\n            Behaviour based on chosen data types for this parameter:\n                * If a ``float``, then that ``flat`` will always be used.\n                * If ``tuple`` ``(a, b)``, then a random probability will be\n                  sampled from the interval ``[a, b]`` per image.\n        n_segments (tuple of int): Rough target number of how many superpixels to generate (the algorithm\n            may deviate from this number). Lower value will lead to coarser superpixels.\n            Higher values are computationally more intensive and will hence lead to a slowdown\n            Then a value from the discrete interval ``[a..b]`` will be sampled per image.\n            If input is a single integer, the range will be ``(1, n_segments)``.\n            If interested in a fixed number of segments, use ``(n_segments, n_segments)``.\n        max_size (int or None): Maximum image size at which the augmentation is performed.\n            If the width or height of an image exceeds this value, it will be\n            downscaled before the augmentation so that the longest side matches `max_size`.\n            This is done to speed up the process. The final output image has the same size as the input image.\n            Note that in case `p_replace` is below ``1.0``,\n            the down-/upscaling will affect the not-replaced pixels too.\n            Use ``None`` to apply no down-/upscaling.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        p_replace: ZeroOneRangeType = (0, 0.1)\n        n_segments: OnePlusIntRangeType = (100, 100)\n        max_size: Optional[int] = Field(default=128, ge=1, description=\"Maximum image size for the transformation.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n    def __init__(\n        self,\n        p_replace: ScaleFloatType = (0, 0.1),\n        n_segments: ScaleIntType = (100, 100),\n        max_size: Optional[int] = 128,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.p_replace = cast(Tuple[float, float], p_replace)\n        self.n_segments = cast(Tuple[int, int], n_segments)\n        self.max_size = max_size\n        self.interpolation = interpolation\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"p_replace\", \"n_segments\", \"max_size\", \"interpolation\")\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        n_segments = random_utils.randint(self.n_segments[0], self.n_segments[1] + 1)\n        p = random.uniform(*self.p_replace)\n        return {\"replace_samples\": random_utils.random(n_segments) &lt; p, \"n_segments\": n_segments}\n\n    def apply(\n        self, img: np.ndarray, replace_samples: Sequence[bool] = (False,), n_segments: int = 1, **kwargs: Any\n    ) -&gt; np.ndarray:\n        return F.superpixels(img, n_segments, replace_samples, self.max_size, cast(int, self.interpolation))\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.TemplateTransform","title":"<code>class  TemplateTransform</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply blending of input image with specified templates</p> <p>Parameters:</p> Name Type Description <code>templates</code> <code>numpy array or list of numpy arrays</code> <p>Images as template for transform.</p> <code>img_weight</code> <p>If single float weight will be sampled from (0, img_weight). If tuple of float img_weight will be in range <code>[img_weight[0], img_weight[1])</code>. If you want fixed weight, use (img_weight, img_weight) Default: (0.5, 0.5).</p> <code>template_weight</code> <p>If single float weight will be sampled from (0, template_weight). If tuple of float template_weight will be in range <code>[template_weight[0], template_weight[1])</code>. If you want fixed weight, use (template_weight, template_weight) Default: (0.5, 0.5).</p> <code>template_transform</code> <p>transformation object which could be applied to template, must produce template the same size as input image.</p> <code>name</code> <p>(Optional) Name of transform, used only for deserialization.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class TemplateTransform(ImageOnlyTransform):\n    \"\"\"Apply blending of input image with specified templates\n    Args:\n        templates (numpy array or list of numpy arrays): Images as template for transform.\n        img_weight: If single float weight will be sampled from (0, img_weight).\n            If tuple of float img_weight will be in range `[img_weight[0], img_weight[1])`.\n            If you want fixed weight, use (img_weight, img_weight)\n            Default: (0.5, 0.5).\n        template_weight: If single float weight will be sampled from (0, template_weight).\n            If tuple of float template_weight will be in range `[template_weight[0], template_weight[1])`.\n            If you want fixed weight, use (template_weight, template_weight)\n            Default: (0.5, 0.5).\n        template_transform: transformation object which could be applied to template,\n            must produce template the same size as input image.\n        name: (Optional) Name of transform, used only for deserialization.\n        p: probability of applying the transform. Default: 0.5.\n    Targets:\n        image\n    Image types:\n        uint8, float32\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        templates: Union[np.ndarray, Sequence[np.ndarray]] = Field(..., description=\"Images as template for transform.\")\n        img_weight: ZeroOneRangeType = (0.5, 0.5)\n        template_weight: ZeroOneRangeType = (0.5, 0.5)\n        template_transform: Optional[Callable[..., Any]] = Field(\n            default=None, description=\"Transformation object applied to template.\"\n        )\n        name: Optional[str] = Field(default=None, description=\"Name of transform, used only for deserialization.\")\n\n        @field_validator(\"templates\")\n        @classmethod\n        def validate_templates(cls, v: Union[np.ndarray, List[np.ndarray]]) -&gt; List[np.ndarray]:\n            if isinstance(v, np.ndarray):\n                return [v]\n            if isinstance(v, list):\n                if not all(isinstance(item, np.ndarray) for item in v):\n                    msg = \"All templates must be numpy arrays.\"\n                    raise ValueError(msg)\n                return v\n            msg = \"Templates must be a numpy array or a list of numpy arrays.\"\n            raise TypeError(msg)\n\n    def __init__(\n        self,\n        templates: Union[np.ndarray, List[np.ndarray]],\n        img_weight: ScaleFloatType = (0.5, 0.5),\n        template_weight: ScaleFloatType = (0.5, 0.5),\n        template_transform: Optional[Callable[..., Any]] = None,\n        name: Optional[str] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.templates = templates\n        self.img_weight = cast(Tuple[float, float], img_weight)\n        self.template_weight = cast(Tuple[float, float], template_weight)\n        self.template_transform = template_transform\n        self.name = name\n\n    def apply(\n        self,\n        img: np.ndarray,\n        template: Optional[np.ndarray] = None,\n        img_weight: float = 0.5,\n        template_weight: float = 0.5,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.add_weighted(img, img_weight, template, template_weight)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\n            \"img_weight\": random.uniform(self.img_weight[0], self.img_weight[1]),\n            \"template_weight\": random.uniform(self.template_weight[0], self.template_weight[1]),\n        }\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        template = random.choice(self.templates)\n\n        if self.template_transform is not None:\n            template = self.template_transform(image=template)[\"image\"]\n\n        if get_num_channels(template) not in [1, get_num_channels(img)]:\n            msg = (\n                \"Template must be a single channel or \"\n                \"has the same number of channels as input \"\n                f\"image ({get_num_channels(img)}), got {get_num_channels(template)}\"\n            )\n            raise ValueError(msg)\n\n        if template.dtype != img.dtype:\n            msg = \"Image and template must be the same image type\"\n            raise ValueError(msg)\n\n        if img.shape[:2] != template.shape[:2]:\n            raise ValueError(f\"Image and template must be the same size, got {img.shape[:2]} and {template.shape[:2]}\")\n\n        if get_num_channels(template) == 1 and get_num_channels(img) &gt; 1:\n            template = np.stack((template,) * get_num_channels(img), axis=-1)\n\n        # in order to support grayscale image with dummy dim\n        template = template.reshape(img.shape)\n\n        return {\"template\": template}\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return False\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        if self.name is None:\n            msg = (\n                \"To make a TemplateTransform serializable you should provide the `name` argument, \"\n                \"e.g. `TemplateTransform(name='my_transform', ...)`.\"\n            )\n            raise ValueError(msg)\n        return {\"__class_fullname__\": self.get_class_fullname(), \"__name__\": self.name}\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ToFloat","title":"<code>class  ToFloat</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Divide pixel values by <code>max_value</code> to get a float32 output array where all values lie in the range [0, 1.0]. If <code>max_value</code> is None the transform will try to infer the maximum value by inspecting the data type of the input image.</p> <p>See Also:     :class:<code>~albumentations.augmentations.transforms.FromFloat</code></p> <p>Parameters:</p> Name Type Description <code>max_value</code> <p>maximum possible input value. Default: None.</p> <code>p</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image</p> <p>Image types:     any type</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ToFloat(ImageOnlyTransform):\n    \"\"\"Divide pixel values by `max_value` to get a float32 output array where all values lie in the range [0, 1.0].\n    If `max_value` is None the transform will try to infer the maximum value by inspecting the data type of the input\n    image.\n\n    See Also:\n        :class:`~albumentations.augmentations.transforms.FromFloat`\n\n    Args:\n        max_value: maximum possible input value. Default: None.\n        p: probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image\n\n    Image types:\n        any type\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        max_value: Optional[float] = Field(default=None, description=\"Maximum possible input value.\")\n        p: ProbabilityType = 1\n\n    def __init__(self, max_value: Optional[float] = None, always_apply: bool = False, p: float = 1.0):\n        super().__init__(always_apply, p)\n        self.max_value = max_value\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.to_float(img, self.max_value)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str]:\n        return (\"max_value\",)\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ToGray","title":"<code>class  ToGray</code> <code> </code>  [view source on GitHub]","text":"<p>Convert the input RGB image to grayscale. If the mean pixel value for the resulting image is greater than 127, invert the resulting grayscale image.</p> <p>Parameters:</p> Name Type Description <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ToGray(ImageOnlyTransform):\n    \"\"\"Convert the input RGB image to grayscale. If the mean pixel value for the resulting image is greater\n    than 127, invert the resulting grayscale image.\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if is_grayscale_image(img):\n            warnings.warn(\"The image is already gray.\")\n            return img\n        if not is_rgb_image(img):\n            msg = \"ToGray transformation expects 3-channel images.\"\n            raise TypeError(msg)\n\n        return F.to_gray(img)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ToRGB","title":"<code>class  ToRGB</code> <code>       (always_apply=True, p=1.0)                   </code>  [view source on GitHub]","text":"<p>Convert the input grayscale image to RGB.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ToRGB(ImageOnlyTransform):\n    \"\"\"Convert the input grayscale image to RGB.\n\n    Args:\n        p: probability of applying the transform. Default: 1.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def __init__(self, always_apply: bool = True, p: float = 1.0):\n        super().__init__(always_apply=always_apply, p=p)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if is_rgb_image(img):\n            warnings.warn(\"The image is already an RGB.\")\n            return img\n        if not is_grayscale_image(img):\n            msg = \"ToRGB transformation expects 2-dim images or 3-dim with the last dimension equal to 1.\"\n            raise TypeError(msg)\n\n        return F.gray_to_rgb(img)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ToRGB.__init__","title":"<code>__init__ (self, always_apply=True, p=1.0)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>def __init__(self, always_apply: bool = True, p: float = 1.0):\n    super().__init__(always_apply=always_apply, p=p)\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ToSepia","title":"<code>class  ToSepia</code> <code>       (always_apply=False, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Applies sepia filter to the input RGB image</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class ToSepia(ImageOnlyTransform):\n    \"\"\"Applies sepia filter to the input RGB image\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def __init__(self, always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply, p)\n        self.sepia_transformation_matrix = np.array(\n            [[0.393, 0.769, 0.189], [0.349, 0.686, 0.168], [0.272, 0.534, 0.131]]\n        )\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if not is_rgb_image(img):\n            msg = \"ToSepia transformation expects 3-channel images.\"\n            raise TypeError(msg)\n        return F.linear_transformation_rgb(img, self.sepia_transformation_matrix)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.ToSepia.__init__","title":"<code>__init__ (self, always_apply=False, p=0.5)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>def __init__(self, always_apply: bool = False, p: float = 0.5):\n    super().__init__(always_apply, p)\n    self.sepia_transformation_matrix = np.array(\n        [[0.393, 0.769, 0.189], [0.349, 0.686, 0.168], [0.272, 0.534, 0.131]]\n    )\n</code></pre>"},{"location":"api_reference/augmentations/transforms/#albumentations.augmentations.transforms.UnsharpMask","title":"<code>class  UnsharpMask</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Sharpen the input image using Unsharp Masking processing and overlays the result with the original image.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <p>maximum Gaussian kernel size for blurring the input image. Must be zero or odd and in range [0, inf). If set to 0 it will be computed from sigma as <code>round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1</code>. If set single value <code>blur_limit</code> will be in range (0, blur_limit). Default: (3, 7).</p> <code>sigma_limit</code> <p>Gaussian kernel standard deviation. Must be in range [0, inf). If set single value <code>sigma_limit</code> will be in range (0, sigma_limit). If set to 0 sigma will be computed as <code>sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8</code>. Default: 0.</p> <code>alpha</code> <p>range to choose the visibility of the sharpened image. At 0, only the original image is visible, at 1.0 only its sharpened version is visible. Default: (0.2, 0.5).</p> <code>threshold</code> <p>Value to limit sharpening only for areas with high pixel difference between original image and it's smoothed version. Higher threshold means less sharpening on flat areas. Must be in range [0, 255]. Default: 10.</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Reference</p> <p>arxiv.org/pdf/2107.10833.pdf</p> <p>Targets</p> <p>image</p> Source code in <code>albumentations/augmentations/transforms.py</code> Python<pre><code>class UnsharpMask(ImageOnlyTransform):\n    \"\"\"Sharpen the input image using Unsharp Masking processing and overlays the result with the original image.\n\n    Args:\n        blur_limit: maximum Gaussian kernel size for blurring the input image.\n            Must be zero or odd and in range [0, inf). If set to 0 it will be computed from sigma\n            as `round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1`.\n            If set single value `blur_limit` will be in range (0, blur_limit).\n            Default: (3, 7).\n        sigma_limit: Gaussian kernel standard deviation. Must be in range [0, inf).\n            If set single value `sigma_limit` will be in range (0, sigma_limit).\n            If set to 0 sigma will be computed as `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`. Default: 0.\n        alpha: range to choose the visibility of the sharpened image.\n            At 0, only the original image is visible, at 1.0 only its sharpened version is visible.\n            Default: (0.2, 0.5).\n        threshold: Value to limit sharpening only for areas with high pixel difference between original image\n            and it's smoothed version. Higher threshold means less sharpening on flat areas.\n            Must be in range [0, 255]. Default: 10.\n        p: probability of applying the transform. Default: 0.5.\n\n    Reference:\n        arxiv.org/pdf/2107.10833.pdf\n\n    Targets:\n        image\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        sigma_limit: NonNegativeFloatRangeType = 0\n        alpha: ZeroOneRangeType = (0.2, 0.5)\n        threshold: int = Field(default=10, ge=0, le=255, description=\"Threshold for limiting sharpening.\")\n\n        blur_limit: ScaleIntType = Field(\n            default=(3, 7), description=\"Maximum kernel size for blurring the input image.\"\n        )\n\n        @field_validator(\"blur_limit\")\n        @classmethod\n        def process_blur(cls, value: ScaleIntType, info: ValidationInfo) -&gt; Tuple[int, int]:\n            return process_blur_limit(value, info, min_value=3)\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = (3, 7),\n        sigma_limit: ScaleFloatType = 0.0,\n        alpha: ScaleFloatType = (0.2, 0.5),\n        threshold: int = 10,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n        self.sigma_limit = cast(Tuple[float, float], sigma_limit)\n        self.alpha = cast(Tuple[float, float], alpha)\n        self.threshold = threshold\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"ksize\": random.randrange(self.blur_limit[0], self.blur_limit[1] + 1, 2),\n            \"sigma\": random.uniform(*self.sigma_limit),\n            \"alpha\": random.uniform(*self.alpha),\n        }\n\n    def apply(self, img: np.ndarray, ksize: int = 3, sigma: int = 0, alpha: float = 0.2, **params: Any) -&gt; np.ndarray:\n        return F.unsharp_mask(img, ksize, sigma=sigma, alpha=alpha, threshold=self.threshold)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return \"blur_limit\", \"sigma_limit\", \"alpha\", \"threshold\"\n</code></pre>"},{"location":"api_reference/augmentations/blur/","title":"Index","text":"<ul> <li>Blur transforms (albumentations.augmentations.blur.transforms)</li> </ul>"},{"location":"api_reference/augmentations/blur/functional/","title":"Blur functional transforms (augmentations.blur.functional)","text":""},{"location":"api_reference/augmentations/blur/transforms/","title":"Blur transforms (augmentations.blur.transforms)","text":""},{"location":"api_reference/augmentations/blur/transforms/#albumentations.augmentations.blur.transforms.AdvancedBlur","title":"<code>class  AdvancedBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Blurs the input image using a Generalized Normal filter with randomly selected parameters.</p> <p>This transform also adds multiplicative noise to the generated kernel before convolution, affecting the image in a unique way that combines blurring and noise injection for enhanced data augmentation.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <code>ScaleIntType</code> <p>Maximum Gaussian kernel size for blurring the input image. Must be zero or odd and in range [0, inf). If set to 0, it will be computed from sigma as <code>round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1</code>. If a single value is provided, <code>blur_limit</code> will be in the range (0, blur_limit). Defaults to (3, 7).</p> <code>sigma_x_limit</code> <code>ScaleFloatType</code> <p>Gaussian kernel standard deviation for the X dimension. Must be in range [0, inf). If a single value is provided, <code>sigma_x_limit</code> will be in the range (0, sigma_limit). If set to 0, sigma will be computed as <code>sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8</code>. Defaults to (0.2, 1.0).</p> <code>sigma_y_limit</code> <code>ScaleFloatType</code> <p>Gaussian kernel standard deviation for the Y dimension. Must follow the same rules as <code>sigma_x_limit</code>. Defaults to (0.2, 1.0).</p> <code>rotate_limit</code> <code>ScaleIntType</code> <p>Range from which a random angle used to rotate the Gaussian kernel is picked. If limit is a single int, an angle is picked from (-rotate_limit, rotate_limit). Defaults to (-90, 90).</p> <code>beta_limit</code> <code>ScaleFloatType</code> <p>Distribution shape parameter. 1 represents the normal distribution. Values below 1.0 make distribution tails heavier than normal, and values above 1.0 make it lighter than normal. Defaults to (0.5, 8.0).</p> <code>noise_limit</code> <code>ScaleFloatType</code> <p>Multiplicative factor that controls the strength of kernel noise. Must be positive and preferably centered around 1.0. If a single value is provided, <code>noise_limit</code> will be in the range (0, noise_limit). Defaults to (0.75, 1.25).</p> <code>p</code> <code>float</code> <p>Probability of applying the transform. Defaults to 0.5.</p> <p>Reference</p> <p>\"Real-ESRGAN: Training Real-World Blind Super-Resolution with Pure Synthetic Data\", available at https://arxiv.org/abs/2107.10833</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class AdvancedBlur(ImageOnlyTransform):\n    \"\"\"Blurs the input image using a Generalized Normal filter with randomly selected parameters.\n\n    This transform also adds multiplicative noise to the generated kernel before convolution,\n    affecting the image in a unique way that combines blurring and noise injection for enhanced\n    data augmentation.\n\n    Args:\n        blur_limit (ScaleIntType, optional): Maximum Gaussian kernel size for blurring the input image.\n            Must be zero or odd and in range [0, inf). If set to 0, it will be computed from sigma\n            as `round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1`.\n            If a single value is provided, `blur_limit` will be in the range (0, blur_limit).\n            Defaults to (3, 7).\n        sigma_x_limit ScaleFloatType: Gaussian kernel standard deviation for the X dimension.\n            Must be in range [0, inf). If a single value is provided, `sigma_x_limit` will be in the range\n            (0, sigma_limit). If set to 0, sigma will be computed as `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.\n            Defaults to (0.2, 1.0).\n        sigma_y_limit ScaleFloatType: Gaussian kernel standard deviation for the Y dimension.\n            Must follow the same rules as `sigma_x_limit`.\n            Defaults to (0.2, 1.0).\n        rotate_limit (ScaleIntType, optional): Range from which a random angle used to rotate the Gaussian kernel\n            is picked. If limit is a single int, an angle is picked from (-rotate_limit, rotate_limit).\n            Defaults to (-90, 90).\n        beta_limit (ScaleFloatType, optional): Distribution shape parameter. 1 represents the normal distribution.\n            Values below 1.0 make distribution tails heavier than normal, and values above 1.0 make it\n            lighter than normal.\n            Defaults to (0.5, 8.0).\n        noise_limit (ScaleFloatType, optional): Multiplicative factor that controls the strength of kernel noise.\n            Must be positive and preferably centered around 1.0. If a single value is provided,\n            `noise_limit` will be in the range (0, noise_limit).\n            Defaults to (0.75, 1.25).\n        p (float, optional): Probability of applying the transform.\n            Defaults to 0.5.\n\n    Reference:\n        \"Real-ESRGAN: Training Real-World Blind Super-Resolution with Pure Synthetic Data\",\n        available at https://arxiv.org/abs/2107.10833\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BlurInitSchema):\n        sigma_x_limit: NonNegativeFloatRangeType = (0.2, 1.0)\n        sigma_y_limit: NonNegativeFloatRangeType = (0.2, 1.0)\n        beta_limit: NonNegativeFloatRangeType = (0.5, 8.0)\n        noise_limit: NonNegativeFloatRangeType = (0.75, 1.25)\n        rotate_limit: SymmetricRangeType = (-90, 90)\n\n        @field_validator(\"beta_limit\")\n        @classmethod\n        def check_beta_limit(cls, value: ScaleFloatType) -&gt; Tuple[float, float]:\n            result = to_tuple(value, low=0)\n            if not (result[0] &lt; 1.0 &lt; result[1]):\n                msg = \"beta_limit is expected to include 1.0.\"\n                raise ValueError(msg)\n            return result\n\n        @model_validator(mode=\"after\")\n        def validate_limits(self) -&gt; Self:\n            if (\n                isinstance(self.sigma_x_limit, (tuple, list))\n                and self.sigma_x_limit[0] == 0\n                and isinstance(self.sigma_y_limit, (tuple, list))\n                and self.sigma_y_limit[0] == 0\n            ):\n                msg = \"sigma_x_limit and sigma_y_limit minimum value cannot be both equal to 0.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = (3, 7),\n        sigma_x_limit: ScaleFloatType = (0.2, 1.0),\n        sigma_y_limit: ScaleFloatType = (0.2, 1.0),\n        sigmaX_limit: Optional[ScaleFloatType] = None,  # noqa: N803\n        sigmaY_limit: Optional[ScaleFloatType] = None,  # noqa: N803\n        rotate_limit: ScaleIntType = 90,\n        beta_limit: ScaleFloatType = (0.5, 8.0),\n        noise_limit: ScaleFloatType = (0.9, 1.1),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        if sigmaX_limit is not None:\n            warnings.warn(\"sigmaX_limit is deprecated; use sigma_x_limit instead.\", DeprecationWarning)\n            sigma_x_limit = sigmaX_limit\n\n        if sigmaY_limit is not None:\n            warnings.warn(\"sigmaY_limit is deprecated; use sigma_y_limit instead.\", DeprecationWarning)\n            sigma_y_limit = sigmaY_limit\n\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n        self.sigma_x_limit = cast(Tuple[float, float], sigma_x_limit)\n        self.sigma_y_limit = cast(Tuple[float, float], sigma_y_limit)\n        self.rotate_limit = cast(Tuple[int, int], rotate_limit)\n        self.beta_limit = cast(Tuple[float, float], beta_limit)\n        self.noise_limit = cast(Tuple[float, float], noise_limit)\n\n    def apply(self, img: np.ndarray, kernel: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return FMain.convolve(img, kernel=kernel)\n\n    def get_params(self) -&gt; Dict[str, np.ndarray]:\n        ksize = random.randrange(self.blur_limit[0], self.blur_limit[1] + 1, 2)\n        sigma_x = random_utils.uniform(*self.sigma_x_limit)\n        sigma_y = random_utils.uniform(*self.sigma_y_limit)\n        angle = np.deg2rad(random.uniform(*self.rotate_limit))\n\n        # Split into 2 cases to avoid selection of narrow kernels (beta &gt; 1) too often.\n        beta = (\n            random.uniform(self.beta_limit[0], 1) if random.random() &lt; HALF else random.uniform(1, self.beta_limit[1])\n        )\n\n        noise_matrix = random_utils.uniform(self.noise_limit[0], self.noise_limit[1], size=[ksize, ksize])\n\n        # Generate mesh grid centered at zero.\n        ax = np.arange(-ksize // 2 + 1.0, ksize // 2 + 1.0)\n        # &gt; Shape (ksize, ksize, 2)\n        grid = np.stack(np.meshgrid(ax, ax), axis=-1)\n\n        # Calculate rotated sigma matrix\n        d_matrix = np.array([[sigma_x**2, 0], [0, sigma_y**2]])\n        u_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])\n        sigma_matrix = np.dot(u_matrix, np.dot(d_matrix, u_matrix.T))\n\n        inverse_sigma = np.linalg.inv(sigma_matrix)\n        # Described in \"Parameter Estimation For Multivariate Generalized Gaussian Distributions\"\n        kernel = np.exp(-0.5 * np.power(np.sum(np.dot(grid, inverse_sigma) * grid, 2), beta))\n        # Add noise\n        kernel *= noise_matrix\n\n        # Normalize kernel\n        kernel = kernel.astype(np.float32) / np.sum(kernel)\n        return {\"kernel\": kernel}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str, str, str]:\n        return (\n            \"blur_limit\",\n            \"sigma_x_limit\",\n            \"sigma_y_limit\",\n            \"rotate_limit\",\n            \"beta_limit\",\n            \"noise_limit\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/blur/transforms/#albumentations.augmentations.blur.transforms.Blur","title":"<code>class  Blur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Blur the input image using a random-sized kernel.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <p>maximum kernel size for blurring the input image. Should be in range [3, inf). Default: (3, 7).</p> <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class Blur(ImageOnlyTransform):\n    \"\"\"Blur the input image using a random-sized kernel.\n\n    Args:\n        blur_limit: maximum kernel size for blurring the input image.\n            Should be in range [3, inf). Default: (3, 7).\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BlurInitSchema):\n        pass\n\n    def __init__(self, blur_limit: ScaleIntType = 7, always_apply: bool = False, p: float = 0.5):\n        super().__init__(always_apply, p)\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n\n    def apply(self, img: np.ndarray, kernel: int = 3, **params: Any) -&gt; np.ndarray:\n        return F.blur(img, kernel)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\"ksize\": int(random.choice(list(range(self.blur_limit[0], self.blur_limit[1] + 1, 2))))}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"blur_limit\",)\n</code></pre>"},{"location":"api_reference/augmentations/blur/transforms/#albumentations.augmentations.blur.transforms.Defocus","title":"<code>class  Defocus</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply defocus transform.</p> <p>Parameters:</p> Name Type Description <code>radius</code> <code>int, int) or int</code> <p>range for radius of defocusing. If limit is a single int, the range will be [1, limit]. Default: (3, 10).</p> <code>alias_blur</code> <code>float, float) or float</code> <p>range for alias_blur of defocusing (sigma of gaussian blur). If limit is a single float, the range will be (0, limit). Default: (0.1, 0.5).</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     unit8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1903.12261</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class Defocus(ImageOnlyTransform):\n    \"\"\"Apply defocus transform.\n\n    Args:\n        radius ((int, int) or int): range for radius of defocusing.\n            If limit is a single int, the range will be [1, limit]. Default: (3, 10).\n        alias_blur ((float, float) or float): range for alias_blur of defocusing (sigma of gaussian blur).\n            If limit is a single float, the range will be (0, limit). Default: (0.1, 0.5).\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        unit8, float32\n\n    Reference:\n        https://arxiv.org/abs/1903.12261\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        radius: OnePlusIntRangeType = (3, 10)\n        alias_blur: NonNegativeFloatRangeType = (0.1, 0.5)\n\n    def __init__(\n        self,\n        radius: ScaleIntType = (3, 10),\n        alias_blur: ScaleFloatType = (0.1, 0.5),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.radius = cast(Tuple[int, int], radius)\n        self.alias_blur = cast(Tuple[float, float], alias_blur)\n\n    def apply(self, img: np.ndarray, radius: int = 3, alias_blur: float = 0.5, **params: Any) -&gt; np.ndarray:\n        return F.defocus(img, radius, alias_blur)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"radius\": random_utils.randint(self.radius[0], self.radius[1] + 1),\n            \"alias_blur\": random_utils.uniform(self.alias_blur[0], self.alias_blur[1]),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"radius\", \"alias_blur\")\n</code></pre>"},{"location":"api_reference/augmentations/blur/transforms/#albumentations.augmentations.blur.transforms.GaussianBlur","title":"<code>class  GaussianBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Blur the input image using a Gaussian filter with a random kernel size.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <code>int, (int, int</code> <p>maximum Gaussian kernel size for blurring the input image. Must be zero or odd and in range [0, inf). If set to 0 it will be computed from sigma as <code>round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1</code>. If set single value <code>blur_limit</code> will be in range (0, blur_limit). Default: (3, 7).</p> <code>sigma_limit</code> <code>float, (float, float</code> <p>Gaussian kernel standard deviation. Must be in range [0, inf). If set single value <code>sigma_limit</code> will be in range (0, sigma_limit). If set to 0 sigma will be computed as <code>sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8</code>. Default: 0.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class GaussianBlur(ImageOnlyTransform):\n    \"\"\"Blur the input image using a Gaussian filter with a random kernel size.\n\n    Args:\n        blur_limit (int, (int, int)): maximum Gaussian kernel size for blurring the input image.\n            Must be zero or odd and in range [0, inf). If set to 0 it will be computed from sigma\n            as `round(sigma * (3 if img.dtype == np.uint8 else 4) * 2 + 1) + 1`.\n            If set single value `blur_limit` will be in range (0, blur_limit).\n            Default: (3, 7).\n        sigma_limit (float, (float, float)): Gaussian kernel standard deviation. Must be in range [0, inf).\n            If set single value `sigma_limit` will be in range (0, sigma_limit).\n            If set to 0 sigma will be computed as `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`. Default: 0.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BlurInitSchema):\n        sigma_limit: NonNegativeFloatRangeType = 0\n\n        @field_validator(\"blur_limit\")\n        @classmethod\n        def process_blur(cls, value: ScaleIntType, info: ValidationInfo) -&gt; Tuple[int, int]:\n            return process_blur_limit(value, info, min_value=0)\n\n        @model_validator(mode=\"after\")\n        def validate_limits(self) -&gt; Self:\n            if (\n                isinstance(self.blur_limit, (tuple, list))\n                and self.blur_limit[0] == 0\n                and isinstance(self.sigma_limit, (tuple, list))\n                and self.sigma_limit[0] == 0\n            ):\n                self.blur_limit = 3, max(3, self.blur_limit[1])\n                warnings.warn(\n                    \"blur_limit and sigma_limit minimum value can not be both equal to 0. \"\n                    \"blur_limit minimum value changed to 3.\"\n                )\n\n            if isinstance(self.blur_limit, tuple):\n                for v in self.blur_limit:\n                    if v != 0 and v % 2 != 1:\n                        raise ValueError(f\"Blur limit must be 0 or odd. Got: {self.blur_limit}\")\n\n            return self\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = (3, 7),\n        sigma_limit: ScaleFloatType = 0,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n        self.sigma_limit = cast(Tuple[float, float], sigma_limit)\n\n    def apply(self, img: np.ndarray, ksize: int = 3, sigma: float = 0, **params: Any) -&gt; np.ndarray:\n        return F.gaussian_blur(img, ksize, sigma=sigma)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        ksize = random.randrange(self.blur_limit[0], self.blur_limit[1] + 1)\n        if ksize != 0 and ksize % 2 != 1:\n            ksize = (ksize + 1) % (self.blur_limit[1] + 1)\n\n        return {\"ksize\": ksize, \"sigma\": random.uniform(*self.sigma_limit)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"blur_limit\", \"sigma_limit\")\n</code></pre>"},{"location":"api_reference/augmentations/blur/transforms/#albumentations.augmentations.blur.transforms.GlassBlur","title":"<code>class  GlassBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply glass noise to the input image.</p> <p>Parameters:</p> Name Type Description <code>sigma</code> <code>float</code> <p>standard deviation for Gaussian kernel.</p> <code>max_delta</code> <code>int</code> <p>max distance between pixels which are swapped.</p> <code>iterations</code> <code>int</code> <p>number of repeats. Should be in range [1, inf). Default: (2).</p> <code>mode</code> <code>str</code> <p>mode of computation: fast or exact. Default: \"fast\".</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1903.12261 https://github.com/hendrycks/robustness/blob/master/ImageNet-C/create_c/make_imagenet_c.py</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class GlassBlur(ImageOnlyTransform):\n    \"\"\"Apply glass noise to the input image.\n\n    Args:\n        sigma (float): standard deviation for Gaussian kernel.\n        max_delta (int): max distance between pixels which are swapped.\n        iterations (int): number of repeats.\n            Should be in range [1, inf). Default: (2).\n        mode (str): mode of computation: fast or exact. Default: \"fast\".\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://arxiv.org/abs/1903.12261\n        https://github.com/hendrycks/robustness/blob/master/ImageNet-C/create_c/make_imagenet_c.py\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        sigma: float = Field(default=0.7, ge=0, description=\"Standard deviation for the Gaussian kernel.\")\n        max_delta: int = Field(default=4, ge=1, description=\"Maximum distance between pixels that are swapped.\")\n        iterations: int = Field(default=2, ge=1, description=\"Number of times the glass noise effect is applied.\")\n        mode: Literal[\"fast\", \"exact\"] = \"fast\"\n\n    def __init__(\n        self,\n        sigma: float = 0.7,\n        max_delta: int = 4,\n        iterations: int = 2,\n        mode: Literal[\"fast\", \"exact\"] = \"fast\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n        self.sigma = sigma\n        self.max_delta = max_delta\n        self.iterations = iterations\n        self.mode = mode\n\n    def apply(self, img: np.ndarray, *args: Any, dxy: np.ndarray = None, **params: Any) -&gt; np.ndarray:\n        if dxy is None:\n            msg = \"dxy is None\"\n            raise ValueError(msg)\n\n        return F.glass_blur(img, self.sigma, self.max_delta, self.iterations, dxy, self.mode)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, np.ndarray]:\n        img = params[\"image\"]\n\n        height, width = img.shape[:2]\n\n        # generate array containing all necessary values for transformations\n        width_pixels = height - self.max_delta * 2\n        height_pixels = width - self.max_delta * 2\n        total_pixels = int(width_pixels * height_pixels)\n        dxy = random_utils.randint(-self.max_delta, self.max_delta, size=(total_pixels, self.iterations, 2))\n\n        return {\"dxy\": dxy}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"sigma\", \"max_delta\", \"iterations\", \"mode\")\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n</code></pre>"},{"location":"api_reference/augmentations/blur/transforms/#albumentations.augmentations.blur.transforms.MedianBlur","title":"<code>class  MedianBlur</code> <code>       (blur_limit=7, always_apply=False, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Blur the input image using a median filter with a random aperture linear size.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <code>int</code> <p>maximum aperture linear size for blurring the input image. Must be odd and in range [3, inf). Default: (3, 7).</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class MedianBlur(Blur):\n    \"\"\"Blur the input image using a median filter with a random aperture linear size.\n\n    Args:\n        blur_limit (int): maximum aperture linear size for blurring the input image.\n            Must be odd and in range [3, inf). Default: (3, 7).\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    def __init__(self, blur_limit: ScaleIntType = 7, always_apply: bool = False, p: float = 0.5):\n        super().__init__(blur_limit, always_apply, p)\n\n    def apply(self, img: np.ndarray, kernel: int = 3, **params: Any) -&gt; np.ndarray:\n        return F.median_blur(img, kernel)\n</code></pre>"},{"location":"api_reference/augmentations/blur/transforms/#albumentations.augmentations.blur.transforms.MedianBlur.__init__","title":"<code>__init__ (self, blur_limit=7, always_apply=False, p=0.5)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>def __init__(self, blur_limit: ScaleIntType = 7, always_apply: bool = False, p: float = 0.5):\n    super().__init__(blur_limit, always_apply, p)\n</code></pre>"},{"location":"api_reference/augmentations/blur/transforms/#albumentations.augmentations.blur.transforms.MotionBlur","title":"<code>class  MotionBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply motion blur to the input image using a random-sized kernel.</p> <p>Parameters:</p> Name Type Description <code>blur_limit</code> <code>int</code> <p>maximum kernel size for blurring the input image. Should be in range [3, inf). Default: (3, 7).</p> <code>allow_shifted</code> <code>bool</code> <p>if set to true creates non shifted kernels only, otherwise creates randomly shifted kernels. Default: True.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class MotionBlur(Blur):\n    \"\"\"Apply motion blur to the input image using a random-sized kernel.\n\n    Args:\n        blur_limit (int): maximum kernel size for blurring the input image.\n            Should be in range [3, inf). Default: (3, 7).\n        allow_shifted (bool): if set to true creates non shifted kernels only,\n            otherwise creates randomly shifted kernels. Default: True.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        allow_shifted: bool = Field(\n            default=True,\n            description=\"If set to true creates non-shifted kernels only, otherwise creates randomly shifted kernels.\",\n        )\n        blur_limit: ScaleIntType = Field(\n            default=(3, 7), description=\"Maximum kernel size for blurring the input image.\"\n        )\n\n        @model_validator(mode=\"after\")\n        def process_blur(self) -&gt; Self:\n            self.blur_limit = cast(Tuple[int, int], to_tuple(self.blur_limit, 3))\n\n            if self.allow_shifted and isinstance(self.blur_limit, tuple) and any(x % 2 != 1 for x in self.blur_limit):\n                raise ValueError(f\"Blur limit must be odd when centered=True. Got: {self.blur_limit}\")\n\n            return self\n\n    def __init__(\n        self,\n        blur_limit: ScaleIntType = 7,\n        allow_shifted: bool = True,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(blur_limit=blur_limit, always_apply=always_apply, p=p)\n        self.allow_shifted = allow_shifted\n        self.blur_limit = cast(Tuple[int, int], blur_limit)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (*super().get_transform_init_args_names(), \"allow_shifted\")\n\n    def apply(self, img: np.ndarray, kernel: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return FMain.convolve(img, kernel=kernel)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        ksize = random.choice(list(range(self.blur_limit[0], self.blur_limit[1] + 1, 2)))\n        if ksize &lt;= TWO:\n            raise ValueError(f\"ksize must be &gt; 2. Got: {ksize}\")\n        kernel = np.zeros((ksize, ksize), dtype=np.uint8)\n        x1, x2 = random.randint(0, ksize - 1), random.randint(0, ksize - 1)\n        if x1 == x2:\n            y1, y2 = random.sample(range(ksize), 2)\n        else:\n            y1, y2 = random.randint(0, ksize - 1), random.randint(0, ksize - 1)\n\n        def make_odd_val(v1: int, v2: int) -&gt; Tuple[int, int]:\n            len_v = abs(v1 - v2) + 1\n            if len_v % 2 != 1:\n                if v2 &gt; v1:\n                    v2 -= 1\n                else:\n                    v1 -= 1\n            return v1, v2\n\n        if not self.allow_shifted:\n            x1, x2 = make_odd_val(x1, x2)\n            y1, y2 = make_odd_val(y1, y2)\n\n            xc = (x1 + x2) / 2\n            yc = (y1 + y2) / 2\n\n            center = ksize / 2 - 0.5\n            dx = xc - center\n            dy = yc - center\n            x1, x2 = (int(i - dx) for i in [x1, x2])\n            y1, y2 = (int(i - dy) for i in [y1, y2])\n\n        cv2.line(kernel, (x1, y1), (x2, y2), 1, thickness=1)\n\n        # Normalize kernel\n        return {\"kernel\": kernel.astype(np.float32) / np.sum(kernel)}\n</code></pre>"},{"location":"api_reference/augmentations/blur/transforms/#albumentations.augmentations.blur.transforms.ZoomBlur","title":"<code>class  ZoomBlur</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply zoom blur transform.</p> <p>Parameters:</p> Name Type Description <code>max_factor</code> <code>float, float) or float</code> <p>range for max factor for blurring. If max_factor is a single float, the range will be (1, limit). Default: (1, 1.31). All max_factor values should be larger than 1.</p> <code>step_factor</code> <code>float, float) or float</code> <p>If single float will be used as step parameter for np.arange. If tuple of float step_factor will be in range <code>[step_factor[0], step_factor[1])</code>. Default: (0.01, 0.03). All step_factor values should be positive.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     unit8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1903.12261</p> Source code in <code>albumentations/augmentations/blur/transforms.py</code> Python<pre><code>class ZoomBlur(ImageOnlyTransform):\n    \"\"\"Apply zoom blur transform.\n\n    Args:\n        max_factor ((float, float) or float): range for max factor for blurring.\n            If max_factor is a single float, the range will be (1, limit). Default: (1, 1.31).\n            All max_factor values should be larger than 1.\n        step_factor ((float, float) or float): If single float will be used as step parameter for np.arange.\n            If tuple of float step_factor will be in range `[step_factor[0], step_factor[1])`. Default: (0.01, 0.03).\n            All step_factor values should be positive.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        unit8, float32\n\n    Reference:\n        https://arxiv.org/abs/1903.12261\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        max_factor: OnePlusFloatRangeType = (1, 1.31)\n        step_factor: NonNegativeFloatRangeType = (0.01, 0.03)\n\n    def __init__(\n        self,\n        max_factor: ScaleFloatType = (1, 1.31),\n        step_factor: ScaleFloatType = (0.01, 0.03),\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.max_factor = cast(Tuple[float, float], max_factor)\n        self.step_factor = cast(Tuple[float, float], step_factor)\n\n    def apply(self, img: np.ndarray, zoom_factors: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        if zoom_factors is None:\n            msg = \"zoom_factors is None\"\n            raise ValueError(msg)\n\n        return F.zoom_blur(img, zoom_factors)\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        max_factor = random.uniform(self.max_factor[0], self.max_factor[1])\n        step_factor = random.uniform(self.step_factor[0], self.step_factor[1])\n        return {\"zoom_factors\": np.arange(1.0, max_factor, step_factor)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"max_factor\", \"step_factor\")\n</code></pre>"},{"location":"api_reference/augmentations/crops/","title":"Index","text":"<ul> <li>Crop functional transforms (albumentations.augmentations.crops.functional)</li> <li>Crop transforms (albumentations.augmentations.crops.transforms)</li> </ul>"},{"location":"api_reference/augmentations/crops/functional/","title":"Crop functional transforms (augmentations.crops.functional)","text":""},{"location":"api_reference/augmentations/crops/functional/#albumentations.augmentations.crops.functional.bbox_crop","title":"<code>def bbox_crop    (bbox, x_min, y_min, x_max, y_max, rows, cols)    </code> [view source on GitHub]","text":"<p>Crop a bounding box.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>x_min</code> <code>int</code> <code>y_min</code> <code>int</code> <code>x_max</code> <code>int</code> <code>y_max</code> <code>int</code> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A cropped bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def bbox_crop(\n    bbox: BoxInternalType, x_min: int, y_min: int, x_max: int, y_max: int, rows: int, cols: int\n) -&gt; BoxInternalType:\n    \"\"\"Crop a bounding box.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        x_min:\n        y_min:\n        x_max:\n        y_max:\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A cropped bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    crop_coords = x_min, y_min, x_max, y_max\n    crop_height = y_max - y_min\n    crop_width = x_max - x_min\n    return crop_bbox_by_coords(bbox, crop_coords, crop_height, crop_width, rows, cols)\n</code></pre>"},{"location":"api_reference/augmentations/crops/functional/#albumentations.augmentations.crops.functional.crop_bbox_by_coords","title":"<code>def crop_bbox_by_coords    (bbox, crop_coords, crop_height, crop_width, rows, cols)    </code> [view source on GitHub]","text":"<p>Crop a bounding box using the provided coordinates of bottom-left and top-right corners in pixels and the required height and width of the crop.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A cropped box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>crop_coords</code> <code>Tuple[int, int, int, int]</code> <p>Crop coordinates <code>(x1, y1, x2, y2)</code>.</p> <code>crop_height</code> <code>int</code> <code>crop_width</code> <code>int</code> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A cropped bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def crop_bbox_by_coords(\n    bbox: BoxInternalType,\n    crop_coords: Tuple[int, int, int, int],\n    crop_height: int,\n    crop_width: int,\n    rows: int,\n    cols: int,\n) -&gt; BoxInternalType:\n    \"\"\"Crop a bounding box using the provided coordinates of bottom-left and top-right corners in pixels and the\n    required height and width of the crop.\n\n    Args:\n        bbox: A cropped box `(x_min, y_min, x_max, y_max)`.\n        crop_coords: Crop coordinates `(x1, y1, x2, y2)`.\n        crop_height:\n        crop_width:\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A cropped bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    normalized_bbox = denormalize_bbox(bbox, rows, cols)\n    x_min, y_min, x_max, y_max = normalized_bbox[:4]\n    x1, y1 = crop_coords[:2]\n    cropped_bbox = x_min - x1, y_min - y1, x_max - x1, y_max - y1\n    return cast(BoxInternalType, normalize_bbox(cropped_bbox, crop_height, crop_width))\n</code></pre>"},{"location":"api_reference/augmentations/crops/functional/#albumentations.augmentations.crops.functional.crop_keypoint_by_coords","title":"<code>def crop_keypoint_by_coords    (keypoint, crop_coords)    </code> [view source on GitHub]","text":"<p>Crop a keypoint using the provided coordinates of bottom-left and top-right corners in pixels and the required height and width of the crop.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>tuple</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>crop_coords</code> <code>tuple</code> <p>Crop box coords <code>(x1, x2, y1, y2)</code>.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def crop_keypoint_by_coords(\n    keypoint: KeypointInternalType, crop_coords: Tuple[int, int, int, int]\n) -&gt; KeypointInternalType:\n    \"\"\"Crop a keypoint using the provided coordinates of bottom-left and top-right corners in pixels and the\n    required height and width of the crop.\n\n    Args:\n        keypoint (tuple): A keypoint `(x, y, angle, scale)`.\n        crop_coords (tuple): Crop box coords `(x1, x2, y1, y2)`.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    x1, y1 = crop_coords[:2]\n    return x - x1, y - y1, angle, scale\n</code></pre>"},{"location":"api_reference/augmentations/crops/functional/#albumentations.augmentations.crops.functional.keypoint_center_crop","title":"<code>def keypoint_center_crop    (keypoint, crop_height, crop_width, rows, cols)    </code> [view source on GitHub]","text":"<p>Keypoint center crop.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>crop_height</code> <code>int</code> <p>Crop height.</p> <code>crop_width</code> <code>int</code> <p>Crop width.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def keypoint_center_crop(\n    keypoint: KeypointInternalType, crop_height: int, crop_width: int, rows: int, cols: int\n) -&gt; KeypointInternalType:\n    \"\"\"Keypoint center crop.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        crop_height: Crop height.\n        crop_width: Crop width.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    crop_coords = get_center_crop_coords(rows, cols, crop_height, crop_width)\n    return crop_keypoint_by_coords(keypoint, crop_coords)\n</code></pre>"},{"location":"api_reference/augmentations/crops/functional/#albumentations.augmentations.crops.functional.keypoint_random_crop","title":"<code>def keypoint_random_crop    (keypoint, crop_height, crop_width, h_start, w_start, rows, cols)    </code> [view source on GitHub]","text":"<p>Keypoint random crop.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>(tuple): A keypoint <code>(x, y, angle, scale)</code>.</p> <code>crop_height</code> <code>int</code> <p>Crop height.</p> <code>crop_width</code> <code>int</code> <p>Crop width.</p> <code>h_start</code> <code>int</code> <p>Crop height start.</p> <code>w_start</code> <code>int</code> <p>Crop width start.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/crops/functional.py</code> Python<pre><code>def keypoint_random_crop(\n    keypoint: KeypointInternalType,\n    crop_height: int,\n    crop_width: int,\n    h_start: float,\n    w_start: float,\n    rows: int,\n    cols: int,\n) -&gt; KeypointInternalType:\n    \"\"\"Keypoint random crop.\n\n    Args:\n        keypoint: (tuple): A keypoint `(x, y, angle, scale)`.\n        crop_height (int): Crop height.\n        crop_width (int): Crop width.\n        h_start (int): Crop height start.\n        w_start (int): Crop width start.\n        rows (int): Image height.\n        cols (int): Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    crop_coords = get_random_crop_coords(rows, cols, crop_height, crop_width, h_start, w_start)\n    return crop_keypoint_by_coords(keypoint, crop_coords)\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/","title":"Crop transforms (augmentations.crops.transforms)","text":""},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.BBoxSafeRandomCrop","title":"<code>class  BBoxSafeRandomCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop a random part of the input without loss of bboxes.</p> <p>Parameters:</p> Name Type Description <code>erosion_rate</code> <p>erosion rate applied on input image height before crop.</p> <code>p</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class BBoxSafeRandomCrop(DualTransform):\n    \"\"\"Crop a random part of the input without loss of bboxes.\n\n    Args:\n        erosion_rate: erosion rate applied on input image height before crop.\n        p: probability of applying the transform. Default: 1.\n    Targets:\n        image, mask, bboxes\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        erosion_rate: float = Field(\n            default=0.0, ge=0.0, le=1.0, description=\"Erosion rate applied on input image height before crop.\"\n        )\n        p: ProbabilityType = 1\n\n    def __init__(self, erosion_rate: float = 0.0, always_apply: bool = False, p: float = 1.0):\n        super().__init__(always_apply, p)\n        self.erosion_rate = erosion_rate\n\n    def apply(\n        self,\n        img: np.ndarray,\n        crop_height: int = 0,\n        crop_width: int = 0,\n        h_start: int = 0,\n        w_start: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.random_crop(img, crop_height, crop_width, h_start, w_start)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Union[int, float]]:\n        img_h, img_w = params[\"image\"].shape[:2]\n        if len(params[\"bboxes\"]) == 0:  # less likely, this class is for use with bboxes.\n            erosive_h = int(img_h * (1.0 - self.erosion_rate))\n            crop_height = img_h if erosive_h &gt;= img_h else random.randint(erosive_h, img_h)\n            return {\n                \"h_start\": random.random(),\n                \"w_start\": random.random(),\n                \"crop_height\": crop_height,\n                \"crop_width\": int(crop_height * img_w / img_h),\n            }\n        # get union of all bboxes\n        x, y, x2, y2 = union_of_bboxes(\n            width=img_w, height=img_h, bboxes=params[\"bboxes\"], erosion_rate=self.erosion_rate\n        )\n        # find bigger region\n        bx, by = x * random.random(), y * random.random()\n        bx2, by2 = x2 + (1 - x2) * random.random(), y2 + (1 - y2) * random.random()\n        bw, bh = bx2 - bx, by2 - by\n        crop_height = img_h if bh &gt;= 1.0 else int(img_h * bh)\n        crop_width = img_w if bw &gt;= 1.0 else int(img_w * bw)\n        h_start = np.clip(0.0 if bh &gt;= 1.0 else by / (1.0 - bh), 0.0, 1.0)\n        w_start = np.clip(0.0 if bw &gt;= 1.0 else bx / (1.0 - bw), 0.0, 1.0)\n        return {\"h_start\": h_start, \"w_start\": w_start, \"crop_height\": crop_height, \"crop_width\": crop_width}\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        crop_height: int = 0,\n        crop_width: int = 0,\n        h_start: int = 0,\n        w_start: int = 0,\n        rows: int = 0,\n        cols: int = 0,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.bbox_random_crop(bbox, crop_height, crop_width, h_start, w_start, rows, cols)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\", \"bboxes\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"erosion_rate\",)\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.CenterCrop","title":"<code>class  CenterCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop the central part of the input.</p> <p>Parameters:</p> Name Type Description <code>height</code> <p>height of the crop.</p> <code>width</code> <p>width of the crop.</p> <code>p</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class CenterCrop(DualTransform):\n    \"\"\"Crop the central part of the input.\n\n    Args:\n        height: height of the crop.\n        width: width of the crop.\n        p: probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(CropInitSchema):\n        pass\n\n    def __init__(self, height: int, width: int, always_apply: bool = False, p: float = 1.0):\n        super().__init__(always_apply, p)\n        self.height = height\n        self.width = width\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.center_crop(img, self.height, self.width)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_center_crop(bbox, self.height, self.width, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_center_crop(keypoint, self.height, self.width, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"height\", \"width\")\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.Crop","title":"<code>class  Crop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop region from image.</p> <p>Parameters:</p> Name Type Description <code>x_min</code> <p>Minimum upper left x coordinate.</p> <code>y_min</code> <p>Minimum upper left y coordinate.</p> <code>x_max</code> <p>Maximum lower right x coordinate.</p> <code>y_max</code> <p>Maximum lower right y coordinate.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class Crop(DualTransform):\n    \"\"\"Crop region from image.\n\n    Args:\n        x_min: Minimum upper left x coordinate.\n        y_min: Minimum upper left y coordinate.\n        x_max: Maximum lower right x coordinate.\n        y_max: Maximum lower right y coordinate.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        x_min: Annotated[int, Field(ge=0, description=\"Minimum upper left x coordinate\")]\n        y_min: Annotated[int, Field(ge=0, description=\"Minimum upper left y coordinate\")]\n        x_max: Annotated[int, Field(gt=0, description=\"Maximum lower right x coordinate\")]\n        y_max: Annotated[int, Field(gt=0, description=\"Maximum lower right y coordinate\")]\n        p: ProbabilityType = 1\n\n        @model_validator(mode=\"after\")\n        def validate_coordinates(self) -&gt; Self:\n            if not self.x_min &lt; self.x_max:\n                msg = \"x_max must be greater than x_min\"\n                raise ValueError(msg)\n            if not self.y_min &lt; self.y_max:\n                msg = \"y_max must be greater than y_min\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        x_min: int = 0,\n        y_min: int = 0,\n        x_max: int = 1024,\n        y_max: int = 1024,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n        self.x_min = x_min\n        self.y_min = y_min\n        self.x_max = x_max\n        self.y_max = y_max\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.crop(img, x_min=self.x_min, y_min=self.y_min, x_max=self.x_max, y_max=self.y_max)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_crop(bbox, x_min=self.x_min, y_min=self.y_min, x_max=self.x_max, y_max=self.y_max, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.crop_keypoint_by_coords(keypoint, crop_coords=(self.x_min, self.y_min, self.x_max, self.y_max))\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"x_min\", \"y_min\", \"x_max\", \"y_max\")\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.CropAndPad","title":"<code>class  CropAndPad</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop and pad images by pixel amounts or fractions of image sizes. Cropping removes pixels at the sides (i.e. extracts a subimage from a given full image). Padding adds pixels to the sides (e.g. black pixels). This transformation will never crop images below a height or width of <code>1</code>.</p> <p>Note</p> <p>This transformation automatically resizes images back to their original size. To deactivate this, add the parameter <code>keep_size=False</code>.</p> <p>Parameters:</p> Name Type Description <code>px</code> <code>int or tuple</code> <p>The number of pixels to crop (negative values) or pad (positive values) on each side of the image. Either this or the parameter <code>percent</code> may be set, not both at the same time.     * If <code>None</code>, then pixel-based cropping/padding will not be used.     * If <code>int</code>, then that exact number of pixels will always be cropped/padded.     * If a <code>tuple</code> of two <code>int</code> s with values <code>a</code> and <code>b</code>,       then each side will be cropped/padded by a random amount sampled       uniformly per image and side from the interval <code>[a, b]</code>. If       however <code>sample_independently</code> is set to <code>False</code>, only one       value will be sampled per image and used for all sides.     * If a <code>tuple</code> of four entries, then the entries represent top,       right, bottom, left. Each entry may be a single <code>int</code> (always       crop/pad by exactly that value), a <code>tuple</code> of two <code>int</code> s       <code>a</code> and <code>b</code> (crop/pad by an amount within <code>[a, b]</code>), a       <code>list</code> of <code>int</code> s (crop/pad by a random value that is       contained in the <code>list</code>).</p> <code>percent</code> <code>float or tuple</code> <p>The number of pixels to crop (negative values) or pad (positive values) on each side of the image given as a fraction of the image height/width. E.g. if this is set to <code>-0.1</code>, the transformation will always crop away <code>10%</code> of the image's height at both the top and the bottom (both <code>10%</code> each), as well as <code>10%</code> of the width at the right and left. Expected value range is <code>(-1.0, inf)</code>. Either this or the parameter <code>px</code> may be set, not both at the same time.     * If <code>None</code>, then fraction-based cropping/padding will not be       used.     * If <code>float</code>, then that fraction will always be cropped/padded.     * If a <code>tuple</code> of two <code>float</code> s with values <code>a</code> and <code>b</code>,       then each side will be cropped/padded by a random fraction       sampled uniformly per image and side from the interval       <code>[a, b]</code>. If however <code>sample_independently</code> is set to       <code>False</code>, only one value will be sampled per image and used for       all sides.     * If a <code>tuple</code> of four entries, then the entries represent top,       right, bottom, left. Each entry may be a single <code>float</code>       (always crop/pad by exactly that percent value), a <code>tuple</code> of       two <code>float</code> s <code>a</code> and <code>b</code> (crop/pad by a fraction from       <code>[a, b]</code>), a <code>list</code> of <code>float</code> s (crop/pad by a random       value that is contained in the list).</p> <code>pad_mode</code> <code>int</code> <p>OpenCV border mode.</p> <code>pad_cval</code> <code>number, Sequence[number]</code> <p>The constant value to use if the pad mode is <code>BORDER_CONSTANT</code>.     * If <code>number</code>, then that value will be used.     * If a <code>tuple</code> of two <code>number</code> s and at least one of them is       a <code>float</code>, then a random number will be uniformly sampled per       image from the continuous interval <code>[a, b]</code> and used as the       value. If both <code>number</code> s are <code>int</code> s, the interval is       discrete.     * If a <code>list</code> of <code>number</code>, then a random value will be chosen       from the elements of the <code>list</code> and used as the value.</p> <code>pad_cval_mask</code> <code>number, Sequence[number]</code> <p>Same as pad_cval but only for masks.</p> <code>keep_size</code> <code>bool</code> <p>After cropping and padding, the result image will usually have a different height/width compared to the original input image. If this parameter is set to <code>True</code>, then the cropped/padded image will be resized to the input image's size, i.e. the output shape is always identical to the input shape.</p> <code>sample_independently</code> <code>bool</code> <p>If <code>False</code> and the values for <code>px</code>/<code>percent</code> result in exactly one probability distribution for all image sides, only one single value will be sampled from that probability distribution and used for all sides. I.e. the crop/pad amount then is the same for all sides. If <code>True</code>, four values will be sampled independently, one per side.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     any</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class CropAndPad(DualTransform):\n    \"\"\"Crop and pad images by pixel amounts or fractions of image sizes.\n    Cropping removes pixels at the sides (i.e. extracts a subimage from a given full image).\n    Padding adds pixels to the sides (e.g. black pixels).\n    This transformation will never crop images below a height or width of ``1``.\n\n    Note:\n        This transformation automatically resizes images back to their original size. To deactivate this, add the\n        parameter ``keep_size=False``.\n\n    Args:\n        px (int or tuple):\n            The number of pixels to crop (negative values) or pad (positive values)\n            on each side of the image. Either this or the parameter `percent` may\n            be set, not both at the same time.\n                * If ``None``, then pixel-based cropping/padding will not be used.\n                * If ``int``, then that exact number of pixels will always be cropped/padded.\n                * If a ``tuple`` of two ``int`` s with values ``a`` and ``b``,\n                  then each side will be cropped/padded by a random amount sampled\n                  uniformly per image and side from the interval ``[a, b]``. If\n                  however `sample_independently` is set to ``False``, only one\n                  value will be sampled per image and used for all sides.\n                * If a ``tuple`` of four entries, then the entries represent top,\n                  right, bottom, left. Each entry may be a single ``int`` (always\n                  crop/pad by exactly that value), a ``tuple`` of two ``int`` s\n                  ``a`` and ``b`` (crop/pad by an amount within ``[a, b]``), a\n                  ``list`` of ``int`` s (crop/pad by a random value that is\n                  contained in the ``list``).\n        percent (float or tuple):\n            The number of pixels to crop (negative values) or pad (positive values)\n            on each side of the image given as a *fraction* of the image\n            height/width. E.g. if this is set to ``-0.1``, the transformation will\n            always crop away ``10%`` of the image's height at both the top and the\n            bottom (both ``10%`` each), as well as ``10%`` of the width at the\n            right and left.\n            Expected value range is ``(-1.0, inf)``.\n            Either this or the parameter `px` may be set, not both\n            at the same time.\n                * If ``None``, then fraction-based cropping/padding will not be\n                  used.\n                * If ``float``, then that fraction will always be cropped/padded.\n                * If a ``tuple`` of two ``float`` s with values ``a`` and ``b``,\n                  then each side will be cropped/padded by a random fraction\n                  sampled uniformly per image and side from the interval\n                  ``[a, b]``. If however `sample_independently` is set to\n                  ``False``, only one value will be sampled per image and used for\n                  all sides.\n                * If a ``tuple`` of four entries, then the entries represent top,\n                  right, bottom, left. Each entry may be a single ``float``\n                  (always crop/pad by exactly that percent value), a ``tuple`` of\n                  two ``float`` s ``a`` and ``b`` (crop/pad by a fraction from\n                  ``[a, b]``), a ``list`` of ``float`` s (crop/pad by a random\n                  value that is contained in the list).\n        pad_mode (int): OpenCV border mode.\n        pad_cval (number, Sequence[number]):\n            The constant value to use if the pad mode is ``BORDER_CONSTANT``.\n                * If ``number``, then that value will be used.\n                * If a ``tuple`` of two ``number`` s and at least one of them is\n                  a ``float``, then a random number will be uniformly sampled per\n                  image from the continuous interval ``[a, b]`` and used as the\n                  value. If both ``number`` s are ``int`` s, the interval is\n                  discrete.\n                * If a ``list`` of ``number``, then a random value will be chosen\n                  from the elements of the ``list`` and used as the value.\n        pad_cval_mask (number, Sequence[number]): Same as pad_cval but only for masks.\n        keep_size (bool):\n            After cropping and padding, the result image will usually have a\n            different height/width compared to the original input image. If this\n            parameter is set to ``True``, then the cropped/padded image will be\n            resized to the input image's size, i.e. the output shape is always identical to the input shape.\n        sample_independently (bool):\n            If ``False`` *and* the values for `px`/`percent` result in exactly\n            *one* probability distribution for all image sides, only one single\n            value will be sampled from that probability distribution and used for\n            all sides. I.e. the crop/pad amount then is the same for all sides.\n            If ``True``, four values will be sampled independently, one per side.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        any\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        px: Optional[Union[int, Tuple[int, int], Tuple[int, int, int, int]]] = Field(\n            default=None, description=\"Number of pixels to crop (negative) or pad (positive).\"\n        )\n        percent: Optional[Union[float, Tuple[float, float], Tuple[float, float, float, float]]] = Field(\n            default=None, description=\"Fraction of image size to crop (negative) or pad (positive).\"\n        )\n        pad_mode: BorderModeType = cv2.BORDER_CONSTANT\n        pad_cval: ColorType = Field(default=0, description=\"Padding value if pad_mode is BORDER_CONSTANT.\")\n        pad_cval_mask: ColorType = Field(\n            default=0, description=\"Padding value for masks if pad_mode is BORDER_CONSTANT.\"\n        )\n        keep_size: bool = Field(\n            default=True,\n            description=\"Whether to resize the image back to the original size after cropping and padding.\",\n        )\n        sample_independently: bool = Field(\n            default=True, description=\"Whether to sample the crop/pad size independently for each side.\"\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        p: ProbabilityType = 1\n\n        @model_validator(mode=\"after\")\n        def check_px_percent(self) -&gt; Self:\n            if self.px is None and self.percent is None:\n                msg = \"px and percent are empty!\"\n                raise ValueError(msg)\n            if self.px is not None and self.percent is not None:\n                msg = \"Only px or percent may be set!\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        px: Optional[Union[int, List[int]]] = None,\n        percent: Optional[Union[float, List[float]]] = None,\n        pad_mode: int = cv2.BORDER_CONSTANT,\n        pad_cval: ColorType = 0,\n        pad_cval_mask: ColorType = 0,\n        keep_size: bool = True,\n        sample_independently: bool = True,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n\n        self.px = px\n        self.percent = percent\n\n        self.pad_mode = pad_mode\n        self.pad_cval = pad_cval\n        self.pad_cval_mask = pad_cval_mask\n\n        self.keep_size = keep_size\n        self.sample_independently = sample_independently\n\n        self.interpolation = interpolation\n\n    def apply(\n        self,\n        img: np.ndarray,\n        crop_params: Sequence[int] = (),\n        pad_params: Sequence[int] = (),\n        pad_value: float = 0,\n        rows: int = 0,\n        cols: int = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.crop_and_pad(\n            img, crop_params, pad_params, pad_value, rows, cols, interpolation, self.pad_mode, self.keep_size\n        )\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        crop_params: Optional[Sequence[int]] = None,\n        pad_params: Optional[Sequence[int]] = None,\n        pad_value_mask: Optional[float] = None,\n        rows: int = 0,\n        cols: int = 0,\n        interpolation: int = cv2.INTER_NEAREST,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.crop_and_pad(\n            mask, crop_params, pad_params, pad_value_mask, rows, cols, interpolation, self.pad_mode, self.keep_size\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        crop_params: Optional[Sequence[int]] = None,\n        pad_params: Optional[Sequence[int]] = None,\n        rows: int = 0,\n        cols: int = 0,\n        result_rows: int = 0,\n        result_cols: int = 0,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.crop_and_pad_bbox(bbox, crop_params, pad_params, rows, cols, result_rows, result_cols)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        crop_params: Optional[Sequence[int]] = None,\n        pad_params: Optional[Sequence[int]] = None,\n        rows: int = 0,\n        cols: int = 0,\n        result_rows: int = 0,\n        result_cols: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.crop_and_pad_keypoint(\n            keypoint, crop_params, pad_params, rows, cols, result_rows, result_cols, self.keep_size\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    @staticmethod\n    def __prevent_zero(val1: int, val2: int, max_val: int) -&gt; Tuple[int, int]:\n        regain = abs(max_val) + 1\n        regain1 = regain // 2\n        regain2 = regain // 2\n        if regain1 + regain2 &lt; regain:\n            regain1 += 1\n\n        if regain1 &gt; val1:\n            diff = regain1 - val1\n            regain1 = val1\n            regain2 += diff\n        elif regain2 &gt; val2:\n            diff = regain2 - val2\n            regain2 = val2\n            regain1 += diff\n\n        val1 = val1 - regain1\n        val2 = val2 - regain2\n\n        return val1, val2\n\n    @staticmethod\n    def _prevent_zero(crop_params: List[int], height: int, width: int) -&gt; List[int]:\n        top, right, bottom, left = crop_params\n\n        remaining_height = height - (top + bottom)\n        remaining_width = width - (left + right)\n\n        if remaining_height &lt; 1:\n            top, bottom = CropAndPad.__prevent_zero(top, bottom, height)\n        if remaining_width &lt; 1:\n            left, right = CropAndPad.__prevent_zero(left, right, width)\n\n        return [max(top, 0), max(right, 0), max(bottom, 0), max(left, 0)]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        if self.px is not None:\n            new_params = self._get_px_params()\n        else:\n            percent_params = self._get_percent_params()\n            new_params = [\n                int(percent_params[0] * height),\n                int(percent_params[1] * width),\n                int(percent_params[2] * height),\n                int(percent_params[3] * width),\n            ]\n\n        pad_params = [max(i, 0) for i in new_params]\n\n        crop_params = self._prevent_zero([-min(i, 0) for i in new_params], height, width)\n\n        top, right, bottom, left = crop_params\n        crop_params = [left, top, width - right, height - bottom]\n        result_rows = crop_params[3] - crop_params[1]\n        result_cols = crop_params[2] - crop_params[0]\n        if result_cols == width and result_rows == height:\n            crop_params = []\n\n        top, right, bottom, left = pad_params\n        pad_params = [top, bottom, left, right]\n        if any(pad_params):\n            result_rows += top + bottom\n            result_cols += left + right\n        else:\n            pad_params = []\n\n        return {\n            \"crop_params\": crop_params or None,\n            \"pad_params\": pad_params or None,\n            \"pad_value\": None if pad_params is None else self._get_pad_value(self.pad_cval),\n            \"pad_value_mask\": None if pad_params is None else self._get_pad_value(self.pad_cval_mask),\n            \"result_rows\": result_rows,\n            \"result_cols\": result_cols,\n        }\n\n    def _get_px_params(self) -&gt; List[int]:\n        if self.px is None:\n            msg = \"px is not set\"\n            raise ValueError(msg)\n\n        if isinstance(self.px, int):\n            params = [self.px] * 4\n        elif len(self.px) == TWO:\n            if self.sample_independently:\n                params = [random.randrange(*self.px) for _ in range(4)]\n            else:\n                px = random.randrange(*self.px)\n                params = [px] * 4\n        elif isinstance(self.px[0], int):\n            params = self.px\n        else:\n            params = [random.randrange(*i) for i in self.px]\n\n        return params\n\n    def _get_percent_params(self) -&gt; List[float]:\n        if self.percent is None:\n            msg = \"percent is not set\"\n            raise ValueError(msg)\n\n        if isinstance(self.percent, float):\n            params = [self.percent] * 4\n        elif len(self.percent) == TWO:\n            if self.sample_independently:\n                params = [random.uniform(*self.percent) for _ in range(4)]\n            else:\n                px = random.uniform(*self.percent)\n                params = [px] * 4\n        elif isinstance(self.percent[0], (int, float)):\n            params = self.percent\n        else:\n            params = [random.uniform(*i) for i in self.percent]\n\n        return params  # params = [top, right, bottom, left]\n\n    @staticmethod\n    def _get_pad_value(pad_value: Union[float, Sequence[float]]) -&gt; Union[int, float]:\n        if isinstance(pad_value, (int, float)):\n            return pad_value\n\n        if len(pad_value) == TWO:\n            a, b = pad_value\n            if isinstance(a, int) and isinstance(b, int):\n                return random.randint(a, b)\n\n            return random.uniform(a, b)\n\n        return random.choice(pad_value)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"px\",\n            \"percent\",\n            \"pad_mode\",\n            \"pad_cval\",\n            \"pad_cval_mask\",\n            \"keep_size\",\n            \"sample_independently\",\n            \"interpolation\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.CropNonEmptyMaskIfExists","title":"<code>class  CropNonEmptyMaskIfExists</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop area with mask if mask is non-empty, else make random crop.</p> <p>Parameters:</p> Name Type Description <code>height</code> <p>vertical size of crop in pixels</p> <code>width</code> <p>horizontal size of crop in pixels</p> <code>ignore_values</code> <code>list of int</code> <p>values to ignore in mask, <code>0</code> values are always ignored (e.g. if background value is 5 set <code>ignore_values=[5]</code> to ignore)</p> <code>ignore_channels</code> <code>list of int</code> <p>channels to ignore in mask (e.g. if background is a first channel set <code>ignore_channels=[0]</code> to ignore)</p> <code>p</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class CropNonEmptyMaskIfExists(DualTransform):\n    \"\"\"Crop area with mask if mask is non-empty, else make random crop.\n\n    Args:\n        height: vertical size of crop in pixels\n        width: horizontal size of crop in pixels\n        ignore_values (list of int): values to ignore in mask, `0` values are always ignored\n            (e.g. if background value is 5 set `ignore_values=[5]` to ignore)\n        ignore_channels (list of int): channels to ignore in mask\n            (e.g. if background is a first channel set `ignore_channels=[0]` to ignore)\n        p: probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(CropInitSchema):\n        ignore_values: Optional[List[int]] = Field(\n            default=None, description=\"Values to ignore in mask, `0` values are always ignored\"\n        )\n        ignore_channels: Optional[List[int]] = Field(default=None, description=\"Channels to ignore in mask\")\n\n    def __init__(\n        self,\n        height: int,\n        width: int,\n        ignore_values: Optional[List[int]] = None,\n        ignore_channels: Optional[List[int]] = None,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n\n        self.height = height\n        self.width = width\n        self.ignore_values = ignore_values\n        self.ignore_channels = ignore_channels\n\n    def apply(\n        self, img: np.ndarray, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        return F.crop(img, x_min, y_min, x_max, y_max)\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; BoxInternalType:\n        return F.bbox_crop(\n            bbox, x_min=x_min, x_max=x_max, y_min=y_min, y_max=y_max, rows=params[\"rows\"], cols=params[\"cols\"]\n        )\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        x_min: int = 0,\n        x_max: int = 0,\n        y_min: int = 0,\n        y_max: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.crop_keypoint_by_coords(keypoint, crop_coords=(x_min, y_min, x_max, y_max))\n\n    def _preprocess_mask(self, mask: np.ndarray) -&gt; np.ndarray:\n        mask_height, mask_width = mask.shape[:2]\n\n        if self.ignore_values is not None:\n            ignore_values_np = np.array(self.ignore_values)\n            mask = np.where(np.isin(mask, ignore_values_np), 0, mask)\n\n        if mask.ndim == THREE and self.ignore_channels is not None:\n            target_channels = np.array([ch for ch in range(mask.shape[-1]) if ch not in self.ignore_channels])\n            mask = np.take(mask, target_channels, axis=-1)\n\n        if self.height &gt; mask_height or self.width &gt; mask_width:\n            raise ValueError(\n                f\"Crop size ({self.height},{self.width}) is larger than image ({mask_height},{mask_width})\"\n            )\n\n        return mask\n\n    def update_params(self, params: Dict[str, Any], **kwargs: Any) -&gt; Dict[str, Any]:\n        super().update_params(params, **kwargs)\n        if \"mask\" in kwargs:\n            mask = self._preprocess_mask(kwargs[\"mask\"])\n        elif \"masks\" in kwargs and len(kwargs[\"masks\"]):\n            masks = kwargs[\"masks\"]\n            mask = self._preprocess_mask(np.copy(masks[0]))  # need copy as we perform in-place mod afterwards\n            for m in masks[1:]:\n                mask |= self._preprocess_mask(m)\n        else:\n            msg = \"Can not find mask for CropNonEmptyMaskIfExists\"\n            raise RuntimeError(msg)\n\n        mask_height, mask_width = mask.shape[:2]\n\n        if mask.any():\n            mask = mask.sum(axis=-1) if mask.ndim == THREE else mask\n            non_zero_yx = np.argwhere(mask)\n            y, x = random.choice(non_zero_yx)\n            x_min = x - random.randint(0, self.width - 1)\n            y_min = y - random.randint(0, self.height - 1)\n            x_min = np.clip(x_min, 0, mask_width - self.width)\n            y_min = np.clip(y_min, 0, mask_height - self.height)\n        else:\n            x_min = random.randint(0, mask_width - self.width)\n            y_min = random.randint(0, mask_height - self.height)\n\n        x_max = x_min + self.width\n        y_max = y_min + self.height\n\n        params.update({\"x_min\": x_min, \"x_max\": x_max, \"y_min\": y_min, \"y_max\": y_max})\n        return params\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str]:\n        return (\"height\", \"width\", \"ignore_values\", \"ignore_channels\")\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.RandomCrop","title":"<code>class  RandomCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop a random part of the input.</p> <p>Parameters:</p> Name Type Description <code>height</code> <p>height of the crop.</p> <code>width</code> <p>width of the crop.</p> <code>p</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomCrop(DualTransform):\n    \"\"\"Crop a random part of the input.\n\n    Args:\n        height: height of the crop.\n        width: width of the crop.\n        p: probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(CropInitSchema):\n        pass\n\n    def __init__(self, height: int, width: int, always_apply: bool = False, p: float = 1.0):\n        super().__init__(always_apply, p)\n        self.height = height\n        self.width = width\n\n    def apply(self, img: np.ndarray, h_start: int = 0, w_start: int = 0, **params: Any) -&gt; np.ndarray:\n        return F.random_crop(img, self.height, self.width, h_start, w_start)\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"h_start\": random.random(), \"w_start\": random.random()}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_random_crop(bbox, self.height, self.width, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_random_crop(keypoint, self.height, self.width, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"height\", \"width\")\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.RandomCropFromBorders","title":"<code>class  RandomCropFromBorders</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop bbox from image randomly cut parts from borders without resize at the end</p> <p>Parameters:</p> Name Type Description <code>crop_left</code> <code>float</code> <p>single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut</p> <code>crop_right</code> <code>float</code> <p>single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut</p> <code>crop_top</code> <code>float</code> <p>singlefloat value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut</p> <code>crop_bottom</code> <code>float</code> <p>single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomCropFromBorders(DualTransform):\n    \"\"\"Crop bbox from image randomly cut parts from borders without resize at the end\n\n    Args:\n        crop_left (float): single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut\n        from left side in range [0, crop_left * width)\n        crop_right (float): single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut\n        from right side in range [(1 - crop_right) * width, width)\n        crop_top (float): singlefloat value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut\n        from top side in range [0, crop_top * height)\n        crop_bottom (float): single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut\n        from bottom side in range [(1 - crop_bottom) * height, height)\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        crop_left: float = Field(\n            default=0.1, ge=0.0, le=1.0, description=\"Fraction of width to randomly crop from the left side.\"\n        )\n        crop_right: float = Field(\n            default=0.1, ge=0.0, le=1.0, description=\"Fraction of width to randomly crop from the right side.\"\n        )\n        crop_top: float = Field(\n            default=0.1, ge=0.0, le=1.0, description=\"Fraction of height to randomly crop from the top side.\"\n        )\n        crop_bottom: float = Field(\n            default=0.1, ge=0.0, le=1.0, description=\"Fraction of height to randomly crop from the bottom side.\"\n        )\n        p: ProbabilityType = 1\n\n        @model_validator(mode=\"after\")\n        def validate_crop_values(self) -&gt; Self:\n            if self.crop_left + self.crop_right &gt;= 1.0:\n                msg = \"The sum of crop_left and crop_right must be less than 1.\"\n                raise ValueError(msg)\n            if self.crop_top + self.crop_bottom &gt;= 1.0:\n                msg = \"The sum of crop_top and crop_bottom must be less than 1.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        crop_left: float = 0.1,\n        crop_right: float = 0.1,\n        crop_top: float = 0.1,\n        crop_bottom: float = 0.1,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n        self.crop_left = crop_left\n        self.crop_right = crop_right\n        self.crop_top = crop_top\n        self.crop_bottom = crop_bottom\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, int]:\n        img = params[\"image\"]\n        x_min = random_utils.randint(0, int(self.crop_left * img.shape[1]))\n        x_max = random_utils.randint(max(x_min + 1, int((1 - self.crop_right) * img.shape[1])), img.shape[1])\n        y_min = random_utils.randint(0, int(self.crop_top * img.shape[0]))\n        y_max = random_utils.randint(max(y_min + 1, int((1 - self.crop_bottom) * img.shape[0])), img.shape[0])\n        return {\"x_min\": x_min, \"x_max\": x_max, \"y_min\": y_min, \"y_max\": y_max}\n\n    def apply(\n        self, img: np.ndarray, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        return F.clamping_crop(img, x_min, y_min, x_max, y_max)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        return F.clamping_crop(mask, x_min, y_min, x_max, y_max)\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        return F.bbox_crop(bbox, x_min, y_min, x_max, y_max, rows, cols)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        x_min: int = 0,\n        x_max: int = 0,\n        y_min: int = 0,\n        y_max: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.crop_keypoint_by_coords(keypoint, crop_coords=(x_min, y_min, x_max, y_max))\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"crop_left\", \"crop_right\", \"crop_top\", \"crop_bottom\"\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.RandomCropNearBBox","title":"<code>class  RandomCropNearBBox</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop bbox from image with random shift by x,y coordinates</p> <p>Parameters:</p> Name Type Description <code>max_part_shift</code> <code>float, (float, float</code> <p>Max shift in <code>height</code> and <code>width</code> dimensions relative to <code>cropping_bbox</code> dimension. If max_part_shift is a single float, the range will be (0, max_part_shift). Default (0, 0.3).</p> <code>cropping_bbox_key</code> <code>str</code> <p>Additional target key for cropping box. Default <code>cropping_bbox</code>.</p> <code>cropping_box_key</code> <code>str</code> <p>[Deprecated] Use <code>cropping_bbox_key</code> instead.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; aug = Compose([RandomCropNearBBox(max_part_shift=(0.1, 0.5), cropping_bbox_key='test_box')],\n&gt;&gt;&gt;              bbox_params=BboxParams(\"pascal_voc\"))\n&gt;&gt;&gt; result = aug(image=image, bboxes=bboxes, test_box=[0, 5, 10, 20])\n</code></pre> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomCropNearBBox(DualTransform):\n    \"\"\"Crop bbox from image with random shift by x,y coordinates\n\n    Args:\n        max_part_shift (float, (float, float)): Max shift in `height` and `width` dimensions relative\n            to `cropping_bbox` dimension.\n            If max_part_shift is a single float, the range will be (0, max_part_shift).\n            Default (0, 0.3).\n        cropping_bbox_key (str): Additional target key for cropping box. Default `cropping_bbox`.\n        cropping_box_key (str): [Deprecated] Use `cropping_bbox_key` instead.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    Examples:\n        &gt;&gt;&gt; aug = Compose([RandomCropNearBBox(max_part_shift=(0.1, 0.5), cropping_bbox_key='test_box')],\n        &gt;&gt;&gt;              bbox_params=BboxParams(\"pascal_voc\"))\n        &gt;&gt;&gt; result = aug(image=image, bboxes=bboxes, test_box=[0, 5, 10, 20])\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        max_part_shift: ZeroOneRangeType = (0, 0.3)\n        cropping_bbox_key: str = Field(default=\"cropping_bbox\", description=\"Additional target key for cropping box.\")\n        p: ProbabilityType = 1\n\n    def __init__(\n        self,\n        max_part_shift: ScaleFloatType = (0, 0.3),\n        cropping_bbox_key: str = \"cropping_bbox\",\n        cropping_box_key: Optional[str] = None,  # Deprecated\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n        # Check for deprecated parameter and issue warning\n        if cropping_box_key is not None:\n            warn(\n                \"The parameter 'cropping_box_key' is deprecated and will be removed in future versions. \"\n                \"Use 'cropping_bbox_key' instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            # Ensure the new parameter is used even if the old one is passed\n            cropping_bbox_key = cropping_box_key\n\n        self.max_part_shift = cast(Tuple[float, float], max_part_shift)\n        self.cropping_bbox_key = cropping_bbox_key\n\n    def apply(\n        self, img: np.ndarray, x_min: int = 0, x_max: int = 0, y_min: int = 0, y_max: int = 0, **params: Any\n    ) -&gt; np.ndarray:\n        return F.clamping_crop(img, x_min, y_min, x_max, y_max)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, int]:\n        bbox = params[self.cropping_bbox_key]\n        h_max_shift = round((bbox[3] - bbox[1]) * self.max_part_shift[0])\n        w_max_shift = round((bbox[2] - bbox[0]) * self.max_part_shift[1])\n\n        x_min = bbox[0] - random.randint(-w_max_shift, w_max_shift)\n        x_max = bbox[2] + random.randint(-w_max_shift, w_max_shift)\n\n        y_min = bbox[1] - random.randint(-h_max_shift, h_max_shift)\n        y_max = bbox[3] + random.randint(-h_max_shift, h_max_shift)\n\n        x_min = max(0, x_min)\n        y_min = max(0, y_min)\n\n        return {\"x_min\": x_min, \"x_max\": x_max, \"y_min\": y_min, \"y_max\": y_max}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_crop(bbox, **params)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        x_min: int = 0,\n        x_max: int = 0,\n        y_min: int = 0,\n        y_max: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.crop_keypoint_by_coords(keypoint, crop_coords=(x_min, y_min, x_max, y_max))\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [self.cropping_bbox_key]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str]:\n        return (\"max_part_shift\", \"cropping_bbox_key\")\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.RandomResizedCrop","title":"<code>class  RandomResizedCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Torchvision's variant of crop a random part of the input and rescale it to some size.</p> <p>Parameters:</p> Name Type Description <code>size</code> <code>int, int</code> <p>target size for the output image, i.e. (height, width) after crop and resize</p> <code>scale</code> <code>float, float</code> <p>range of size of the origin size cropped</p> <code>ratio</code> <code>float, float</code> <p>range of aspect ratio of the origin aspect ratio cropped</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomResizedCrop(_BaseRandomSizedCrop):\n    \"\"\"Torchvision's variant of crop a random part of the input and rescale it to some size.\n\n    Args:\n        size (int, int): target size for the output image, i.e. (height, width) after crop and resize\n        scale ((float, float)): range of size of the origin size cropped\n        ratio ((float, float)): range of aspect ratio of the origin aspect ratio cropped\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: ZeroOneRangeType = (0.08, 1.0)\n        ratio: NonNegativeFloatRangeType = (0.75, 1.3333333333333333)\n        width: Optional[int] = None\n        height: Optional[int] = None\n        size: Optional[ScaleIntType] = None\n        p: ProbabilityType = 1\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n        @model_validator(mode=\"after\")\n        def process(self) -&gt; Self:\n            if isinstance(self.size, int):\n                if isinstance(self.width, int):\n                    self.size = (self.size, self.width)\n                    warn(\n                        \"Initializing with 'size' as an integer and a separate 'width' is deprecated. \"\n                        \"Please use a tuple (height, width) for the 'size' argument.\",\n                        DeprecationWarning,\n                        stacklevel=2,\n                    )\n                else:\n                    msg = \"If size is an integer, width as integer must be specified.\"\n                    raise TypeError(msg)\n\n            if self.size is None:\n                if self.height is None or self.width is None:\n                    message = \"If 'size' is not provided, both 'height' and 'width' must be specified.\"\n                    raise ValueError(message)\n                self.size = (self.height, self.width)\n                warn(\n                    \"Initializing with 'height' and 'width' is deprecated. \"\n                    \"Please use a tuple (height, width) for the 'size' argument.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n\n            return self\n\n    def __init__(\n        self,\n        # NOTE @zetyquickly: when (width, height) are deprecated, make 'size' non optional\n        size: Optional[ScaleIntType] = None,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        *,\n        scale: Tuple[float, float] = (0.08, 1.0),\n        ratio: Tuple[float, float] = (0.75, 1.3333333333333333),\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(size=cast(Tuple[int, int], size), interpolation=interpolation, always_apply=always_apply, p=p)\n        self.scale = scale\n        self.ratio = ratio\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Union[int, float]]:\n        img = params[\"image\"]\n        img_height, img_width = img.shape[:2]\n        area = img_height * img_width\n\n        for _ in range(10):\n            target_area = random_utils.uniform(*self.scale) * area\n            log_ratio = (math.log(self.ratio[0]), math.log(self.ratio[1]))\n            aspect_ratio = math.exp(random_utils.uniform(*log_ratio))\n\n            width = int(round(math.sqrt(target_area * aspect_ratio)))\n            height = int(round(math.sqrt(target_area / aspect_ratio)))\n\n            if 0 &lt; width &lt;= img_width and 0 &lt; height &lt;= img_height:\n                i = random.randint(0, img_height - height)\n                j = random.randint(0, img_width - width)\n                return {\n                    \"crop_height\": height,\n                    \"crop_width\": width,\n                    \"h_start\": i * 1.0 / (img_height - height + 1e-10),\n                    \"w_start\": j * 1.0 / (img_width - width + 1e-10),\n                }\n\n        # Fallback to central crop\n        in_ratio = img_width / img_height\n        if in_ratio &lt; min(self.ratio):\n            width = img_width\n            height = int(round(img_width / min(self.ratio)))\n        elif in_ratio &gt; max(self.ratio):\n            height = img_height\n            width = int(round(height * max(self.ratio)))\n        else:  # whole image\n            width = img_width\n            height = img_height\n        i = (img_height - height) // 2\n        j = (img_width - width) // 2\n        return {\n            \"crop_height\": height,\n            \"crop_width\": width,\n            \"h_start\": i * 1.0 / (img_height - height + 1e-10),\n            \"w_start\": j * 1.0 / (img_width - width + 1e-10),\n        }\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"size\", \"scale\", \"ratio\", \"interpolation\"\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.RandomSizedBBoxSafeCrop","title":"<code>class  RandomSizedBBoxSafeCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop a random part of the input and rescale it to some size without loss of bboxes.</p> <p>Parameters:</p> Name Type Description <code>height</code> <p>height after crop and resize.</p> <code>width</code> <p>width after crop and resize.</p> <code>erosion_rate</code> <p>erosion rate applied on input image height before crop.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomSizedBBoxSafeCrop(BBoxSafeRandomCrop):\n    \"\"\"Crop a random part of the input and rescale it to some size without loss of bboxes.\n\n    Args:\n        height: height after crop and resize.\n        width: width after crop and resize.\n        erosion_rate: erosion rate applied on input image height before crop.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n    Targets:\n        image, mask, bboxes\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(CropInitSchema):\n        erosion_rate: float = Field(\n            default=0.0, ge=0.0, le=1.0, description=\"Erosion rate applied on input image height before crop.\"\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n    def __init__(\n        self,\n        height: int,\n        width: int,\n        erosion_rate: float = 0.0,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(erosion_rate, always_apply, p)\n        self.height = height\n        self.width = width\n        self.interpolation = interpolation\n\n    def apply(\n        self,\n        img: np.ndarray,\n        crop_height: int = 0,\n        crop_width: int = 0,\n        h_start: int = 0,\n        w_start: int = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        crop = F.random_crop(img, crop_height, crop_width, h_start, w_start)\n        return FGeometric.resize(crop, self.height, self.width, interpolation)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (*super().get_transform_init_args_names(), \"height\", \"width\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/augmentations/crops/transforms/#albumentations.augmentations.crops.transforms.RandomSizedCrop","title":"<code>class  RandomSizedCrop</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Crop a random portion of the input and rescale it to a specific size.</p> <p>Parameters:</p> Name Type Description <code>min_max_height</code> <code>int, int</code> <p>crop size limits.</p> <code>size</code> <code>int, int</code> <p>target size for the output image, i.e. (height, width) after crop and resize</p> <code>w2h_ratio</code> <code>float</code> <p>aspect ratio of crop.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/crops/transforms.py</code> Python<pre><code>class RandomSizedCrop(_BaseRandomSizedCrop):\n    \"\"\"Crop a random portion of the input and rescale it to a specific size.\n\n    Args:\n        min_max_height ((int, int)): crop size limits.\n        size ((int, int)): target size for the output image, i.e. (height, width) after crop and resize\n        w2h_ratio (float): aspect ratio of crop.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        p: ProbabilityType = 1\n        min_max_height: OnePlusIntRangeType\n        w2h_ratio: Annotated[float, Field(gt=0, description=\"Aspect ratio of crop.\")]\n        width: Optional[int] = None\n        height: Optional[int] = None\n        size: Optional[ScaleIntType] = None\n\n        @model_validator(mode=\"after\")\n        def process(self) -&gt; Self:\n            if isinstance(self.size, int):\n                if isinstance(self.width, int):\n                    self.size = (self.size, self.width)\n                    warn(\n                        \"Initializing with 'size' as an integer and a separate 'width' is deprecated. \"\n                        \"Please use a tuple (height, width) for the 'size' argument.\",\n                        DeprecationWarning,\n                        stacklevel=2,\n                    )\n                else:\n                    msg = \"If size is an integer, width as integer must be specified.\"\n                    raise TypeError(msg)\n\n            if self.size is None:\n                if self.height is None or self.width is None:\n                    message = \"If 'size' is not provided, both 'height' and 'width' must be specified.\"\n                    raise ValueError(message)\n                self.size = (self.height, self.width)\n                warn(\n                    \"Initializing with 'height' and 'width' is deprecated. \"\n                    \"Please use a tuple (height, width) for the 'size' argument.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n\n            return self\n\n    def __init__(\n        self,\n        min_max_height: Tuple[int, int],\n        # NOTE @zetyquickly: when (width, height) are deprecated, make 'size' non optional\n        size: Optional[ScaleIntType] = None,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        *,\n        w2h_ratio: float = 1.0,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(size=cast(Tuple[int, int], size), interpolation=interpolation, always_apply=always_apply, p=p)\n        self.min_max_height = min_max_height\n        self.w2h_ratio = w2h_ratio\n\n    def get_params(self) -&gt; Dict[str, Union[int, float]]:\n        crop_height = random_utils.randint(self.min_max_height[0], self.min_max_height[1])\n        return {\n            \"h_start\": random.random(),\n            \"w_start\": random.random(),\n            \"crop_height\": crop_height,\n            \"crop_width\": int(crop_height * self.w2h_ratio),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"min_max_height\", \"size\", \"w2h_ratio\", \"interpolation\"\n</code></pre>"},{"location":"api_reference/augmentations/dropout/","title":"Index","text":"<ul> <li>ChannelDropout augmentation (albumentations.augmentations.dropout.channel_dropout)</li> <li>CoarseDropout augmentation (albumentations.augmentations.dropout.coarse_dropout)</li> <li>GridDropout augmentation (albumentations.augmentations.dropout.grid_dropout)</li> <li>MaskDropout augmentation (albumentations.augmentations.dropout.mask_dropout)</li> </ul>"},{"location":"api_reference/augmentations/dropout/channel_dropout/","title":"ChannelDropout augmentation (augmentations.dropout.channel_dropout)","text":""},{"location":"api_reference/augmentations/dropout/channel_dropout/#albumentations.augmentations.dropout.channel_dropout.ChannelDropout","title":"<code>class  ChannelDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly Drop Channels in the input Image.</p> <p>Parameters:</p> Name Type Description <code>channel_drop_range</code> <code>int, int</code> <p>range from which we choose the number of channels to drop.</p> <code>fill_value</code> <code>int, float</code> <p>pixel value for the dropped channel.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image</p> <p>Image types:     uint8, uint16, unit32, float32</p> Source code in <code>albumentations/augmentations/dropout/channel_dropout.py</code> Python<pre><code>class ChannelDropout(ImageOnlyTransform):\n    \"\"\"Randomly Drop Channels in the input Image.\n\n    Args:\n        channel_drop_range (int, int): range from which we choose the number of channels to drop.\n        fill_value (int, float): pixel value for the dropped channel.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image\n\n    Image types:\n        uint8, uint16, unit32, float32\n\n    \"\"\"\n\n    class InitSchema(BaseTransformInitSchema):\n        channel_drop_range: OnePlusIntRangeType = (1, 1)\n        fill_value: Annotated[ColorType, Field(description=\"Pixel value for the dropped channel.\")]\n\n    def __init__(\n        self,\n        channel_drop_range: Tuple[int, int] = (1, 1),\n        fill_value: float = 0,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        self.channel_drop_range = channel_drop_range\n        self.fill_value = fill_value\n\n    def apply(self, img: np.ndarray, channels_to_drop: Tuple[int, ...] = (0,), **params: Any) -&gt; np.ndarray:\n        return channel_dropout(img, channels_to_drop, self.fill_value)\n\n    def get_params_dependent_on_targets(self, params: Mapping[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        num_channels = img.shape[-1]\n\n        if is_grayscale_image(img):\n            msg = \"Images has one channel. ChannelDropout is not defined.\"\n            raise NotImplementedError(msg)\n\n        if self.channel_drop_range[1] &gt;= num_channels:\n            msg = \"Can not drop all channels in ChannelDropout.\"\n            raise ValueError(msg)\n\n        num_drop_channels = random_utils.randint(self.channel_drop_range[0], self.channel_drop_range[1] + 1)\n\n        channels_to_drop = random.sample(range(num_channels), k=num_drop_channels)\n\n        return {\"channels_to_drop\": channels_to_drop}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"channel_drop_range\", \"fill_value\"\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n</code></pre>"},{"location":"api_reference/augmentations/dropout/coarse_dropout/","title":"CoarseDropout augmentation (augmentations.dropout.coarse_dropout)","text":""},{"location":"api_reference/augmentations/dropout/coarse_dropout/#albumentations.augmentations.dropout.coarse_dropout.CoarseDropout","title":"<code>class  CoarseDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>CoarseDropout of the rectangular regions in the image.</p> <p>Parameters:</p> Name Type Description <code>max_holes</code> <code>int</code> <p>Maximum number of regions to zero out.</p> <code>max_height</code> <code>int, float</code> <p>Maximum height of the hole.</p> <code>max_width</code> <code>int, float</code> <p>Maximum width of the hole.</p> <code>min_holes</code> <code>int</code> <p>Minimum number of regions to zero out. If <code>None</code>, <code>min_holes</code> is be set to <code>max_holes</code>. Default: <code>None</code>.</p> <code>min_height</code> <code>int, float</code> <p>Minimum height of the hole. Default: None. If <code>None</code>, <code>min_height</code> is set to <code>max_height</code>. Default: <code>None</code>. If float, it is calculated as a fraction of the image height.</p> <code>min_width</code> <code>int, float</code> <p>Minimum width of the hole. If <code>None</code>, <code>min_height</code> is set to <code>max_width</code>. Default: <code>None</code>. If float, it is calculated as a fraction of the image width.</p> <code>fill_value</code> <code>int, float, list of int, list of float</code> <p>value for dropped pixels.</p> <code>mask_fill_value</code> <code>int, float, list of int, list of float</code> <p>fill value for dropped pixels in mask. If <code>None</code> - mask is not affected. Default: <code>None</code>.</p> <p>Targets</p> <p>image, mask, keypoints</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/1708.04552 https://github.com/uoguelph-mlrg/Cutout/blob/master/util/cutout.py https://github.com/aleju/imgaug/blob/master/imgaug/augmenters/arithmetic.py</p> Source code in <code>albumentations/augmentations/dropout/coarse_dropout.py</code> Python<pre><code>class CoarseDropout(DualTransform):\n    \"\"\"CoarseDropout of the rectangular regions in the image.\n\n    Args:\n        max_holes (int): Maximum number of regions to zero out.\n        max_height (int, float): Maximum height of the hole.\n        If float, it is calculated as a fraction of the image height.\n        max_width (int, float): Maximum width of the hole.\n        If float, it is calculated as a fraction of the image width.\n        min_holes (int): Minimum number of regions to zero out. If `None`,\n            `min_holes` is be set to `max_holes`. Default: `None`.\n        min_height (int, float): Minimum height of the hole. Default: None. If `None`,\n            `min_height` is set to `max_height`. Default: `None`.\n            If float, it is calculated as a fraction of the image height.\n        min_width (int, float): Minimum width of the hole. If `None`, `min_height` is\n            set to `max_width`. Default: `None`.\n            If float, it is calculated as a fraction of the image width.\n\n        fill_value (int, float, list of int, list of float): value for dropped pixels.\n        mask_fill_value (int, float, list of int, list of float): fill value for dropped pixels\n            in mask. If `None` - mask is not affected. Default: `None`.\n\n    Targets:\n        image, mask, keypoints\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://arxiv.org/abs/1708.04552\n        https://github.com/uoguelph-mlrg/Cutout/blob/master/util/cutout.py\n        https://github.com/aleju/imgaug/blob/master/imgaug/augmenters/arithmetic.py\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        max_holes: int = Field(default=8, ge=0, description=\"Maximum number of regions to zero out.\")\n        max_height: ScalarType = Field(default=8, ge=0, description=\"Maximum height of the hole.\")\n        max_width: ScalarType = Field(default=8, ge=0, description=\"Maximum width of the hole.\")\n        min_holes: Optional[int] = Field(default=None, ge=0, description=\"Minimum number of regions to zero out.\")\n        min_height: Optional[ScalarType] = Field(default=None, ge=0, description=\"Minimum height of the hole.\")\n        min_width: Optional[ScalarType] = Field(default=None, ge=0, description=\"Minimum width of the hole.\")\n        fill_value: ColorType = Field(default=0, description=\"Value for dropped pixels.\")\n        mask_fill_value: Optional[ColorType] = Field(default=None, description=\"Fill value for dropped pixels in mask.\")\n\n        @model_validator(mode=\"after\")\n        def check_holes_and_dimensions(self) -&gt; Self:\n            self.min_holes = self.min_holes if self.min_holes is not None else self.max_holes\n\n            self.min_height = self.min_height if self.min_height is not None else self.max_height\n            self.min_width = self.min_width if self.min_width is not None else self.max_width\n\n            if not 0 &lt; self.min_height &lt;= self.max_height:\n                raise ValueError(\n                    f\"Invalid combination of min_height and max_height. Got: {[self.min_height, self.max_height]}\"\n                )\n            if not 0 &lt; self.min_width &lt;= self.max_width:\n                raise ValueError(\n                    f\"Invalid combination of min_width and max_width. Got: {[self.min_width, self.max_width]}\"\n                )\n            if not 0 &lt; self.min_holes &lt;= self.max_holes:\n                raise ValueError(\n                    f\"Invalid combination of min_holes and max_holes. Got: {[self.min_holes, self.max_holes]}\"\n                )\n            return self\n\n    def __init__(\n        self,\n        max_holes: int = 8,\n        max_height: ScalarType = 8,\n        max_width: ScalarType = 8,\n        min_holes: Optional[int] = None,\n        min_height: Optional[ScalarType] = None,\n        min_width: Optional[ScalarType] = None,\n        fill_value: ColorType = 0,\n        mask_fill_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.min_holes = cast(int, min_holes)\n        self.max_holes = max_holes\n        self.min_height = cast(ScalarType, min_height)\n        self.max_height = max_height\n        self.min_width = cast(ScalarType, min_width)\n        self.max_width = max_width\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n\n    def apply(\n        self,\n        img: np.ndarray,\n        fill_value: ScalarType = 0,\n        holes: Iterable[Tuple[int, int, int, int]] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return cutout(img, holes, fill_value)\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        mask_fill_value: ScalarType = 0,\n        holes: Iterable[Tuple[int, int, int, int]] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if mask_fill_value is None:\n            return mask\n        return cutout(mask, holes, mask_fill_value)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        holes = []\n        for _ in range(random.randint(self.min_holes, self.max_holes)):\n            if all(\n                [\n                    isinstance(self.min_height, int),\n                    isinstance(self.min_width, int),\n                    isinstance(self.max_height, int),\n                    isinstance(self.max_width, int),\n                ]\n            ):\n                hole_height = random.randint(int(self.min_height), int(self.max_height))\n                hole_width = random.randint(int(self.min_width), int(self.max_width))\n            elif all(\n                [\n                    isinstance(self.min_height, float),\n                    isinstance(self.min_width, float),\n                    isinstance(self.max_height, float),\n                    isinstance(self.max_width, float),\n                ]\n            ):\n                hole_height = int(height * random.uniform(self.min_height, self.max_height))\n                hole_width = int(width * random.uniform(self.min_width, self.max_width))\n            else:\n                msg = \"Min width, max width, \\\n                    min height and max height \\\n                    should all either be ints or floats. \\\n                    Got: {} respectively\".format(\n                    [\n                        type(self.min_width),\n                        type(self.max_width),\n                        type(self.min_height),\n                        type(self.max_height),\n                    ]\n                )\n                raise ValueError(msg)\n\n            y1 = random.randint(0, height - hole_height)\n            x1 = random.randint(0, width - hole_width)\n            y2 = y1 + hole_height\n            x2 = x1 + hole_width\n            holes.append((x1, y1, x2, y2))\n\n        return {\"holes\": holes}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def apply_to_keypoints(\n        self, keypoints: Sequence[KeypointType], holes: Iterable[Tuple[int, int, int, int]] = (), **params: Any\n    ) -&gt; List[KeypointType]:\n        return [keypoint for keypoint in keypoints if not any(keypoint_in_hole(keypoint, hole) for hole in holes)]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"max_holes\",\n            \"max_height\",\n            \"max_width\",\n            \"min_holes\",\n            \"min_height\",\n            \"min_width\",\n            \"fill_value\",\n            \"mask_fill_value\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/dropout/functional/","title":"Geometric functional transforms (augmentations.dropout.functional)","text":""},{"location":"api_reference/augmentations/dropout/grid_dropout/","title":"GridDropout augmentation (augmentations.dropout.grid_dropout)","text":""},{"location":"api_reference/augmentations/dropout/grid_dropout/#albumentations.augmentations.dropout.grid_dropout.GridDropout","title":"<code>class  GridDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.</p> <p>Parameters:</p> Name Type Description <code>ratio</code> <p>the ratio of the mask holes to the unit_size (same for horizontal and vertical directions). Must be between 0 and 1. Default: 0.5.</p> <code>unit_size_min</code> <code>int</code> <p>minimum size of the grid unit. Must be between 2 and the image shorter edge. If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: <code>None</code>.</p> <code>unit_size_max</code> <code>int</code> <p>maximum size of the grid unit. Must be between 2 and the image shorter edge. If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: <code>None</code>.</p> <code>holes_number_x</code> <code>int</code> <p>the number of grid units in x direction. Must be between 1 and image width//2. If 'None', grid unit width is set as image_width//10. Default: <code>None</code>.</p> <code>holes_number_y</code> <code>int</code> <p>the number of grid units in y direction. Must be between 1 and image height//2. If <code>None</code>, grid unit height is set equal to the grid unit width or image height, whatever is smaller.</p> <code>shift_x</code> <code>int</code> <p>offsets of the grid start in x direction from (0,0) coordinate. Clipped between 0 and grid unit_width - hole_width. Default: 0.</p> <code>shift_y</code> <code>int</code> <p>offsets of the grid start in y direction from (0,0) coordinate. Clipped between 0 and grid unit height - hole_height. Default: 0.</p> <code>random_offset</code> <code>boolean</code> <p>weather to offset the grid randomly between 0 and grid unit size - hole size If 'True', entered shift_x, shift_y are ignored and set randomly. Default: <code>False</code>.</p> <code>fill_value</code> <code>int</code> <p>value for the dropped pixels. Default = 0</p> <code>mask_fill_value</code> <code>int</code> <p>value for the dropped pixels in mask. If <code>None</code>, transformation is not applied to the mask. Default: <code>None</code>.</p> <p>Targets</p> <p>image, mask</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://arxiv.org/abs/2001.04086</p> Source code in <code>albumentations/augmentations/dropout/grid_dropout.py</code> Python<pre><code>class GridDropout(DualTransform):\n    \"\"\"GridDropout, drops out rectangular regions of an image and the corresponding mask in a grid fashion.\n\n    Args:\n        ratio: the ratio of the mask holes to the unit_size (same for horizontal and vertical directions).\n            Must be between 0 and 1. Default: 0.5.\n        unit_size_min (int): minimum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        unit_size_max (int): maximum size of the grid unit. Must be between 2 and the image shorter edge.\n            If 'None', holes_number_x and holes_number_y are used to setup the grid. Default: `None`.\n        holes_number_x (int): the number of grid units in x direction. Must be between 1 and image width//2.\n            If 'None', grid unit width is set as image_width//10. Default: `None`.\n        holes_number_y (int): the number of grid units in y direction. Must be between 1 and image height//2.\n            If `None`, grid unit height is set equal to the grid unit width or image height, whatever is smaller.\n        shift_x (int): offsets of the grid start in x direction from (0,0) coordinate.\n            Clipped between 0 and grid unit_width - hole_width. Default: 0.\n        shift_y (int): offsets of the grid start in y direction from (0,0) coordinate.\n            Clipped between 0 and grid unit height - hole_height. Default: 0.\n        random_offset (boolean): weather to offset the grid randomly between 0 and grid unit size - hole size\n            If 'True', entered shift_x, shift_y are ignored and set randomly. Default: `False`.\n        fill_value (int): value for the dropped pixels. Default = 0\n        mask_fill_value (int): value for the dropped pixels in mask.\n            If `None`, transformation is not applied to the mask. Default: `None`.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://arxiv.org/abs/2001.04086\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK)\n\n    class InitSchema(BaseTransformInitSchema):\n        ratio: float = Field(description=\"The ratio of the mask holes to the unit_size.\", ge=0, le=1)\n        unit_size_min: Optional[int] = Field(None, description=\"Minimum size of the grid unit.\", ge=2)\n        unit_size_max: Optional[int] = Field(None, description=\"Maximum size of the grid unit.\", ge=2)\n        holes_number_x: Optional[int] = Field(None, description=\"The number of grid units in x direction.\", ge=1)\n        holes_number_y: Optional[int] = Field(None, description=\"The number of grid units in y direction.\", ge=1)\n        shift_x: int = Field(0, description=\"Offsets of the grid start in x direction.\", ge=0)\n        shift_y: int = Field(0, description=\"Offsets of the grid start in y direction.\", ge=0)\n        random_offset: bool = Field(False, description=\"Whether to offset the grid randomly.\")\n        fill_value: Optional[ColorType] = Field(0, description=\"Value for the dropped pixels.\")\n        mask_fill_value: Optional[ColorType] = Field(None, description=\"Value for the dropped pixels in mask.\")\n\n    def __init__(\n        self,\n        ratio: float = 0.5,\n        unit_size_min: Optional[int] = None,\n        unit_size_max: Optional[int] = None,\n        holes_number_x: Optional[int] = None,\n        holes_number_y: Optional[int] = None,\n        shift_x: int = 0,\n        shift_y: int = 0,\n        random_offset: bool = False,\n        fill_value: float = 0,\n        mask_fill_value: Optional[ScalarType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.ratio = ratio\n        self.unit_size_min = unit_size_min\n        self.unit_size_max = unit_size_max\n        self.holes_number_x = holes_number_x\n        self.holes_number_y = holes_number_y\n        self.shift_x = shift_x\n        self.shift_y = shift_y\n        self.random_offset = random_offset\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n\n    def apply(self, img: np.ndarray, holes: Iterable[Tuple[int, int, int, int]] = (), **params: Any) -&gt; np.ndarray:\n        return F.cutout(img, holes, self.fill_value)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, holes: Iterable[Tuple[int, int, int, int]] = (), **params: Any\n    ) -&gt; np.ndarray:\n        if self.mask_fill_value is None:\n            return mask\n\n        return F.cutout(mask, holes, self.mask_fill_value)\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n        unit_width, unit_height = self._calculate_unit_dimensions(width, height)\n        hole_width, hole_height = self._calculate_hole_dimensions(unit_width, unit_height)\n        shift_x, shift_y = self._calculate_shifts(unit_width, unit_height, hole_width, hole_height)\n        holes = self._generate_holes(width, height, unit_width, unit_height, hole_width, hole_height, shift_x, shift_y)\n        return {\"holes\": holes}\n\n    def _calculate_unit_dimensions(self, width: int, height: int) -&gt; Tuple[int, int]:\n        \"\"\"Calculates the dimensions of the grid units.\"\"\"\n        if self.unit_size_min is not None and self.unit_size_max is not None:\n            self._validate_unit_sizes(height, width)\n            unit_size = random.randint(self.unit_size_min, self.unit_size_max)\n            return unit_size, unit_size\n\n        return self._calculate_dimensions_based_on_holes(width, height)\n\n    def _validate_unit_sizes(self, height: int, width: int) -&gt; None:\n        \"\"\"Validates the minimum and maximum unit sizes.\"\"\"\n        if self.unit_size_min is not None and self.unit_size_max is not None:\n            if not TWO &lt;= self.unit_size_min &lt;= self.unit_size_max:\n                msg = \"Max unit size should be &gt;= min size, both at least 2 pixels.\"\n                raise ValueError(msg)\n            if self.unit_size_max &gt; min(height, width):\n                msg = \"Grid size limits must be within the shortest image edge.\"\n                raise ValueError(msg)\n        else:\n            msg = \"unit_size_min and unit_size_max must not be None.\"\n            raise ValueError(msg)\n\n    def _calculate_dimensions_based_on_holes(self, width: int, height: int) -&gt; Tuple[int, int]:\n        \"\"\"Calculates dimensions based on the number of holes specified.\"\"\"\n        unit_width = self._calculate_dimension(width, self.holes_number_x, 10)\n        unit_height = self._calculate_dimension(height, self.holes_number_y, unit_width)\n        return unit_width, unit_height\n\n    def _calculate_dimension(self, dimension: int, holes_number: Optional[int], fallback: int) -&gt; int:\n        \"\"\"Helper function to calculate unit width or height.\"\"\"\n        if holes_number is None:\n            return max(2, dimension // fallback)\n\n        if not 1 &lt;= holes_number &lt;= dimension // 2:\n            raise ValueError(f\"The number of holes must be between 1 and {dimension // 2}.\")\n        return dimension // holes_number\n\n    def _calculate_hole_dimensions(self, unit_width: int, unit_height: int) -&gt; Tuple[int, int]:\n        \"\"\"Calculates the dimensions of the holes to be dropped out.\"\"\"\n        hole_width = int(unit_width * self.ratio)\n        hole_height = int(unit_height * self.ratio)\n        hole_width = min(max(hole_width, 1), unit_width - 1)\n        hole_height = min(max(hole_height, 1), unit_height - 1)\n        return hole_width, hole_height\n\n    def _calculate_shifts(\n        self, unit_width: int, unit_height: int, hole_width: int, hole_height: int\n    ) -&gt; Tuple[int, int]:\n        \"\"\"Calculates the shifts for the grid start.\"\"\"\n        if self.random_offset:\n            shift_x = random.randint(0, unit_width - hole_width)\n            shift_y = random.randint(0, unit_height - hole_height)\n        else:\n            shift_x = 0 if self.shift_x is None else min(max(0, self.shift_x), unit_width - hole_width)\n            shift_y = 0 if self.shift_y is None else min(max(0, self.shift_y), unit_height - hole_height)\n        return shift_x, shift_y\n\n    def _generate_holes(\n        self,\n        width: int,\n        height: int,\n        unit_width: int,\n        unit_height: int,\n        hole_width: int,\n        hole_height: int,\n        shift_x: int,\n        shift_y: int,\n    ) -&gt; List[Tuple[int, int, int, int]]:\n        \"\"\"Generates the list of holes to be dropped out.\"\"\"\n        holes = []\n        for i in range(width // unit_width + 1):\n            for j in range(height // unit_height + 1):\n                x1 = min(shift_x + unit_width * i, width)\n                y1 = min(shift_y + unit_height * j, height)\n                x2 = min(x1 + hole_width, width)\n                y2 = min(y1 + hole_height, height)\n                holes.append((x1, y1, x2, y2))\n        return holes\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"ratio\",\n            \"unit_size_min\",\n            \"unit_size_max\",\n            \"holes_number_x\",\n            \"holes_number_y\",\n            \"shift_x\",\n            \"shift_y\",\n            \"random_offset\",\n            \"fill_value\",\n            \"mask_fill_value\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/dropout/mask_dropout/","title":"MaskDropout augmentation (augmentations.dropout.mask_dropout)","text":""},{"location":"api_reference/augmentations/dropout/mask_dropout/#albumentations.augmentations.dropout.mask_dropout.MaskDropout","title":"<code>class  MaskDropout</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Image &amp; mask augmentation that zero out mask and image regions corresponding to randomly chosen object instance from mask.</p> <p>Mask must be single-channel image, zero values treated as background. Image can be any number of channels.</p> <p>Parameters:</p> Name Type Description <code>max_objects</code> <p>Maximum number of labels that can be zeroed out. Can be tuple, in this case it's [min, max]</p> <code>image_fill_value</code> <p>Fill value to use when filling image. Can be 'inpaint' to apply inpainting (works only  for 3-channel images)</p> <code>mask_fill_value</code> <p>Fill value to use when filling mask.</p> <p>Targets</p> <p>image, mask</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://www.kaggle.com/c/severstal-steel-defect-detection/discussion/114254</p> Source code in <code>albumentations/augmentations/dropout/mask_dropout.py</code> Python<pre><code>class MaskDropout(DualTransform):\n    \"\"\"Image &amp; mask augmentation that zero out mask and image regions corresponding\n    to randomly chosen object instance from mask.\n\n    Mask must be single-channel image, zero values treated as background.\n    Image can be any number of channels.\n\n    Args:\n        max_objects: Maximum number of labels that can be zeroed out. Can be tuple, in this case it's [min, max]\n        image_fill_value: Fill value to use when filling image.\n            Can be 'inpaint' to apply inpainting (works only  for 3-channel images)\n        mask_fill_value: Fill value to use when filling mask.\n\n    Targets:\n        image, mask\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://www.kaggle.com/c/severstal-steel-defect-detection/discussion/114254\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK)\n\n    class InitSchema(BaseTransformInitSchema):\n        max_objects: OnePlusIntRangeType = (1, 1)\n\n        image_fill_value: Union[float, Literal[\"inpaint\"]] = Field(\n            default=0,\n            description=(\n                \"Fill value to use when filling image. \"\n                \"Can be 'inpaint' to apply inpainting (works only for 3-channel images).\"\n            ),\n        )\n        mask_fill_value: float = Field(default=0, description=\"Fill value to use when filling mask.\")\n\n    def __init__(\n        self,\n        max_objects: ScaleIntType = (1, 1),\n        image_fill_value: Union[float, Literal[\"inpaint\"]] = 0,\n        mask_fill_value: ScalarType = 0,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.max_objects = cast(Tuple[int, int], max_objects)\n        self.image_fill_value = image_fill_value\n        self.mask_fill_value = mask_fill_value\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"mask\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        mask = params[\"mask\"]\n\n        label_image, num_labels = label(mask, return_num=True)\n\n        if num_labels == 0:\n            dropout_mask = None\n        else:\n            objects_to_drop = random.randint(self.max_objects[0], self.max_objects[1])\n            objects_to_drop = min(num_labels, objects_to_drop)\n\n            if objects_to_drop == num_labels:\n                dropout_mask = mask &gt; 0\n            else:\n                labels_index = random.sample(range(1, num_labels + 1), objects_to_drop)\n                dropout_mask = np.zeros((mask.shape[0], mask.shape[1]), dtype=bool)\n                for label_index in labels_index:\n                    dropout_mask |= label_image == label_index\n\n        params.update({\"dropout_mask\": dropout_mask})\n        del params[\"mask\"]\n        return params\n\n    def apply(self, img: np.ndarray, dropout_mask: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        if dropout_mask is None:\n            return img\n\n        if self.image_fill_value == \"inpaint\":\n            dropout_mask = dropout_mask.astype(np.uint8)\n            _, _, width, height = cv2.boundingRect(dropout_mask)\n            radius = min(3, max(width, height) // 2)\n            return cv2.inpaint(img, dropout_mask, radius, cv2.INPAINT_NS)\n\n        img = img.copy()\n        img[dropout_mask] = self.image_fill_value\n\n        return img\n\n    def apply_to_mask(self, mask: np.ndarray, dropout_mask: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        if dropout_mask is None:\n            return mask\n\n        mask = mask.copy()\n        mask[dropout_mask] = self.mask_fill_value\n        return mask\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"max_objects\", \"image_fill_value\", \"mask_fill_value\"\n</code></pre>"},{"location":"api_reference/augmentations/dropout/xy_masking/","title":"XYMasking augmentation (augmentations.dropout.xy_masking)","text":""},{"location":"api_reference/augmentations/dropout/xy_masking/#albumentations.augmentations.dropout.xy_masking.XYMasking","title":"<code>class  XYMasking</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Applies masking strips to an image, either horizontally (X axis) or vertically (Y axis), simulating occlusions. This transform is useful for training models to recognize images with varied visibility conditions. It's particularly effective for spectrogram images, allowing spectral and frequency masking to improve model robustness.</p> <p>At least one of <code>max_x_length</code> or <code>max_y_length</code> must be specified, dictating the mask's maximum size along each axis.</p> <p>Parameters:</p> Name Type Description <code>num_masks_x</code> <code>Union[int, Tuple[int, int]]</code> <p>Number or range of horizontal regions to mask. Defaults to 0.</p> <code>num_masks_y</code> <code>Union[int, Tuple[int, int]]</code> <p>Number or range of vertical regions to mask. Defaults to 0.</p> <code>mask_x_length</code> <code>[Union[int, Tuple[int, int]]</code> <p>Specifies the length of the masks along the X (horizontal) axis. If an integer is provided, it sets a fixed mask length. If a tuple of two integers (min, max) is provided, the mask length is randomly chosen within this range for each mask. This allows for variable-length masks in the horizontal direction.</p> <code>mask_y_length</code> <code>Union[int, Tuple[int, int]]</code> <p>Specifies the height of the masks along the Y (vertical) axis. Similar to <code>mask_x_length</code>, an integer sets a fixed mask height, while a tuple (min, max) allows for variable-height masks, chosen randomly within the specified range for each mask. This flexibility facilitates creating masks of various sizes in the vertical direction.</p> <code>fill_value</code> <code>Union[int, float, List[int], List[float]]</code> <p>Value to fill image masks. Defaults to 0.</p> <code>mask_fill_value</code> <code>Optional[Union[int, float, List[int], List[float]]]</code> <p>Value to fill masks in the mask. If <code>None</code>, uses mask is not affected. Default: <code>None</code>.</p> <code>p</code> <code>float</code> <p>Probability of applying the transform. Defaults to 0.5.</p> <p>Targets</p> <p>image, mask, keypoints</p> <p>Image types:     uint8, float32</p> <p>Note: Either <code>max_x_length</code> or <code>max_y_length</code> or both must be defined.</p> Source code in <code>albumentations/augmentations/dropout/xy_masking.py</code> Python<pre><code>class XYMasking(DualTransform):\n    \"\"\"Applies masking strips to an image, either horizontally (X axis) or vertically (Y axis),\n    simulating occlusions. This transform is useful for training models to recognize images\n    with varied visibility conditions. It's particularly effective for spectrogram images,\n    allowing spectral and frequency masking to improve model robustness.\n\n    At least one of `max_x_length` or `max_y_length` must be specified, dictating the mask's\n    maximum size along each axis.\n\n    Args:\n        num_masks_x (Union[int, Tuple[int, int]]): Number or range of horizontal regions to mask. Defaults to 0.\n        num_masks_y (Union[int, Tuple[int, int]]): Number or range of vertical regions to mask. Defaults to 0.\n        mask_x_length ([Union[int, Tuple[int, int]]): Specifies the length of the masks along\n            the X (horizontal) axis. If an integer is provided, it sets a fixed mask length.\n            If a tuple of two integers (min, max) is provided,\n            the mask length is randomly chosen within this range for each mask.\n            This allows for variable-length masks in the horizontal direction.\n        mask_y_length (Union[int, Tuple[int, int]]): Specifies the height of the masks along\n            the Y (vertical) axis. Similar to `mask_x_length`, an integer sets a fixed mask height,\n            while a tuple (min, max) allows for variable-height masks, chosen randomly\n            within the specified range for each mask. This flexibility facilitates creating masks of various\n            sizes in the vertical direction.\n        fill_value (Union[int, float, List[int], List[float]]): Value to fill image masks. Defaults to 0.\n        mask_fill_value (Optional[Union[int, float, List[int], List[float]]]): Value to fill masks in the mask.\n            If `None`, uses mask is not affected. Default: `None`.\n        p (float): Probability of applying the transform. Defaults to 0.5.\n\n    Targets:\n        image, mask, keypoints\n\n    Image types:\n        uint8, float32\n\n    Note: Either `max_x_length` or `max_y_length` or both must be defined.\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        num_masks_x: NonNegativeIntRangeType = 0\n        num_masks_y: NonNegativeIntRangeType = 0\n        mask_x_length: NonNegativeIntRangeType = 0\n        mask_y_length: NonNegativeIntRangeType = 0\n\n        fill_value: ColorType = Field(default=0, description=\"Value to fill image masks.\")\n        mask_fill_value: ColorType = Field(default=0, description=\"Value to fill masks in the mask.\")\n\n        @model_validator(mode=\"after\")\n        def check_mask_length(self) -&gt; Self:\n            if (\n                isinstance(self.mask_x_length, int)\n                and self.mask_x_length &lt;= 0\n                and isinstance(self.mask_y_length, int)\n                and self.mask_y_length &lt;= 0\n            ):\n                msg = \"At least one of `mask_x_length` or `mask_y_length` Should be a positive number.\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        num_masks_x: ScaleIntType = 0,\n        num_masks_y: ScaleIntType = 0,\n        mask_x_length: ScaleIntType = 0,\n        mask_y_length: ScaleIntType = 0,\n        fill_value: ColorType = 0,\n        mask_fill_value: ColorType = 0,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.num_masks_x = cast(Tuple[int, int], num_masks_x)\n        self.num_masks_y = cast(Tuple[int, int], num_masks_y)\n\n        self.mask_x_length = cast(Tuple[int, int], mask_x_length)\n        self.mask_y_length = cast(Tuple[int, int], mask_y_length)\n        self.fill_value = fill_value\n        self.mask_fill_value = mask_fill_value\n\n    def apply(\n        self,\n        img: np.ndarray,\n        masks_x: List[Tuple[int, int, int, int]],\n        masks_y: List[Tuple[int, int, int, int]],\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return cutout(img, masks_x + masks_y, self.fill_value)\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        masks_x: List[Tuple[int, int, int, int]],\n        masks_y: List[Tuple[int, int, int, int]],\n        **params: Any,\n    ) -&gt; np.ndarray:\n        if self.mask_fill_value is None:\n            return mask\n        return cutout(mask, masks_x + masks_y, self.mask_fill_value)\n\n    def validate_mask_length(\n        self, mask_length: Optional[Tuple[int, int]], dimension_size: int, dimension_name: str\n    ) -&gt; None:\n        \"\"\"Validate the mask length against the corresponding image dimension size.\n\n        Args:\n            mask_length (Optional[Tuple[int, int]]): The length of the mask to be validated.\n            dimension_size (int): The size of the image dimension (width or height)\n                against which to validate the mask length.\n            dimension_name (str): The name of the dimension ('width' or 'height') for error messaging.\n\n        \"\"\"\n        if mask_length is not None:\n            if isinstance(mask_length, (tuple, list)):\n                if mask_length[0] &lt; 0 or mask_length[1] &gt; dimension_size:\n                    raise ValueError(\n                        f\"{dimension_name} range {mask_length} is out of valid range [0, {dimension_size}]\"\n                    )\n            elif mask_length &lt; 0 or mask_length &gt; dimension_size:\n                raise ValueError(f\"{dimension_name} {mask_length} exceeds image {dimension_name} {dimension_size}\")\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, List[Tuple[int, int, int, int]]]:\n        img = params[\"image\"]\n        height, width = img.shape[:2]\n\n        # Use the helper method to validate mask lengths against image dimensions\n        self.validate_mask_length(self.mask_x_length, width, \"mask_x_length\")\n        self.validate_mask_length(self.mask_y_length, height, \"mask_y_length\")\n\n        masks_x = self.generate_masks(self.num_masks_x, width, height, self.mask_x_length, axis=\"x\")\n        masks_y = self.generate_masks(self.num_masks_y, width, height, self.mask_y_length, axis=\"y\")\n\n        return {\"masks_x\": masks_x, \"masks_y\": masks_y}\n\n    @staticmethod\n    def generate_mask_size(mask_length: Tuple[int, int]) -&gt; int:\n        return random.randint(mask_length[0], mask_length[1])\n\n    def generate_masks(\n        self,\n        num_masks: Tuple[int, int],\n        width: int,\n        height: int,\n        max_length: Optional[Tuple[int, int]],\n        axis: str,\n    ) -&gt; List[Tuple[int, int, int, int]]:\n        if max_length is None or max_length == 0 or isinstance(num_masks, (int, float)) and num_masks == 0:\n            return []\n\n        masks = []\n\n        num_masks_integer = (\n            num_masks if isinstance(num_masks, int) else random_utils.randint(num_masks[0], num_masks[1])\n        )\n\n        for _ in range(num_masks_integer):\n            length = self.generate_mask_size(max_length)\n\n            if axis == \"x\":\n                x1 = random.randint(0, width - length)\n                y1 = 0\n                x2, y2 = x1 + length, height\n            else:  # axis == 'y'\n                y1 = random.randint(0, height - length)\n                x1 = 0\n                x2, y2 = width, y1 + length\n\n            masks.append((x1, y1, x2, y2))\n        return masks\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def apply_to_keypoints(\n        self,\n        keypoints: Sequence[KeypointType],\n        masks_x: List[Tuple[int, int, int, int]],\n        masks_y: List[Tuple[int, int, int, int]],\n        **params: Any,\n    ) -&gt; List[KeypointType]:\n        return [\n            keypoint\n            for keypoint in keypoints\n            if not any(keypoint_in_hole(keypoint, hole) for hole in masks_x + masks_y)\n        ]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"num_masks_x\",\n            \"num_masks_y\",\n            \"mask_x_length\",\n            \"mask_y_length\",\n            \"fill_value\",\n            \"mask_fill_value\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/dropout/xy_masking/#albumentations.augmentations.dropout.xy_masking.XYMasking.validate_mask_length","title":"<code>validate_mask_length (self, mask_length, dimension_size, dimension_name)</code>","text":"<p>Validate the mask length against the corresponding image dimension size.</p> <p>Parameters:</p> Name Type Description <code>mask_length</code> <code>Optional[Tuple[int, int]]</code> <p>The length of the mask to be validated.</p> <code>dimension_size</code> <code>int</code> <p>The size of the image dimension (width or height) against which to validate the mask length.</p> <code>dimension_name</code> <code>str</code> <p>The name of the dimension ('width' or 'height') for error messaging.</p> Source code in <code>albumentations/augmentations/dropout/xy_masking.py</code> Python<pre><code>def validate_mask_length(\n    self, mask_length: Optional[Tuple[int, int]], dimension_size: int, dimension_name: str\n) -&gt; None:\n    \"\"\"Validate the mask length against the corresponding image dimension size.\n\n    Args:\n        mask_length (Optional[Tuple[int, int]]): The length of the mask to be validated.\n        dimension_size (int): The size of the image dimension (width or height)\n            against which to validate the mask length.\n        dimension_name (str): The name of the dimension ('width' or 'height') for error messaging.\n\n    \"\"\"\n    if mask_length is not None:\n        if isinstance(mask_length, (tuple, list)):\n            if mask_length[0] &lt; 0 or mask_length[1] &gt; dimension_size:\n                raise ValueError(\n                    f\"{dimension_name} range {mask_length} is out of valid range [0, {dimension_size}]\"\n                )\n        elif mask_length &lt; 0 or mask_length &gt; dimension_size:\n            raise ValueError(f\"{dimension_name} {mask_length} exceeds image {dimension_name} {dimension_size}\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/","title":"Index","text":"<ul> <li>Geometric functional transforms (albumentations.augmentations.geometric.functional)</li> <li>Resizing transforms (augmentations.geometric.resize)</li> <li>Rotation transforms (augmentations.geometric.functional)</li> <li>Geometric transforms (augmentations.geometric.transforms)</li> </ul>"},{"location":"api_reference/augmentations/geometric/functional/","title":"Geometric functional transforms (augmentations.geometric.functional)","text":""},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.bbox_flip","title":"<code>def bbox_flip    (bbox, d, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a bounding box either vertically, horizontally or both depending on the value of <code>d</code>.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>d</code> <code>int</code> <p>dimension. 0 for vertical flip, 1 for horizontal, -1 for transpose</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if value of <code>d</code> is not -1, 0 or 1.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_flip(bbox: BoxInternalType, d: int, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Flip a bounding box either vertically, horizontally or both depending on the value of `d`.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        d: dimension. 0 for vertical flip, 1 for horizontal, -1 for transpose\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: if value of `d` is not -1, 0 or 1.\n\n    \"\"\"\n    if d == 0:\n        bbox = bbox_vflip(bbox, rows, cols)\n    elif d == 1:\n        bbox = bbox_hflip(bbox, rows, cols)\n    elif d == -1:\n        bbox = bbox_hflip(bbox, rows, cols)\n        bbox = bbox_vflip(bbox, rows, cols)\n    else:\n        raise ValueError(f\"Invalid d value {d}. Valid values are -1, 0 and 1\")\n    return bbox\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.bbox_hflip","title":"<code>def bbox_hflip    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a bounding box horizontally around the y-axis.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_hflip(bbox: BoxInternalType, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Flip a bounding box horizontally around the y-axis.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    return 1 - x_max, y_min, 1 - x_min, y_max\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.bbox_rot90","title":"<code>def bbox_rot90    (bbox, factor, rows, cols)    </code> [view source on GitHub]","text":"<p>Rotates a bounding box by 90 degrees CCW (see np.rot90)</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box tuple (x_min, y_min, x_max, y_max).</p> <code>factor</code> <code>int</code> <p>Number of CCW rotations. Must be in set {0, 1, 2, 3} See np.rot90.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box tuple (x_min, y_min, x_max, y_max).</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_rot90(bbox: BoxInternalType, factor: int, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Rotates a bounding box by 90 degrees CCW (see np.rot90)\n\n    Args:\n        bbox: A bounding box tuple (x_min, y_min, x_max, y_max).\n        factor: Number of CCW rotations. Must be in set {0, 1, 2, 3} See np.rot90.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        tuple: A bounding box tuple (x_min, y_min, x_max, y_max).\n\n    \"\"\"\n    if factor not in {0, 1, 2, 3}:\n        msg = \"Parameter n must be in set {0, 1, 2, 3}\"\n        raise ValueError(msg)\n    x_min, y_min, x_max, y_max = bbox[:4]\n    if factor == 1:\n        bbox = y_min, 1 - x_max, y_max, 1 - x_min\n    elif factor == TWO:\n        bbox = 1 - x_max, 1 - y_max, 1 - x_min, 1 - y_min\n    elif factor == THREE:\n        bbox = 1 - y_max, x_min, 1 - y_min, x_max\n    return bbox\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.bbox_rotate","title":"<code>def bbox_rotate    (bbox, angle, method, rows, cols)    </code> [view source on GitHub]","text":"<p>Rotates a bounding box by angle degrees.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>angle</code> <code>float</code> <p>Angle of rotation in degrees.</p> <code>method</code> <code>str</code> <p>Rotation method used. Should be one of: \"largest_box\", \"ellipse\". Default: \"largest_box\".</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>References</p> <p>https://arxiv.org/abs/2109.13488</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_rotate(bbox: BoxInternalType, angle: float, method: str, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Rotates a bounding box by angle degrees.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        angle: Angle of rotation in degrees.\n        method: Rotation method used. Should be one of: \"largest_box\", \"ellipse\". Default: \"largest_box\".\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    References:\n        https://arxiv.org/abs/2109.13488\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    scale = cols / float(rows)\n    if method == \"largest_box\":\n        x = np.array([x_min, x_max, x_max, x_min]) - 0.5\n        y = np.array([y_min, y_min, y_max, y_max]) - 0.5\n    elif method == \"ellipse\":\n        w = (x_max - x_min) / 2\n        h = (y_max - y_min) / 2\n        data = np.arange(0, 360, dtype=np.float32)\n        x = w * np.sin(np.radians(data)) + (w + x_min - 0.5)\n        y = h * np.cos(np.radians(data)) + (h + y_min - 0.5)\n    else:\n        raise ValueError(f\"Method {method} is not a valid rotation method.\")\n    angle = np.deg2rad(angle)\n    x_t = (np.cos(angle) * x * scale + np.sin(angle) * y) / scale\n    y_t = -np.sin(angle) * x * scale + np.cos(angle) * y\n    x_t = x_t + 0.5\n    y_t = y_t + 0.5\n\n    x_min, x_max = min(x_t), max(x_t)\n    y_min, y_max = min(y_t), max(y_t)\n\n    return x_min, y_min, x_max, y_max\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.bbox_transpose","title":"<code>def bbox_transpose    (bbox, axis, rows, cols)    </code> [view source on GitHub]","text":"<p>Transposes a bounding box along given axis.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>axis</code> <code>int</code> <p>0 - main axis, 1 - secondary axis.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A bounding box tuple <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If axis not equal to 0 or 1.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_transpose(bbox: KeypointInternalType, axis: int, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Transposes a bounding box along given axis.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        axis: 0 - main axis, 1 - secondary axis.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        A bounding box tuple `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: If axis not equal to 0 or 1.\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    if axis not in {0, 1}:\n        msg = \"Axis must be either 0 or 1.\"\n        raise ValueError(msg)\n    if axis == 0:\n        bbox = (y_min, x_min, y_max, x_max)\n    if axis == 1:\n        bbox = (1 - y_max, 1 - x_max, 1 - y_min, 1 - x_min)\n    return bbox\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.bbox_vflip","title":"<code>def bbox_vflip    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a bounding box vertically around the x-axis.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Tuple[float, float, float, float]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image rows.</p> <code>cols</code> <code>int</code> <p>Image cols.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def bbox_vflip(bbox: BoxInternalType, rows: int, cols: int) -&gt; BoxInternalType:\n    \"\"\"Flip a bounding box vertically around the x-axis.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image rows.\n        cols: Image cols.\n\n    Returns:\n        tuple: A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    x_min, y_min, x_max, y_max = bbox[:4]\n    return x_min, 1 - y_max, x_max, 1 - y_min\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.elastic_transform","title":"<code>def elastic_transform    (img, alpha, sigma, alpha_affine, interpolation=1, border_mode=4, value=None, random_state=None, approximate=False, same_dxdy=False)    </code> [view source on GitHub]","text":"<p>Elastic deformation of images as described in [Simard2003]_ (with modifications). Based on https://gist.github.com/ernestum/601cdf56d2b424757de5</p> <p>.. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for      Convolutional Neural Networks applied to Visual Document Analysis\", in      Proc. of the International Conference on Document Analysis and      Recognition, 2003.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef elastic_transform(\n    img: np.ndarray,\n    alpha: float,\n    sigma: float,\n    alpha_affine: float,\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n    random_state: Optional[np.random.RandomState] = None,\n    approximate: bool = False,\n    same_dxdy: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications).\n    Based on https://gist.github.com/ernestum/601cdf56d2b424757de5\n\n    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for\n         Convolutional Neural Networks applied to Visual Document Analysis\", in\n         Proc. of the International Conference on Document Analysis and\n         Recognition, 2003.\n    \"\"\"\n    height, width = img.shape[:2]\n\n    # Random affine\n    center_square = np.array((height, width), dtype=np.float32) // 2\n    square_size = min((height, width)) // 3\n    alpha = float(alpha)\n    sigma = float(sigma)\n    alpha_affine = float(alpha_affine)\n\n    pts1 = np.array(\n        [\n            center_square + square_size,\n            [center_square[0] + square_size, center_square[1] - square_size],\n            center_square - square_size,\n        ],\n        dtype=np.float32,\n    )\n    pts2 = pts1 + random_utils.uniform(-alpha_affine, alpha_affine, size=pts1.shape, random_state=random_state).astype(\n        np.float32\n    )\n    matrix = cv2.getAffineTransform(pts1, pts2)\n\n    warp_fn = _maybe_process_in_chunks(\n        cv2.warpAffine, M=matrix, dsize=(width, height), flags=interpolation, borderMode=border_mode, borderValue=value\n    )\n    img = warp_fn(img)\n\n    if approximate:\n        # Approximate computation smooth displacement map with a large enough kernel.\n        # On large images (512+) this is approximately 2X times faster\n        dx = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n        cv2.GaussianBlur(dx, (17, 17), sigma, dst=dx)\n        dx *= alpha\n        if same_dxdy:\n            # Speed up even more\n            dy = dx\n        else:\n            dy = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n            cv2.GaussianBlur(dy, (17, 17), sigma, dst=dy)\n            dy *= alpha\n    else:\n        dx = np.float32(\n            gaussian_filter((random_utils.rand(height, width, random_state=random_state) * 2 - 1), sigma) * alpha\n        )\n        if same_dxdy:\n            # Speed up\n            dy = dx\n        else:\n            dy = np.float32(\n                gaussian_filter((random_utils.rand(height, width, random_state=random_state) * 2 - 1), sigma) * alpha\n            )\n\n    x, y = np.meshgrid(np.arange(width), np.arange(height))\n\n    map_x = np.float32(x + dx)\n    map_y = np.float32(y + dy)\n\n    remap_fn = _maybe_process_in_chunks(\n        cv2.remap, map1=map_x, map2=map_y, interpolation=interpolation, borderMode=border_mode, borderValue=value\n    )\n    return remap_fn(img)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.elastic_transform_approx","title":"<code>def elastic_transform_approx    (img, alpha, sigma, alpha_affine, interpolation=1, border_mode=4, value=None, random_state=None)    </code> [view source on GitHub]","text":"<p>Elastic deformation of images as described in [Simard2003]_ (with modifications for speed). Based on https://gist.github.com/ernestum/601cdf56d2b424757de5</p> <p>.. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for      Convolutional Neural Networks applied to Visual Document Analysis\", in      Proc. of the International Conference on Document Analysis and      Recognition, 2003.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef elastic_transform_approx(\n    img: np.ndarray,\n    alpha: float,\n    sigma: float,\n    alpha_affine: float,\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n    random_state: Optional[np.random.RandomState] = None,\n) -&gt; np.ndarray:\n    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications for speed).\n    Based on https://gist.github.com/ernestum/601cdf56d2b424757de5\n\n    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for\n         Convolutional Neural Networks applied to Visual Document Analysis\", in\n         Proc. of the International Conference on Document Analysis and\n         Recognition, 2003.\n    \"\"\"\n    height, width = img.shape[:2]\n\n    # Random affine\n    center_square = np.array((height, width), dtype=np.float32) // 2\n    square_size = min((height, width)) // 3\n    alpha = float(alpha)\n    sigma = float(sigma)\n    alpha_affine = float(alpha_affine)\n\n    pts1 = np.array(\n        [\n            center_square + square_size,\n            [center_square[0] + square_size, center_square[1] - square_size],\n            center_square - square_size,\n        ],\n        dtype=np.float32,\n    )\n    pts2 = pts1 + random_utils.uniform(-alpha_affine, alpha_affine, size=pts1.shape, random_state=random_state).astype(\n        np.float32\n    )\n    matrix = cv2.getAffineTransform(pts1, pts2)\n\n    warp_fn = _maybe_process_in_chunks(\n        cv2.warpAffine,\n        M=matrix,\n        dsize=(width, height),\n        flags=interpolation,\n        borderMode=border_mode,\n        borderValue=value,\n    )\n    img = warp_fn(img)\n\n    dx = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n    cv2.GaussianBlur(dx, (17, 17), sigma, dst=dx)\n    dx *= alpha\n\n    dy = random_utils.rand(height, width, random_state=random_state).astype(np.float32) * 2 - 1\n    cv2.GaussianBlur(dy, (17, 17), sigma, dst=dy)\n    dy *= alpha\n\n    x, y = np.meshgrid(np.arange(width), np.arange(height))\n\n    map_x = np.float32(x + dx)\n    map_y = np.float32(y + dy)\n\n    remap_fn = _maybe_process_in_chunks(\n        cv2.remap,\n        map1=map_x,\n        map2=map_y,\n        interpolation=interpolation,\n        borderMode=border_mode,\n        borderValue=value,\n    )\n    return remap_fn(img)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.find_keypoint","title":"<code>def find_keypoint    (position, distance_map, threshold, inverted)    </code> [view source on GitHub]","text":"<p>Determine if a valid keypoint can be found at the given position.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def find_keypoint(\n    position: Tuple[int, int], distance_map: np.ndarray, threshold: Optional[float], inverted: bool\n) -&gt; Optional[Tuple[float, float]]:\n    \"\"\"Determine if a valid keypoint can be found at the given position.\"\"\"\n    y, x = position\n    value = distance_map[y, x]\n    if not inverted and threshold is not None and value &gt;= threshold:\n        return None\n    if inverted and threshold is not None and value &lt; threshold:\n        return None\n    return float(x), float(y)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.from_distance_maps","title":"<code>def from_distance_maps    (distance_maps, inverted, if_not_found_coords, threshold=None)    </code> [view source on GitHub]","text":"<p>Convert outputs of <code>to_distance_maps</code> to <code>KeypointsOnImage</code>. This is the inverse of <code>to_distance_maps</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def from_distance_maps(\n    distance_maps: np.ndarray,\n    inverted: bool,\n    if_not_found_coords: Optional[Union[Sequence[int], Dict[str, Any]]],\n    threshold: Optional[float] = None,\n) -&gt; List[Tuple[float, float]]:\n    \"\"\"Convert outputs of `to_distance_maps` to `KeypointsOnImage`.\n    This is the inverse of `to_distance_maps`.\n    \"\"\"\n    if distance_maps.ndim != THREE:\n        msg = f\"Expected three-dimensional input, got {distance_maps.ndim} dimensions and shape {distance_maps.shape}.\"\n        raise ValueError(msg)\n    height, width, nb_keypoints = distance_maps.shape\n\n    drop_if_not_found, if_not_found_x, if_not_found_y = validate_if_not_found_coords(if_not_found_coords)\n\n    keypoints = []\n    for i in range(nb_keypoints):\n        hitidx_flat = np.argmax(distance_maps[..., i]) if inverted else np.argmin(distance_maps[..., i])\n        hitidx_ndim = np.unravel_index(hitidx_flat, (height, width))\n        keypoint = find_keypoint(hitidx_ndim, distance_maps[:, :, i], threshold, inverted)\n        if keypoint:\n            keypoints.append(keypoint)\n        elif not drop_if_not_found:\n            keypoints.append((if_not_found_x, if_not_found_y))\n\n    return keypoints\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.grid_distortion","title":"<code>def grid_distortion    (img, num_steps=10, xsteps=(), ysteps=(), interpolation=1, border_mode=4, value=None)    </code> [view source on GitHub]","text":"<p>Perform a grid distortion of an input image.</p> <p>Reference</p> <p>http://pythology.blogspot.sg/2014/03/interpolation-on-regular-distorted-grid.html</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef grid_distortion(\n    img: np.ndarray,\n    num_steps: int = 10,\n    xsteps: Tuple[()] = (),\n    ysteps: Tuple[()] = (),\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n) -&gt; np.ndarray:\n    \"\"\"Perform a grid distortion of an input image.\n\n    Reference:\n        http://pythology.blogspot.sg/2014/03/interpolation-on-regular-distorted-grid.html\n    \"\"\"\n    height, width = img.shape[:2]\n\n    x_step = width // num_steps\n    xx = np.zeros(width, np.float32)\n    prev = 0\n    for idx in range(num_steps + 1):\n        x = idx * x_step\n        start = int(x)\n        end = int(x) + x_step\n        if end &gt; width:\n            end = width\n            cur = width\n        else:\n            cur = prev + x_step * xsteps[idx]\n\n        xx[start:end] = np.linspace(prev, cur, end - start)\n        prev = cur\n\n    y_step = height // num_steps\n    yy = np.zeros(height, np.float32)\n    prev = 0\n    for idx in range(num_steps + 1):\n        y = idx * y_step\n        start = int(y)\n        end = int(y) + y_step\n        if end &gt; height:\n            end = height\n            cur = height\n        else:\n            cur = prev + y_step * ysteps[idx]\n\n        yy[start:end] = np.linspace(prev, cur, end - start)\n        prev = cur\n\n    map_x, map_y = np.meshgrid(xx, yy)\n    map_x = map_x.astype(np.float32)\n    map_y = map_y.astype(np.float32)\n\n    remap_fn = _maybe_process_in_chunks(\n        cv2.remap,\n        map1=map_x,\n        map2=map_y,\n        interpolation=interpolation,\n        borderMode=border_mode,\n        borderValue=value,\n    )\n    return remap_fn(img)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.keypoint_flip","title":"<code>def keypoint_flip    (keypoint, d, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a keypoint either vertically, horizontally or both depending on the value of <code>d</code>.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>d</code> <code>int</code> <p>Number of flip. Must be -1, 0 or 1: * 0 - vertical flip, * 1 - horizontal flip, * -1 - vertical and horizontal flip.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if value of <code>d</code> is not -1, 0 or 1.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def keypoint_flip(keypoint: KeypointInternalType, d: int, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Flip a keypoint either vertically, horizontally or both depending on the value of `d`.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        d: Number of flip. Must be -1, 0 or 1:\n            * 0 - vertical flip,\n            * 1 - horizontal flip,\n            * -1 - vertical and horizontal flip.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    Raises:\n        ValueError: if value of `d` is not -1, 0 or 1.\n\n    \"\"\"\n    if d == 0:\n        keypoint = keypoint_vflip(keypoint, rows, cols)\n    elif d == 1:\n        keypoint = keypoint_hflip(keypoint, rows, cols)\n    elif d == -1:\n        keypoint = keypoint_hflip(keypoint, rows, cols)\n        keypoint = keypoint_vflip(keypoint, rows, cols)\n    else:\n        raise ValueError(f\"Invalid d value {d}. Valid values are -1, 0 and 1\")\n    return keypoint\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.keypoint_hflip","title":"<code>def keypoint_hflip    (keypoint, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a keypoint horizontally around the y-axis.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_hflip(keypoint: KeypointInternalType, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Flip a keypoint horizontally around the y-axis.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    angle = math.pi - angle\n    return (cols - 1) - x, y, angle, scale\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.keypoint_rot90","title":"<code>def keypoint_rot90    (keypoint, factor, rows, cols, ** params)    </code> [view source on GitHub]","text":"<p>Rotates a keypoint by 90 degrees CCW (see np.rot90)</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>factor</code> <code>int</code> <p>Number of CCW rotations. Must be in range [0;3] See np.rot90.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if factor not in set {0, 1, 2, 3}</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_rot90(\n    keypoint: KeypointInternalType, factor: int, rows: int, cols: int, **params: Any\n) -&gt; KeypointInternalType:\n    \"\"\"Rotates a keypoint by 90 degrees CCW (see np.rot90)\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        factor: Number of CCW rotations. Must be in range [0;3] See np.rot90.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        tuple: A keypoint `(x, y, angle, scale)`.\n\n    Raises:\n        ValueError: if factor not in set {0, 1, 2, 3}\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n\n    if factor not in {0, 1, 2, 3}:\n        msg = \"Parameter n must be in set {0, 1, 2, 3}\"\n        raise ValueError(msg)\n\n    if factor == 1:\n        x, y, angle = y, (cols - 1) - x, angle - math.pi / 2\n    elif factor == TWO:\n        x, y, angle = (cols - 1) - x, (rows - 1) - y, angle - math.pi\n    elif factor == THREE:\n        x, y, angle = (rows - 1) - y, x, angle + math.pi / 2\n\n    return x, y, angle, scale\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.keypoint_rotate","title":"<code>def keypoint_rotate    (keypoint, angle, rows, cols, ** params)    </code> [view source on GitHub]","text":"<p>Rotate a keypoint by angle.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>angle</code> <code>float</code> <p>Rotation angle.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_rotate(\n    keypoint: KeypointInternalType, angle: float, rows: int, cols: int, **params: Any\n) -&gt; KeypointInternalType:\n    \"\"\"Rotate a keypoint by angle.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        angle: Rotation angle.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    center = (cols - 1) * 0.5, (rows - 1) * 0.5\n    matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n    x, y, a, s = keypoint[:4]\n    x, y = cv2.transform(np.array([[[x, y]]]), matrix).squeeze()\n    return x, y, a + math.radians(angle), s\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.keypoint_scale","title":"<code>def keypoint_scale    (keypoint, scale_x, scale_y)    </code> [view source on GitHub]","text":"<p>Scales a keypoint by scale_x and scale_y.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>scale_x</code> <code>float</code> <p>Scale coefficient x-axis.</p> <code>scale_y</code> <code>float</code> <p>Scale coefficient y-axis.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def keypoint_scale(keypoint: KeypointInternalType, scale_x: float, scale_y: float) -&gt; KeypointInternalType:\n    \"\"\"Scales a keypoint by scale_x and scale_y.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        scale_x: Scale coefficient x-axis.\n        scale_y: Scale coefficient y-axis.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    return x * scale_x, y * scale_y, angle, scale * max(scale_x, scale_y)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.keypoint_transpose","title":"<code>def keypoint_transpose    (keypoint)    </code> [view source on GitHub]","text":"<p>Rotate a keypoint by angle.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def keypoint_transpose(keypoint: KeypointInternalType) -&gt; KeypointInternalType:\n    \"\"\"Rotate a keypoint by angle.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n\n    Returns:\n        A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n\n    angle = np.pi - angle if angle &lt;= np.pi else 3 * np.pi - angle\n\n    return y, x, angle, scale\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.keypoint_vflip","title":"<code>def keypoint_vflip    (keypoint, rows, cols)    </code> [view source on GitHub]","text":"<p>Flip a keypoint vertically around the x-axis.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <code>Tuple[float, float, float, float]</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A keypoint <code>(x, y, angle, scale)</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@angle_2pi_range\ndef keypoint_vflip(keypoint: KeypointInternalType, rows: int, cols: int) -&gt; KeypointInternalType:\n    \"\"\"Flip a keypoint vertically around the x-axis.\n\n    Args:\n        keypoint: A keypoint `(x, y, angle, scale)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        tuple: A keypoint `(x, y, angle, scale)`.\n\n    \"\"\"\n    x, y, angle, scale = keypoint[:4]\n    angle = -angle\n    return x, (rows - 1) - y, angle, scale\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.optical_distortion","title":"<code>def optical_distortion    (img, k=0, dx=0, dy=0, interpolation=1, border_mode=4, value=None)    </code> [view source on GitHub]","text":"<p>Barrel / pincushion distortion. Unconventional augment.</p> <p>Reference</p> <p>|  https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion |  https://stackoverflow.com/questions/10364201/image-transformation-in-opencv |  https://stackoverflow.com/questions/2477774/correcting-fisheye-distortion-programmatically |  http://www.coldvision.io/2017/03/02/advanced-lane-finding-using-opencv/</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>@preserve_shape\ndef optical_distortion(\n    img: np.ndarray,\n    k: int = 0,\n    dx: int = 0,\n    dy: int = 0,\n    interpolation: int = cv2.INTER_LINEAR,\n    border_mode: int = cv2.BORDER_REFLECT_101,\n    value: Optional[ColorType] = None,\n) -&gt; np.ndarray:\n    \"\"\"Barrel / pincushion distortion. Unconventional augment.\n\n    Reference:\n        |  https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion\n        |  https://stackoverflow.com/questions/10364201/image-transformation-in-opencv\n        |  https://stackoverflow.com/questions/2477774/correcting-fisheye-distortion-programmatically\n        |  http://www.coldvision.io/2017/03/02/advanced-lane-finding-using-opencv/\n    \"\"\"\n    height, width = img.shape[:2]\n\n    fx = width\n    fy = height\n\n    cx = width * 0.5 + dx\n    cy = height * 0.5 + dy\n\n    camera_matrix = np.array([[fx, 0, cx], [0, fy, cy], [0, 0, 1]], dtype=np.float32)\n\n    distortion = np.array([k, k, 0, 0, 0], dtype=np.float32)\n    map1, map2 = cv2.initUndistortRectifyMap(camera_matrix, distortion, None, None, (width, height), cv2.CV_32FC1)\n    return cv2.remap(img, map1, map2, interpolation=interpolation, borderMode=border_mode, borderValue=value)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.rotation2d_matrix_to_euler_angles","title":"<code>def rotation2d_matrix_to_euler_angles    (matrix, y_up=False)    </code> [view source on GitHub]","text":"<p>matrix (np.ndarray): Rotation matrix y_up (bool): is Y axis looks up or down</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def rotation2d_matrix_to_euler_angles(matrix: np.ndarray, y_up: bool = False) -&gt; float:\n    \"\"\"Args:\n    matrix (np.ndarray): Rotation matrix\n    y_up (bool): is Y axis looks up or down\n\n    \"\"\"\n    if y_up:\n        return np.arctan2(matrix[1, 0], matrix[0, 0])\n    return np.arctan2(-matrix[1, 0], matrix[0, 0])\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.to_distance_maps","title":"<code>def to_distance_maps    (keypoints, height, width, inverted=False)    </code> [view source on GitHub]","text":"<p>Generate a <code>(H,W,N)</code> array of distance maps for <code>N</code> keypoints.</p> <p>The <code>n</code>-th distance map contains at every location <code>(y, x)</code> the euclidean distance to the <code>n</code>-th keypoint.</p> <p>This function can be used as a helper when augmenting keypoints with a method that only supports the augmentation of images.</p> <p>Parameters:</p> Name Type Description <code>keypoint</code> <p>keypoint coordinates</p> <code>height</code> <code>int</code> <p>image height</p> <code>width</code> <code>int</code> <p>image width</p> <code>inverted</code> <code>bool</code> <p>If <code>True</code>, inverted distance maps are returned where each distance value d is replaced by <code>d/(d+1)</code>, i.e. the distance maps have values in the range <code>(0.0, 1.0]</code> with <code>1.0</code> denoting exactly the position of the respective keypoint.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(H, W, N) ndarray     A <code>float32</code> array containing <code>N</code> distance maps for <code>N</code>     keypoints. Each location <code>(y, x, n)</code> in the array denotes the     euclidean distance at <code>(y, x)</code> to the <code>n</code>-th keypoint.     If <code>inverted</code> is <code>True</code>, the distance <code>d</code> is replaced     by <code>d/(d+1)</code>. The height and width of the array match the     height and width in <code>KeypointsOnImage.shape</code>.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def to_distance_maps(\n    keypoints: Sequence[Tuple[float, float]], height: int, width: int, inverted: bool = False\n) -&gt; np.ndarray:\n    \"\"\"Generate a ``(H,W,N)`` array of distance maps for ``N`` keypoints.\n\n    The ``n``-th distance map contains at every location ``(y, x)`` the\n    euclidean distance to the ``n``-th keypoint.\n\n    This function can be used as a helper when augmenting keypoints with a\n    method that only supports the augmentation of images.\n\n    Args:\n        keypoint: keypoint coordinates\n        height: image height\n        width: image width\n        inverted (bool): If ``True``, inverted distance maps are returned where each\n            distance value d is replaced by ``d/(d+1)``, i.e. the distance\n            maps have values in the range ``(0.0, 1.0]`` with ``1.0`` denoting\n            exactly the position of the respective keypoint.\n\n    Returns:\n        (H, W, N) ndarray\n            A ``float32`` array containing ``N`` distance maps for ``N``\n            keypoints. Each location ``(y, x, n)`` in the array denotes the\n            euclidean distance at ``(y, x)`` to the ``n``-th keypoint.\n            If `inverted` is ``True``, the distance ``d`` is replaced\n            by ``d/(d+1)``. The height and width of the array match the\n            height and width in ``KeypointsOnImage.shape``.\n\n    \"\"\"\n    distance_maps = np.zeros((height, width, len(keypoints)), dtype=np.float32)\n\n    yy = np.arange(0, height)\n    xx = np.arange(0, width)\n    grid_xx, grid_yy = np.meshgrid(xx, yy)\n\n    for i, (x, y) in enumerate(keypoints):\n        distance_maps[:, :, i] = (grid_xx - x) ** 2 + (grid_yy - y) ** 2\n\n    distance_maps = np.sqrt(distance_maps)\n    if inverted:\n        return 1 / (distance_maps + 1)\n    return distance_maps\n</code></pre>"},{"location":"api_reference/augmentations/geometric/functional/#albumentations.augmentations.geometric.functional.validate_if_not_found_coords","title":"<code>def validate_if_not_found_coords    (if_not_found_coords)    </code> [view source on GitHub]","text":"<p>Validate and process <code>if_not_found_coords</code> parameter.</p> Source code in <code>albumentations/augmentations/geometric/functional.py</code> Python<pre><code>def validate_if_not_found_coords(\n    if_not_found_coords: Optional[Union[Sequence[int], Dict[str, Any]]],\n) -&gt; Tuple[bool, int, int]:\n    \"\"\"Validate and process `if_not_found_coords` parameter.\"\"\"\n    if if_not_found_coords is None:\n        return True, -1, -1\n    if isinstance(if_not_found_coords, (tuple, list)):\n        if len(if_not_found_coords) != TWO:\n            msg = \"Expected tuple/list 'if_not_found_coords' to contain exactly two entries.\"\n            raise ValueError(msg)\n        return False, if_not_found_coords[0], if_not_found_coords[1]\n    if isinstance(if_not_found_coords, dict):\n        return False, if_not_found_coords[\"x\"], if_not_found_coords[\"y\"]\n\n    msg = \"Expected if_not_found_coords to be None, tuple, list, or dict.\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/resize/","title":"Resizing transforms (augmentations.geometric.resize)","text":""},{"location":"api_reference/augmentations/geometric/resize/#albumentations.augmentations.geometric.resize.LongestMaxSize","title":"<code>class  LongestMaxSize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rescale an image so that maximum side is equal to max_size, keeping the aspect ratio of the initial image.</p> <p>Parameters:</p> Name Type Description <code>max_size</code> <code>int, list of int</code> <p>maximum size of the image after the transformation. When using a list, max size will be randomly selected from the values in the list.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>interpolation method. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class LongestMaxSize(DualTransform):\n    \"\"\"Rescale an image so that maximum side is equal to max_size, keeping the aspect ratio of the initial image.\n\n    Args:\n        max_size (int, list of int): maximum size of the image after the transformation. When using a list, max size\n            will be randomly selected from the values in the list.\n        interpolation (OpenCV flag): interpolation method. Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(MaxSizeInitSchema):\n        pass\n\n    def __init__(\n        self,\n        max_size: Union[int, Sequence[int]] = 1024,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1,\n    ):\n        super().__init__(always_apply, p)\n        self.interpolation = interpolation\n        self.max_size = max_size\n\n    def apply(\n        self, img: np.ndarray, max_size: int = 1024, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.longest_max_size(img, max_size=max_size, interpolation=interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        # Bounding box coordinates are scale invariant\n        return bbox\n\n    def apply_to_keypoint(\n        self, keypoint: KeypointInternalType, max_size: int = 1024, **params: Any\n    ) -&gt; KeypointInternalType:\n        height = params[\"rows\"]\n        width = params[\"cols\"]\n\n        scale = max_size / max([height, width])\n        return F.keypoint_scale(keypoint, scale, scale)\n\n    def get_params(self) -&gt; Dict[str, int]:\n        return {\"max_size\": self.max_size if isinstance(self.max_size, int) else random.choice(self.max_size)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"max_size\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/resize/#albumentations.augmentations.geometric.resize.RandomScale","title":"<code>class  RandomScale</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly resize the input. Output image size is different from the input image size.</p> <p>Parameters:</p> Name Type Description <code>scale_limit</code> <code>float, float) or float</code> <p>scaling factor range. If scale_limit is a single float value, the range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1. If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high). Default: (-0.1, 0.1).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class RandomScale(DualTransform):\n    \"\"\"Randomly resize the input. Output image size is different from the input image size.\n\n    Args:\n        scale_limit ((float, float) or float): scaling factor range. If scale_limit is a single float value, the\n            range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1.\n            If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high).\n            Default: (-0.1, 0.1).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale_limit: ScaleFloatType = Field(\n            default=0.1,\n            description=\"Scaling factor range. If a single float value =&gt; (1-scale_limit, 1 + scale_limit).\",\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n        @field_validator(\"scale_limit\")\n        @classmethod\n        def check_scale_limit(cls, v: ScaleFloatType) -&gt; Tuple[float, float]:\n            return to_tuple(v, bias=1.0)\n\n    def __init__(\n        self,\n        scale_limit: ScaleFloatType = 0.1,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.scale_limit = cast(Tuple[float, float], scale_limit)\n        self.interpolation = interpolation\n\n    def get_params(self) -&gt; Dict[str, float]:\n        return {\"scale\": random.uniform(self.scale_limit[0], self.scale_limit[1])}\n\n    def apply(\n        self, img: np.ndarray, scale: float = 0, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.scale(img, scale, interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        # Bounding box coordinates are scale invariant\n        return bbox\n\n    def apply_to_keypoint(\n        self, keypoint: KeypointInternalType, scale: float = 0, **params: Any\n    ) -&gt; KeypointInternalType:\n        return F.keypoint_scale(keypoint, scale, scale)\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\"interpolation\": self.interpolation, \"scale_limit\": to_tuple(self.scale_limit, bias=-1.0)}\n</code></pre>"},{"location":"api_reference/augmentations/geometric/resize/#albumentations.augmentations.geometric.resize.Resize","title":"<code>class  Resize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Resize the input to the given height and width.</p> <p>Parameters:</p> Name Type Description <code>height</code> <code>int</code> <p>desired height of the output.</p> <code>width</code> <code>int</code> <p>desired width of the output.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class Resize(DualTransform):\n    \"\"\"Resize the input to the given height and width.\n\n    Args:\n        height (int): desired height of the output.\n        width (int): desired width of the output.\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        height: int = Field(ge=1, description=\"Desired height of the output.\")\n        width: int = Field(ge=1, description=\"Desired width of the output.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        p: ProbabilityType = 1\n\n    def __init__(\n        self, height: int, width: int, interpolation: int = cv2.INTER_LINEAR, always_apply: bool = False, p: float = 1\n    ):\n        super().__init__(always_apply, p)\n        self.height = height\n        self.width = width\n        self.interpolation = interpolation\n\n    def apply(self, img: np.ndarray, interpolation: int = cv2.INTER_LINEAR, **params: Any) -&gt; np.ndarray:\n        return F.resize(img, height=self.height, width=self.width, interpolation=interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        # Bounding box coordinates are scale invariant\n        return bbox\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        height = params[\"rows\"]\n        width = params[\"cols\"]\n        scale_x = self.width / width\n        scale_y = self.height / height\n        return F.keypoint_scale(keypoint, scale_x, scale_y)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"height\", \"width\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/resize/#albumentations.augmentations.geometric.resize.SmallestMaxSize","title":"<code>class  SmallestMaxSize</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rescale an image so that minimum side is equal to max_size, keeping the aspect ratio of the initial image.</p> <p>Parameters:</p> Name Type Description <code>max_size</code> <code>int, list of int</code> <p>maximum size of smallest side of the image after the transformation. When using a list, max size will be randomly selected from the values in the list.</p> <code>interpolation</code> <code>OpenCV flag</code> <p>interpolation method. Default: cv2.INTER_LINEAR.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/resize.py</code> Python<pre><code>class SmallestMaxSize(DualTransform):\n    \"\"\"Rescale an image so that minimum side is equal to max_size, keeping the aspect ratio of the initial image.\n\n    Args:\n        max_size (int, list of int): maximum size of smallest side of the image after the transformation. When using a\n            list, max size will be randomly selected from the values in the list.\n        interpolation (OpenCV flag): interpolation method. Default: cv2.INTER_LINEAR.\n        p (float): probability of applying the transform. Default: 1.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(MaxSizeInitSchema):\n        pass\n\n    def __init__(\n        self,\n        max_size: Union[int, Sequence[int]] = 1024,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 1,\n    ):\n        super().__init__(always_apply, p)\n        self.interpolation = interpolation\n        self.max_size = max_size\n\n    def apply(\n        self, img: np.ndarray, max_size: int = 1024, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.smallest_max_size(img, max_size=max_size, interpolation=interpolation)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return bbox\n\n    def apply_to_keypoint(\n        self, keypoint: KeypointInternalType, max_size: int = 1024, **params: Any\n    ) -&gt; KeypointInternalType:\n        height = params[\"rows\"]\n        width = params[\"cols\"]\n\n        scale = max_size / min([height, width])\n        return F.keypoint_scale(keypoint, scale, scale)\n\n    def get_params(self) -&gt; Dict[str, int]:\n        return {\"max_size\": self.max_size if isinstance(self.max_size, int) else random.choice(self.max_size)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"max_size\", \"interpolation\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/rotate/","title":"Rotation transforms (augmentations.geometric.functional)","text":""},{"location":"api_reference/augmentations/geometric/rotate/#albumentations.augmentations.geometric.rotate.RandomRotate90","title":"<code>class  RandomRotate90</code> <code> </code>  [view source on GitHub]","text":"<p>Randomly rotate the input by 90 degrees zero or more times.</p> <p>Parameters:</p> Name Type Description <code>p</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>class RandomRotate90(DualTransform):\n    \"\"\"Randomly rotate the input by 90 degrees zero or more times.\n\n    Args:\n        p: probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, factor: float = 0, **params: Any) -&gt; np.ndarray:\n        \"\"\"Args:\n        factor (int): number of times the input will be rotated by 90 degrees.\n\n        \"\"\"\n        return np.ascontiguousarray(np.rot90(img, factor))\n\n    def get_params(self) -&gt; Dict[str, int]:\n        # Random int in the range [0, 3]\n        return {\"factor\": random.randint(0, 3)}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, factor: int = 0, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_rot90(bbox, factor, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, factor: int = 0, **params: Any) -&gt; BoxInternalType:\n        return F.keypoint_rot90(keypoint, factor, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/geometric/rotate/#albumentations.augmentations.geometric.rotate.RandomRotate90.apply","title":"<code>apply (self, img, factor=0, **params)</code>","text":"<p>factor (int): number of times the input will be rotated by 90 degrees.</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>def apply(self, img: np.ndarray, factor: float = 0, **params: Any) -&gt; np.ndarray:\n    \"\"\"Args:\n    factor (int): number of times the input will be rotated by 90 degrees.\n\n    \"\"\"\n    return np.ascontiguousarray(np.rot90(img, factor))\n</code></pre>"},{"location":"api_reference/augmentations/geometric/rotate/#albumentations.augmentations.geometric.rotate.Rotate","title":"<code>class  Rotate</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rotate the input by an angle selected randomly from the uniform distribution.</p> <p>Parameters:</p> Name Type Description <code>limit</code> <p>range from which a random angle is picked. If limit is a single int an angle is picked from (-limit, limit). Default: (-90, 90)</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>rotate_method</code> <code>str</code> <p>rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\". Default: \"largest_box\"</p> <code>crop_border</code> <code>bool</code> <p>If True would make a largest possible crop within rotated image</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>class Rotate(DualTransform):\n    \"\"\"Rotate the input by an angle selected randomly from the uniform distribution.\n\n    Args:\n        limit: range from which a random angle is picked. If limit is a single int\n            an angle is picked from (-limit, limit). Default: (-90, 90)\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        rotate_method (str): rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\".\n            Default: \"largest_box\"\n        crop_border (bool): If True would make a largest possible crop within rotated image\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(RotateInitSchema):\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\"\n        crop_border: bool = Field(\n            default=False, description=\"If True, makes a largest possible crop within the rotated image.\"\n        )\n\n    def __init__(\n        self,\n        limit: ScaleFloatType = 90,\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\",\n        crop_border: bool = False,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.limit = cast(Tuple[float, float], limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n        self.rotate_method = rotate_method\n        self.crop_border = crop_border\n\n    def apply(\n        self,\n        img: np.ndarray,\n        angle: float = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        img_out = F.rotate(img, angle, interpolation, self.border_mode, self.value)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.crop(img_out, x_min, y_min, x_max, y_max)\n        return img_out\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        angle: float,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        img_out = F.rotate(mask, angle, cv2.INTER_NEAREST, self.border_mode, self.mask_value)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.crop(img_out, x_min, y_min, x_max, y_max)\n        return img_out\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        angle: float = 0,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        cols: int = 0,\n        rows: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        bbox_out = F.bbox_rotate(bbox, angle, self.rotate_method, rows, cols)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.bbox_crop(bbox_out, x_min, y_min, x_max, y_max, rows, cols)\n        return bbox_out\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        angle: float = 0,\n        x_min: Optional[int] = None,\n        x_max: Optional[int] = None,\n        y_min: Optional[int] = None,\n        y_max: Optional[int] = None,\n        cols: int = 0,\n        rows: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        keypoint_out = F.keypoint_rotate(keypoint, angle, rows, cols, **params)\n        if self.crop_border and x_min is not None and x_max is not None and y_min is not None and y_max is not None:\n            return FCrops.crop_keypoint_by_coords(keypoint_out, (x_min, y_min, x_max, y_max))\n        return keypoint_out\n\n    @staticmethod\n    def _rotated_rect_with_max_area(height: int, width: int, angle: float) -&gt; Dict[str, int]:\n        \"\"\"Given a rectangle of size wxh that has been rotated by 'angle' (in\n        degrees), computes the width and height of the largest possible\n        axis-aligned rectangle (maximal area) within the rotated rectangle.\n\n        Reference:\n            https://stackoverflow.com/questions/16702966/rotate-image-and-crop-out-black-borders\n        \"\"\"\n        angle = math.radians(angle)\n        width_is_longer = width &gt;= height\n        side_long, side_short = (width, height) if width_is_longer else (height, width)\n\n        # since the solutions for angle, -angle and 180-angle are all the same,\n        # it is sufficient to look at the first quadrant and the absolute values of sin,cos:\n        sin_a, cos_a = abs(math.sin(angle)), abs(math.cos(angle))\n        if side_short &lt;= 2.0 * sin_a * cos_a * side_long or abs(sin_a - cos_a) &lt; SMALL_NUMBER:\n            # half constrained case: two crop corners touch the longer side,\n            # the other two corners are on the mid-line parallel to the longer line\n            x = 0.5 * side_short\n            wr, hr = (x / sin_a, x / cos_a) if width_is_longer else (x / cos_a, x / sin_a)\n        else:\n            # fully constrained case: crop touches all 4 sides\n            cos_2a = cos_a * cos_a - sin_a * sin_a\n            wr, hr = (width * cos_a - height * sin_a) / cos_2a, (height * cos_a - width * sin_a) / cos_2a\n\n        return {\n            \"x_min\": max(0, int(width / 2 - wr / 2)),\n            \"x_max\": min(width, int(width / 2 + wr / 2)),\n            \"y_min\": max(0, int(height / 2 - hr / 2)),\n            \"y_max\": min(height, int(height / 2 + hr / 2)),\n        }\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        out_params = {\"angle\": random.uniform(self.limit[0], self.limit[1])}\n        if self.crop_border:\n            height, width = params[\"image\"].shape[:2]\n            out_params.update(self._rotated_rect_with_max_area(height, width, out_params[\"angle\"]))\n        return out_params\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"limit\", \"interpolation\", \"border_mode\", \"value\", \"mask_value\", \"rotate_method\", \"crop_border\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/rotate/#albumentations.augmentations.geometric.rotate.SafeRotate","title":"<code>class  SafeRotate</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Rotate the input inside the input's frame by an angle selected randomly from the uniform distribution.</p> <p>The resulting image may have artifacts in it. After rotation, the image may have a different aspect ratio, and after resizing, it returns to its original shape with the original aspect ratio of the image. For these reason we may see some artifacts.</p> <p>Parameters:</p> Name Type Description <code>limit</code> <code>int, int) or int</code> <p>range from which a random angle is picked. If limit is a single int an angle is picked from (-limit, limit). Default: (-90, 90)</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/rotate.py</code> Python<pre><code>class SafeRotate(DualTransform):\n    \"\"\"Rotate the input inside the input's frame by an angle selected randomly from the uniform distribution.\n\n    The resulting image may have artifacts in it. After rotation, the image may have a different aspect ratio, and\n    after resizing, it returns to its original shape with the original aspect ratio of the image. For these reason we\n    may see some artifacts.\n\n    Args:\n        limit ((int, int) or int): range from which a random angle is picked. If limit is a single int\n            an angle is picked from (-limit, limit). Default: (-90, 90)\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(RotateInitSchema):\n        pass\n\n    def __init__(\n        self,\n        limit: ScaleFloatType = (-90, 90),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.limit = cast(Tuple[float, float], limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def apply(self, img: np.ndarray, matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.safe_rotate(img, matrix, cast(int, self.interpolation), self.value, self.border_mode)\n\n    def apply_to_mask(self, mask: np.ndarray, matrix: Optional[np.ndarray] = None, **params: Any) -&gt; np.ndarray:\n        return F.safe_rotate(mask, matrix, cv2.INTER_NEAREST, self.mask_value, self.border_mode)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, cols: int = 0, rows: int = 0, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_safe_rotate(bbox, params[\"matrix\"], cols, rows)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        angle: float = 0,\n        scale_x: float = 0,\n        scale_y: float = 0,\n        cols: int = 0,\n        rows: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.keypoint_safe_rotate(keypoint, params[\"matrix\"], angle, scale_x, scale_y, cols, rows)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        angle = random.uniform(self.limit[0], self.limit[1])\n\n        image = params[\"image\"]\n        height, width = image.shape[:2]\n\n        # https://stackoverflow.com/questions/43892506/opencv-python-rotate-image-without-cropping-sides\n        image_center = (width / 2, height / 2)\n\n        # Rotation Matrix\n        rotation_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)\n\n        # rotation calculates the cos and sin, taking absolutes of those.\n        abs_cos = abs(rotation_mat[0, 0])\n        abs_sin = abs(rotation_mat[0, 1])\n\n        # find the new width and height bounds\n        new_w = math.ceil(height * abs_sin + width * abs_cos)\n        new_h = math.ceil(height * abs_cos + width * abs_sin)\n\n        scale_x = width / new_w\n        scale_y = height / new_h\n\n        # Shift the image to create padding\n        rotation_mat[0, 2] += new_w / 2 - image_center[0]\n        rotation_mat[1, 2] += new_h / 2 - image_center[1]\n\n        # Rescale to original size\n        scale_mat = np.diag(np.ones(3))\n        scale_mat[0, 0] *= scale_x\n        scale_mat[1, 1] *= scale_y\n        _tmp = np.diag(np.ones(3))\n        _tmp[:2] = rotation_mat\n        _tmp = scale_mat @ _tmp\n        rotation_mat = _tmp[:2]\n\n        return {\"matrix\": rotation_mat, \"angle\": angle, \"scale_x\": scale_x, \"scale_y\": scale_y}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, str, str, str, str]:\n        return (\"limit\", \"interpolation\", \"border_mode\", \"value\", \"mask_value\")\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/","title":"Geometric transforms (augmentations.geometric.transforms)","text":""},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.Affine","title":"<code>class  Affine</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Augmentation to apply affine transformations to images. This is mostly a wrapper around the corresponding classes and functions in OpenCV.</p> <p>Affine transformations involve:</p> <pre><code>- Translation (\"move\" image on the x-/y-axis)\n- Rotation\n- Scaling (\"zoom\" in/out)\n- Shear (move one side of the image, turning a square into a trapezoid)\n</code></pre> <p>All such transformations can create \"new\" pixels in the image without a defined content, e.g. if the image is translated to the left, pixels are created on the right. A method has to be defined to deal with these pixel values. The parameters <code>cval</code> and <code>mode</code> of this class deal with this.</p> <p>Some transformations involve interpolations between several pixels of the input image to generate output pixel values. The parameters <code>interpolation</code> and <code>mask_interpolation</code> deals with the method of interpolation used for this.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <code>number, tuple of number or dict</code> <p>Scaling factor to use, where <code>1.0</code> denotes \"no change\" and <code>0.5</code> is zoomed out to <code>50</code> percent of the original size.     * If a single number, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from the interval <code>[a, b]</code>.       That the same range will be used for both x- and y-axis. To keep the aspect ratio, set       <code>keep_ratio=True</code>, then the same value will be used for both x- and y-axis.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes. Note that when       the <code>keep_ratio=True</code>, the x- and y-axis ranges should be the same.</p> <code>translate_percent</code> <code>None, number, tuple of number or dict</code> <p>Translation as a fraction of the image height/width (x-translation, y-translation), where <code>0</code> denotes \"no change\" and <code>0.5</code> denotes \"half of the axis size\".     * If <code>None</code> then equivalent to <code>0.0</code> unless <code>translate_px</code> has a value other than <code>None</code>.     * If a single number, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from the interval <code>[a, b]</code>.       That sampled fraction value will be used identically for both x- and y-axis.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes.</p> <code>translate_px</code> <code>None, int, tuple of int or dict</code> <p>Translation in pixels.     * If <code>None</code> then equivalent to <code>0</code> unless <code>translate_percent</code> has a value other than <code>None</code>.     * If a single int, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from       the discrete interval <code>[a..b]</code>. That number will be used identically for both x- and y-axis.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes.</p> <code>rotate</code> <code>number or tuple of number</code> <p>Rotation in degrees (NOT radians), i.e. expected value range is around <code>[-360, 360]</code>. Rotation happens around the center of the image, not the top left corner as in some other frameworks.     * If a number, then that value will be used for all images.     * If a tuple <code>(a, b)</code>, then a value will be uniformly sampled per image from the interval <code>[a, b]</code>       and used as the rotation value.</p> <code>shear</code> <code>number, tuple of number or dict</code> <p>Shear in degrees (NOT radians), i.e. expected value range is around <code>[-360, 360]</code>, with reasonable values being in the range of <code>[-45, 45]</code>.     * If a number, then that value will be used for all images as       the shear on the x-axis (no shear on the y-axis will be done).     * If a tuple <code>(a, b)</code>, then two value will be uniformly sampled per image       from the interval <code>[a, b]</code> and be used as the x- and y-shear value.     * If a dictionary, then it is expected to have the keys <code>x</code> and/or <code>y</code>.       Each of these keys can have the same values as described above.       Using a dictionary allows to set different values for the two axis and sampling will then happen       independently per axis, resulting in samples that differ between the axes.</p> <code>interpolation</code> <code>int</code> <p>OpenCV interpolation flag.</p> <code>mask_interpolation</code> <code>int</code> <p>OpenCV interpolation flag.</p> <code>cval</code> <code>number or sequence of number</code> <p>The constant value to use when filling in newly created pixels. (E.g. translating by 1px to the right will create a new 1px-wide column of pixels on the left of the image). The value is only used when <code>mode=constant</code>. The expected value range is <code>[0, 255]</code> for <code>uint8</code> images.</p> <code>cval_mask</code> <code>number or tuple of number</code> <p>Same as cval but only for masks.</p> <code>mode</code> <code>int</code> <p>OpenCV border flag.</p> <code>fit_output</code> <code>bool</code> <p>If True, the image plane size and position will be adjusted to tightly capture the whole image after affine transformation (<code>translate_percent</code> and <code>translate_px</code> are ignored). Otherwise (<code>False</code>),  parts of the transformed image may end up outside the image plane. Fitting the output shape can be useful to avoid corners of the image being outside the image plane after applying rotations. Default: False</p> <code>keep_ratio</code> <code>bool</code> <p>When True, the original aspect ratio will be kept when the random scale is applied.                Default: False.</p> <code>rotate_method</code> <code>str</code> <p>rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\"[1]. Default: \"largest_box\"</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>[1] https://arxiv.org/abs/2109.13488</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Affine(DualTransform):\n    \"\"\"Augmentation to apply affine transformations to images.\n    This is mostly a wrapper around the corresponding classes and functions in OpenCV.\n\n    Affine transformations involve:\n\n        - Translation (\"move\" image on the x-/y-axis)\n        - Rotation\n        - Scaling (\"zoom\" in/out)\n        - Shear (move one side of the image, turning a square into a trapezoid)\n\n    All such transformations can create \"new\" pixels in the image without a defined content, e.g.\n    if the image is translated to the left, pixels are created on the right.\n    A method has to be defined to deal with these pixel values.\n    The parameters `cval` and `mode` of this class deal with this.\n\n    Some transformations involve interpolations between several pixels\n    of the input image to generate output pixel values. The parameters `interpolation` and\n    `mask_interpolation` deals with the method of interpolation used for this.\n\n    Args:\n        scale (number, tuple of number or dict): Scaling factor to use, where ``1.0`` denotes \"no change\" and\n            ``0.5`` is zoomed out to ``50`` percent of the original size.\n                * If a single number, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from the interval ``[a, b]``.\n                  That the same range will be used for both x- and y-axis. To keep the aspect ratio, set\n                  ``keep_ratio=True``, then the same value will be used for both x- and y-axis.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes. Note that when\n                  the ``keep_ratio=True``, the x- and y-axis ranges should be the same.\n        translate_percent (None, number, tuple of number or dict): Translation as a fraction of the image height/width\n            (x-translation, y-translation), where ``0`` denotes \"no change\"\n            and ``0.5`` denotes \"half of the axis size\".\n                * If ``None`` then equivalent to ``0.0`` unless `translate_px` has a value other than ``None``.\n                * If a single number, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from the interval ``[a, b]``.\n                  That sampled fraction value will be used identically for both x- and y-axis.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes.\n        translate_px (None, int, tuple of int or dict): Translation in pixels.\n                * If ``None`` then equivalent to ``0`` unless `translate_percent` has a value other than ``None``.\n                * If a single int, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from\n                  the discrete interval ``[a..b]``. That number will be used identically for both x- and y-axis.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes.\n        rotate (number or tuple of number): Rotation in degrees (**NOT** radians), i.e. expected value range is\n            around ``[-360, 360]``. Rotation happens around the *center* of the image,\n            not the top left corner as in some other frameworks.\n                * If a number, then that value will be used for all images.\n                * If a tuple ``(a, b)``, then a value will be uniformly sampled per image from the interval ``[a, b]``\n                  and used as the rotation value.\n        shear (number, tuple of number or dict): Shear in degrees (**NOT** radians), i.e. expected value range is\n            around ``[-360, 360]``, with reasonable values being in the range of ``[-45, 45]``.\n                * If a number, then that value will be used for all images as\n                  the shear on the x-axis (no shear on the y-axis will be done).\n                * If a tuple ``(a, b)``, then two value will be uniformly sampled per image\n                  from the interval ``[a, b]`` and be used as the x- and y-shear value.\n                * If a dictionary, then it is expected to have the keys ``x`` and/or ``y``.\n                  Each of these keys can have the same values as described above.\n                  Using a dictionary allows to set different values for the two axis and sampling will then happen\n                  *independently* per axis, resulting in samples that differ between the axes.\n        interpolation (int): OpenCV interpolation flag.\n        mask_interpolation (int): OpenCV interpolation flag.\n        cval (number or sequence of number): The constant value to use when filling in newly created pixels.\n            (E.g. translating by 1px to the right will create a new 1px-wide column of pixels\n            on the left of the image).\n            The value is only used when `mode=constant`. The expected value range is ``[0, 255]`` for ``uint8`` images.\n        cval_mask (number or tuple of number): Same as cval but only for masks.\n        mode (int): OpenCV border flag.\n        fit_output (bool): If True, the image plane size and position will be adjusted to tightly capture\n            the whole image after affine transformation (`translate_percent` and `translate_px` are ignored).\n            Otherwise (``False``),  parts of the transformed image may end up outside the image plane.\n            Fitting the output shape can be useful to avoid corners of the image being outside the image plane\n            after applying rotations. Default: False\n        keep_ratio (bool): When True, the original aspect ratio will be kept when the random scale is applied.\n                           Default: False.\n        rotate_method (str): rotation method used for the bounding boxes. Should be one of \"largest_box\" or\n            \"ellipse\"[1].\n            Default: \"largest_box\"\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        [1] https://arxiv.org/abs/2109.13488\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: Optional[Union[ScaleFloatType, Dict[str, Any]]] = Field(\n            default=None, description=\"Scaling factor or dictionary for independent axis scaling.\"\n        )\n        translate_percent: Optional[Union[ScaleFloatType, Dict[str, Any]]] = Field(\n            default=None, description=\"Translation as a fraction of the image dimension.\"\n        )\n        translate_px: Optional[Union[ScaleIntType, Dict[str, Any]]] = Field(\n            default=None, description=\"Translation in pixels.\"\n        )\n        rotate: Optional[ScaleFloatType] = Field(default=None, description=\"Rotation angle in degrees.\")\n        shear: Optional[Union[ScaleFloatType, Dict[str, Any]]] = Field(\n            default=None, description=\"Shear angle in degrees.\"\n        )\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        mask_interpolation: InterpolationType = cv2.INTER_NEAREST\n\n        cval: ColorType = Field(default=0, description=\"Value used for constant padding.\")\n        cval_mask: ColorType = Field(default=0, description=\"Value used for mask constant padding.\")\n        mode: BorderModeType = cv2.BORDER_CONSTANT\n        fit_output: Annotated[bool, Field(default=False, description=\"Adjust output to capture whole image.\")]\n        keep_ratio: Annotated[bool, Field(default=False, description=\"Maintain aspect ratio when scaling.\")]\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\"\n\n    def __init__(\n        self,\n        scale: Optional[Union[ScaleFloatType, Dict[str, Any]]] = None,\n        translate_percent: Optional[Union[ScaleFloatType, Dict[str, Any]]] = None,\n        translate_px: Optional[Union[ScaleIntType, Dict[str, Any]]] = None,\n        rotate: Optional[ScaleFloatType] = None,\n        shear: Optional[Union[ScaleFloatType, Dict[str, Any]]] = None,\n        interpolation: int = cv2.INTER_LINEAR,\n        mask_interpolation: int = cv2.INTER_NEAREST,\n        cval: ColorType = 0,\n        cval_mask: ColorType = 0,\n        mode: int = cv2.BORDER_CONSTANT,\n        fit_output: bool = False,\n        keep_ratio: bool = False,\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply=always_apply, p=p)\n\n        params = [scale, translate_percent, translate_px, rotate, shear]\n        if all(p is None for p in params):\n            scale = {\"x\": (0.9, 1.1), \"y\": (0.9, 1.1)}\n            translate_percent = {\"x\": (-0.1, 0.1), \"y\": (-0.1, 0.1)}\n            rotate = (-15, 15)\n            shear = {\"x\": (-10, 10), \"y\": (-10, 10)}\n        else:\n            scale = scale if scale is not None else 1.0\n            rotate = rotate if rotate is not None else 0.0\n            shear = shear if shear is not None else 0.0\n\n        self.interpolation = interpolation\n        self.mask_interpolation = mask_interpolation\n        self.cval = cval\n        self.cval_mask = cval_mask\n        self.mode = mode\n        self.scale = self._handle_dict_arg(scale, \"scale\")\n        self.translate_percent, self.translate_px = self._handle_translate_arg(translate_px, translate_percent)\n        self.rotate = to_tuple(rotate, rotate)\n        self.fit_output = fit_output\n        self.shear = self._handle_dict_arg(shear, \"shear\")\n        self.keep_ratio = keep_ratio\n        self.rotate_method = rotate_method\n\n        if self.keep_ratio and self.scale[\"x\"] != self.scale[\"y\"]:\n            raise ValueError(f\"When keep_ratio is True, the x and y scale range should be identical. got {self.scale}\")\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"interpolation\",\n            \"mask_interpolation\",\n            \"cval\",\n            \"mode\",\n            \"scale\",\n            \"translate_percent\",\n            \"translate_px\",\n            \"rotate\",\n            \"fit_output\",\n            \"shear\",\n            \"cval_mask\",\n            \"keep_ratio\",\n            \"rotate_method\",\n        )\n\n    @staticmethod\n    def _handle_dict_arg(\n        val: Union[float, Tuple[float, float], Dict[str, Any]], name: str, default: float = 1.0\n    ) -&gt; Dict[str, Any]:\n        if isinstance(val, dict):\n            if \"x\" not in val and \"y\" not in val:\n                raise ValueError(\n                    f'Expected {name} dictionary to contain at least key \"x\" or ' 'key \"y\". Found neither of them.'\n                )\n            x = val.get(\"x\", default)\n            y = val.get(\"y\", default)\n            return {\"x\": to_tuple(x, x), \"y\": to_tuple(y, y)}\n        return {\"x\": to_tuple(val, val), \"y\": to_tuple(val, val)}\n\n    @classmethod\n    def _handle_translate_arg(\n        cls,\n        translate_px: Optional[Union[ScaleFloatType, Dict[str, Any]]],\n        translate_percent: Optional[Union[ScaleFloatType, Dict[str, Any]]],\n    ) -&gt; Any:\n        if translate_percent is None and translate_px is None:\n            translate_px = 0\n\n        if translate_percent is not None and translate_px is not None:\n            msg = \"Expected either translate_percent or translate_px to be \" \"provided, \" \"but neither of them was.\"\n            raise ValueError(msg)\n\n        if translate_percent is not None:\n            # translate by percent\n            return cls._handle_dict_arg(translate_percent, \"translate_percent\", default=0.0), translate_px\n\n        if translate_px is None:\n            msg = \"translate_px is None.\"\n            raise ValueError(msg)\n        # translate by pixels\n        return translate_percent, cls._handle_dict_arg(translate_px, \"translate_px\")\n\n    def apply(\n        self,\n        img: np.ndarray,\n        matrix: skimage.transform.ProjectiveTransform = None,\n        output_shape: Sequence[int] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.warp_affine(\n            img,\n            matrix,\n            interpolation=cast(int, self.interpolation),\n            cval=self.cval,\n            mode=self.mode,\n            output_shape=output_shape,\n        )\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        matrix: skimage.transform.ProjectiveTransform = None,\n        output_shape: Sequence[int] = (),\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.warp_affine(\n            mask,\n            matrix,\n            interpolation=self.mask_interpolation,\n            cval=self.cval_mask,\n            mode=self.mode,\n            output_shape=output_shape,\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        matrix: skimage.transform.ProjectiveTransform = None,\n        rows: int = 0,\n        cols: int = 0,\n        output_shape: Sequence[int] = (),\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.bbox_affine(bbox, matrix, self.rotate_method, rows, cols, output_shape)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        matrix: Optional[skimage.transform.ProjectiveTransform] = None,\n        scale: Optional[Dict[str, Any]] = None,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        if scale is None:\n            msg = \"Expected scale to be provided, but got None.\"\n            raise ValueError(msg)\n        if matrix is None:\n            msg = \"Expected matrix to be provided, but got None.\"\n            raise ValueError(msg)\n\n        return F.keypoint_affine(keypoint, matrix=matrix, scale=scale)\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        translate: Dict[str, Union[int, float]]\n        if self.translate_px is not None:\n            translate = {key: random.randint(*value) for key, value in self.translate_px.items()}\n        elif self.translate_percent is not None:\n            translate = {key: random.uniform(*value) for key, value in self.translate_percent.items()}\n            translate[\"x\"] = translate[\"x\"] * width\n            translate[\"y\"] = translate[\"y\"] * height\n        else:\n            translate = {\"x\": 0, \"y\": 0}\n\n        # Look to issue https://github.com/albumentations-team/albumentations/issues/1079\n        shear = {key: -random.uniform(*value) for key, value in self.shear.items()}\n        scale = {key: random.uniform(*value) for key, value in self.scale.items()}\n        if self.keep_ratio:\n            scale[\"y\"] = scale[\"x\"]\n\n        # Look to issue https://github.com/albumentations-team/albumentations/issues/1079\n        rotate = -random.uniform(*self.rotate)\n\n        # for images we use additional shifts of (0.5, 0.5) as otherwise\n        # we get an ugly black border for 90deg rotations\n        shift_x = width / 2 - 0.5\n        shift_y = height / 2 - 0.5\n\n        matrix_to_topleft = skimage.transform.SimilarityTransform(translation=[-shift_x, -shift_y])\n        matrix_shear_y_rot = skimage.transform.AffineTransform(rotation=-np.pi / 2)\n        matrix_shear_y = skimage.transform.AffineTransform(shear=np.deg2rad(shear[\"y\"]))\n        matrix_shear_y_rot_inv = skimage.transform.AffineTransform(rotation=np.pi / 2)\n        matrix_transforms = skimage.transform.AffineTransform(\n            scale=(scale[\"x\"], scale[\"y\"]),\n            translation=(translate[\"x\"], translate[\"y\"]),\n            rotation=np.deg2rad(rotate),\n            shear=np.deg2rad(shear[\"x\"]),\n        )\n        matrix_to_center = skimage.transform.SimilarityTransform(translation=[shift_x, shift_y])\n        matrix = (\n            matrix_to_topleft\n            + matrix_shear_y_rot\n            + matrix_shear_y\n            + matrix_shear_y_rot_inv\n            + matrix_transforms\n            + matrix_to_center\n        )\n        if self.fit_output:\n            matrix, output_shape = self._compute_affine_warp_output_shape(matrix, params[\"image\"].shape)\n        else:\n            output_shape = params[\"image\"].shape\n\n        return {\n            \"rotate\": rotate,\n            \"scale\": scale,\n            \"matrix\": matrix,\n            \"output_shape\": output_shape,\n        }\n\n    @staticmethod\n    def _compute_affine_warp_output_shape(\n        matrix: skimage.transform.ProjectiveTransform, input_shape: Sequence[int]\n    ) -&gt; Tuple[skimage.transform.ProjectiveTransform, Sequence[int]]:\n        height, width = input_shape[:2]\n\n        if height == 0 or width == 0:\n            return matrix, input_shape\n\n        # determine shape of output image\n        corners = np.array([[0, 0], [0, height - 1], [width - 1, height - 1], [width - 1, 0]])\n        corners = matrix(corners)\n        minc = corners[:, 0].min()\n        minr = corners[:, 1].min()\n        maxc = corners[:, 0].max()\n        maxr = corners[:, 1].max()\n        out_height = maxr - minr + 1\n        out_width = maxc - minc + 1\n        if len(input_shape) == THREE:\n            output_shape = np.ceil((out_height, out_width, input_shape[2]))\n        else:\n            output_shape = np.ceil((out_height, out_width))\n        output_shape_tuple = tuple([int(v) for v in output_shape.tolist()])\n        # fit output image in new shape\n        translation = (-minc, -minr)\n        matrix_to_fit = skimage.transform.SimilarityTransform(translation=translation)\n        matrix = matrix + matrix_to_fit\n        return matrix, output_shape_tuple\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.ElasticTransform","title":"<code>class  ElasticTransform</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Elastic deformation of images as described in [Simard2003]_ (with modifications).</p> <p>.. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for      Convolutional Neural Networks applied to Visual Document Analysis\", in      Proc. of the International Conference on Document Analysis and      Recognition, 2003.</p> <p>Parameters:</p> Name Type Description <code>alpha</code> <code>float</code> <code>sigma</code> <code>float</code> <p>Gaussian filter parameter.</p> <code>alpha_affine</code> <code>float</code> <p>The range will be (-alpha_affine, alpha_affine)</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>approximate</code> <code>boolean</code> <p>Whether to smooth displacement map with fixed kernel size.                    Enabling this option gives ~2X speedup on large images.</p> <code>same_dxdy</code> <code>boolean</code> <p>Whether to use same random generated shift for x and y.                  Enabling this option gives ~2X speedup.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> <p>Reference</p> <p>https://gist.github.com/ernestum/601cdf56d2b424757de5</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class ElasticTransform(DualTransform):\n    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications).\n\n    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for\n         Convolutional Neural Networks applied to Visual Document Analysis\", in\n         Proc. of the International Conference on Document Analysis and\n         Recognition, 2003.\n\n    Args:\n        alpha (float):\n        sigma (float): Gaussian filter parameter.\n        alpha_affine (float): The range will be (-alpha_affine, alpha_affine)\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        approximate (boolean): Whether to smooth displacement map with fixed kernel size.\n                               Enabling this option gives ~2X speedup on large images.\n        same_dxdy (boolean): Whether to use same random generated shift for x and y.\n                             Enabling this option gives ~2X speedup.\n\n    Targets:\n        image, mask, bboxes\n\n    Image types:\n        uint8, float32\n\n    Reference:\n        https://gist.github.com/ernestum/601cdf56d2b424757de5\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        alpha: Annotated[float, Field(default=1, description=\"Alpha parameter.\", ge=0)]\n        sigma: Annotated[float, Field(default=50, description=\"Sigma parameter for Gaussian filter.\", ge=0)]\n        alpha_affine: Annotated[float, Field(default=50, description=\"Alpha affine parameter.\", ge=0)]\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[Union[int, float, List[int], List[float]]] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        mask_value: Optional[Union[float, List[int], List[float]]] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\"\n        )\n        approximate: Annotated[bool, Field(default=False, description=\"Approximate displacement map smoothing.\")]\n        same_dxdy: Annotated[bool, Field(default=False, description=\"Use same shift for x and y.\")]\n\n    def __init__(\n        self,\n        alpha: float = 1,\n        sigma: float = 50,\n        alpha_affine: float = 50,\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[Union[int, float, List[int], List[float]]] = None,\n        mask_value: Optional[Union[int, float, List[int], List[float]]] = None,\n        always_apply: bool = False,\n        approximate: bool = False,\n        same_dxdy: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.alpha = alpha\n        self.alpha_affine = alpha_affine\n        self.sigma = sigma\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n        self.approximate = approximate\n        self.same_dxdy = same_dxdy\n\n    def apply(\n        self, img: np.ndarray, random_state: Optional[int] = None, interpolation: int = cv2.INTER_LINEAR, **params: Any\n    ) -&gt; np.ndarray:\n        return F.elastic_transform(\n            img,\n            self.alpha,\n            self.sigma,\n            self.alpha_affine,\n            interpolation,\n            self.border_mode,\n            self.value,\n            np.random.RandomState(random_state),\n            self.approximate,\n            self.same_dxdy,\n        )\n\n    def apply_to_mask(self, mask: np.ndarray, random_state: Optional[int] = None, **params: Any) -&gt; np.ndarray:\n        return F.elastic_transform(\n            mask,\n            self.alpha,\n            self.sigma,\n            self.alpha_affine,\n            cv2.INTER_NEAREST,\n            self.border_mode,\n            self.mask_value,\n            np.random.RandomState(random_state),\n            self.approximate,\n            self.same_dxdy,\n        )\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, random_state: Optional[int] = None, **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        mask = np.zeros((rows, cols), dtype=np.uint8)\n        bbox_denorm = F.denormalize_bbox(bbox, rows, cols)\n        x_min, y_min, x_max, y_max = bbox_denorm[:4]\n        x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)\n        mask[y_min:y_max, x_min:x_max] = 1\n        mask = F.elastic_transform(\n            mask,\n            self.alpha,\n            self.sigma,\n            self.alpha_affine,\n            cv2.INTER_NEAREST,\n            self.border_mode,\n            self.mask_value,\n            np.random.RandomState(random_state),\n            self.approximate,\n        )\n        bbox_returned = bbox_from_mask(mask)\n        return cast(BoxInternalType, F.normalize_bbox(bbox_returned, rows, cols))\n\n    def get_params(self) -&gt; Dict[str, int]:\n        return {\"random_state\": random.randint(0, 10000)}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"alpha\",\n            \"sigma\",\n            \"alpha_affine\",\n            \"interpolation\",\n            \"border_mode\",\n            \"value\",\n            \"mask_value\",\n            \"approximate\",\n            \"same_dxdy\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.Flip","title":"<code>class  Flip</code> <code> </code>  [view source on GitHub]","text":"<p>Flip the input either horizontally, vertically or both horizontally and vertically.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Flip(DualTransform):\n    \"\"\"Flip the input either horizontally, vertically or both horizontally and vertically.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, d: int = 0, **params: Any) -&gt; np.ndarray:\n        \"\"\"Args:\n        d (int): code that specifies how to flip the input. 0 for vertical flipping, 1 for horizontal flipping,\n                -1 for both vertical and horizontal flipping (which is also could be seen as rotating the input by\n                180 degrees).\n        \"\"\"\n        return F.random_flip(img, d)\n\n    def get_params(self) -&gt; Dict[str, int]:\n        # Random int in the range [-1, 1]\n        return {\"d\": random.randint(-1, 1)}\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_flip(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_flip(keypoint, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.Flip.apply","title":"<code>apply (self, img, d=0, **params)</code>","text":"<p>d (int): code that specifies how to flip the input. 0 for vertical flipping, 1 for horizontal flipping,         -1 for both vertical and horizontal flipping (which is also could be seen as rotating the input by         180 degrees).</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>def apply(self, img: np.ndarray, d: int = 0, **params: Any) -&gt; np.ndarray:\n    \"\"\"Args:\n    d (int): code that specifies how to flip the input. 0 for vertical flipping, 1 for horizontal flipping,\n            -1 for both vertical and horizontal flipping (which is also could be seen as rotating the input by\n            180 degrees).\n    \"\"\"\n    return F.random_flip(img, d)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.GridDistortion","title":"<code>class  GridDistortion</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Parameters:</p> Name Type Description <code>num_steps</code> <code>int</code> <p>count of grid cells on each side.</p> <code>distort_limit</code> <code>float, (float, float</code> <p>If distort_limit is a single float, the range will be (-distort_limit, distort_limit). Default: (-0.03, 0.03).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>normalized</code> <code>bool</code> <p>if true, distortion will be normalized to do not go outside the image. Default: False See for more information: https://github.com/albumentations-team/albumentations/pull/722</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class GridDistortion(DualTransform):\n    \"\"\"Args:\n        num_steps (int): count of grid cells on each side.\n        distort_limit (float, (float, float)): If distort_limit is a single float, the range\n            will be (-distort_limit, distort_limit). Default: (-0.03, 0.03).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        normalized (bool): if true, distortion will be normalized to do not go outside the image. Default: False\n            See for more information: https://github.com/albumentations-team/albumentations/pull/722\n\n    Targets:\n        image, mask, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        num_steps: Annotated[int, Field(ge=1, description=\"Count of grid cells on each side.\")]\n        distort_limit: SymmetricRangeType = (-0.03, 0.03)\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        mask_value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value for mask if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        normalized: bool = Field(\n            default=False, description=\"If true, distortion will be normalized to not go outside the image.\"\n        )\n\n        @field_validator(\"distort_limit\")\n        @classmethod\n        def check_limits(cls, v: Tuple[float, float], info: ValidationInfo) -&gt; Tuple[float, float]:\n            bounds = -1, 1\n            result = to_tuple(v)\n            check_range(result, *bounds, info.field_name)\n            return result\n\n    def __init__(\n        self,\n        num_steps: int = 5,\n        distort_limit: ScaleFloatType = (-0.3, 0.3),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        normalized: bool = False,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        self.num_steps = num_steps\n        self.distort_limit = cast(Tuple[float, float], distort_limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n        self.normalized = normalized\n\n    def apply(\n        self,\n        img: np.ndarray,\n        stepsx: Tuple[()] = (),\n        stepsy: Tuple[()] = (),\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.grid_distortion(img, self.num_steps, stepsx, stepsy, interpolation, self.border_mode, self.value)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, stepsx: Tuple[()] = (), stepsy: Tuple[()] = (), **params: Any\n    ) -&gt; np.ndarray:\n        return F.grid_distortion(\n            mask, self.num_steps, stepsx, stepsy, cv2.INTER_NEAREST, self.border_mode, self.mask_value\n        )\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, stepsx: Tuple[()] = (), stepsy: Tuple[()] = (), **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        mask = np.zeros((rows, cols), dtype=np.uint8)\n        bbox_denorm = F.denormalize_bbox(bbox, rows, cols)\n        x_min, y_min, x_max, y_max = bbox_denorm[:4]\n        x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)\n        mask[y_min:y_max, x_min:x_max] = 1\n        mask = F.grid_distortion(\n            mask, self.num_steps, stepsx, stepsy, cv2.INTER_NEAREST, self.border_mode, self.mask_value\n        )\n        bbox_returned = bbox_from_mask(mask)\n        return cast(BoxInternalType, F.normalize_bbox(bbox_returned, rows, cols))\n\n    def _normalize(self, h: int, w: int, xsteps: List[float], ysteps: List[float]) -&gt; Dict[str, Any]:\n        # compensate for smaller last steps in source image.\n        x_step = w // self.num_steps\n        last_x_step = min(w, ((self.num_steps + 1) * x_step)) - (self.num_steps * x_step)\n        xsteps[-1] *= last_x_step / x_step\n\n        y_step = h // self.num_steps\n        last_y_step = min(h, ((self.num_steps + 1) * y_step)) - (self.num_steps * y_step)\n        ysteps[-1] *= last_y_step / y_step\n\n        # now normalize such that distortion never leaves image bounds.\n        tx = w / math.floor(w / self.num_steps)\n        ty = h / math.floor(h / self.num_steps)\n        xsteps = np.array(xsteps) * (tx / np.sum(xsteps))\n        ysteps = np.array(ysteps) * (ty / np.sum(ysteps))\n\n        return {\"stepsx\": xsteps, \"stepsy\": ysteps}\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        stepsx = [\n            1 + random_utils.uniform(self.distort_limit[0], self.distort_limit[1]) for _ in range(self.num_steps + 1)\n        ]\n        stepsy = [\n            1 + random_utils.uniform(self.distort_limit[0], self.distort_limit[1]) for _ in range(self.num_steps + 1)\n        ]\n\n        if self.normalized:\n            return self._normalize(height, width, stepsx, stepsy)\n\n        return {\"stepsx\": stepsx, \"stepsy\": stepsy}\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"num_steps\", \"distort_limit\", \"interpolation\", \"border_mode\", \"value\", \"mask_value\", \"normalized\"\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.HorizontalFlip","title":"<code>class  HorizontalFlip</code> <code> </code>  [view source on GitHub]","text":"<p>Flip the input horizontally around the y-axis.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class HorizontalFlip(DualTransform):\n    \"\"\"Flip the input horizontally around the y-axis.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        if img.ndim == THREE and img.shape[2] &gt; 1 and img.dtype == np.uint8:\n            # Opencv is faster than numpy only in case of\n            # non-gray scale 8bits images\n            return F.hflip_cv2(img)\n\n        return F.hflip(img)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_hflip(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_hflip(keypoint, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.OpticalDistortion","title":"<code>class  OpticalDistortion</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Parameters:</p> Name Type Description <code>distort_limit</code> <code>float, (float, float</code> <p>If distort_limit is a single float, the range will be (-distort_limit, distort_limit). Default: (-0.05, 0.05).</p> <code>shift_limit</code> <code>float, (float, float</code> <p>If shift_limit is a single float, the range will be (-shift_limit, shift_limit). Default: (-0.05, 0.05).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of ints, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of ints,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <p>Targets</p> <p>image, mask, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class OpticalDistortion(DualTransform):\n    \"\"\"Args:\n        distort_limit (float, (float, float)): If distort_limit is a single float, the range\n            will be (-distort_limit, distort_limit). Default: (-0.05, 0.05).\n        shift_limit (float, (float, float))): If shift_limit is a single float, the range\n            will be (-shift_limit, shift_limit). Default: (-0.05, 0.05).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of ints,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n\n    Targets:\n        image, mask, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        distort_limit: SymmetricRangeType = (-0.05, 0.05)\n        shift_limit: SymmetricRangeType = (-0.05, 0.05)\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n        mask_value: Optional[ColorType] = Field(\n            default=None, description=\"Padding value for mask if border_mode is cv2.BORDER_CONSTANT.\"\n        )\n\n    def __init__(\n        self,\n        distort_limit: ScaleFloatType = (-0.05, 0.05),\n        shift_limit: ScaleFloatType = (-0.05, 0.05),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.shift_limit = cast(Tuple[float, float], shift_limit)\n        self.distort_limit = cast(Tuple[float, float], distort_limit)\n        self.interpolation = interpolation\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def apply(\n        self,\n        img: np.ndarray,\n        k: int = 0,\n        dx: int = 0,\n        dy: int = 0,\n        interpolation: int = cv2.INTER_LINEAR,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.optical_distortion(img, k, dx, dy, interpolation, self.border_mode, self.value)\n\n    def apply_to_mask(self, mask: np.ndarray, k: int = 0, dx: int = 0, dy: int = 0, **params: Any) -&gt; np.ndarray:\n        return F.optical_distortion(mask, k, dx, dy, cv2.INTER_NEAREST, self.border_mode, self.mask_value)\n\n    def apply_to_bbox(\n        self, bbox: BoxInternalType, k: int = 0, dx: int = 0, dy: int = 0, **params: Any\n    ) -&gt; BoxInternalType:\n        rows, cols = params[\"rows\"], params[\"cols\"]\n        mask = np.zeros((rows, cols), dtype=np.uint8)\n        bbox_denorm = F.denormalize_bbox(bbox, rows, cols)\n        x_min, y_min, x_max, y_max = bbox_denorm[:4]\n        x_min, y_min, x_max, y_max = int(x_min), int(y_min), int(x_max), int(y_max)\n        mask[y_min:y_max, x_min:x_max] = 1\n        mask = F.optical_distortion(mask, k, dx, dy, cv2.INTER_NEAREST, self.border_mode, self.mask_value)\n        bbox_returned = bbox_from_mask(mask)\n        return cast(BoxInternalType, F.normalize_bbox(bbox_returned, rows, cols))\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {\n            \"k\": random.uniform(self.distort_limit[0], self.distort_limit[1]),\n            \"dx\": round(random.uniform(self.shift_limit[0], self.shift_limit[1])),\n            \"dy\": round(random.uniform(self.shift_limit[0], self.shift_limit[1])),\n        }\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"distort_limit\",\n            \"shift_limit\",\n            \"interpolation\",\n            \"border_mode\",\n            \"value\",\n            \"mask_value\",\n        )\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.PadIfNeeded","title":"<code>class  PadIfNeeded</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Pad side of the image / max if side is less than desired number.</p> <p>Parameters:</p> Name Type Description <code>min_height</code> <code>int</code> <p>minimal result image height.</p> <code>min_width</code> <code>int</code> <p>minimal result image width.</p> <code>pad_height_divisor</code> <code>int</code> <p>if not None, ensures image height is dividable by value of this argument.</p> <code>pad_width_divisor</code> <code>int</code> <p>if not None, ensures image width is dividable by value of this argument.</p> <code>position</code> <code>Union[str, PositionType]</code> <p>Position of the image. should be PositionType.CENTER or PositionType.TOP_LEFT or PositionType.TOP_RIGHT or PositionType.BOTTOM_LEFT or PositionType.BOTTOM_RIGHT. or PositionType.RANDOM. Default: PositionType.CENTER.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>OpenCV border mode.</p> <code>value</code> <code>int, float, list of int, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of int,         list of float</code> <p>padding value for mask if border_mode is cv2.BORDER_CONSTANT.</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 1.0.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class PadIfNeeded(DualTransform):\n    \"\"\"Pad side of the image / max if side is less than desired number.\n\n    Args:\n        min_height (int): minimal result image height.\n        min_width (int): minimal result image width.\n        pad_height_divisor (int): if not None, ensures image height is dividable by value of this argument.\n        pad_width_divisor (int): if not None, ensures image width is dividable by value of this argument.\n        position (Union[str, PositionType]): Position of the image. should be PositionType.CENTER or\n            PositionType.TOP_LEFT or PositionType.TOP_RIGHT or PositionType.BOTTOM_LEFT or PositionType.BOTTOM_RIGHT.\n            or PositionType.RANDOM. Default: PositionType.CENTER.\n        border_mode (OpenCV flag): OpenCV border mode.\n        value (int, float, list of int, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of int,\n                    list of float): padding value for mask if border_mode is cv2.BORDER_CONSTANT.\n        p (float): probability of applying the transform. Default: 1.0.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    class PositionType(Enum):\n        \"\"\"Enumerates the types of positions for placing an object within a container.\n\n        This Enum class is utilized to define specific anchor positions that an object can\n        assume relative to a container. It's particularly useful in image processing, UI layout,\n        and graphic design to specify the alignment and positioning of elements.\n\n        Attributes:\n            CENTER (str): Specifies that the object should be placed at the center.\n            TOP_LEFT (str): Specifies that the object should be placed at the top-left corner.\n            TOP_RIGHT (str): Specifies that the object should be placed at the top-right corner.\n            BOTTOM_LEFT (str): Specifies that the object should be placed at the bottom-left corner.\n            BOTTOM_RIGHT (str): Specifies that the object should be placed at the bottom-right corner.\n            RANDOM (str): Indicates that the object's position should be determined randomly.\n\n        \"\"\"\n\n        CENTER = \"center\"\n        TOP_LEFT = \"top_left\"\n        TOP_RIGHT = \"top_right\"\n        BOTTOM_LEFT = \"bottom_left\"\n        BOTTOM_RIGHT = \"bottom_right\"\n        RANDOM = \"random\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        min_height: Optional[int] = Field(default=None, ge=1, description=\"Minimal result image height.\")\n        min_width: Optional[int] = Field(default=None, ge=1, description=\"Minimal result image width.\")\n        pad_height_divisor: Optional[int] = Field(\n            default=None, ge=1, description=\"Ensures image height is divisible by this value.\"\n        )\n        pad_width_divisor: Optional[int] = Field(\n            default=None, ge=1, description=\"Ensures image width is divisible by this value.\"\n        )\n        position: str = Field(default=\"center\", description=\"Position of the padded image.\")\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: Optional[ColorType] = Field(default=None, description=\"Value for border if BORDER_CONSTANT is used.\")\n        mask_value: Optional[ColorType] = Field(\n            default=None, description=\"Value for mask border if BORDER_CONSTANT is used.\"\n        )\n        p: ProbabilityType = 1.0\n\n        @model_validator(mode=\"after\")\n        def validate_divisibility(self) -&gt; Self:\n            if (self.min_height is None) == (self.pad_height_divisor is None):\n                msg = \"Only one of 'min_height' and 'pad_height_divisor' parameters must be set\"\n                raise ValueError(msg)\n            if (self.min_width is None) == (self.pad_width_divisor is None):\n                msg = \"Only one of 'min_width' and 'pad_width_divisor' parameters must be set\"\n                raise ValueError(msg)\n            return self\n\n    def __init__(\n        self,\n        min_height: Optional[int] = 1024,\n        min_width: Optional[int] = 1024,\n        pad_height_divisor: Optional[int] = None,\n        pad_width_divisor: Optional[int] = None,\n        position: Union[PositionType, str] = PositionType.CENTER,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: Optional[ColorType] = None,\n        mask_value: Optional[ColorType] = None,\n        always_apply: bool = False,\n        p: float = 1.0,\n    ):\n        super().__init__(always_apply, p)\n        self.min_height = min_height\n        self.min_width = min_width\n        self.pad_width_divisor = pad_width_divisor\n        self.pad_height_divisor = pad_height_divisor\n        self.position = PadIfNeeded.PositionType(position)\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def update_params(self, params: Dict[str, Any], **kwargs: Any) -&gt; Dict[str, Any]:\n        params = super().update_params(params, **kwargs)\n        rows = params[\"rows\"]\n        cols = params[\"cols\"]\n\n        if self.min_height is not None:\n            if rows &lt; self.min_height:\n                h_pad_top = int((self.min_height - rows) / 2.0)\n                h_pad_bottom = self.min_height - rows - h_pad_top\n            else:\n                h_pad_top = 0\n                h_pad_bottom = 0\n        else:\n            pad_remained = rows % self.pad_height_divisor\n            pad_rows = self.pad_height_divisor - pad_remained if pad_remained &gt; 0 else 0\n\n            h_pad_top = pad_rows // 2\n            h_pad_bottom = pad_rows - h_pad_top\n\n        if self.min_width is not None:\n            if cols &lt; self.min_width:\n                w_pad_left = int((self.min_width - cols) / 2.0)\n                w_pad_right = self.min_width - cols - w_pad_left\n            else:\n                w_pad_left = 0\n                w_pad_right = 0\n        else:\n            pad_remainder = cols % self.pad_width_divisor\n            pad_cols = self.pad_width_divisor - pad_remainder if pad_remainder &gt; 0 else 0\n\n            w_pad_left = pad_cols // 2\n            w_pad_right = pad_cols - w_pad_left\n\n        h_pad_top, h_pad_bottom, w_pad_left, w_pad_right = self.__update_position_params(\n            h_top=h_pad_top, h_bottom=h_pad_bottom, w_left=w_pad_left, w_right=w_pad_right\n        )\n\n        params.update(\n            {\n                \"pad_top\": h_pad_top,\n                \"pad_bottom\": h_pad_bottom,\n                \"pad_left\": w_pad_left,\n                \"pad_right\": w_pad_right,\n            }\n        )\n        return params\n\n    def apply(\n        self,\n        img: np.ndarray,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.pad_with_params(\n            img,\n            pad_top,\n            pad_bottom,\n            pad_left,\n            pad_right,\n            border_mode=self.border_mode,\n            value=self.value,\n        )\n\n    def apply_to_mask(\n        self,\n        mask: np.ndarray,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.pad_with_params(\n            mask,\n            pad_top,\n            pad_bottom,\n            pad_left,\n            pad_right,\n            border_mode=self.border_mode,\n            value=self.mask_value,\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        rows: int = 0,\n        cols: int = 0,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        x_min, y_min, x_max, y_max = denormalize_bbox(bbox, rows, cols)[:4]\n        bbox = x_min + pad_left, y_min + pad_top, x_max + pad_left, y_max + pad_top\n        return cast(BoxInternalType, normalize_bbox(bbox, rows + pad_top + pad_bottom, cols + pad_left + pad_right))\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        pad_top: int = 0,\n        pad_bottom: int = 0,\n        pad_left: int = 0,\n        pad_right: int = 0,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        x, y, angle, scale = keypoint[:4]\n        return x + pad_left, y + pad_top, angle, scale\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"min_height\",\n            \"min_width\",\n            \"pad_height_divisor\",\n            \"pad_width_divisor\",\n            \"position\",\n            \"border_mode\",\n            \"value\",\n            \"mask_value\",\n        )\n\n    def __update_position_params(\n        self, h_top: int, h_bottom: int, w_left: int, w_right: int\n    ) -&gt; Tuple[int, int, int, int]:\n        if self.position == PadIfNeeded.PositionType.TOP_LEFT:\n            h_bottom += h_top\n            w_right += w_left\n            h_top = 0\n            w_left = 0\n\n        elif self.position == PadIfNeeded.PositionType.TOP_RIGHT:\n            h_bottom += h_top\n            w_left += w_right\n            h_top = 0\n            w_right = 0\n\n        elif self.position == PadIfNeeded.PositionType.BOTTOM_LEFT:\n            h_top += h_bottom\n            w_right += w_left\n            h_bottom = 0\n            w_left = 0\n\n        elif self.position == PadIfNeeded.PositionType.BOTTOM_RIGHT:\n            h_top += h_bottom\n            w_left += w_right\n            h_bottom = 0\n            w_right = 0\n\n        elif self.position == PadIfNeeded.PositionType.RANDOM:\n            h_pad = h_top + h_bottom\n            w_pad = w_left + w_right\n            h_top = random.randint(0, h_pad)\n            h_bottom = h_pad - h_top\n            w_left = random.randint(0, w_pad)\n            w_right = w_pad - w_left\n\n        return h_top, h_bottom, w_left, w_right\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.PadIfNeeded.PositionType","title":"<code>class  PositionType</code> <code> </code>","text":"<p>Enumerates the types of positions for placing an object within a container.</p> <p>This Enum class is utilized to define specific anchor positions that an object can assume relative to a container. It's particularly useful in image processing, UI layout, and graphic design to specify the alignment and positioning of elements.</p> <p>Attributes:</p> Name Type Description <code>CENTER</code> <code>str</code> <p>Specifies that the object should be placed at the center.</p> <code>TOP_LEFT</code> <code>str</code> <p>Specifies that the object should be placed at the top-left corner.</p> <code>TOP_RIGHT</code> <code>str</code> <p>Specifies that the object should be placed at the top-right corner.</p> <code>BOTTOM_LEFT</code> <code>str</code> <p>Specifies that the object should be placed at the bottom-left corner.</p> <code>BOTTOM_RIGHT</code> <code>str</code> <p>Specifies that the object should be placed at the bottom-right corner.</p> <code>RANDOM</code> <code>str</code> <p>Indicates that the object's position should be determined randomly.</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class PositionType(Enum):\n    \"\"\"Enumerates the types of positions for placing an object within a container.\n\n    This Enum class is utilized to define specific anchor positions that an object can\n    assume relative to a container. It's particularly useful in image processing, UI layout,\n    and graphic design to specify the alignment and positioning of elements.\n\n    Attributes:\n        CENTER (str): Specifies that the object should be placed at the center.\n        TOP_LEFT (str): Specifies that the object should be placed at the top-left corner.\n        TOP_RIGHT (str): Specifies that the object should be placed at the top-right corner.\n        BOTTOM_LEFT (str): Specifies that the object should be placed at the bottom-left corner.\n        BOTTOM_RIGHT (str): Specifies that the object should be placed at the bottom-right corner.\n        RANDOM (str): Indicates that the object's position should be determined randomly.\n\n    \"\"\"\n\n    CENTER = \"center\"\n    TOP_LEFT = \"top_left\"\n    TOP_RIGHT = \"top_right\"\n    BOTTOM_LEFT = \"bottom_left\"\n    BOTTOM_RIGHT = \"bottom_right\"\n    RANDOM = \"random\"\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.Perspective","title":"<code>class  Perspective</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Perform a random four point perspective transform of the input.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <p>standard deviation of the normal distributions. These are used to sample the random distances of the subimage's corners from the full image's corners. If scale is a single float value, the range will be (0, scale). Default: (0.05, 0.1).</p> <code>keep_size</code> <p>Whether to resize image back to their original size after applying the perspective transform. If set to False, the resulting images may end up having different shapes and will always be a list, never an array. Default: True</p> <code>pad_mode</code> <code>OpenCV flag</code> <p>OpenCV border mode.</p> <code>pad_val</code> <code>int, float, list of int, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT. Default: 0</p> <code>mask_pad_val</code> <code>int, float, list of int, list of float</code> <p>padding value for mask if border_mode is cv2.BORDER_CONSTANT. Default: 0</p> <code>fit_output</code> <code>bool</code> <p>If True, the image plane size and position will be adjusted to still capture the whole image after perspective transformation. (Followed by image resizing if keep_size is set to True.) Otherwise, parts of the transformed image may be outside of the image plane. This setting should not be set to True when using large scale values as it could lead to very large images. Default: False</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Perspective(DualTransform):\n    \"\"\"Perform a random four point perspective transform of the input.\n\n    Args:\n        scale: standard deviation of the normal distributions. These are used to sample\n            the random distances of the subimage's corners from the full image's corners.\n            If scale is a single float value, the range will be (0, scale). Default: (0.05, 0.1).\n        keep_size: Whether to resize image back to their original size after applying the perspective\n            transform. If set to False, the resulting images may end up having different shapes\n            and will always be a list, never an array. Default: True\n        pad_mode (OpenCV flag): OpenCV border mode.\n        pad_val (int, float, list of int, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n            Default: 0\n        mask_pad_val (int, float, list of int, list of float): padding value for mask\n            if border_mode is cv2.BORDER_CONSTANT. Default: 0\n        fit_output (bool): If True, the image plane size and position will be adjusted to still capture\n            the whole image after perspective transformation. (Followed by image resizing if keep_size is set to True.)\n            Otherwise, parts of the transformed image may be outside of the image plane.\n            This setting should not be set to True when using large scale values as it could lead to very large images.\n            Default: False\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: NonNegativeFloatRangeType = (0.05, 0.1)\n        keep_size: Annotated[bool, Field(default=True, description=\"Keep size after transform.\")]\n        pad_mode: BorderModeType = cv2.BORDER_CONSTANT\n        pad_val: Optional[ColorType] = Field(\n            default=0,\n            description=\"Padding value if border_mode is cv2.BORDER_CONSTANT.\",\n        )\n        mask_pad_val: Optional[ColorType] = Field(\n            default=0,\n            description=\"Mask padding value if border_mode is cv2.BORDER_CONSTANT.\",\n        )\n        fit_output: Annotated[bool, Field(default=False, description=\"Adjust image plane to capture whole image.\")]\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n\n    def __init__(\n        self,\n        scale: ScaleFloatType = (0.05, 0.1),\n        keep_size: bool = True,\n        pad_mode: int = cv2.BORDER_CONSTANT,\n        pad_val: Union[ColorType] = 0,\n        mask_pad_val: Union[ColorType] = 0,\n        fit_output: bool = False,\n        interpolation: int = cv2.INTER_LINEAR,\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.scale = cast(Tuple[float, float], scale)\n        self.keep_size = keep_size\n        self.pad_mode = pad_mode\n        self.pad_val = pad_val\n        self.mask_pad_val = mask_pad_val\n        self.fit_output = fit_output\n        self.interpolation = interpolation\n\n    def apply(\n        self,\n        img: np.ndarray,\n        matrix: np.ndarray,\n        max_height: int,\n        max_width: int,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.perspective(\n            img, matrix, max_width, max_height, self.pad_val, self.pad_mode, self.keep_size, params[\"interpolation\"]\n        )\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        matrix: np.ndarray,\n        max_height: int,\n        max_width: int,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.perspective_bbox(bbox, params[\"rows\"], params[\"cols\"], matrix, max_width, max_height, self.keep_size)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        matrix: np.ndarray,\n        max_height: int,\n        max_width: int,\n        **params: Any,\n    ) -&gt; np.ndarray:\n        return F.perspective_keypoint(\n            keypoint, params[\"rows\"], params[\"cols\"], matrix, max_width, max_height, self.keep_size\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        scale = random_utils.uniform(*self.scale)\n        points = random_utils.normal(0, scale, [4, 2])\n        points = np.mod(np.abs(points), 0.32)\n\n        # top left -- no changes needed, just use jitter\n        # top right\n        points[1, 0] = 1.0 - points[1, 0]  # w = 1.0 - jitter\n        # bottom right\n        points[2] = 1.0 - points[2]  # w = 1.0 - jitt\n        # bottom left\n        points[3, 1] = 1.0 - points[3, 1]  # h = 1.0 - jitter\n\n        points[:, 0] *= width\n        points[:, 1] *= height\n\n        # Obtain a consistent order of the points and unpack them individually.\n        # Warning: don't just do (tl, tr, br, bl) = _order_points(...)\n        # here, because the reordered points is used further below.\n        points = self._order_points(points)\n        tl, tr, br, bl = points\n\n        # compute the width of the new image, which will be the\n        # maximum distance between bottom-right and bottom-left\n        # x-coordiates or the top-right and top-left x-coordinates\n        min_width = None\n        max_width = None\n        while min_width is None or min_width &lt; TWO:\n            width_top = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))\n            width_bottom = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))\n            max_width = int(max(width_top, width_bottom))\n            min_width = int(min(width_top, width_bottom))\n            if min_width &lt; TWO:\n                step_size = (2 - min_width) / 2\n                tl[0] -= step_size\n                tr[0] += step_size\n                bl[0] -= step_size\n                br[0] += step_size\n\n        # compute the height of the new image, which will be the maximum distance between the top-right\n        # and bottom-right y-coordinates or the top-left and bottom-left y-coordinates\n        min_height = None\n        max_height = None\n        while min_height is None or min_height &lt; TWO:\n            height_right = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))\n            height_left = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))\n            max_height = int(max(height_right, height_left))\n            min_height = int(min(height_right, height_left))\n            if min_height &lt; TWO:\n                step_size = (2 - min_height) / 2\n                tl[1] -= step_size\n                tr[1] -= step_size\n                bl[1] += step_size\n                br[1] += step_size\n\n        # now that we have the dimensions of the new image, construct\n        # the set of destination points to obtain a \"birds eye view\",\n        # (i.e. top-down view) of the image, again specifying points\n        # in the top-left, top-right, bottom-right, and bottom-left order\n        # do not use width-1 or height-1 here, as for e.g. width=3, height=2\n        # the bottom right coordinate is at (3.0, 2.0) and not (2.0, 1.0)\n        dst = np.array([[0, 0], [max_width, 0], [max_width, max_height], [0, max_height]], dtype=np.float32)\n\n        # compute the perspective transform matrix and then apply it\n        m = cv2.getPerspectiveTransform(points, dst)\n\n        if self.fit_output:\n            m, max_width, max_height = self._expand_transform(m, (height, width))\n\n        return {\"matrix\": m, \"max_height\": max_height, \"max_width\": max_width, \"interpolation\": self.interpolation}\n\n    @classmethod\n    def _expand_transform(cls, matrix: np.ndarray, shape: SizeType) -&gt; Tuple[np.ndarray, int, int]:\n        height, width = shape[:2]\n        # do not use width-1 or height-1 here, as for e.g. width=3, height=2, max_height\n        # the bottom right coordinate is at (3.0, 2.0) and not (2.0, 1.0)\n        rect = np.array([[0, 0], [width, 0], [width, height], [0, height]], dtype=np.float32)\n        dst = cv2.perspectiveTransform(np.array([rect]), matrix)[0]\n\n        # get min x, y over transformed 4 points\n        # then modify target points by subtracting these minima  =&gt; shift to (0, 0)\n        dst -= dst.min(axis=0, keepdims=True)\n        dst = np.around(dst, decimals=0)\n\n        matrix_expanded = cv2.getPerspectiveTransform(rect, dst)\n        max_width, max_height = dst.max(axis=0)\n        return matrix_expanded, int(max_width), int(max_height)\n\n    @staticmethod\n    def _order_points(pts: np.ndarray) -&gt; np.ndarray:\n        pts = np.array(sorted(pts, key=lambda x: x[0]))\n        left = pts[:2]  # points with smallest x coordinate - left points\n        right = pts[2:]  # points with greatest x coordinate - right points\n\n        if left[0][1] &lt; left[1][1]:\n            tl, bl = left\n        else:\n            bl, tl = left\n\n        if right[0][1] &lt; right[1][1]:\n            tr, br = right\n        else:\n            br, tr = right\n\n        return np.array([tl, tr, br, bl], dtype=np.float32)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"scale\", \"keep_size\", \"pad_mode\", \"pad_val\", \"mask_pad_val\", \"fit_output\", \"interpolation\"\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.PiecewiseAffine","title":"<code>class  PiecewiseAffine</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Apply affine transformations that differ between local neighborhoods. This augmentation places a regular grid of points on an image and randomly moves the neighborhood of these point around via affine transformations. This leads to local distortions.</p> <p>This is mostly a wrapper around scikit-image's <code>PiecewiseAffine</code>. See also <code>Affine</code> for a similar technique.</p> <p>Note</p> <p>This augmenter is very slow. Try to use <code>ElasticTransformation</code> instead, which is at least 10x faster.</p> <p>Note</p> <p>For coordinate-based inputs (keypoints, bounding boxes, polygons, ...), this augmenter still has to perform an image-based augmentation, which will make it significantly slower and not fully correct for such inputs than other transforms.</p> <p>Parameters:</p> Name Type Description <code>scale</code> <code>float, tuple of float</code> <p>Each point on the regular grid is moved around via a normal distribution. This scale factor is equivalent to the normal distribution's sigma. Note that the jitter (how far each point is moved in which direction) is multiplied by the height/width of the image if <code>absolute_scale=False</code> (default), so this scale can be the same for different sized images. Recommended values are in the range <code>0.01</code> to <code>0.05</code> (weak to strong augmentations).     * If a single <code>float</code>, then that value will always be used as the scale.     * If a tuple <code>(a, b)</code> of <code>float</code> s, then a random value will       be uniformly sampled per image from the interval <code>[a, b]</code>.</p> <code>nb_rows</code> <code>int, tuple of int</code> <p>Number of rows of points that the regular grid should have. Must be at least <code>2</code>. For large images, you might want to pick a higher value than <code>4</code>. You might have to then adjust scale to lower values.     * If a single <code>int</code>, then that value will always be used as the number of rows.     * If a tuple <code>(a, b)</code>, then a value from the discrete interval       <code>[a..b]</code> will be uniformly sampled per image.</p> <code>nb_cols</code> <code>int, tuple of int</code> <p>Number of columns. Analogous to <code>nb_rows</code>.</p> <code>interpolation</code> <code>int</code> <p>The order of interpolation. The order has to be in the range 0-5:  - 0: Nearest-neighbor  - 1: Bi-linear (default)  - 2: Bi-quadratic  - 3: Bi-cubic  - 4: Bi-quartic  - 5: Bi-quintic</p> <code>mask_interpolation</code> <code>int</code> <p>same as interpolation but for mask.</p> <code>cval</code> <code>number</code> <p>The constant value to use when filling in newly created pixels.</p> <code>cval_mask</code> <code>number</code> <p>Same as cval but only for masks.</p> <code>mode</code> <code>str</code> <p>{'constant', 'edge', 'symmetric', 'reflect', 'wrap'}, optional Points outside the boundaries of the input are filled according to the given mode.  Modes match the behaviour of <code>numpy.pad</code>.</p> <code>absolute_scale</code> <code>bool</code> <p>Take <code>scale</code> as an absolute value rather than a relative value.</p> <code>keypoints_threshold</code> <code>float</code> <p>Used as threshold in conversion from distance maps to keypoints. The search for keypoints works by searching for the argmin (non-inverted) or argmax (inverted) in each channel. This parameters contains the maximum (non-inverted) or minimum (inverted) value to accept in order to view a hit as a keypoint. Use <code>None</code> to use no min/max. Default: 0.01</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class PiecewiseAffine(DualTransform):\n    \"\"\"Apply affine transformations that differ between local neighborhoods.\n    This augmentation places a regular grid of points on an image and randomly moves the neighborhood of these point\n    around via affine transformations. This leads to local distortions.\n\n    This is mostly a wrapper around scikit-image's ``PiecewiseAffine``.\n    See also ``Affine`` for a similar technique.\n\n    Note:\n        This augmenter is very slow. Try to use ``ElasticTransformation`` instead, which is at least 10x faster.\n\n    Note:\n        For coordinate-based inputs (keypoints, bounding boxes, polygons, ...),\n        this augmenter still has to perform an image-based augmentation,\n        which will make it significantly slower and not fully correct for such inputs than other transforms.\n\n    Args:\n        scale (float, tuple of float): Each point on the regular grid is moved around via a normal distribution.\n            This scale factor is equivalent to the normal distribution's sigma.\n            Note that the jitter (how far each point is moved in which direction) is multiplied by the height/width of\n            the image if ``absolute_scale=False`` (default), so this scale can be the same for different sized images.\n            Recommended values are in the range ``0.01`` to ``0.05`` (weak to strong augmentations).\n                * If a single ``float``, then that value will always be used as the scale.\n                * If a tuple ``(a, b)`` of ``float`` s, then a random value will\n                  be uniformly sampled per image from the interval ``[a, b]``.\n        nb_rows (int, tuple of int): Number of rows of points that the regular grid should have.\n            Must be at least ``2``. For large images, you might want to pick a higher value than ``4``.\n            You might have to then adjust scale to lower values.\n                * If a single ``int``, then that value will always be used as the number of rows.\n                * If a tuple ``(a, b)``, then a value from the discrete interval\n                  ``[a..b]`` will be uniformly sampled per image.\n        nb_cols (int, tuple of int): Number of columns. Analogous to `nb_rows`.\n        interpolation (int): The order of interpolation. The order has to be in the range 0-5:\n             - 0: Nearest-neighbor\n             - 1: Bi-linear (default)\n             - 2: Bi-quadratic\n             - 3: Bi-cubic\n             - 4: Bi-quartic\n             - 5: Bi-quintic\n        mask_interpolation (int): same as interpolation but for mask.\n        cval (number): The constant value to use when filling in newly created pixels.\n        cval_mask (number): Same as cval but only for masks.\n        mode (str): {'constant', 'edge', 'symmetric', 'reflect', 'wrap'}, optional\n            Points outside the boundaries of the input are filled according\n            to the given mode.  Modes match the behaviour of `numpy.pad`.\n        absolute_scale (bool): Take `scale` as an absolute value rather than a relative value.\n        keypoints_threshold (float): Used as threshold in conversion from distance maps to keypoints.\n            The search for keypoints works by searching for the\n            argmin (non-inverted) or argmax (inverted) in each channel. This\n            parameters contains the maximum (non-inverted) or minimum (inverted) value to accept in order to view a hit\n            as a keypoint. Use ``None`` to use no min/max. Default: 0.01\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    class InitSchema(BaseTransformInitSchema):\n        scale: NonNegativeFloatRangeType = (0.03, 0.05)\n        nb_rows: ScaleIntType = Field(default=4, description=\"Number of rows in the regular grid.\")\n        nb_cols: ScaleIntType = Field(default=4, description=\"Number of columns in the regular grid.\")\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        mask_interpolation: InterpolationType = cv2.INTER_NEAREST\n        cval: int = Field(default=0, description=\"Constant value used for newly created pixels.\")\n        cval_mask: int = Field(default=0, description=\"Constant value used for newly created mask pixels.\")\n        mode: Literal[\"constant\", \"edge\", \"symmetric\", \"reflect\", \"wrap\"] = \"constant\"\n        absolute_scale: bool = Field(\n            default=False, description=\"Whether scale is an absolute value rather than relative.\"\n        )\n        keypoints_threshold: float = Field(\n            default=0.01, description=\"Threshold for conversion from distance maps to keypoints.\"\n        )\n\n        @field_validator(\"nb_rows\", \"nb_cols\")\n        @classmethod\n        def process_range(cls, value: ScaleFloatType, info: ValidationInfo) -&gt; Tuple[float, float]:\n            bounds = 2, BIG_INTEGER\n            result = to_tuple(value, value)\n            check_range(result, *bounds, info.field_name)\n            return result\n\n    def __init__(\n        self,\n        scale: ScaleFloatType = (0.03, 0.05),\n        nb_rows: ScaleIntType = 4,\n        nb_cols: ScaleIntType = 4,\n        interpolation: int = cv2.INTER_LINEAR,\n        mask_interpolation: int = cv2.INTER_NEAREST,\n        cval: int = 0,\n        cval_mask: int = 0,\n        mode: Literal[\"constant\", \"edge\", \"symmetric\", \"reflect\", \"wrap\"] = \"constant\",\n        absolute_scale: bool = False,\n        always_apply: bool = False,\n        keypoints_threshold: float = 0.01,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n\n        warn(\"This augmenter is very slow. Try to use ``ElasticTransformation`` instead, which is at least 10x faster.\")\n\n        self.scale = cast(Tuple[float, float], scale)\n        self.nb_rows = cast(Tuple[int, int], nb_rows)\n        self.nb_cols = cast(Tuple[int, int], nb_cols)\n        self.interpolation = interpolation\n        self.mask_interpolation = mask_interpolation\n        self.cval = cval\n        self.cval_mask = cval_mask\n        self.mode = mode\n        self.absolute_scale = absolute_scale\n        self.keypoints_threshold = keypoints_threshold\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\n            \"scale\",\n            \"nb_rows\",\n            \"nb_cols\",\n            \"interpolation\",\n            \"mask_interpolation\",\n            \"cval\",\n            \"cval_mask\",\n            \"mode\",\n            \"absolute_scale\",\n            \"keypoints_threshold\",\n        )\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return [\"image\"]\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        height, width = params[\"image\"].shape[:2]\n\n        nb_rows = np.clip(random.randint(*self.nb_rows), 2, None)\n        nb_cols = np.clip(random.randint(*self.nb_cols), 2, None)\n        nb_cells = nb_cols * nb_rows\n        scale = random.uniform(*self.scale)\n\n        jitter: np.ndarray = random_utils.normal(0, scale, (nb_cells, 2))\n        if not np.any(jitter &gt; 0):\n            for _ in range(10):  # See: https://github.com/albumentations-team/albumentations/issues/1442\n                jitter = random_utils.normal(0, scale, (nb_cells, 2))\n                if np.any(jitter &gt; 0):\n                    break\n            if not np.any(jitter &gt; 0):\n                return {\"matrix\": None}\n\n        y = np.linspace(0, height, nb_rows)\n        x = np.linspace(0, width, nb_cols)\n\n        # (H, W) and (H, W) for H=rows, W=cols\n        xx_src, yy_src = np.meshgrid(x, y)\n\n        # (1, HW, 2) =&gt; (HW, 2) for H=rows, W=cols\n        points_src = np.dstack([yy_src.flat, xx_src.flat])[0]\n\n        if self.absolute_scale:\n            jitter[:, 0] = jitter[:, 0] / height if height &gt; 0 else 0.0\n            jitter[:, 1] = jitter[:, 1] / width if width &gt; 0 else 0.0\n\n        jitter[:, 0] = jitter[:, 0] * height\n        jitter[:, 1] = jitter[:, 1] * width\n\n        points_dest = np.copy(points_src)\n        points_dest[:, 0] = points_dest[:, 0] + jitter[:, 0]\n        points_dest[:, 1] = points_dest[:, 1] + jitter[:, 1]\n\n        # Restrict all destination points to be inside the image plane.\n        # This is necessary, as otherwise keypoints could be augmented\n        # outside of the image plane and these would be replaced by\n        # (-1, -1), which would not conform with the behaviour of the other augmenters.\n        points_dest[:, 0] = np.clip(points_dest[:, 0], 0, height - 1)\n        points_dest[:, 1] = np.clip(points_dest[:, 1], 0, width - 1)\n\n        matrix = skimage.transform.PiecewiseAffineTransform()\n        matrix.estimate(points_src[:, ::-1], points_dest[:, ::-1])\n\n        return {\n            \"matrix\": matrix,\n        }\n\n    def apply(\n        self, img: np.ndarray, matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None, **params: Any\n    ) -&gt; np.ndarray:\n        return F.piecewise_affine(img, matrix, cast(int, self.interpolation), self.mode, self.cval)\n\n    def apply_to_mask(\n        self, mask: np.ndarray, matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None, **params: Any\n    ) -&gt; np.ndarray:\n        return F.piecewise_affine(mask, matrix, self.mask_interpolation, self.mode, self.cval_mask)\n\n    def apply_to_bbox(\n        self,\n        bbox: BoxInternalType,\n        rows: int = 0,\n        cols: int = 0,\n        matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None,\n        **params: Any,\n    ) -&gt; BoxInternalType:\n        return F.bbox_piecewise_affine(bbox, matrix, rows, cols, self.keypoints_threshold)\n\n    def apply_to_keypoint(\n        self,\n        keypoint: KeypointInternalType,\n        rows: int = 0,\n        cols: int = 0,\n        matrix: Optional[skimage.transform.PiecewiseAffineTransform] = None,\n        **params: Any,\n    ) -&gt; KeypointInternalType:\n        return F.keypoint_piecewise_affine(keypoint, matrix, rows, cols, self.keypoints_threshold)\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.ShiftScaleRotate","title":"<code>class  ShiftScaleRotate</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Randomly apply affine transforms: translate, scale and rotate the input.</p> <p>Parameters:</p> Name Type Description <code>shift_limit</code> <code>float, float) or float</code> <p>shift factor range for both height and width. If shift_limit is a single float value, the range will be (-shift_limit, shift_limit). Absolute values for lower and upper bounds should lie in range [-1, 1]. Default: (-0.0625, 0.0625).</p> <code>scale_limit</code> <code>float, float) or float</code> <p>scaling factor range. If scale_limit is a single float value, the range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1. If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high). Default: (-0.1, 0.1).</p> <code>rotate_limit</code> <code>int, int) or int</code> <p>rotation range. If rotate_limit is a single int value, the range will be (-rotate_limit, rotate_limit). Default: (-45, 45).</p> <code>interpolation</code> <code>OpenCV flag</code> <p>flag that is used to specify the interpolation algorithm. Should be one of: cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4. Default: cv2.INTER_LINEAR.</p> <code>border_mode</code> <code>OpenCV flag</code> <p>flag that is used to specify the pixel extrapolation method. Should be one of: cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101. Default: cv2.BORDER_REFLECT_101</p> <code>value</code> <code>int, float, list of int, list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT.</p> <code>mask_value</code> <code>int, float,         list of int,         list of float</code> <p>padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.</p> <code>shift_limit_x</code> <code>float, float) or float</code> <p>shift factor range for width. If it is set then this value instead of shift_limit will be used for shifting width.  If shift_limit_x is a single float value, the range will be (-shift_limit_x, shift_limit_x). Absolute values for lower and upper bounds should lie in the range [-1, 1]. Default: None.</p> <code>shift_limit_y</code> <code>float, float) or float</code> <p>shift factor range for height. If it is set then this value instead of shift_limit will be used for shifting height.  If shift_limit_y is a single float value, the range will be (-shift_limit_y, shift_limit_y). Absolute values for lower and upper bounds should lie in the range [-, 1]. Default: None.</p> <code>rotate_method</code> <code>str</code> <p>rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\". Default: \"largest_box\"</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, keypoints, bboxes</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class ShiftScaleRotate(Affine):\n    \"\"\"Randomly apply affine transforms: translate, scale and rotate the input.\n\n    Args:\n        shift_limit ((float, float) or float): shift factor range for both height and width. If shift_limit\n            is a single float value, the range will be (-shift_limit, shift_limit). Absolute values for lower and\n            upper bounds should lie in range [-1, 1]. Default: (-0.0625, 0.0625).\n        scale_limit ((float, float) or float): scaling factor range. If scale_limit is a single float value, the\n            range will be (-scale_limit, scale_limit). Note that the scale_limit will be biased by 1.\n            If scale_limit is a tuple, like (low, high), sampling will be done from the range (1 + low, 1 + high).\n            Default: (-0.1, 0.1).\n        rotate_limit ((int, int) or int): rotation range. If rotate_limit is a single int value, the\n            range will be (-rotate_limit, rotate_limit). Default: (-45, 45).\n        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:\n            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.\n            Default: cv2.INTER_LINEAR.\n        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:\n            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.\n            Default: cv2.BORDER_REFLECT_101\n        value (int, float, list of int, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.\n        mask_value (int, float,\n                    list of int,\n                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.\n        shift_limit_x ((float, float) or float): shift factor range for width. If it is set then this value\n            instead of shift_limit will be used for shifting width.  If shift_limit_x is a single float value,\n            the range will be (-shift_limit_x, shift_limit_x). Absolute values for lower and upper bounds should lie in\n            the range [-1, 1]. Default: None.\n        shift_limit_y ((float, float) or float): shift factor range for height. If it is set then this value\n            instead of shift_limit will be used for shifting height.  If shift_limit_y is a single float value,\n            the range will be (-shift_limit_y, shift_limit_y). Absolute values for lower and upper bounds should lie\n            in the range [-, 1]. Default: None.\n        rotate_method (str): rotation method used for the bounding boxes. Should be one of \"largest_box\" or \"ellipse\".\n            Default: \"largest_box\"\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, keypoints, bboxes\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.KEYPOINTS, Targets.BBOXES)\n\n    class InitSchema(BaseTransformInitSchema):\n        shift_limit: SymmetricRangeType = (-0.0625, 0.0625)\n        scale_limit: SymmetricRangeType = (-0.1, 0.1)\n        rotate_limit: SymmetricRangeType = (-45, 45)\n        interpolation: InterpolationType = cv2.INTER_LINEAR\n        border_mode: BorderModeType = cv2.BORDER_REFLECT_101\n        value: ColorType = 0\n        mask_value: ColorType = 0\n        shift_limit_x: Optional[ScaleFloatType] = Field(default=None)\n        shift_limit_y: Optional[ScaleFloatType] = Field(default=None)\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\"\n\n        @model_validator(mode=\"after\")\n        def check_shift_limit(self) -&gt; Self:\n            bounds = -1, 1\n            self.shift_limit_x = to_tuple(self.shift_limit_x if self.shift_limit_x is not None else self.shift_limit)\n            check_range(self.shift_limit_x, *bounds, \"shift_limit_x\")\n            self.shift_limit_y = to_tuple(self.shift_limit_y if self.shift_limit_y is not None else self.shift_limit)\n            check_range(self.shift_limit_y, *bounds, \"shift_limit_y\")\n            return self\n\n        @field_validator(\"scale_limit\")\n        @classmethod\n        def check_scale_limit(cls, value: ScaleFloatType, info: ValidationInfo) -&gt; ScaleFloatType:\n            bounds = 0, float(\"inf\")\n            result = to_tuple(value, bias=1.0)\n            check_range(result, *bounds, str(info.field_name))\n            return result\n\n    def __init__(\n        self,\n        shift_limit: ScaleFloatType = (-0.0625, 0.0625),\n        scale_limit: ScaleFloatType = (-0.1, 0.1),\n        rotate_limit: ScaleFloatType = (-45, 45),\n        interpolation: int = cv2.INTER_LINEAR,\n        border_mode: int = cv2.BORDER_REFLECT_101,\n        value: ColorType = 0,\n        mask_value: ColorType = 0,\n        shift_limit_x: Optional[ScaleFloatType] = None,\n        shift_limit_y: Optional[ScaleFloatType] = None,\n        rotate_method: Literal[\"largest_box\", \"ellipse\"] = \"largest_box\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(\n            scale=scale_limit,\n            translate_percent={\"x\": shift_limit_x, \"y\": shift_limit_y},\n            rotate=rotate_limit,\n            shear=(0, 0),\n            interpolation=interpolation,\n            mask_interpolation=cv2.INTER_NEAREST,\n            cval=value,\n            cval_mask=mask_value,\n            mode=border_mode,\n            fit_output=False,\n            keep_ratio=False,\n            rotate_method=rotate_method,\n            always_apply=always_apply,\n            p=p,\n        )\n        warn(\n            \"ShiftScaleRotate is deprecated. Please use Affine transform instead .\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.shift_limit_x = cast(Tuple[float, float], shift_limit_x)\n        self.shift_limit_y = cast(Tuple[float, float], shift_limit_y)\n        self.scale_limit = cast(Tuple[float, float], scale_limit)\n        self.rotate_limit = cast(Tuple[int, int], rotate_limit)\n        self.border_mode = border_mode\n        self.value = value\n        self.mask_value = mask_value\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {\n            \"shift_limit_x\": self.shift_limit_x,\n            \"shift_limit_y\": self.shift_limit_y,\n            \"scale_limit\": to_tuple(self.scale_limit, bias=-1.0),\n            \"rotate_limit\": self.rotate_limit,\n            \"interpolation\": self.interpolation,\n            \"border_mode\": self.border_mode,\n            \"value\": self.value,\n            \"mask_value\": self.mask_value,\n            \"rotate_method\": self.rotate_method,\n        }\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.Transpose","title":"<code>class  Transpose</code> <code> </code>  [view source on GitHub]","text":"<p>Transpose the input by swapping rows and columns.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class Transpose(DualTransform):\n    \"\"\"Transpose the input by swapping rows and columns.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.transpose(img)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_transpose(bbox, 0, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_transpose(keypoint)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/geometric/transforms/#albumentations.augmentations.geometric.transforms.VerticalFlip","title":"<code>class  VerticalFlip</code> <code> </code>  [view source on GitHub]","text":"<p>Flip the input vertically around the x-axis.</p> <p>Parameters:</p> Name Type Description <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> <p>Targets</p> <p>image, mask, bboxes, keypoints</p> <p>Image types:     uint8, float32</p> Source code in <code>albumentations/augmentations/geometric/transforms.py</code> Python<pre><code>class VerticalFlip(DualTransform):\n    \"\"\"Flip the input vertically around the x-axis.\n\n    Args:\n        p (float): probability of applying the transform. Default: 0.5.\n\n    Targets:\n        image, mask, bboxes, keypoints\n\n    Image types:\n        uint8, float32\n\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS)\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return F.vflip(img)\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return F.bbox_vflip(bbox, **params)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return F.keypoint_vflip(keypoint, **params)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[()]:\n        return ()\n</code></pre>"},{"location":"api_reference/augmentations/mixing/","title":"Index","text":"<ul> <li>Mixing transforms (albumentations.augmentations.mixing.transforms)</li> </ul>"},{"location":"api_reference/augmentations/mixing/functional/","title":"Mixing functional transforms (augmentations.mixing.functional)","text":""},{"location":"api_reference/augmentations/mixing/transforms/","title":"Mixing transforms (augmentations.mixing.transforms)","text":""},{"location":"api_reference/augmentations/mixing/transforms/#albumentations.augmentations.mixing.transforms.MixUp","title":"<code>class  MixUp</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"<p>Performs MixUp data augmentation, blending images, masks, and class labels with reference data.</p> <p>MixUp augmentation linearly combines an input (image, mask, and class label) with another set from a predefined reference dataset. The mixing degree is controlled by a parameter \u03bb (lambda), sampled from a Beta distribution. This method is known for improving model generalization by promoting linear behavior between classes and smoothing decision boundaries.</p> <p>Reference</p> <p>Zhang, H., Cisse, M., Dauphin, Y.N., and Lopez-Paz, D. (2018). mixup: Beyond Empirical Risk Minimization. In International Conference on Learning Representations. https://arxiv.org/abs/1710.09412</p> <p>Parameters:</p> Name Type Description <code>reference_data</code> <code>Optional[Union[Generator[ReferenceImage, None, None], Sequence[Any]]]</code> <p>A sequence or generator of dictionaries containing the reference data for mixing If None or an empty sequence is provided, no operation is performed and a warning is issued.</p> <code>read_fn</code> <code>Callable[[ReferenceImage], Dict[str, Any]]</code> <p>A function to process items from reference_data. It should accept items from reference_data and return a dictionary containing processed data:     - The returned dictionary must include an 'image' key with a numpy array value.     - It may also include 'mask', 'global_label' each associated with numpy array values. Defaults to a function that assumes input dictionary contains numpy arrays and directly returns it.</p> <code>mix_coef_return_name</code> <code>str</code> <p>Name used for the applied alpha coefficient in the returned dictionary. Defaults to \"mix_coef\".</p> <code>alpha</code> <code>float</code> <p>The alpha parameter for the Beta distribution, influencing the mix's balance. Must be \u2265 0. Higher values lead to more uniform mixing. Defaults to 0.4.</p> <code>p</code> <code>float</code> <p>The probability of applying the transformation. Defaults to 0.5.</p> <p>Targets</p> <p>image, mask, global_label</p> <p>Image types:     - uint8, float32</p> <p>Exceptions:</p> Type Description <code>- ValueError</code> <p>If the alpha parameter is negative.</p> <code>- NotImplementedError</code> <p>If the transform is applied to bounding boxes or keypoints.</p> <p>Notes</p> <ul> <li>If no reference data is provided, a warning is issued, and the transform acts as a no-op.</li> <li>Notes if images are in float32 format, they should be within [0, 1] range.</li> </ul> <p>Example Usage:     import albumentations as A     import numpy as np     from albumentations.core.types import ReferenceImage</p> <pre><code># Prepare reference data\n# Note: This code generates random reference data for demonstration purposes only.\n# In real-world applications, it's crucial to use meaningful and representative data.\n# The quality and relevance of your input data significantly impact the effectiveness\n# of the augmentation process. Ensure your data closely aligns with your specific\n# use case and application requirements.\nreference_data = [ReferenceImage(image=np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8),\n                                 mask=np.random.randint(0, 4, (100, 100, 1), dtype=np.uint8),\n                                 global_label=np.random.choice([0, 1], size=3)) for i in range(10)]\n\n# In this example, the lambda function simply returns its input, which works well for\n# data already in the expected format. For more complex scenarios, where the data might not be in\n# the required format or additional processing is needed, a more sophisticated function can be implemented.\n# Below is a hypothetical example where the input data is a file path, # and the function reads the image\n# file, converts it to a specific format, and possibly performs other preprocessing steps.\n\n# Example of a more complex read_fn that reads an image from a file path, converts it to RGB, and resizes it.\n# def custom_read_fn(file_path):\n#     from PIL import Image\n#     image = Image.open(file_path).convert('RGB')\n#     image = image.resize((100, 100))  # Example resize, adjust as needed.\n#     return np.array(image)\n\n# aug = A.Compose([A.RandomRotate90(), A.MixUp(p=1, reference_data=reference_data, read_fn=lambda x: x)])\n\n# For simplicity, the original lambda function is used in this example.\n# Replace `lambda x: x` with `custom_read_fn`if you need to process the data more extensively.\n\n# Apply augmentations\nimage = np.empty([100, 100, 3], dtype=np.uint8)\nmask = np.empty([100, 100], dtype=np.uint8)\nglobal_label = np.array([0, 1, 0])\ndata = aug(image=image, global_label=global_label, mask=mask)\ntransformed_image = data[\"image\"]\ntransformed_mask = data[\"mask\"]\ntransformed_global_label = data[\"global_label\"]\n\n# Print applied mix coefficient\nprint(data[\"mix_coef\"])  # Output: e.g., 0.9991580344142427\n</code></pre> Source code in <code>albumentations/augmentations/mixing/transforms.py</code> Python<pre><code>class MixUp(ReferenceBasedTransform):\n    \"\"\"Performs MixUp data augmentation, blending images, masks, and class labels with reference data.\n\n    MixUp augmentation linearly combines an input (image, mask, and class label) with another set from a predefined\n    reference dataset. The mixing degree is controlled by a parameter \u03bb (lambda), sampled from a Beta distribution.\n    This method is known for improving model generalization by promoting linear behavior between classes and\n    smoothing decision boundaries.\n\n    Reference:\n        Zhang, H., Cisse, M., Dauphin, Y.N., and Lopez-Paz, D. (2018). mixup: Beyond Empirical Risk Minimization.\n        In International Conference on Learning Representations. https://arxiv.org/abs/1710.09412\n\n    Args:\n        reference_data (Optional[Union[Generator[ReferenceImage, None, None], Sequence[Any]]]):\n            A sequence or generator of dictionaries containing the reference data for mixing\n            If None or an empty sequence is provided, no operation is performed and a warning is issued.\n        read_fn (Callable[[ReferenceImage], Dict[str, Any]]):\n            A function to process items from reference_data. It should accept items from reference_data\n            and return a dictionary containing processed data:\n                - The returned dictionary must include an 'image' key with a numpy array value.\n                - It may also include 'mask', 'global_label' each associated with numpy array values.\n            Defaults to a function that assumes input dictionary contains numpy arrays and directly returns it.\n        mix_coef_return_name (str): Name used for the applied alpha coefficient in the returned dictionary.\n            Defaults to \"mix_coef\".\n        alpha (float):\n            The alpha parameter for the Beta distribution, influencing the mix's balance. Must be \u2265 0.\n            Higher values lead to more uniform mixing. Defaults to 0.4.\n        p (float):\n            The probability of applying the transformation. Defaults to 0.5.\n\n    Targets:\n        image, mask, global_label\n\n    Image types:\n        - uint8, float32\n\n    Raises:\n        - ValueError: If the alpha parameter is negative.\n        - NotImplementedError: If the transform is applied to bounding boxes or keypoints.\n\n    Notes:\n        - If no reference data is provided, a warning is issued, and the transform acts as a no-op.\n        - Notes if images are in float32 format, they should be within [0, 1] range.\n\n    Example Usage:\n        import albumentations as A\n        import numpy as np\n        from albumentations.core.types import ReferenceImage\n\n        # Prepare reference data\n        # Note: This code generates random reference data for demonstration purposes only.\n        # In real-world applications, it's crucial to use meaningful and representative data.\n        # The quality and relevance of your input data significantly impact the effectiveness\n        # of the augmentation process. Ensure your data closely aligns with your specific\n        # use case and application requirements.\n        reference_data = [ReferenceImage(image=np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8),\n                                         mask=np.random.randint(0, 4, (100, 100, 1), dtype=np.uint8),\n                                         global_label=np.random.choice([0, 1], size=3)) for i in range(10)]\n\n        # In this example, the lambda function simply returns its input, which works well for\n        # data already in the expected format. For more complex scenarios, where the data might not be in\n        # the required format or additional processing is needed, a more sophisticated function can be implemented.\n        # Below is a hypothetical example where the input data is a file path, # and the function reads the image\n        # file, converts it to a specific format, and possibly performs other preprocessing steps.\n\n        # Example of a more complex read_fn that reads an image from a file path, converts it to RGB, and resizes it.\n        # def custom_read_fn(file_path):\n        #     from PIL import Image\n        #     image = Image.open(file_path).convert('RGB')\n        #     image = image.resize((100, 100))  # Example resize, adjust as needed.\n        #     return np.array(image)\n\n        # aug = A.Compose([A.RandomRotate90(), A.MixUp(p=1, reference_data=reference_data, read_fn=lambda x: x)])\n\n        # For simplicity, the original lambda function is used in this example.\n        # Replace `lambda x: x` with `custom_read_fn`if you need to process the data more extensively.\n\n        # Apply augmentations\n        image = np.empty([100, 100, 3], dtype=np.uint8)\n        mask = np.empty([100, 100], dtype=np.uint8)\n        global_label = np.array([0, 1, 0])\n        data = aug(image=image, global_label=global_label, mask=mask)\n        transformed_image = data[\"image\"]\n        transformed_mask = data[\"mask\"]\n        transformed_global_label = data[\"global_label\"]\n\n        # Print applied mix coefficient\n        print(data[\"mix_coef\"])  # Output: e.g., 0.9991580344142427\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.GLOBAL_LABEL)\n\n    class InitSchema(BaseTransformInitSchema):\n        reference_data: Optional[Union[Generator[Any, None, None], Sequence[Any]]] = None\n        read_fn: Callable[[ReferenceImage], Any]\n        alpha: Annotated[float, Field(default=0.4, ge=0, le=1)]\n        mix_coef_return_name: str = \"mix_coef\"\n\n    def __init__(\n        self,\n        reference_data: Optional[Union[Generator[Any, None, None], Sequence[Any]]] = None,\n        read_fn: Callable[[ReferenceImage], Any] = lambda x: {\"image\": x, \"mask\": None, \"class_label\": None},\n        alpha: float = 0.4,\n        mix_coef_return_name: str = \"mix_coef\",\n        always_apply: bool = False,\n        p: float = 0.5,\n    ):\n        super().__init__(always_apply, p)\n        self.mix_coef_return_name = mix_coef_return_name\n\n        self.read_fn = read_fn\n        self.alpha = alpha\n\n        if reference_data is None:\n            warn(\"No reference data provided for MixUp. This transform will act as a no-op.\")\n            # Create an empty generator\n            self.reference_data: List[Any] = []\n        elif (\n            isinstance(reference_data, types.GeneratorType)\n            or isinstance(reference_data, Iterable)\n            and not isinstance(reference_data, str)\n        ):\n            self.reference_data = reference_data  # type: ignore[assignment]\n        else:\n            msg = \"reference_data must be a list, tuple, generator, or None.\"\n            raise TypeError(msg)\n\n    def apply(self, img: np.ndarray, mix_data: ReferenceImage, mix_coef: float, **params: Any) -&gt; np.ndarray:\n        if not mix_data:\n            return img\n\n        mix_img = mix_data[\"image\"]\n\n        if not is_grayscale_image(img) and img.shape != mix_img.shape:\n            msg = \"The shape of the reference image should be the same as the input image.\"\n            raise ValueError(msg)\n\n        return add_weighted(img, mix_coef, mix_img, 1 - mix_coef) if mix_img is not None else img\n\n    def apply_to_mask(self, mask: np.ndarray, mix_data: ReferenceImage, mix_coef: float, **params: Any) -&gt; np.ndarray:\n        mix_mask = mix_data.get(\"mask\")\n        return add_weighted(mask, mix_coef, mix_mask, 1 - mix_coef) if mix_mask is not None else mask\n\n    def apply_to_global_label(\n        self, label: np.ndarray, mix_data: ReferenceImage, mix_coef: float, **params: Any\n    ) -&gt; np.ndarray:\n        mix_label = mix_data.get(\"global_label\")\n        if mix_label is not None and label is not None:\n            return mix_coef * label + (1 - mix_coef) * mix_label\n        return label\n\n    def apply_to_bboxes(self, bboxes: Sequence[BoxType], mix_data: ReferenceImage, **params: Any) -&gt; Sequence[BoxType]:\n        msg = \"MixUp does not support bounding boxes yet, feel free to submit pull request to https://github.com/albumentations-team/albumentations/.\"\n        raise NotImplementedError(msg)\n\n    def apply_to_keypoints(\n        self, keypoints: Sequence[KeypointType], *args: Any, **params: Any\n    ) -&gt; Sequence[KeypointType]:\n        msg = \"MixUp does not support keypoints yet, feel free to submit pull request to https://github.com/albumentations-team/albumentations/.\"\n        raise NotImplementedError(msg)\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return \"reference_data\", \"alpha\"\n\n    def get_params(self) -&gt; Dict[str, Union[None, float, Dict[str, Any]]]:\n        mix_data = None\n        # Check if reference_data is not empty and is a sequence (list, tuple, np.array)\n        if isinstance(self.reference_data, Sequence) and not isinstance(self.reference_data, (str, bytes)):\n            if len(self.reference_data) &gt; 0:  # Additional check to ensure it's not empty\n                mix_idx = random.randint(0, len(self.reference_data) - 1)\n                mix_data = self.reference_data[mix_idx]\n        # Check if reference_data is an iterator or generator\n        elif isinstance(self.reference_data, Iterator):\n            try:\n                mix_data = next(self.reference_data)  # Attempt to get the next item\n            except StopIteration:\n                warn(\n                    \"Reference data iterator/generator has been exhausted. \"\n                    \"Further mixing augmentations will not be applied.\",\n                    RuntimeWarning,\n                )\n                return {\"mix_data\": {}, \"mix_coef\": 1}\n\n        # If mix_data is None or empty after the above checks, return default values\n        if mix_data is None:\n            return {\"mix_data\": {}, \"mix_coef\": 1}\n\n        # If mix_data is not None, calculate mix_coef and apply read_fn\n        mix_coef = beta(self.alpha, self.alpha)  # Assuming beta is defined elsewhere\n        return {\"mix_data\": self.read_fn(mix_data), \"mix_coef\": mix_coef}\n\n    def apply_with_params(self, params: Dict[str, Any], *args: Any, **kwargs: Any) -&gt; Dict[str, Any]:\n        res = super().apply_with_params(params, *args, **kwargs)\n        if self.mix_coef_return_name:\n            res[self.mix_coef_return_name] = params[\"mix_coef\"]\n        return res\n</code></pre>"},{"location":"api_reference/core/","title":"Index","text":"<ul> <li>Composition API (albumentations.core.composition)</li> <li>Serialization API (albumentations.core.serialization)</li> <li>Transforms Interface (albumentations.core.transforms_interface)</li> <li>Helper functions for working with bounding boxes (albumentations.core.bbox_utils)</li> <li>Helper functions for working with keypoints (albumentations.core.keypoints_utils)</li> </ul>"},{"location":"api_reference/core/bbox_utils/","title":"Helper functions for working with bounding boxes (augmentations.core.bbox_utils)","text":""},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.BboxParams","title":"<code>class  BboxParams</code> <code>       (format, label_fields=None, min_area=0.0, min_visibility=0.0, min_width=0.0, min_height=0.0, check_each_transform=True)                   </code>  [view source on GitHub]","text":"<p>Parameters of bounding boxes</p> <p>Parameters:</p> Name Type Description <code>format</code> <code>str</code> <p>format of bounding boxes. Should be 'coco', 'pascal_voc', 'albumentations' or 'yolo'.</p> <p>The <code>coco</code> format     <code>[x_min, y_min, width, height]</code>, e.g. [97, 12, 150, 200]. The <code>pascal_voc</code> format     <code>[x_min, y_min, x_max, y_max]</code>, e.g. [97, 12, 247, 212]. The <code>albumentations</code> format     is like <code>pascal_voc</code>, but normalized,     in other words: <code>[x_min, y_min, x_max, y_max]</code>, e.g. [0.2, 0.3, 0.4, 0.5]. The <code>yolo</code> format     <code>[x, y, width, height]</code>, e.g. [0.1, 0.2, 0.3, 0.4];     <code>x</code>, <code>y</code> - normalized bbox center; <code>width</code>, <code>height</code> - normalized bbox width and height.</p> <code>label_fields</code> <code>list</code> <p>list of fields that are joined with boxes, e.g labels. Should be same type as boxes.</p> <code>min_area</code> <code>float</code> <p>minimum area of a bounding box. All bounding boxes whose visible area in pixels is less than this value will be removed. Default: 0.0.</p> <code>min_visibility</code> <code>float</code> <p>minimum fraction of area for a bounding box to remain this box in list. Default: 0.0.</p> <code>min_width</code> <code>float</code> <p>Minimum width of a bounding box. All bounding boxes whose width is less than this value will be removed. Default: 0.0.</p> <code>min_height</code> <code>float</code> <p>Minimum height of a bounding box. All bounding boxes whose height is less than this value will be removed. Default: 0.0.</p> <code>check_each_transform</code> <code>bool</code> <p>if <code>True</code>, then bboxes will be checked after each dual transform. Default: <code>True</code></p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>class BboxParams(Params):\n    \"\"\"Parameters of bounding boxes\n\n    Args:\n        format (str): format of bounding boxes. Should be 'coco', 'pascal_voc', 'albumentations' or 'yolo'.\n\n            The `coco` format\n                `[x_min, y_min, width, height]`, e.g. [97, 12, 150, 200].\n            The `pascal_voc` format\n                `[x_min, y_min, x_max, y_max]`, e.g. [97, 12, 247, 212].\n            The `albumentations` format\n                is like `pascal_voc`, but normalized,\n                in other words: `[x_min, y_min, x_max, y_max]`, e.g. [0.2, 0.3, 0.4, 0.5].\n            The `yolo` format\n                `[x, y, width, height]`, e.g. [0.1, 0.2, 0.3, 0.4];\n                `x`, `y` - normalized bbox center; `width`, `height` - normalized bbox width and height.\n        label_fields (list): list of fields that are joined with boxes, e.g labels.\n            Should be same type as boxes.\n        min_area (float): minimum area of a bounding box. All bounding boxes whose\n            visible area in pixels is less than this value will be removed. Default: 0.0.\n        min_visibility (float): minimum fraction of area for a bounding box\n            to remain this box in list. Default: 0.0.\n        min_width (float): Minimum width of a bounding box. All bounding boxes whose width is\n            less than this value will be removed. Default: 0.0.\n        min_height (float): Minimum height of a bounding box. All bounding boxes whose height is\n            less than this value will be removed. Default: 0.0.\n        check_each_transform (bool): if `True`, then bboxes will be checked after each dual transform.\n            Default: `True`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        format: str,\n        label_fields: Optional[Sequence[str]] = None,\n        min_area: float = 0.0,\n        min_visibility: float = 0.0,\n        min_width: float = 0.0,\n        min_height: float = 0.0,\n        check_each_transform: bool = True,\n    ):\n        super().__init__(format, label_fields)\n        self.min_area = min_area\n        self.min_visibility = min_visibility\n        self.min_width = min_width\n        self.min_height = min_height\n        self.check_each_transform = check_each_transform\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        data = super().to_dict_private()\n        data.update(\n            {\n                \"min_area\": self.min_area,\n                \"min_visibility\": self.min_visibility,\n                \"min_width\": self.min_width,\n                \"min_height\": self.min_height,\n                \"check_each_transform\": self.check_each_transform,\n            }\n        )\n        return data\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return True\n\n    @classmethod\n    def get_class_fullname(cls) -&gt; str:\n        return \"BboxParams\"\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.calculate_bbox_area","title":"<code>def calculate_bbox_area    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Calculate the area of a bounding box in (fractional) pixels.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>float</code> <p>Area in (fractional) pixels of the (denormalized) bounding box.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def calculate_bbox_area(bbox: BoxType, rows: int, cols: int) -&gt; float:\n    \"\"\"Calculate the area of a bounding box in (fractional) pixels.\n\n    Args:\n        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image height.\n        cols: Image width.\n\n    Return:\n        Area in (fractional) pixels of the (denormalized) bounding box.\n\n    \"\"\"\n    bbox = denormalize_bbox(bbox, rows, cols)\n    x_min, y_min, x_max, y_max = bbox[:4]\n    return (x_max - x_min) * (y_max - y_min)\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.check_bbox","title":"<code>def check_bbox    (bbox)    </code> [view source on GitHub]","text":"<p>Check if bbox boundaries are in range 0, 1 and minimums are lesser then maximums</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def check_bbox(bbox: BoxType) -&gt; None:\n    \"\"\"Check if bbox boundaries are in range 0, 1 and minimums are lesser then maximums\"\"\"\n    for name, value in zip([\"x_min\", \"y_min\", \"x_max\", \"y_max\"], bbox[:4]):\n        if not 0 &lt;= value &lt;= 1 and not np.isclose(value, 0) and not np.isclose(value, 1):\n            raise ValueError(f\"Expected {name} for bbox {bbox} to be in the range [0.0, 1.0], got {value}.\")\n    x_min, y_min, x_max, y_max = bbox[:4]\n    if x_max &lt;= x_min:\n        raise ValueError(f\"x_max is less than or equal to x_min for bbox {bbox}.\")\n    if y_max &lt;= y_min:\n        raise ValueError(f\"y_max is less than or equal to y_min for bbox {bbox}.\")\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.check_bboxes","title":"<code>def check_bboxes    (bboxes)    </code> [view source on GitHub]","text":"<p>Check if bboxes boundaries are in range 0, 1 and minimums are lesser then maximums</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def check_bboxes(bboxes: Sequence[BoxType]) -&gt; None:\n    \"\"\"Check if bboxes boundaries are in range 0, 1 and minimums are lesser then maximums\"\"\"\n    for bbox in bboxes:\n        check_bbox(bbox)\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.convert_bbox_from_albumentations","title":"<code>def convert_bbox_from_albumentations    (bbox, target_format, rows, cols, check_validity=False)    </code> [view source on GitHub]","text":"<p>Convert a bounding box from the format used by albumentations to a format, specified in <code>target_format</code>.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>An albumentations bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>target_format</code> <code>str</code> <p>required format of the output bounding box. Should be 'coco', 'pascal_voc' or 'yolo'.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <code>check_validity</code> <code>bool</code> <p>Check if all boxes are valid boxes.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box.</p> <p>Note</p> <p>The <code>coco</code> format of a bounding box looks like <code>[x_min, y_min, width, height]</code>, e.g. [97, 12, 150, 200]. The <code>pascal_voc</code> format of a bounding box looks like <code>[x_min, y_min, x_max, y_max]</code>, e.g. [97, 12, 247, 212]. The <code>yolo</code> format of a bounding box looks like <code>[x, y, width, height]</code>, e.g. [0.3, 0.1, 0.05, 0.07].</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if <code>target_format</code> is not equal to <code>coco</code>, <code>pascal_voc</code> or <code>yolo</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def convert_bbox_from_albumentations(\n    bbox: BoxType, target_format: str, rows: int, cols: int, check_validity: bool = False\n) -&gt; BoxType:\n    \"\"\"Convert a bounding box from the format used by albumentations to a format, specified in `target_format`.\n\n    Args:\n        bbox: An albumentations bounding box `(x_min, y_min, x_max, y_max)`.\n        target_format: required format of the output bounding box. Should be 'coco', 'pascal_voc' or 'yolo'.\n        rows: Image height.\n        cols: Image width.\n        check_validity: Check if all boxes are valid boxes.\n\n    Returns:\n        tuple: A bounding box.\n\n    Note:\n        The `coco` format of a bounding box looks like `[x_min, y_min, width, height]`, e.g. [97, 12, 150, 200].\n        The `pascal_voc` format of a bounding box looks like `[x_min, y_min, x_max, y_max]`, e.g. [97, 12, 247, 212].\n        The `yolo` format of a bounding box looks like `[x, y, width, height]`, e.g. [0.3, 0.1, 0.05, 0.07].\n\n    Raises:\n        ValueError: if `target_format` is not equal to `coco`, `pascal_voc` or `yolo`.\n\n    \"\"\"\n    if target_format not in {\"coco\", \"pascal_voc\", \"yolo\"}:\n        raise ValueError(\n            f\"Unknown target_format {target_format}. Supported formats are: 'coco', 'pascal_voc' and 'yolo'\"\n        )\n    if check_validity:\n        check_bbox(bbox)\n\n    if target_format != \"yolo\":\n        bbox = denormalize_bbox(bbox, rows, cols)\n    if target_format == \"coco\":\n        (x_min, y_min, x_max, y_max), tail = bbox[:4], tuple(bbox[4:])\n        width = x_max - x_min\n        height = y_max - y_min\n        bbox = cast(BoxType, (x_min, y_min, width, height, *tail))\n    elif target_format == \"yolo\":\n        (x_min, y_min, x_max, y_max), tail = bbox[:4], bbox[4:]\n        x = (x_min + x_max) / 2.0\n        y = (y_min + y_max) / 2.0\n        w = x_max - x_min\n        h = y_max - y_min\n        bbox = cast(BoxType, (x, y, w, h, *tail))\n    return bbox\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.convert_bbox_to_albumentations","title":"<code>def convert_bbox_to_albumentations    (bbox, source_format, rows, cols, check_validity=False)    </code> [view source on GitHub]","text":"<p>Convert a bounding box from a format specified in <code>source_format</code> to the format used by albumentations: normalized coordinates of top-left and bottom-right corners of the bounding box in a form of <code>(x_min, y_min, x_max, y_max)</code> e.g. <code>(0.15, 0.27, 0.67, 0.5)</code>.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>A bounding box tuple.</p> <code>source_format</code> <code>str</code> <p>format of the bounding box. Should be 'coco', 'pascal_voc', or 'yolo'.</p> <code>check_validity</code> <code>bool</code> <p>Check if all boxes are valid boxes.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Note</p> <p>The <code>coco</code> format of a bounding box looks like <code>(x_min, y_min, width, height)</code>, e.g. (97, 12, 150, 200). The <code>pascal_voc</code> format of a bounding box looks like <code>(x_min, y_min, x_max, y_max)</code>, e.g. (97, 12, 247, 212). The <code>yolo</code> format of a bounding box looks like <code>(x, y, width, height)</code>, e.g. (0.3, 0.1, 0.05, 0.07); where <code>x</code>, <code>y</code> coordinates of the center of the box, all values normalized to 1 by image height and width.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if <code>target_format</code> is not equal to <code>coco</code> or <code>pascal_voc</code>, or <code>yolo</code>.</p> <code>ValueError</code> <p>If in YOLO format all labels not in range (0, 1).</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def convert_bbox_to_albumentations(\n    bbox: BoxType, source_format: str, rows: int, cols: int, check_validity: bool = False\n) -&gt; BoxType:\n    \"\"\"Convert a bounding box from a format specified in `source_format` to the format used by albumentations:\n    normalized coordinates of top-left and bottom-right corners of the bounding box in a form of\n    `(x_min, y_min, x_max, y_max)` e.g. `(0.15, 0.27, 0.67, 0.5)`.\n\n    Args:\n        bbox: A bounding box tuple.\n        source_format: format of the bounding box. Should be 'coco', 'pascal_voc', or 'yolo'.\n        check_validity: Check if all boxes are valid boxes.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        tuple: A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    Note:\n        The `coco` format of a bounding box looks like `(x_min, y_min, width, height)`, e.g. (97, 12, 150, 200).\n        The `pascal_voc` format of a bounding box looks like `(x_min, y_min, x_max, y_max)`, e.g. (97, 12, 247, 212).\n        The `yolo` format of a bounding box looks like `(x, y, width, height)`, e.g. (0.3, 0.1, 0.05, 0.07);\n        where `x`, `y` coordinates of the center of the box, all values normalized to 1 by image height and width.\n\n    Raises:\n        ValueError: if `target_format` is not equal to `coco` or `pascal_voc`, or `yolo`.\n        ValueError: If in YOLO format all labels not in range (0, 1).\n\n    \"\"\"\n    if source_format not in {\"coco\", \"pascal_voc\", \"yolo\"}:\n        raise ValueError(\n            f\"Unknown source_format {source_format}. Supported formats are: 'coco', 'pascal_voc' and 'yolo'\"\n        )\n\n    if source_format == \"coco\":\n        (x_min, y_min, width, height), tail = bbox[:4], bbox[4:]\n        x_max = x_min + width\n        y_max = y_min + height\n    elif source_format == \"yolo\":\n        # https://github.com/pjreddie/darknet/blob/f6d861736038da22c9eb0739dca84003c5a5e275/scripts/voc_label.py#L12\n        _bbox = np.array(bbox[:4])\n        if check_validity and np.any((_bbox &lt;= 0) | (_bbox &gt; 1)):\n            msg = \"In YOLO format all coordinates must be float and in range (0, 1]\"\n            raise ValueError(msg)\n\n        (x, y, w, h), tail = bbox[:4], bbox[4:]\n\n        w_half, h_half = w / 2, h / 2\n        x_min = x - w_half\n        y_min = y - h_half\n        x_max = x_min + w\n        y_max = y_min + h\n    else:\n        (x_min, y_min, x_max, y_max), tail = bbox[:4], bbox[4:]\n\n    bbox = (x_min, y_min, x_max, y_max, *tuple(tail))\n\n    if source_format != \"yolo\":\n        bbox = normalize_bbox(bbox, rows, cols)\n    if check_validity:\n        check_bbox(bbox)\n    return bbox\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.convert_bboxes_from_albumentations","title":"<code>def convert_bboxes_from_albumentations    (bboxes, target_format, rows, cols, check_validity=False)    </code> [view source on GitHub]","text":"<p>Convert a list of bounding boxes from the format used by albumentations to a format, specified in <code>target_format</code>.</p> <p>Parameters:</p> Name Type Description <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>List of albumentations bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>target_format</code> <code>str</code> <p>required format of the output bounding box. Should be 'coco', 'pascal_voc' or 'yolo'.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <code>check_validity</code> <code>bool</code> <p>Check if all boxes are valid boxes.</p> <p>Returns:</p> Type Description <code>List[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>List of bounding boxes.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def convert_bboxes_from_albumentations(\n    bboxes: Sequence[BoxType], target_format: str, rows: int, cols: int, check_validity: bool = False\n) -&gt; List[BoxType]:\n    \"\"\"Convert a list of bounding boxes from the format used by albumentations to a format, specified\n    in `target_format`.\n\n    Args:\n        bboxes: List of albumentations bounding box `(x_min, y_min, x_max, y_max)`.\n        target_format: required format of the output bounding box. Should be 'coco', 'pascal_voc' or 'yolo'.\n        rows: Image height.\n        cols: Image width.\n        check_validity: Check if all boxes are valid boxes.\n\n    Returns:\n        List of bounding boxes.\n\n    \"\"\"\n    return [convert_bbox_from_albumentations(bbox, target_format, rows, cols, check_validity) for bbox in bboxes]\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.convert_bboxes_to_albumentations","title":"<code>def convert_bboxes_to_albumentations    (bboxes, source_format, rows, cols, check_validity=False)    </code> [view source on GitHub]","text":"<p>Convert a list bounding boxes from a format specified in <code>source_format</code> to the format used by albumentations</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def convert_bboxes_to_albumentations(\n    bboxes: Sequence[BoxType], source_format: str, rows: int, cols: int, check_validity: bool = False\n) -&gt; List[BoxType]:\n    \"\"\"Convert a list bounding boxes from a format specified in `source_format` to the format used by albumentations\"\"\"\n    return [convert_bbox_to_albumentations(bbox, source_format, rows, cols, check_validity) for bbox in bboxes]\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.denormalize_bbox","title":"<code>def denormalize_bbox    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Denormalize coordinates of a bounding box. Multiply x-coordinates by image width and y-coordinates by image height. This is an inverse operation for :func:<code>~albumentations.augmentations.bbox.normalize_bbox</code>.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>Normalized bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>Denormalized bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If rows or cols is less or equal zero</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def denormalize_bbox(bbox: BoxType, rows: int, cols: int) -&gt; BoxType:\n    \"\"\"Denormalize coordinates of a bounding box. Multiply x-coordinates by image width and y-coordinates\n    by image height. This is an inverse operation for :func:`~albumentations.augmentations.bbox.normalize_bbox`.\n\n    Args:\n        bbox: Normalized bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        Denormalized bounding box `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: If rows or cols is less or equal zero\n\n    \"\"\"\n    tail: Tuple[Any, ...]\n    (x_min, y_min, x_max, y_max), tail = bbox[:4], tuple(bbox[4:])\n\n    if rows &lt;= 0:\n        msg = \"Argument rows must be positive integer\"\n        raise ValueError(msg)\n    if cols &lt;= 0:\n        msg = \"Argument cols must be positive integer\"\n        raise ValueError(msg)\n\n    x_min, x_max = x_min * cols, x_max * cols\n    y_min, y_max = y_min * rows, y_max * rows\n\n    return cast(BoxType, (x_min, y_min, x_max, y_max, *tail))\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.denormalize_bboxes","title":"<code>def denormalize_bboxes    (bboxes, rows, cols)    </code> [view source on GitHub]","text":"<p>Denormalize a list of bounding boxes.</p> <p>Parameters:</p> Name Type Description <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Normalized bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>List</code> <p>Denormalized bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def denormalize_bboxes(bboxes: Sequence[BoxType], rows: int, cols: int) -&gt; List[BoxType]:\n    \"\"\"Denormalize a list of bounding boxes.\n\n    Args:\n        bboxes: Normalized bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        List: Denormalized bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n\n    \"\"\"\n    return [denormalize_bbox(bbox, rows, cols) for bbox in bboxes]\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.filter_bboxes","title":"<code>def filter_bboxes    (bboxes, rows, cols, min_area=0.0, min_visibility=0.0, min_width=0.0, min_height=0.0)    </code> [view source on GitHub]","text":"<p>Remove bounding boxes that either lie outside of the visible area by more then min_visibility or whose area in pixels is under the threshold set by <code>min_area</code>. Also it crops boxes to final image size.</p> <p>Parameters:</p> Name Type Description <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>List of albumentations bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <code>min_area</code> <code>float</code> <p>Minimum area of a bounding box. All bounding boxes whose visible area in pixels. is less than this value will be removed. Default: 0.0.</p> <code>min_visibility</code> <code>float</code> <p>Minimum fraction of area for a bounding box to remain this box in list. Default: 0.0.</p> <code>min_width</code> <code>float</code> <p>Minimum width of a bounding box. All bounding boxes whose width is less than this value will be removed. Default: 0.0.</p> <code>min_height</code> <code>float</code> <p>Minimum height of a bounding box. All bounding boxes whose height is less than this value will be removed. Default: 0.0.</p> <p>Returns:</p> Type Description <code>List[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>List of bounding boxes.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def filter_bboxes(\n    bboxes: Sequence[BoxType],\n    rows: int,\n    cols: int,\n    min_area: float = 0.0,\n    min_visibility: float = 0.0,\n    min_width: float = 0.0,\n    min_height: float = 0.0,\n) -&gt; List[BoxType]:\n    \"\"\"Remove bounding boxes that either lie outside of the visible area by more then min_visibility\n    or whose area in pixels is under the threshold set by `min_area`. Also it crops boxes to final image size.\n\n    Args:\n        bboxes: List of albumentations bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image height.\n        cols: Image width.\n        min_area: Minimum area of a bounding box. All bounding boxes whose visible area in pixels.\n            is less than this value will be removed. Default: 0.0.\n        min_visibility: Minimum fraction of area for a bounding box to remain this box in list. Default: 0.0.\n        min_width: Minimum width of a bounding box. All bounding boxes whose width is\n            less than this value will be removed. Default: 0.0.\n        min_height: Minimum height of a bounding box. All bounding boxes whose height is\n            less than this value will be removed. Default: 0.0.\n\n    Returns:\n        List of bounding boxes.\n\n    \"\"\"\n    resulting_boxes: List[BoxType] = []\n    for i in range(len(bboxes)):\n        bbox = bboxes[i]\n        # Calculate areas of bounding box before and after clipping.\n        transformed_box_area = calculate_bbox_area(bbox, rows, cols)\n        bbox, tail = cast(BoxType, tuple(np.clip(bbox[:4], 0, 1.0))), tuple(bbox[4:])\n        clipped_box_area = calculate_bbox_area(bbox, rows, cols)\n\n        # Calculate width and height of the clipped bounding box.\n        x_min, y_min, x_max, y_max = denormalize_bbox(bbox, rows, cols)[:4]\n        clipped_width, clipped_height = x_max - x_min, y_max - y_min\n\n        if (\n            clipped_box_area != 0  # to ensure transformed_box_area!=0 and to handle min_area=0 or min_visibility=0\n            and clipped_box_area &gt;= min_area\n            and clipped_box_area / transformed_box_area &gt;= min_visibility\n            and clipped_width &gt;= min_width\n            and clipped_height &gt;= min_height\n        ):\n            resulting_boxes.append(cast(BoxType, bbox + tail))\n    return resulting_boxes\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.filter_bboxes_by_visibility","title":"<code>def filter_bboxes_by_visibility    (original_shape, bboxes, transformed_shape, transformed_bboxes, threshold=0.0, min_area=0.0)    </code> [view source on GitHub]","text":"<p>Filter bounding boxes and return only those boxes whose visibility after transformation is above the threshold and minimal area of bounding box in pixels is more then min_area.</p> <p>Parameters:</p> Name Type Description <code>original_shape</code> <code>Sequence[int]</code> <p>Original image shape <code>(height, width, ...)</code>.</p> <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Original bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>transformed_shape</code> <code>Sequence[int]</code> <p>Transformed image shape <code>(height, width)</code>.</p> <code>transformed_bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Transformed bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>threshold</code> <code>float</code> <p>visibility threshold. Should be a value in the range [0.0, 1.0].</p> <code>min_area</code> <code>float</code> <p>Minimal area threshold.</p> <p>Returns:</p> Type Description <code>List[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Filtered bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def filter_bboxes_by_visibility(\n    original_shape: Sequence[int],\n    bboxes: Sequence[BoxType],\n    transformed_shape: Sequence[int],\n    transformed_bboxes: Sequence[BoxType],\n    threshold: float = 0.0,\n    min_area: float = 0.0,\n) -&gt; List[BoxType]:\n    \"\"\"Filter bounding boxes and return only those boxes whose visibility after transformation is above\n    the threshold and minimal area of bounding box in pixels is more then min_area.\n\n    Args:\n        original_shape: Original image shape `(height, width, ...)`.\n        bboxes: Original bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n        transformed_shape: Transformed image shape `(height, width)`.\n        transformed_bboxes: Transformed bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n        threshold: visibility threshold. Should be a value in the range [0.0, 1.0].\n        min_area: Minimal area threshold.\n\n    Returns:\n        Filtered bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n\n    \"\"\"\n    img_height, img_width = original_shape[:2]\n    transformed_img_height, transformed_img_width = transformed_shape[:2]\n\n    visible_bboxes = []\n    for bbox, transformed_bbox in zip(bboxes, transformed_bboxes):\n        if not all(0.0 &lt;= value &lt;= 1.0 for value in transformed_bbox[:4]):\n            continue\n        bbox_area = calculate_bbox_area(bbox, img_height, img_width)\n        transformed_bbox_area = calculate_bbox_area(transformed_bbox, transformed_img_height, transformed_img_width)\n        if transformed_bbox_area &lt; min_area:\n            continue\n        visibility = transformed_bbox_area / bbox_area\n        if visibility &gt;= threshold:\n            visible_bboxes.append(transformed_bbox)\n    return visible_bboxes\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.normalize_bbox","title":"<code>def normalize_bbox    (bbox, rows, cols)    </code> [view source on GitHub]","text":"<p>Normalize coordinates of a bounding box. Divide x-coordinates by image width and y-coordinates by image height.</p> <p>Parameters:</p> Name Type Description <code>bbox</code> <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>Denormalized bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]</code> <p>Normalized bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If rows or cols is less or equal zero</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def normalize_bbox(bbox: BoxType, rows: int, cols: int) -&gt; BoxType:\n    \"\"\"Normalize coordinates of a bounding box. Divide x-coordinates by image width and y-coordinates\n    by image height.\n\n    Args:\n        bbox: Denormalized bounding box `(x_min, y_min, x_max, y_max)`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        Normalized bounding box `(x_min, y_min, x_max, y_max)`.\n\n    Raises:\n        ValueError: If rows or cols is less or equal zero\n\n    \"\"\"\n    if rows &lt;= 0:\n        msg = \"Argument rows must be positive integer\"\n        raise ValueError(msg)\n    if cols &lt;= 0:\n        msg = \"Argument cols must be positive integer\"\n        raise ValueError(msg)\n\n    tail: Tuple[Any, ...]\n    (x_min, y_min, x_max, y_max), tail = bbox[:4], tuple(bbox[4:])\n    x_min /= cols\n    x_max /= cols\n    y_min /= rows\n    y_max /= rows\n\n    return cast(BoxType, (x_min, y_min, x_max, y_max, *tail))\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.normalize_bboxes","title":"<code>def normalize_bboxes    (bboxes, rows, cols)    </code> [view source on GitHub]","text":"<p>Normalize a list of bounding boxes.</p> <p>Parameters:</p> Name Type Description <code>bboxes</code> <code>Sequence[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Denormalized bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>rows</code> <code>int</code> <p>Image height.</p> <code>cols</code> <code>int</code> <p>Image width.</p> <p>Returns:</p> Type Description <code>List[Union[Tuple[float, float, float, float], Tuple[float, float, float, float, Any]]]</code> <p>Normalized bounding boxes <code>[(x_min, y_min, x_max, y_max)]</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def normalize_bboxes(bboxes: Sequence[BoxType], rows: int, cols: int) -&gt; List[BoxType]:\n    \"\"\"Normalize a list of bounding boxes.\n\n    Args:\n        bboxes: Denormalized bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n        rows: Image height.\n        cols: Image width.\n\n    Returns:\n        Normalized bounding boxes `[(x_min, y_min, x_max, y_max)]`.\n\n    \"\"\"\n    return [normalize_bbox(bbox, rows, cols) for bbox in bboxes]\n</code></pre>"},{"location":"api_reference/core/bbox_utils/#albumentations.core.bbox_utils.union_of_bboxes","title":"<code>def union_of_bboxes    (height, width, bboxes, erosion_rate=0.0)    </code> [view source on GitHub]","text":"<p>Calculate union of bounding boxes.</p> <p>Parameters:</p> Name Type Description <code>height</code> <code>float</code> <p>Height of image or space.</p> <code>width</code> <code>float</code> <p>Width of image or space.</p> <code>bboxes</code> <code>List[tuple]</code> <p>List like bounding boxes. Format is <code>[(x_min, y_min, x_max, y_max)]</code>.</p> <code>erosion_rate</code> <code>float</code> <p>How much each bounding box can be shrunk, useful for erosive cropping. Set this in range [0, 1]. 0 will not be erosive at all, 1.0 can make any bbox to lose its volume.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A bounding box <code>(x_min, y_min, x_max, y_max)</code>.</p> Source code in <code>albumentations/core/bbox_utils.py</code> Python<pre><code>def union_of_bboxes(height: int, width: int, bboxes: Sequence[BoxType], erosion_rate: float = 0.0) -&gt; BoxInternalType:\n    \"\"\"Calculate union of bounding boxes.\n\n    Args:\n        height (float): Height of image or space.\n        width (float): Width of image or space.\n        bboxes (List[tuple]): List like bounding boxes. Format is `[(x_min, y_min, x_max, y_max)]`.\n        erosion_rate (float): How much each bounding box can be shrunk, useful for erosive cropping.\n            Set this in range [0, 1]. 0 will not be erosive at all, 1.0 can make any bbox to lose its volume.\n\n    Returns:\n        tuple: A bounding box `(x_min, y_min, x_max, y_max)`.\n\n    \"\"\"\n    x1, y1 = width, height\n    x2, y2 = 0, 0\n    for bbox in bboxes:\n        x_min, y_min, x_max, y_max = bbox[:4]\n        w, h = x_max - x_min, y_max - y_min\n        lim_x1, lim_y1 = x_min + erosion_rate * w, y_min + erosion_rate * h\n        lim_x2, lim_y2 = x_max - erosion_rate * w, y_max - erosion_rate * h\n        x1, y1 = np.min([x1, lim_x1]), np.min([y1, lim_y1])\n        x2, y2 = np.max([x2, lim_x2]), np.max([y2, lim_y2])\n    return x1, y1, x2, y2\n</code></pre>"},{"location":"api_reference/core/composition/","title":"Composition API (core.composition)","text":""},{"location":"api_reference/core/composition/#albumentations.core.composition.Compose","title":"<code>class  Compose</code> <code>       (transforms, bbox_params=None, keypoint_params=None, additional_targets=None, p=1.0, is_check_shapes=True)                   </code>  [view source on GitHub]","text":"<p>Compose transforms and handle all transformations regarding bounding boxes</p> <p>Parameters:</p> Name Type Description <code>transforms</code> <code>list</code> <p>list of transformations to compose.</p> <code>bbox_params</code> <code>BboxParams</code> <p>Parameters for bounding boxes transforms</p> <code>keypoint_params</code> <code>KeypointParams</code> <p>Parameters for keypoints transforms</p> <code>additional_targets</code> <code>dict</code> <p>Dict with keys - new target name, values - old target name. ex: {'image2': 'image'}</p> <code>p</code> <code>float</code> <p>probability of applying all list of transforms. Default: 1.0.</p> <code>is_check_shapes</code> <code>bool</code> <p>If True shapes consistency of images/mask/masks would be checked on each call. If you would like to disable this check - pass False (do it only if you are sure in your data consistency).</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class Compose(BaseCompose):\n    \"\"\"Compose transforms and handle all transformations regarding bounding boxes\n\n    Args:\n        transforms (list): list of transformations to compose.\n        bbox_params (BboxParams): Parameters for bounding boxes transforms\n        keypoint_params (KeypointParams): Parameters for keypoints transforms\n        additional_targets (dict): Dict with keys - new target name, values - old target name. ex: {'image2': 'image'}\n        p (float): probability of applying all list of transforms. Default: 1.0.\n        is_check_shapes (bool): If True shapes consistency of images/mask/masks would be checked on each call. If you\n            would like to disable this check - pass False (do it only if you are sure in your data consistency).\n\n    \"\"\"\n\n    def __init__(\n        self,\n        transforms: TransformsSeqType,\n        bbox_params: Optional[Union[Dict[str, Any], \"BboxParams\"]] = None,\n        keypoint_params: Optional[Union[Dict[str, Any], \"KeypointParams\"]] = None,\n        additional_targets: Optional[Dict[str, str]] = None,\n        p: float = 1.0,\n        is_check_shapes: bool = True,\n    ):\n        super().__init__(transforms, p)\n\n        self.processors: Dict[str, Union[BboxProcessor, KeypointsProcessor]] = {}\n        if bbox_params:\n            if isinstance(bbox_params, dict):\n                b_params = BboxParams(**bbox_params)\n            elif isinstance(bbox_params, BboxParams):\n                b_params = bbox_params\n            else:\n                msg = \"unknown format of bbox_params, please use `dict` or `BboxParams`\"\n                raise ValueError(msg)\n            self.processors[\"bboxes\"] = BboxProcessor(b_params, additional_targets)\n\n        if keypoint_params:\n            if isinstance(keypoint_params, dict):\n                k_params = KeypointParams(**keypoint_params)\n            elif isinstance(keypoint_params, KeypointParams):\n                k_params = keypoint_params\n            else:\n                msg = \"unknown format of keypoint_params, please use `dict` or `KeypointParams`\"\n                raise ValueError(msg)\n            self.processors[\"keypoints\"] = KeypointsProcessor(k_params, additional_targets)\n\n        if additional_targets is None:\n            additional_targets = {}\n\n        self.additional_targets = additional_targets\n\n        for proc in self.processors.values():\n            proc.ensure_transforms_valid(self.transforms)\n\n        self.add_targets(additional_targets)\n\n        self.is_check_args = True\n        self._disable_check_args_for_transforms(self.transforms)\n\n        self.is_check_shapes = is_check_shapes\n\n    @staticmethod\n    def _disable_check_args_for_transforms(transforms: TransformsSeqType) -&gt; None:\n        for transform in transforms:\n            if isinstance(transform, BaseCompose):\n                Compose._disable_check_args_for_transforms(transform.transforms)\n            if isinstance(transform, Compose):\n                transform.disable_check_args_private()\n\n    def disable_check_args_private(self) -&gt; None:\n        self.is_check_args = False\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if args:\n            msg = \"You have to pass data to augmentations as named arguments, for example: aug(image=image)\"\n            raise KeyError(msg)\n        if self.is_check_args:\n            self._check_args(**data)\n\n        if not isinstance(force_apply, (bool, int)):\n            msg = \"force_apply must have bool or int type\"\n            raise TypeError(msg)\n\n        need_to_run = force_apply or random.random() &lt; self.p\n\n        for p in self.processors.values():\n            p.ensure_data_valid(data)\n        transforms = self.transforms if need_to_run else get_always_apply(self.transforms)\n\n        check_each_transform = any(\n            getattr(item.params, \"check_each_transform\", False) for item in self.processors.values()\n        )\n\n        for p in self.processors.values():\n            p.preprocess(data)\n\n        for t in transforms:\n            data = t(**data)\n\n            if check_each_transform:\n                data = self._check_data_post_transform(data)\n        data = Compose._make_targets_contiguous(data)  # ensure output targets are contiguous\n\n        for p in self.processors.values():\n            p.postprocess(data)\n\n        return data\n\n    def _check_data_post_transform(self, data: Any) -&gt; Dict[str, Any]:\n        rows, cols = get_shape(data[\"image\"])\n\n        for p in self.processors.values():\n            if not getattr(p.params, \"check_each_transform\", False):\n                continue\n\n            for data_name in p.data_fields:\n                data[data_name] = p.filter(data[data_name], rows, cols)\n        return data\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        dictionary = super().to_dict_private()\n        bbox_processor = self.processors.get(\"bboxes\")\n        keypoints_processor = self.processors.get(\"keypoints\")\n        dictionary.update(\n            {\n                \"bbox_params\": bbox_processor.params.to_dict_private() if bbox_processor else None,\n                \"keypoint_params\": (keypoints_processor.params.to_dict_private() if keypoints_processor else None),\n                \"additional_targets\": self.additional_targets,\n                \"is_check_shapes\": self.is_check_shapes,\n            }\n        )\n        return dictionary\n\n    def get_dict_with_id(self) -&gt; Dict[str, Any]:\n        dictionary = super().get_dict_with_id()\n        bbox_processor = self.processors.get(\"bboxes\")\n        keypoints_processor = self.processors.get(\"keypoints\")\n        dictionary.update(\n            {\n                \"bbox_params\": bbox_processor.params.to_dict_private() if bbox_processor else None,\n                \"keypoint_params\": (keypoints_processor.params.to_dict_private() if keypoints_processor else None),\n                \"additional_targets\": self.additional_targets,\n                \"params\": None,\n                \"is_check_shapes\": self.is_check_shapes,\n            }\n        )\n        return dictionary\n\n    def _check_args(self, **kwargs: Any) -&gt; None:\n        checked_single = [\"image\", \"mask\"]\n        checked_multi = [\"masks\"]\n        check_bbox_param = [\"bboxes\"]\n        shapes = []\n        for data_name, data in kwargs.items():\n            internal_data_name = self.additional_targets.get(data_name, data_name)\n            if internal_data_name in checked_single:\n                if not isinstance(data, np.ndarray):\n                    raise TypeError(f\"{data_name} must be numpy array type\")\n                shapes.append(data.shape[:2])\n            if internal_data_name in checked_multi and data is not None and len(data):\n                if not isinstance(data[0], np.ndarray):\n                    raise TypeError(f\"{data_name} must be list of numpy arrays\")\n                shapes.append(data[0].shape[:2])\n            if internal_data_name in check_bbox_param and self.processors.get(\"bboxes\") is None:\n                msg = \"bbox_params must be specified for bbox transformations\"\n                raise ValueError(msg)\n\n        if self.is_check_shapes and shapes and shapes.count(shapes[0]) != len(shapes):\n            msg = (\n                \"Height and Width of image, mask or masks should be equal. You can disable shapes check \"\n                \"by setting a parameter is_check_shapes=False of Compose class (do it only if you are sure \"\n                \"about your data consistency).\"\n            )\n            raise ValueError(msg)\n\n    @staticmethod\n    def _make_targets_contiguous(data: Any) -&gt; Dict[str, Any]:\n        result = {}\n        for key, value in data.items():\n            if isinstance(value, np.ndarray):\n                result[key] = np.ascontiguousarray(value)\n            else:\n                result[key] = value\n\n        return result\n</code></pre>"},{"location":"api_reference/core/composition/#albumentations.core.composition.OneOf","title":"<code>class  OneOf</code> <code>       (transforms, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Select one of transforms to apply. Selected transform will be called with <code>force_apply=True</code>. Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.</p> <p>Parameters:</p> Name Type Description <code>transforms</code> <code>list</code> <p>list of transformations to compose.</p> <code>p</code> <code>float</code> <p>probability of applying selected transform. Default: 0.5.</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class OneOf(BaseCompose):\n    \"\"\"Select one of transforms to apply. Selected transform will be called with `force_apply=True`.\n    Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.\n\n    Args:\n        transforms (list): list of transformations to compose.\n        p (float): probability of applying selected transform. Default: 0.5.\n\n    \"\"\"\n\n    def __init__(self, transforms: TransformsSeqType, p: float = 0.5):\n        super().__init__(transforms, p)\n        transforms_ps = [t.p for t in self.transforms]\n        s = sum(transforms_ps)\n        self.transforms_ps = [t / s for t in transforms_ps]\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if self.replay_mode:\n            for t in self.transforms:\n                data = t(**data)\n            return data\n\n        if self.transforms_ps and (force_apply or random.random() &lt; self.p):\n            idx: int = random_utils.choice(len(self.transforms), p=self.transforms_ps)\n            t = self.transforms[idx]\n            data = t(force_apply=True, **data)\n        return data\n</code></pre>"},{"location":"api_reference/core/composition/#albumentations.core.composition.OneOrOther","title":"<code>class  OneOrOther</code> <code>       (first=None, second=None, transforms=None, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Select one or another transform to apply. Selected transform will be called with <code>force_apply=True</code>.</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class OneOrOther(BaseCompose):\n    \"\"\"Select one or another transform to apply. Selected transform will be called with `force_apply=True`.\"\"\"\n\n    def __init__(\n        self,\n        first: Optional[TransformType] = None,\n        second: Optional[TransformType] = None,\n        transforms: Optional[TransformsSeqType] = None,\n        p: float = 0.5,\n    ):\n        if transforms is None:\n            if first is None or second is None:\n                msg = \"You must set both first and second or set transforms argument.\"\n                raise ValueError(msg)\n            transforms = [first, second]\n        super().__init__(transforms, p)\n        if len(self.transforms) != TWO:\n            warnings.warn(\"Length of transforms is not equal to 2.\")\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if self.replay_mode:\n            for t in self.transforms:\n                data = t(**data)\n            return data\n\n        if random.random() &lt; self.p:\n            return self.transforms[0](force_apply=True, **data)\n\n        return self.transforms[-1](force_apply=True, **data)\n</code></pre>"},{"location":"api_reference/core/composition/#albumentations.core.composition.PerChannel","title":"<code>class  PerChannel</code> <code>       (transforms, channels=None, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Apply transformations per-channel</p> <p>Parameters:</p> Name Type Description <code>transforms</code> <code>list</code> <p>list of transformations to compose.</p> <code>channels</code> <code>sequence</code> <p>channels to apply the transform to. Pass None to apply to all.</p> <code>Default</code> <p>None (apply to all)</p> <code>p</code> <code>float</code> <p>probability of applying the transform. Default: 0.5.</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class PerChannel(BaseCompose):\n    \"\"\"Apply transformations per-channel\n\n    Args:\n        transforms (list): list of transformations to compose.\n        channels (sequence): channels to apply the transform to. Pass None to apply to all.\n        Default: None (apply to all)\n        p (float): probability of applying the transform. Default: 0.5.\n\n    \"\"\"\n\n    def __init__(self, transforms: TransformsSeqType, channels: Optional[Sequence[int]] = None, p: float = 0.5):\n        super().__init__(transforms, p)\n        self.channels = channels\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if force_apply or random.random() &lt; self.p:\n            image = data[\"image\"]\n\n            # Expand mono images to have a single channel\n            if len(image.shape) == TWO:\n                image = np.expand_dims(image, -1)\n\n            if self.channels is None:\n                self.channels = range(image.shape[2])\n\n            for c in self.channels:\n                for t in self.transforms:\n                    image[:, :, c] = t(image=image[:, :, c])[\"image\"]\n\n            data[\"image\"] = image\n\n        return data\n</code></pre>"},{"location":"api_reference/core/composition/#albumentations.core.composition.Sequential","title":"<code>class  Sequential</code> <code>       (transforms, p=0.5)                   </code>  [view source on GitHub]","text":"<p>Sequentially applies all transforms to targets.</p> <p>Note</p> <p>This transform is not intended to be a replacement for <code>Compose</code>. Instead, it should be used inside <code>Compose</code> the same way <code>OneOf</code> or <code>OneOrOther</code> are used. For instance, you can combine <code>OneOf</code> with <code>Sequential</code> to create an augmentation pipeline that contains multiple sequences of augmentations and applies one randomly chose sequence to input data (see the <code>Example</code> section for an example definition of such pipeline).</p> <p>Examples:</p> Python<pre><code>&gt;&gt;&gt; import albumentations as A\n&gt;&gt;&gt; transform = A.Compose([\n&gt;&gt;&gt;    A.OneOf([\n&gt;&gt;&gt;        A.Sequential([\n&gt;&gt;&gt;            A.HorizontalFlip(p=0.5),\n&gt;&gt;&gt;            A.ShiftScaleRotate(p=0.5),\n&gt;&gt;&gt;        ]),\n&gt;&gt;&gt;        A.Sequential([\n&gt;&gt;&gt;            A.VerticalFlip(p=0.5),\n&gt;&gt;&gt;            A.RandomBrightnessContrast(p=0.5),\n&gt;&gt;&gt;        ]),\n&gt;&gt;&gt;    ], p=1)\n&gt;&gt;&gt; ])\n</code></pre> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class Sequential(BaseCompose):\n    \"\"\"Sequentially applies all transforms to targets.\n\n    Note:\n        This transform is not intended to be a replacement for `Compose`. Instead, it should be used inside `Compose`\n        the same way `OneOf` or `OneOrOther` are used. For instance, you can combine `OneOf` with `Sequential` to\n        create an augmentation pipeline that contains multiple sequences of augmentations and applies one randomly\n        chose sequence to input data (see the `Example` section for an example definition of such pipeline).\n\n    Example:\n        &gt;&gt;&gt; import albumentations as A\n        &gt;&gt;&gt; transform = A.Compose([\n        &gt;&gt;&gt;    A.OneOf([\n        &gt;&gt;&gt;        A.Sequential([\n        &gt;&gt;&gt;            A.HorizontalFlip(p=0.5),\n        &gt;&gt;&gt;            A.ShiftScaleRotate(p=0.5),\n        &gt;&gt;&gt;        ]),\n        &gt;&gt;&gt;        A.Sequential([\n        &gt;&gt;&gt;            A.VerticalFlip(p=0.5),\n        &gt;&gt;&gt;            A.RandomBrightnessContrast(p=0.5),\n        &gt;&gt;&gt;        ]),\n        &gt;&gt;&gt;    ], p=1)\n        &gt;&gt;&gt; ])\n\n    \"\"\"\n\n    def __init__(self, transforms: TransformsSeqType, p: float = 0.5):\n        super().__init__(transforms, p)\n\n    def __call__(self, *args: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        for t in self.transforms:\n            data = t(**data)\n        return data\n</code></pre>"},{"location":"api_reference/core/composition/#albumentations.core.composition.SomeOf","title":"<code>class  SomeOf</code> <code>       (transforms, n, replace=True, p=1)                   </code>  [view source on GitHub]","text":"<p>Select N transforms to apply. Selected transforms will be called with <code>force_apply=True</code>. Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.</p> <p>Parameters:</p> Name Type Description <code>transforms</code> <code>list</code> <p>list of transformations to compose.</p> <code>n</code> <code>int</code> <p>number of transforms to apply.</p> <code>replace</code> <code>bool</code> <p>Whether the sampled transforms are with or without replacement. Default: True.</p> <code>p</code> <code>float</code> <p>probability of applying selected transform. Default: 1.</p> Source code in <code>albumentations/core/composition.py</code> Python<pre><code>class SomeOf(BaseCompose):\n    \"\"\"Select N transforms to apply. Selected transforms will be called with `force_apply=True`.\n    Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.\n\n    Args:\n        transforms (list): list of transformations to compose.\n        n (int): number of transforms to apply.\n        replace (bool): Whether the sampled transforms are with or without replacement. Default: True.\n        p (float): probability of applying selected transform. Default: 1.\n\n    \"\"\"\n\n    def __init__(self, transforms: TransformsSeqType, n: int, replace: bool = True, p: float = 1):\n        super().__init__(transforms, p)\n        self.n = n\n        self.replace = replace\n        transforms_ps = [t.p for t in self.transforms]\n        s = sum(transforms_ps)\n        self.transforms_ps = [t / s for t in transforms_ps]\n\n    def __call__(self, *arg: Any, force_apply: bool = False, **data: Any) -&gt; Dict[str, Any]:\n        if self.replay_mode:\n            for t in self.transforms:\n                data = t(**data)\n            return data\n\n        if self.transforms_ps and (force_apply or random.random() &lt; self.p):\n            idx = random_utils.choice(len(self.transforms), size=self.n, replace=self.replace, p=self.transforms_ps)\n            for i in idx:\n                t = self.transforms[i]\n                data = t(force_apply=True, **data)\n        return data\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        dictionary = super().to_dict_private()\n        dictionary.update({\"n\": self.n, \"replace\": self.replace})\n        return dictionary\n</code></pre>"},{"location":"api_reference/core/keypoints_utils/","title":"Helper functions for working with keypoints (augmentations.core.keypoints_utils)","text":""},{"location":"api_reference/core/keypoints_utils/#albumentations.core.keypoints_utils.KeypointParams","title":"<code>class  KeypointParams</code> <code>       (format, label_fields=None, remove_invisible=True, angle_in_degrees=True, check_each_transform=True)                   </code>  [view source on GitHub]","text":"<p>Parameters of keypoints</p> <p>Parameters:</p> Name Type Description <code>format</code> <code>str</code> <p>format of keypoints. Should be 'xy', 'yx', 'xya', 'xys', 'xyas', 'xysa'.</p> <p>x - X coordinate,</p> <p>y - Y coordinate</p> <p>s - Keypoint scale</p> <p>a - Keypoint orientation in radians or degrees (depending on KeypointParams.angle_in_degrees)</p> <code>label_fields</code> <code>list</code> <p>list of fields that are joined with keypoints, e.g labels. Should be same type as keypoints.</p> <code>remove_invisible</code> <code>bool</code> <p>to remove invisible points after transform or not</p> <code>angle_in_degrees</code> <code>bool</code> <p>angle in degrees or radians in 'xya', 'xyas', 'xysa' keypoints</p> <code>check_each_transform</code> <code>bool</code> <p>if <code>True</code>, then keypoints will be checked after each dual transform. Default: <code>True</code></p> Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>class KeypointParams(Params):\n    \"\"\"Parameters of keypoints\n\n    Args:\n        format (str): format of keypoints. Should be 'xy', 'yx', 'xya', 'xys', 'xyas', 'xysa'.\n\n            x - X coordinate,\n\n            y - Y coordinate\n\n            s - Keypoint scale\n\n            a - Keypoint orientation in radians or degrees (depending on KeypointParams.angle_in_degrees)\n        label_fields (list): list of fields that are joined with keypoints, e.g labels.\n            Should be same type as keypoints.\n        remove_invisible (bool): to remove invisible points after transform or not\n        angle_in_degrees (bool): angle in degrees or radians in 'xya', 'xyas', 'xysa' keypoints\n        check_each_transform (bool): if `True`, then keypoints will be checked after each dual transform.\n            Default: `True`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        format: str,\n        label_fields: Optional[Sequence[str]] = None,\n        remove_invisible: bool = True,\n        angle_in_degrees: bool = True,\n        check_each_transform: bool = True,\n    ):\n        super().__init__(format, label_fields)\n        self.remove_invisible = remove_invisible\n        self.angle_in_degrees = angle_in_degrees\n        self.check_each_transform = check_each_transform\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        data = super().to_dict_private()\n        data.update(\n            {\n                \"remove_invisible\": self.remove_invisible,\n                \"angle_in_degrees\": self.angle_in_degrees,\n                \"check_each_transform\": self.check_each_transform,\n            }\n        )\n        return data\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return True\n\n    @classmethod\n    def get_class_fullname(cls) -&gt; str:\n        return \"KeypointParams\"\n</code></pre>"},{"location":"api_reference/core/keypoints_utils/#albumentations.core.keypoints_utils.KeypointsProcessor","title":"<code>class  KeypointsProcessor</code> <code>       (params, additional_targets=None)                   </code>  [view source on GitHub]","text":"Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>class KeypointsProcessor(DataProcessor):\n    def __init__(self, params: KeypointParams, additional_targets: Optional[Dict[str, str]] = None):\n        super().__init__(params, additional_targets)\n\n    @property\n    def default_data_name(self) -&gt; str:\n        return \"keypoints\"\n\n    def ensure_data_valid(self, data: Dict[str, Any]) -&gt; None:\n        if self.params.label_fields and not all(i in data for i in self.params.label_fields):\n            msg = \"Your 'label_fields' are not valid - them must have same names as params in \" \"'keypoint_params' dict\"\n            raise ValueError(msg)\n\n    def filter(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; Sequence[KeypointType]:\n        \"\"\"The function filters a sequence of data based on the number of rows and columns, and returns a\n        sequence of keypoints.\n\n        :param data: The `data` parameter is a sequence of sequences. Each inner sequence represents a\n        set of keypoints\n        :type data: Sequence[Sequence]\n        :param rows: The `rows` parameter represents the number of rows in the data matrix. It specifies\n        the number of rows that will be used for filtering the keypoints\n        :type rows: int\n        :param cols: The parameter \"cols\" represents the number of columns in the grid that the\n        keypoints will be filtered on\n        :type cols: int\n        :return: a sequence of KeypointType objects.\n        \"\"\"\n        self.params: KeypointParams\n        return filter_keypoints(data, rows, cols, remove_invisible=self.params.remove_invisible)\n\n    def check(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; None:\n        check_keypoints(data, rows, cols)\n\n    def convert_from_albumentations(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; List[KeypointType]:\n        params = self.params\n        return convert_keypoints_from_albumentations(\n            data,\n            params.format,\n            rows,\n            cols,\n            check_validity=params.remove_invisible,\n            angle_in_degrees=params.angle_in_degrees,\n        )\n\n    def convert_to_albumentations(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; List[KeypointType]:\n        params = self.params\n        return convert_keypoints_to_albumentations(\n            data,\n            params.format,\n            rows,\n            cols,\n            check_validity=params.remove_invisible,\n            angle_in_degrees=params.angle_in_degrees,\n        )\n</code></pre>"},{"location":"api_reference/core/keypoints_utils/#albumentations.core.keypoints_utils.KeypointsProcessor.filter","title":"<code>filter (self, data, rows, cols)</code>","text":"<p>The function filters a sequence of data based on the number of rows and columns, and returns a sequence of keypoints.</p> <p>:param data: The <code>data</code> parameter is a sequence of sequences. Each inner sequence represents a set of keypoints :type data: Sequence[Sequence] :param rows: The <code>rows</code> parameter represents the number of rows in the data matrix. It specifies the number of rows that will be used for filtering the keypoints :type rows: int :param cols: The parameter \"cols\" represents the number of columns in the grid that the keypoints will be filtered on :type cols: int :return: a sequence of KeypointType objects.</p> Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>def filter(self, data: Sequence[KeypointType], rows: int, cols: int) -&gt; Sequence[KeypointType]:\n    \"\"\"The function filters a sequence of data based on the number of rows and columns, and returns a\n    sequence of keypoints.\n\n    :param data: The `data` parameter is a sequence of sequences. Each inner sequence represents a\n    set of keypoints\n    :type data: Sequence[Sequence]\n    :param rows: The `rows` parameter represents the number of rows in the data matrix. It specifies\n    the number of rows that will be used for filtering the keypoints\n    :type rows: int\n    :param cols: The parameter \"cols\" represents the number of columns in the grid that the\n    keypoints will be filtered on\n    :type cols: int\n    :return: a sequence of KeypointType objects.\n    \"\"\"\n    self.params: KeypointParams\n    return filter_keypoints(data, rows, cols, remove_invisible=self.params.remove_invisible)\n</code></pre>"},{"location":"api_reference/core/keypoints_utils/#albumentations.core.keypoints_utils.check_keypoint","title":"<code>def check_keypoint    (kp, rows, cols)    </code> [view source on GitHub]","text":"<p>Check if keypoint coordinates are less than image shapes</p> Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>def check_keypoint(kp: KeypointType, rows: int, cols: int) -&gt; None:\n    \"\"\"Check if keypoint coordinates are less than image shapes\"\"\"\n    for name, value, size in zip([\"x\", \"y\"], kp[:2], [cols, rows]):\n        if not 0 &lt;= value &lt; size:\n            raise ValueError(f\"Expected {name} for keypoint {kp} \" f\"to be in the range [0.0, {size}], got {value}.\")\n\n    angle = kp[2]\n    if not (0 &lt;= angle &lt; 2 * math.pi):\n        raise ValueError(f\"Keypoint angle must be in range [0, 2 * PI). Got: {angle}\")\n</code></pre>"},{"location":"api_reference/core/keypoints_utils/#albumentations.core.keypoints_utils.check_keypoints","title":"<code>def check_keypoints    (keypoints, rows, cols)    </code> [view source on GitHub]","text":"<p>Check if keypoints boundaries are less than image shapes</p> Source code in <code>albumentations/core/keypoints_utils.py</code> Python<pre><code>def check_keypoints(keypoints: Sequence[KeypointType], rows: int, cols: int) -&gt; None:\n    \"\"\"Check if keypoints boundaries are less than image shapes\"\"\"\n    for kp in keypoints:\n        check_keypoint(kp, rows, cols)\n</code></pre>"},{"location":"api_reference/core/serialization/","title":"Serialization API (core.serialization)","text":""},{"location":"api_reference/core/serialization/#albumentations.core.serialization.Serializable","title":"<code>class  Serializable</code> <code> </code>  [view source on GitHub]","text":"Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>class Serializable(metaclass=SerializableMeta):\n    @classmethod\n    @abstractmethod\n    def is_serializable(cls) -&gt; bool:\n        raise NotImplementedError\n\n    @classmethod\n    @abstractmethod\n    def get_class_fullname(cls) -&gt; str:\n        raise NotImplementedError\n\n    @abstractmethod\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        raise NotImplementedError\n\n    def to_dict(self, on_not_implemented_error: str = \"raise\") -&gt; Dict[str, Any]:\n        \"\"\"Take a transform pipeline and convert it to a serializable representation that uses only standard\n        python data types: dictionaries, lists, strings, integers, and floats.\n\n        Args:\n            self: A transform that should be serialized. If the transform doesn't implement the `to_dict`\n                method and `on_not_implemented_error` equals to 'raise' then `NotImplementedError` is raised.\n                If `on_not_implemented_error` equals to 'warn' then `NotImplementedError` will be ignored\n                but no transform parameters will be serialized.\n            on_not_implemented_error (str): `raise` or `warn`.\n\n        \"\"\"\n        if on_not_implemented_error not in {\"raise\", \"warn\"}:\n            msg = f\"Unknown on_not_implemented_error value: {on_not_implemented_error}. Supported values are: 'raise' \"\n            \"and 'warn'\"\n            raise ValueError(msg)\n        try:\n            transform_dict = self.to_dict_private()\n        except NotImplementedError:\n            if on_not_implemented_error == \"raise\":\n                raise\n\n            transform_dict = {}\n            warnings.warn(\n                f\"Got NotImplementedError while trying to serialize {self}. Object arguments are not preserved. \"\n                f\"Implement either '{self.__class__.__name__}.get_transform_init_args_names' \"\n                f\"or '{self.__class__.__name__}.get_transform_init_args' \"\n                \"method to make the transform serializable\"\n            )\n        return {\"__version__\": __version__, \"transform\": transform_dict}\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.Serializable.to_dict","title":"<code>to_dict (self, on_not_implemented_error='raise')</code>","text":"<p>Take a transform pipeline and convert it to a serializable representation that uses only standard python data types: dictionaries, lists, strings, integers, and floats.</p> <p>Parameters:</p> Name Type Description <code>self</code> <p>A transform that should be serialized. If the transform doesn't implement the <code>to_dict</code> method and <code>on_not_implemented_error</code> equals to 'raise' then <code>NotImplementedError</code> is raised. If <code>on_not_implemented_error</code> equals to 'warn' then <code>NotImplementedError</code> will be ignored but no transform parameters will be serialized.</p> <code>on_not_implemented_error</code> <code>str</code> <p><code>raise</code> or <code>warn</code>.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def to_dict(self, on_not_implemented_error: str = \"raise\") -&gt; Dict[str, Any]:\n    \"\"\"Take a transform pipeline and convert it to a serializable representation that uses only standard\n    python data types: dictionaries, lists, strings, integers, and floats.\n\n    Args:\n        self: A transform that should be serialized. If the transform doesn't implement the `to_dict`\n            method and `on_not_implemented_error` equals to 'raise' then `NotImplementedError` is raised.\n            If `on_not_implemented_error` equals to 'warn' then `NotImplementedError` will be ignored\n            but no transform parameters will be serialized.\n        on_not_implemented_error (str): `raise` or `warn`.\n\n    \"\"\"\n    if on_not_implemented_error not in {\"raise\", \"warn\"}:\n        msg = f\"Unknown on_not_implemented_error value: {on_not_implemented_error}. Supported values are: 'raise' \"\n        \"and 'warn'\"\n        raise ValueError(msg)\n    try:\n        transform_dict = self.to_dict_private()\n    except NotImplementedError:\n        if on_not_implemented_error == \"raise\":\n            raise\n\n        transform_dict = {}\n        warnings.warn(\n            f\"Got NotImplementedError while trying to serialize {self}. Object arguments are not preserved. \"\n            f\"Implement either '{self.__class__.__name__}.get_transform_init_args_names' \"\n            f\"or '{self.__class__.__name__}.get_transform_init_args' \"\n            \"method to make the transform serializable\"\n        )\n    return {\"__version__\": __version__, \"transform\": transform_dict}\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.SerializableMeta","title":"<code>class  SerializableMeta</code> <code> </code>  [view source on GitHub]","text":"<p>A metaclass that is used to register classes in <code>SERIALIZABLE_REGISTRY</code> or <code>NON_SERIALIZABLE_REGISTRY</code> so they can be found later while deserializing transformation pipeline using classes full names.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>class SerializableMeta(ABCMeta):\n    \"\"\"A metaclass that is used to register classes in `SERIALIZABLE_REGISTRY` or `NON_SERIALIZABLE_REGISTRY`\n    so they can be found later while deserializing transformation pipeline using classes full names.\n    \"\"\"\n\n    def __new__(cls, name: str, bases: Tuple[type, ...], *args: Any, **kwargs: Any) -&gt; \"SerializableMeta\":\n        cls_obj = super().__new__(cls, name, bases, *args, **kwargs)\n        if name != \"Serializable\" and ABC not in bases:\n            if cls_obj.is_serializable():\n                SERIALIZABLE_REGISTRY[cls_obj.get_class_fullname()] = cls_obj\n            else:\n                NON_SERIALIZABLE_REGISTRY[cls_obj.get_class_fullname()] = cls_obj\n        return cls_obj\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return False\n\n    @classmethod\n    def get_class_fullname(cls) -&gt; str:\n        return get_shortest_class_fullname(cls)\n\n    @classmethod\n    def _to_dict(cls) -&gt; Dict[str, Any]:\n        return {}\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.SerializableMeta.__new__","title":"<code>__new__ (cls, name, bases, *args, **kwargs)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def __new__(cls, name: str, bases: Tuple[type, ...], *args: Any, **kwargs: Any) -&gt; \"SerializableMeta\":\n    cls_obj = super().__new__(cls, name, bases, *args, **kwargs)\n    if name != \"Serializable\" and ABC not in bases:\n        if cls_obj.is_serializable():\n            SERIALIZABLE_REGISTRY[cls_obj.get_class_fullname()] = cls_obj\n        else:\n            NON_SERIALIZABLE_REGISTRY[cls_obj.get_class_fullname()] = cls_obj\n    return cls_obj\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.from_dict","title":"<code>def from_dict    (transform_dict, nonserializable=None)    </code> [view source on GitHub]","text":"<p>transform_dict: A dictionary with serialized transform pipeline. nonserializable (dict): A dictionary that contains non-serializable transforms.     This dictionary is required when you are restoring a pipeline that contains non-serializable transforms.     Keys in that dictionary should be named same as <code>name</code> arguments in respective transforms from     a serialized pipeline.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def from_dict(\n    transform_dict: Dict[str, Any], nonserializable: Optional[Dict[str, Any]] = None\n) -&gt; Optional[Serializable]:\n    \"\"\"Args:\n    transform_dict: A dictionary with serialized transform pipeline.\n    nonserializable (dict): A dictionary that contains non-serializable transforms.\n        This dictionary is required when you are restoring a pipeline that contains non-serializable transforms.\n        Keys in that dictionary should be named same as `name` arguments in respective transforms from\n        a serialized pipeline.\n\n    \"\"\"\n    register_additional_transforms()\n    transform = transform_dict[\"transform\"]\n    lmbd = instantiate_nonserializable(transform, nonserializable)\n    if lmbd:\n        return lmbd\n    name = transform[\"__class_fullname__\"]\n    args = {k: v for k, v in transform.items() if k != \"__class_fullname__\"}\n    cls = SERIALIZABLE_REGISTRY[shorten_class_name(name)]\n    if \"transforms\" in args:\n        args[\"transforms\"] = [from_dict({\"transform\": t}, nonserializable=nonserializable) for t in args[\"transforms\"]]\n    return cls(**args)\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.get_shortest_class_fullname","title":"<code>def get_shortest_class_fullname    (cls)    </code> [view source on GitHub]","text":"<p>The function <code>get_shortest_class_fullname</code> takes a class object as input and returns its shortened full name.</p> <p>:param cls: The parameter <code>cls</code> is of type <code>Type[BasicCompose]</code>, which means it expects a class that is a subclass of <code>BasicCompose</code> :type cls: Type[BasicCompose] :return: a string, which is the shortened version of the full class name.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def get_shortest_class_fullname(cls: Type[Any]) -&gt; str:\n    \"\"\"The function `get_shortest_class_fullname` takes a class object as input and returns its shortened\n    full name.\n\n    :param cls: The parameter `cls` is of type `Type[BasicCompose]`, which means it expects a class that\n    is a subclass of `BasicCompose`\n    :type cls: Type[BasicCompose]\n    :return: a string, which is the shortened version of the full class name.\n    \"\"\"\n    class_fullname = f\"{cls.__module__}.{cls.__name__}\"\n    return shorten_class_name(class_fullname)\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.load","title":"<code>def load    (filepath_or_buffer, data_format='json', nonserializable=None)    </code> [view source on GitHub]","text":"<p>Load a serialized pipeline from a file or file-like object and construct a transform pipeline.</p> <p>Parameters:</p> Name Type Description <code>filepath_or_buffer</code> <code>Union[str, Path, TextIO]</code> <p>The file path or file-like object to read the serialized data from. If a string is provided, it is interpreted as a path to a file. If a file-like object is provided, the serialized data will be read from it directly.</p> <code>data_format</code> <code>str</code> <p>The format of the serialized data. Valid options are 'json' and 'yaml'. Defaults to 'json'.</p> <code>nonserializable</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary that contains non-serializable transforms. This dictionary is required when restoring a pipeline that contains non-serializable transforms. Keys in the dictionary should be named the same as the <code>name</code> arguments in respective transforms from the serialized pipeline. Defaults to None.</p> <p>Returns:</p> Type Description <code>object</code> <p>The deserialized transform pipeline.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If <code>data_format</code> is 'yaml' but PyYAML is not installed.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def load(\n    filepath_or_buffer: Union[str, Path, TextIO],\n    data_format: str = \"json\",\n    nonserializable: Optional[Dict[str, Any]] = None,\n) -&gt; object:\n    \"\"\"Load a serialized pipeline from a file or file-like object and construct a transform pipeline.\n\n    Args:\n        filepath_or_buffer (Union[str, Path, TextIO]): The file path or file-like object to read the serialized\n            data from.\n            If a string is provided, it is interpreted as a path to a file. If a file-like object is provided,\n            the serialized data will be read from it directly.\n        data_format (str): The format of the serialized data. Valid options are 'json' and 'yaml'.\n            Defaults to 'json'.\n        nonserializable (Optional[Dict[str, Any]]): A dictionary that contains non-serializable transforms.\n            This dictionary is required when restoring a pipeline that contains non-serializable transforms.\n            Keys in the dictionary should be named the same as the `name` arguments in respective transforms\n            from the serialized pipeline. Defaults to None.\n\n    Returns:\n        object: The deserialized transform pipeline.\n\n    Raises:\n        ValueError: If `data_format` is 'yaml' but PyYAML is not installed.\n\n    \"\"\"\n    check_data_format(data_format)\n\n    if isinstance(filepath_or_buffer, (str, Path)):  # Assume it's a filepath\n        with open(filepath_or_buffer) as f:\n            if data_format == \"json\":\n                transform_dict = json.load(f)\n            else:\n                if not yaml_available:\n                    msg = \"You need to install PyYAML to load a pipeline in yaml format\"\n                    raise ValueError(msg)\n                transform_dict = yaml.safe_load(f)\n    elif data_format == \"json\":\n        transform_dict = json.load(filepath_or_buffer)\n    else:\n        if not yaml_available:\n            msg = \"You need to install PyYAML to load a pipeline in yaml format\"\n            raise ValueError(msg)\n        transform_dict = yaml.safe_load(filepath_or_buffer)\n\n    return from_dict(transform_dict, nonserializable=nonserializable)\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.register_additional_transforms","title":"<code>def register_additional_transforms    ()    </code> [view source on GitHub]","text":"<p>Register transforms that are not imported directly into the <code>albumentations</code> module by checking the availability of optional dependencies.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def register_additional_transforms() -&gt; None:\n    \"\"\"Register transforms that are not imported directly into the `albumentations` module by checking\n    the availability of optional dependencies.\n    \"\"\"\n    if importlib.util.find_spec(\"torch\") is not None:\n        try:\n            # Import `albumentations.pytorch` only if `torch` is installed.\n            import albumentations.pytorch\n\n            # Use a dummy operation to acknowledge the use of the imported module and avoid linting errors.\n            _ = albumentations.pytorch.ToTensorV2\n        except ImportError:\n            pass\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.save","title":"<code>def save    (transform, filepath_or_buffer, data_format='json', on_not_implemented_error='raise')    </code> [view source on GitHub]","text":"<p>Serialize a transform pipeline and save it to either a file specified by a path or a file-like object in either JSON or YAML format.</p> <p>Parameters:</p> Name Type Description <code>transform</code> <code>Serializable</code> <p>The transform pipeline to serialize.</p> <code>filepath_or_buffer</code> <code>Union[str, Path, TextIO]</code> <p>The file path or file-like object to write the serialized data to. If a string is provided, it is interpreted as a path to a file. If a file-like object is provided, the serialized data will be written to it directly.</p> <code>data_format</code> <code>str</code> <p>The format to serialize the data in. Valid options are 'json' and 'yaml'. Defaults to 'json'.</p> <code>on_not_implemented_error</code> <code>str</code> <p>Determines the behavior if a transform does not implement the <code>to_dict</code> method. If set to 'raise', a <code>NotImplementedError</code> is raised. If set to 'warn', the exception is ignored, and no transform arguments are saved. Defaults to 'raise'.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If <code>data_format</code> is 'yaml' but PyYAML is not installed.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def save(\n    transform: \"Serializable\",\n    filepath_or_buffer: Union[str, Path, TextIO],\n    data_format: str = \"json\",\n    on_not_implemented_error: str = \"raise\",\n) -&gt; None:\n    \"\"\"Serialize a transform pipeline and save it to either a file specified by a path or a file-like object\n    in either JSON or YAML format.\n\n    Args:\n        transform (Serializable): The transform pipeline to serialize.\n        filepath_or_buffer (Union[str, Path, TextIO]): The file path or file-like object to write the serialized\n            data to.\n            If a string is provided, it is interpreted as a path to a file. If a file-like object is provided,\n            the serialized data will be written to it directly.\n        data_format (str): The format to serialize the data in. Valid options are 'json' and 'yaml'.\n            Defaults to 'json'.\n        on_not_implemented_error (str): Determines the behavior if a transform does not implement the `to_dict` method.\n            If set to 'raise', a `NotImplementedError` is raised. If set to 'warn', the exception is ignored, and\n            no transform arguments are saved. Defaults to 'raise'.\n\n    Raises:\n        ValueError: If `data_format` is 'yaml' but PyYAML is not installed.\n\n    \"\"\"\n    check_data_format(data_format)\n    transform_dict = transform.to_dict(on_not_implemented_error=on_not_implemented_error)\n    transform_dict = serialize_enum(transform_dict)\n\n    # Determine whether to write to a file or a file-like object\n    if isinstance(filepath_or_buffer, (str, Path)):  # It's a filepath\n        with open(filepath_or_buffer, \"w\") as f:\n            if data_format == \"yaml\":\n                if not yaml_available:\n                    msg = \"You need to install PyYAML to save a pipeline in YAML format\"\n                    raise ValueError(msg)\n                yaml.safe_dump(transform_dict, f, default_flow_style=False)\n            elif data_format == \"json\":\n                json.dump(transform_dict, f)\n    elif data_format == \"yaml\":\n        if not yaml_available:\n            msg = \"You need to install PyYAML to save a pipeline in YAML format\"\n            raise ValueError(msg)\n        yaml.safe_dump(transform_dict, filepath_or_buffer, default_flow_style=False)\n    elif data_format == \"json\":\n        json.dump(transform_dict, filepath_or_buffer)\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.serialize_enum","title":"<code>def serialize_enum    (obj)    </code> [view source on GitHub]","text":"<p>Recursively search for Enum objects and convert them to their value. Also handle any Mapping or Sequence types.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def serialize_enum(obj: Any) -&gt; Any:\n    \"\"\"Recursively search for Enum objects and convert them to their value.\n    Also handle any Mapping or Sequence types.\n    \"\"\"\n    if isinstance(obj, Mapping):\n        return {k: serialize_enum(v) for k, v in obj.items()}\n    if isinstance(obj, Sequence) and not isinstance(obj, str):  # exclude strings since they're also sequences\n        return [serialize_enum(v) for v in obj]\n    return obj.value if isinstance(obj, Enum) else obj\n</code></pre>"},{"location":"api_reference/core/serialization/#albumentations.core.serialization.to_dict","title":"<code>def to_dict    (transform, on_not_implemented_error='raise')    </code> [view source on GitHub]","text":"<p>Take a transform pipeline and convert it to a serializable representation that uses only standard python data types: dictionaries, lists, strings, integers, and floats.</p> <p>Parameters:</p> Name Type Description <code>transform</code> <code>Serializable</code> <p>A transform that should be serialized. If the transform doesn't implement the <code>to_dict</code> method and <code>on_not_implemented_error</code> equals to 'raise' then <code>NotImplementedError</code> is raised. If <code>on_not_implemented_error</code> equals to 'warn' then <code>NotImplementedError</code> will be ignored but no transform parameters will be serialized.</p> <code>on_not_implemented_error</code> <code>str</code> <p><code>raise</code> or <code>warn</code>.</p> Source code in <code>albumentations/core/serialization.py</code> Python<pre><code>def to_dict(transform: Serializable, on_not_implemented_error: str = \"raise\") -&gt; Dict[str, Any]:\n    \"\"\"Take a transform pipeline and convert it to a serializable representation that uses only standard\n    python data types: dictionaries, lists, strings, integers, and floats.\n\n    Args:\n        transform: A transform that should be serialized. If the transform doesn't implement the `to_dict`\n            method and `on_not_implemented_error` equals to 'raise' then `NotImplementedError` is raised.\n            If `on_not_implemented_error` equals to 'warn' then `NotImplementedError` will be ignored\n            but no transform parameters will be serialized.\n        on_not_implemented_error (str): `raise` or `warn`.\n\n    \"\"\"\n    return transform.to_dict(on_not_implemented_error)\n</code></pre>"},{"location":"api_reference/core/transforms_interface/","title":"Transforms Interface (core.transforms_interface)","text":""},{"location":"api_reference/core/transforms_interface/#albumentations.core.transforms_interface.BasicTransform","title":"<code>class  BasicTransform</code> <code>       (* args, ** kwargs)                   </code>  [view source on GitHub]","text":"Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>class BasicTransform(Serializable, metaclass=CombinedMeta):\n    call_backup = None\n    interpolation: Union[int, Interpolation]\n    fill_value: ColorType\n    mask_fill_value: Optional[ColorType]\n\n    class InitSchema(BaseTransformInitSchema):\n        pass\n\n    def __init__(self, always_apply: bool = False, p: float = 0.5):\n        self.p = p\n        self.always_apply = always_apply\n        self._additional_targets: Dict[str, str] = {}\n\n        # replay mode params\n        self.deterministic = False\n        self.save_key = \"replay\"\n        self.params: Dict[Any, Any] = {}\n        self.replay_mode = False\n        self.applied_in_replay = False\n\n    def __call__(self, *args: Any, force_apply: bool = False, **kwargs: Any) -&gt; Any:\n        if args:\n            msg = \"You have to pass data to augmentations as named arguments, for example: aug(image=image)\"\n            raise KeyError(msg)\n        if self.replay_mode:\n            if self.applied_in_replay:\n                return self.apply_with_params(self.params, **kwargs)\n\n            return kwargs\n\n        if force_apply or self.always_apply or (random.random() &lt; self.p):\n            params = self.get_params()\n\n            if self.targets_as_params:\n                if not all(key in kwargs for key in self.targets_as_params):\n                    msg = f\"{self.__class__.__name__} requires {self.targets_as_params}\"\n                    raise ValueError(msg)\n\n                targets_as_params = {k: kwargs[k] for k in self.targets_as_params}\n                params_dependent_on_targets = self.get_params_dependent_on_targets(targets_as_params)\n                params.update(params_dependent_on_targets)\n            if self.deterministic:\n                if self.targets_as_params:\n                    warn(\n                        self.get_class_fullname() + \" could work incorrectly in ReplayMode for other input data\"\n                        \" because its' params depend on targets.\"\n                    )\n                kwargs[self.save_key][id(self)] = deepcopy(params)\n            return self.apply_with_params(params, **kwargs)\n\n        return kwargs\n\n    def apply_with_params(self, params: Dict[str, Any], *args: Any, **kwargs: Any) -&gt; Dict[str, Any]:\n        if params is None:\n            return kwargs\n        params = self.update_params(params, **kwargs)\n        res = {}\n        for key, arg in kwargs.items():\n            if arg is not None:\n                target_function = self._get_target_function(key)\n                target_dependencies = {k: kwargs[k] for k in self.target_dependence.get(key, [])}\n                res[key] = target_function(arg, **dict(params, **target_dependencies))\n            else:\n                res[key] = None\n        return res\n\n    def set_deterministic(self, flag: bool, save_key: str = \"replay\") -&gt; \"BasicTransform\":\n        if save_key == \"params\":\n            msg = \"params save_key is reserved\"\n            raise KeyError(msg)\n\n        self.deterministic = flag\n        self.save_key = save_key\n        return self\n\n    def __repr__(self) -&gt; str:\n        state = self.get_base_init_args()\n        state.update(self.get_transform_init_args())\n        return f\"{self.__class__.__name__}({format_args(state)})\"\n\n    def _get_target_function(self, key: str) -&gt; Callable[..., Any]:\n        transform_key = key\n        if key in self._additional_targets:\n            transform_key = self._additional_targets.get(key, key)\n\n        return self.targets.get(transform_key, lambda x, **p: x)\n\n    def apply(self, img: np.ndarray, *args: Any, **params: Any) -&gt; np.ndarray:\n        raise NotImplementedError\n\n    def get_params(self) -&gt; Dict[str, Any]:\n        return {}\n\n    @property\n    def targets(self) -&gt; Dict[str, Callable[..., Any]]:\n        # you must specify targets in subclass\n        # foe example:\n        # &gt;&gt;  ('image', 'mask')\n        # &gt;&gt;  ('image', 'boxes')\n        raise NotImplementedError\n\n    def update_params(self, params: Dict[str, Any], **kwargs: Any) -&gt; Dict[str, Any]:\n        if hasattr(self, \"interpolation\"):\n            params[\"interpolation\"] = self.interpolation\n        if hasattr(self, \"fill_value\"):\n            params[\"fill_value\"] = self.fill_value\n        if hasattr(self, \"mask_fill_value\"):\n            params[\"mask_fill_value\"] = self.mask_fill_value\n        params.update({\"cols\": kwargs[\"image\"].shape[1], \"rows\": kwargs[\"image\"].shape[0]})\n        return params\n\n    @property\n    def target_dependence(self) -&gt; Dict[str, Any]:\n        return {}\n\n    def add_targets(self, additional_targets: Dict[str, str]) -&gt; None:\n        \"\"\"Add targets to transform them the same way as one of existing targets\n        ex: {'target_image': 'image'}\n        ex: {'obj1_mask': 'mask', 'obj2_mask': 'mask'}\n        by the way you must have at least one object with key 'image'\n\n        Args:\n            additional_targets (dict): keys - new target name, values - old target name. ex: {'image2': 'image'}\n\n        \"\"\"\n        self._additional_targets = additional_targets\n\n    @property\n    def targets_as_params(self) -&gt; List[str]:\n        return []\n\n    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        raise NotImplementedError(\n            \"Method get_params_dependent_on_targets is not implemented in class \" + self.__class__.__name__\n        )\n\n    @classmethod\n    def get_class_fullname(cls) -&gt; str:\n        return get_shortest_class_fullname(cls)\n\n    @classmethod\n    def is_serializable(cls) -&gt; bool:\n        return True\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        msg = f\"Class {self.get_class_fullname()} is not serializable because the `get_transform_init_args_names` \"\n        \"method is not implemented\"\n        raise NotImplementedError(msg)\n\n    def get_base_init_args(self) -&gt; Dict[str, Any]:\n        return {\"always_apply\": self.always_apply, \"p\": self.p}\n\n    def get_transform_init_args(self) -&gt; Dict[str, Any]:\n        return {k: getattr(self, k) for k in self.get_transform_init_args_names()}\n\n    def to_dict_private(self) -&gt; Dict[str, Any]:\n        state = {\"__class_fullname__\": self.get_class_fullname()}\n        state.update(self.get_base_init_args())\n        state.update(self.get_transform_init_args())\n\n        return state\n\n    def get_dict_with_id(self) -&gt; Dict[str, Any]:\n        d = self.to_dict_private()\n        d[\"id\"] = id(self)\n        return d\n</code></pre>"},{"location":"api_reference/core/transforms_interface/#albumentations.core.transforms_interface.BasicTransform.add_targets","title":"<code>add_targets (self, additional_targets)</code>","text":"<p>Add targets to transform them the same way as one of existing targets ex: {'target_image': 'image'} ex: {'obj1_mask': 'mask', 'obj2_mask': 'mask'} by the way you must have at least one object with key 'image'</p> <p>Parameters:</p> Name Type Description <code>additional_targets</code> <code>dict</code> <p>keys - new target name, values - old target name. ex: {'image2': 'image'}</p> Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>def add_targets(self, additional_targets: Dict[str, str]) -&gt; None:\n    \"\"\"Add targets to transform them the same way as one of existing targets\n    ex: {'target_image': 'image'}\n    ex: {'obj1_mask': 'mask', 'obj2_mask': 'mask'}\n    by the way you must have at least one object with key 'image'\n\n    Args:\n        additional_targets (dict): keys - new target name, values - old target name. ex: {'image2': 'image'}\n\n    \"\"\"\n    self._additional_targets = additional_targets\n</code></pre>"},{"location":"api_reference/core/transforms_interface/#albumentations.core.transforms_interface.DualTransform","title":"<code>class  DualTransform</code> <code> </code>  [view source on GitHub]","text":"<p>A base class for transformations that should be applied both to an image and its corresponding properties such as masks, bounding boxes, and keypoints. This class ensures that when a transform is applied to an image, all associated entities are transformed accordingly to maintain consistency between the image and its annotations.</p> <p>Properties</p> <p>targets (Dict[str, Callable[..., Any]]): Defines the types of targets (e.g., image, mask, bboxes, keypoints)     that the transform should be applied to and maps them to the corresponding methods.</p> <p>Methods</p> <p>apply_to_bbox(bbox: BoxInternalType, args: Any, *params: Any) -&gt; BoxInternalType:     Applies the transform to a single bounding box. Should be implemented in the subclass.</p> <p>apply_to_keypoint(keypoint: KeypointInternalType, args: Any, *params: Any) -&gt; KeypointInternalType:     Applies the transform to a single keypoint. Should be implemented in the subclass.</p> <p>apply_to_bboxes(bboxes: Sequence[BoxType], args: Any, *params: Any) -&gt; Sequence[BoxType]:     Applies the transform to a list of bounding boxes. Delegates to <code>apply_to_bbox</code> for each bounding box.</p> <p>apply_to_keypoints(keypoints: Sequence[KeypointType], args: Any, *params: Any) -&gt; Sequence[KeypointType]:     Applies the transform to a list of keypoints. Delegates to <code>apply_to_keypoint</code> for each keypoint.</p> <p>apply_to_mask(mask: np.ndarray, args: Any, *params: Any) -&gt; np.ndarray:     Applies the transform specifically to a single mask.</p> <p>apply_to_masks(masks: Sequence[np.ndarray], **params: Any) -&gt; List[np.ndarray]:     Applies the transform to a list of masks. Delegates to <code>apply_to_mask</code> for each mask.</p> <p>Note</p> <p>This class is intended to be subclassed and should not be used directly. Subclasses are expected to implement the specific logic for each type of target (e.g., image, mask, bboxes, keypoints) in the corresponding <code>apply_to_*</code> methods.</p> Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>class DualTransform(BasicTransform):\n    \"\"\"A base class for transformations that should be applied both to an image and its corresponding properties\n    such as masks, bounding boxes, and keypoints. This class ensures that when a transform is applied to an image,\n    all associated entities are transformed accordingly to maintain consistency between the image and its annotations.\n\n    Properties:\n        targets (Dict[str, Callable[..., Any]]): Defines the types of targets (e.g., image, mask, bboxes, keypoints)\n            that the transform should be applied to and maps them to the corresponding methods.\n\n    Methods:\n        apply_to_bbox(bbox: BoxInternalType, *args: Any, **params: Any) -&gt; BoxInternalType:\n            Applies the transform to a single bounding box. Should be implemented in the subclass.\n\n        apply_to_keypoint(keypoint: KeypointInternalType, *args: Any, **params: Any) -&gt; KeypointInternalType:\n            Applies the transform to a single keypoint. Should be implemented in the subclass.\n\n        apply_to_bboxes(bboxes: Sequence[BoxType], *args: Any, **params: Any) -&gt; Sequence[BoxType]:\n            Applies the transform to a list of bounding boxes. Delegates to `apply_to_bbox` for each bounding box.\n\n        apply_to_keypoints(keypoints: Sequence[KeypointType], *args: Any, **params: Any) -&gt; Sequence[KeypointType]:\n            Applies the transform to a list of keypoints. Delegates to `apply_to_keypoint` for each keypoint.\n\n        apply_to_mask(mask: np.ndarray, *args: Any, **params: Any) -&gt; np.ndarray:\n            Applies the transform specifically to a single mask.\n\n        apply_to_masks(masks: Sequence[np.ndarray], **params: Any) -&gt; List[np.ndarray]:\n            Applies the transform to a list of masks. Delegates to `apply_to_mask` for each mask.\n\n    Note:\n        This class is intended to be subclassed and should not be used directly. Subclasses are expected to\n        implement the specific logic for each type of target (e.g., image, mask, bboxes, keypoints) in the\n        corresponding `apply_to_*` methods.\n\n    \"\"\"\n\n    @property\n    def targets(self) -&gt; Dict[str, Callable[..., Any]]:\n        return {\n            \"image\": self.apply,\n            \"mask\": self.apply_to_mask,\n            \"masks\": self.apply_to_masks,\n            \"bboxes\": self.apply_to_bboxes,\n            \"keypoints\": self.apply_to_keypoints,\n        }\n\n    def apply_to_bbox(self, bbox: BoxInternalType, *args: Any, **params: Any) -&gt; BoxInternalType:\n        msg = f\"Method apply_to_bbox is not implemented in class {self.__class__.__name__}\"\n        raise NotImplementedError(msg)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, *args: Any, **params: Any) -&gt; KeypointInternalType:\n        msg = f\"Method apply_to_keypoint is not implemented in class {self.__class__.__name__}\"\n        raise NotImplementedError(msg)\n\n    def apply_to_global_label(self, label: np.ndarray, *args: Any, **params: Any) -&gt; np.ndarray:\n        msg = f\"Method apply_to_global_label is not implemented in class {self.__class__.__name__}\"\n        raise NotImplementedError(msg)\n\n    def apply_to_bboxes(self, bboxes: Sequence[BoxType], *args: Any, **params: Any) -&gt; Sequence[BoxType]:\n        return [\n            self.apply_to_bbox(cast(BoxInternalType, tuple(cast(BoxInternalType, bbox[:4]))), **params)\n            + tuple(bbox[4:])\n            for bbox in bboxes\n        ]\n\n    def apply_to_keypoints(\n        self, keypoints: Sequence[KeypointType], *args: Any, **params: Any\n    ) -&gt; Sequence[KeypointType]:\n        return [\n            self.apply_to_keypoint(cast(KeypointInternalType, tuple(keypoint[:4])), **params) + tuple(keypoint[4:])\n            for keypoint in keypoints\n        ]\n\n    def apply_to_mask(self, mask: np.ndarray, *args: Any, **params: Any) -&gt; np.ndarray:\n        return self.apply(mask, **{k: cv2.INTER_NEAREST if k == \"interpolation\" else v for k, v in params.items()})\n\n    def apply_to_masks(self, masks: Sequence[np.ndarray], **params: Any) -&gt; List[np.ndarray]:\n        return [self.apply_to_mask(mask, **params) for mask in masks]\n\n    def apply_to_global_labels(self, labels: Sequence[np.ndarray], **params: Any) -&gt; List[np.ndarray]:\n        return [self.apply_to_global_label(label, **params) for label in labels]\n</code></pre>"},{"location":"api_reference/core/transforms_interface/#albumentations.core.transforms_interface.ImageOnlyTransform","title":"<code>class  ImageOnlyTransform</code> <code> </code>  [view source on GitHub]","text":"<p>Transform applied to image only.</p> Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>class ImageOnlyTransform(BasicTransform):\n    \"\"\"Transform applied to image only.\"\"\"\n\n    _targets = Targets.IMAGE\n\n    @property\n    def targets(self) -&gt; Dict[str, Callable[..., Any]]:\n        return {\"image\": self.apply}\n</code></pre>"},{"location":"api_reference/core/transforms_interface/#albumentations.core.transforms_interface.NoOp","title":"<code>class  NoOp</code> <code> </code>  [view source on GitHub]","text":"<p>Does nothing</p> <p>Targets</p> <p>image, mask, bboxes, keypoints, global_label</p> Source code in <code>albumentations/core/transforms_interface.py</code> Python<pre><code>class NoOp(DualTransform):\n    \"\"\"Does nothing\n\n    Targets:\n        image, mask, bboxes, keypoints, global_label\n    \"\"\"\n\n    _targets = (Targets.IMAGE, Targets.MASK, Targets.BBOXES, Targets.KEYPOINTS, Targets.GLOBAL_LABEL)\n\n    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params: Any) -&gt; KeypointInternalType:\n        return keypoint\n\n    def apply_to_bbox(self, bbox: BoxInternalType, **params: Any) -&gt; BoxInternalType:\n        return bbox\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return img\n\n    def apply_to_mask(self, mask: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return mask\n\n    def apply_to_global_label(self, label: np.ndarray, **params: Any) -&gt; np.ndarray:\n        return label\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return ()\n</code></pre>"},{"location":"api_reference/pytorch/","title":"Index","text":"<ul> <li>Transforms (albumentations.pytorch.transforms)</li> </ul>"},{"location":"api_reference/pytorch/transforms/","title":"Transforms (pytorch.transforms)","text":""},{"location":"api_reference/pytorch/transforms/#albumentations.pytorch.transforms.ToTensorV2","title":"<code>class  ToTensorV2</code> <code>       (transpose_mask=False, always_apply=True, p=1.0)                   </code>  [view source on GitHub]","text":"<p>Converts images/masks to PyTorch Tensors, inheriting from BasicTransform. Supports images in numpy <code>HWC</code> format and converts them to PyTorch <code>CHW</code> format. If the image is in <code>HW</code> format, it will be converted to PyTorch <code>HW</code>.</p> <p>Attributes:</p> Name Type Description <code>transpose_mask</code> <code>bool</code> <p>If True, transposes 3D input mask dimensions from <code>[height, width, num_channels]</code> to <code>[num_channels, height, width]</code>.</p> <code>always_apply</code> <code>bool</code> <p>Indicates if this transformation should be always applied. Default: True.</p> <code>p</code> <code>float</code> <p>Probability of applying the transform. Default: 1.0.</p> Source code in <code>albumentations/pytorch/transforms.py</code> Python<pre><code>class ToTensorV2(BasicTransform):\n    \"\"\"Converts images/masks to PyTorch Tensors, inheriting from BasicTransform. Supports images in numpy `HWC` format\n    and converts them to PyTorch `CHW` format. If the image is in `HW` format, it will be converted to PyTorch `HW`.\n\n    Attributes:\n        transpose_mask (bool): If True, transposes 3D input mask dimensions from `[height, width, num_channels]` to\n            `[num_channels, height, width]`.\n        always_apply (bool): Indicates if this transformation should be always applied. Default: True.\n        p (float): Probability of applying the transform. Default: 1.0.\n\n    \"\"\"\n\n    def __init__(self, transpose_mask: bool = False, always_apply: bool = True, p: float = 1.0):\n        super().__init__(always_apply=always_apply, p=p)\n        self.transpose_mask = transpose_mask\n\n    @property\n    def targets(self) -&gt; Dict[str, Any]:\n        return {\"image\": self.apply, \"mask\": self.apply_to_mask, \"masks\": self.apply_to_masks}\n\n    def apply(self, img: np.ndarray, **params: Any) -&gt; torch.Tensor:\n        if len(img.shape) not in [2, 3]:\n            msg = \"Albumentations only supports images in HW or HWC format\"\n            raise ValueError(msg)\n\n        if len(img.shape) == TWO:\n            img = np.expand_dims(img, 2)\n\n        return torch.from_numpy(img.transpose(2, 0, 1))\n\n    def apply_to_mask(self, mask: np.ndarray, **params: Any) -&gt; torch.Tensor:\n        if self.transpose_mask and mask.ndim == THREE:\n            mask = mask.transpose(2, 0, 1)\n        return torch.from_numpy(mask)\n\n    def apply_to_masks(self, masks: List[np.ndarray], **params: Any) -&gt; List[torch.Tensor]:\n        return [self.apply_to_mask(mask, **params) for mask in masks]\n\n    def get_transform_init_args_names(self) -&gt; Tuple[str, ...]:\n        return (\"transpose_mask\",)\n\n    def get_params_dependent_on_targets(self, params: Any) -&gt; Dict[str, Any]:\n        return {}\n</code></pre>"},{"location":"api_reference/pytorch/transforms/#albumentations.pytorch.transforms.ToTensorV2.__init__","title":"<code>__init__ (self, transpose_mask=False, always_apply=True, p=1.0)</code>  <code>special</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>albumentations/pytorch/transforms.py</code> Python<pre><code>def __init__(self, transpose_mask: bool = False, always_apply: bool = True, p: float = 1.0):\n    super().__init__(always_apply=always_apply, p=p)\n    self.transpose_mask = transpose_mask\n</code></pre>"},{"location":"autoalbument/","title":"AutoAlbument Overview","text":"<p>AutoAlbument is an AutoML tool that learns image augmentation policies from data using the Faster AutoAugment algorithm. It relieves the user from manually selecting augmentations and tuning their parameters. AutoAlbument provides a complete ready-to-use configuration for an augmentation pipeline.</p> <p>AutoAlbument supports image classification and semantic segmentation tasks. The library requires Python 3.6 or higher.</p> <p>The source code and issue tracker are available at https://github.com/albumentations-team/autoalbument</p> <p>Table of contents:</p> <ul> <li>AutoAlbument introduction and core concepts</li> <li>Installation</li> <li>Benchmarks and a comparison with baseline augmentation strategies</li> <li>How to use AutoAlbument</li> <li>How to use an AutoAlbument Docker image</li> <li>How to use a custom classification or semantic segmentation model</li> <li>Metrics and their meaning</li> <li>Tuning parameters</li> <li>Examples</li> <li>Search algorithms</li> <li>FAQ</li> </ul>"},{"location":"autoalbument/benchmarks/","title":"Benchmarks and a comparison with baseline augmentation strategies","text":"<p>Here is a comparison between a baseline augmentation strategy and an augmentation policy discovered by AutoAlbument for different classification and semantic segmentation tasks. You can read more about these benchmarks in the autoalbument-benchmarks repository.</p>"},{"location":"autoalbument/benchmarks/#classification","title":"Classification","text":"Dataset Baseline Top-1 Accuracy AutoAlbument Top-1 Accuracy CIFAR10 91.79 96.02 SVHN 98.31 98.48 ImageNet 73.27 75.17"},{"location":"autoalbument/benchmarks/#semantic-segmentation","title":"Semantic segmentation","text":"Dataset Baseline mIOU AutoAlbument mIOU Pascal VOC 73.34 75.55 Cityscapes 79.47 79.92"},{"location":"autoalbument/custom_model/","title":"How to use a custom classification or semantic segmentation model","text":"<p>By default AutoAlbument uses <code>pytorch-image-models</code> for classification and <code>segmentation_models.pytorch</code> for semantic segmentation. You can use any model from these packages by providing an appropriate model name.</p> <p>However, you can also use a custom model with AutoAlbument. To do so, you need to define a Discriminator model. This Discriminator model should have two outputs.</p> <ul> <li> <p>The first output should provide a prediction for a classification or semantic segmentation task. For classification, it should output a tensor with a shape <code>[batch_size, num_classes]</code> with logits. For semantic segmentation, it should output a tensor with the shape <code>[batch_size, num_classes, height, width]</code> with logits.</p> </li> <li> <p>The second (auxiliary) output should return a tensor with the shape <code>[batch_size]</code> that contains logits for Discriminator's predictions (whether Discriminator thinks that an image wasn't or was augmented).</p> </li> </ul> <p>To create such a model, you need to subclass the <code>autoalbument.faster_autoaugment.models.BaseDiscriminator</code> class and implement the <code>forward</code> method. This method should take a batch of images, that is, a tensor with the shape <code>[batch_size, num_channels, height, width]</code>. It should return a tuple that contains tensors from the two outputs described above.</p> <p>As an example, take a look at how default classification and semantic segmentation models are defined in AutoAlbument - https://github.com/albumentations-team/autoalbument/blob/master/autoalbument/faster_autoaugment/models.py or explore an example of a custom model for the CIFAR10 dataset.</p> <p>Next, you need to specify this custom model in <code>config.yaml</code>, an  AutoAlbument config file. AutoAlbument uses the <code>instantiate</code> function from Hydra to instantiate an object. You need to set the <code>_target_</code> config variable in the <code>classification_model</code> or <code>semantic_segmentation_model</code> section, depending on the task. In this config variable, you need to provide a path to a class with the model. This path should be located inside PYTHONPATH, so Hydra could correctly use it. The simplest way is to define your model in a file such as <code>model.py</code> and place this file in the same directory with <code>dataset.py</code> and <code>search.yaml</code> because this directory is automatically added to PYTHONPATH. Next, you could define <code>_target_</code> such as <code>_target_: model.MyClassificationModel</code>.</p> <p>Take a look at the CIFAR10 example config that uses a custom model defined in model.py as a starting point for defining a custom model.</p>"},{"location":"autoalbument/docker/","title":"How to use an AutoAlbument Docker image","text":"<p>You can run AutoAlbument from a Docker image. The <code>ghcr.io/albumentations-team/autoalbument:latest</code> Docker image contains the latest release version of AutoAlbument.</p> <p>You can also use an image that contains a specific version of AutoAlbument. In that case, you need to use the AutoAlbument version as a tag for a Docker image, e.g., the <code>ghcr.io/albumentations-team/autoalbument:0.3.0</code> image contains AutoAlbument 0.3.0.</p> <p>The latest AutoAlbument image is based on the <code>pytorch/pytorch:1.7.0-cuda11.0-cudnn8-runtime</code> image.</p> <p>When you run a Docker container with AutoAlbument, you need to mount a config directory (a directory containing <code>dataset.py</code> and <code>search.yaml</code> files) and other required directories, such as a directory that contains training data.</p> <p>Here is an example command that runs a Docker container that will search for CIFAR10 augmentation policies.</p> <p><code>docker run -it --rm --gpus all --ipc=host -v ~/projects/autoalbument/examples/cifar10:/config -v ~/data:/home/autoalbument/data -u $(id -u ${USER}):$(id -g ${USER}) ghcr.io/albumentations-team/autoalbument:latest</code></p> <p>Let's take a look at the arguments:</p> <ul> <li><code>--it</code>. Tell Docker that you run an interactive process. Read more in the Docker documentation.</li> <li><code>--rm</code>. Automatically clean up a container when it exits. Read more in the Docker documentation.</li> <li><code>--gpus all</code>. Specify GPUs to use. Read more in the Docker documentation.</li> <li><code>--ipc=host</code>. Increase shared memory size for PyTorch DataLoader. Read more in the PyTorch documentation.</li> <li><code>-v ~/projects/autoalbument/examples/cifar10:/config</code>. Mounts the <code>~/projects/autoalbument/examples/cifar10</code> directory from the host to the <code>/config</code> directory into the container. This example assumes that you have the AutoAlbument repository in the <code>~/projects/autoalbument/</code> directory. Generally speaking, you need to mount a directory containing <code>dataset.py</code> and <code>search.yaml</code> into the <code>/config</code> directory in a container.</li> <li><code>-v ~/data:/home/autoalbument/data</code>. Mounts the directory <code>~/data</code> that contains the CIFAR10 dataset into the <code>/home/autoalbument/data</code> directory. You can mount a host directory with a dataset into any container directory, but you need to specify config parameters accordingly. In this example, we mount the directory into <code>/home/autoalbument/data</code> because we set this directory (<code>~/data/cifar10</code>) in the config as a root directory for the dataset. Note that Docker doesn't support tilde expansion for the HOME directory, so we explicitly name HOME directory as <code>/home/autoalbument</code> because <code>autoalbument</code> is a default user inside the container.</li> <li><code>-u $(id -u ${USER}):$(id -g ${USER})</code>. We use that command to tell Docker to use the host's user ID to run code inside a container. We need this command because AutoAlbument will produce artifacts in the config directory (such as augmentation configs and logs). We need that the host user owns those files (and not <code>root</code>, for example) so you can access them afterward.</li> <li><code>ghcr.io/albumentations-team/autoalbument:latest</code> is the Docker image's name. <code>latest</code> is a tag for the latest stable release. Alternatively, you can use a tag that specifies an AutoAlbument version, e.g., <code>ghcr.io/albumentations-team/autoalbument:0.3.0</code>.</li> </ul>"},{"location":"autoalbument/faq/","title":"FAQ","text":""},{"location":"autoalbument/faq/#search-takes-a-lot-of-time-how-can-i-speed-it-up","title":"Search takes a lot of time. How can I speed it up?","text":"<p>Instead of a full training dataset, you can use a reduced version to search for augmentation policies. For example, the authors of Faster AutoAugment used 6000 images from the 120 selected classes to find augmentation policies for ImageNet (while the full dataset for ILSVRC contains 1.2 million images and 1000 classes).</p>"},{"location":"autoalbument/how_to_use/","title":"How to use AutoAlbument","text":"<ol> <li>You need to create a configuration file with AutoAlbument parameters and a Python file that implements a custom PyTorch Dataset for your data. Next, you need to pass those files to AutoAlbument.</li> <li>AutoAlbument will use Generative Adversarial Network to discover augmentation policies and then create a file containing those policies.</li> <li>Finally, you can use Albumentations to load augmentation policies from the file and utilize them in your computer vision pipeline.</li> </ol>"},{"location":"autoalbument/how_to_use/#step-1-create-a-configuration-file-and-a-custom-pytorch-dataset-for-your-data","title":"Step 1. Create a configuration file and a custom PyTorch Dataset for your data","text":""},{"location":"autoalbument/how_to_use/#a-create-a-directory-with-configuration-files","title":"a. Create a directory with configuration files","text":"<p>Run <code>autoalbument-create --config-dir &lt;/path/to/directory&gt; --task &lt;deep_learning_task&gt; --num-classes &lt;num_classes&gt;</code>, e.g. <code>autoalbument-create --config-dir ~/experiments/autoalbument-search-cifar10 --task classification --num-classes 10</code>.  - A value for the <code>--config-dir</code> option should contain a path to the directory. AutoAlbument will create this directory and put two files into it: <code>dataset.py</code> and <code>search.yaml</code> (more on them later).   - A value for the <code>--task</code> option should contain the name of a deep learning task. Supported values are <code>classification</code> and <code>semantic_segmentation</code>.  - A value for the <code>--num-classes</code> option should contain the number of distinct classes in the classification or segmentation dataset.</p> <p>By default, AutoAlbument creates a <code>search.yaml</code> file that contains only most important configuration parameters. To explore all available parameters you can create a config file that contains them all by providing the <code>--generate-full-config</code> argument, e.g. <code>autoalbument-create --config-dir ~/experiments/autoalbument-search-cifar10 --task classification --num-classes 10 --generate-full-config</code></p>"},{"location":"autoalbument/how_to_use/#b-add-implementation-for-__len__-and-__getitem__-methods-in-datasetpy","title":"b. Add implementation for <code>__len__</code> and <code>__getitem__</code> methods in <code>dataset.py</code>","text":"<p>The <code>dataset.py</code> file created at step 1 by <code>autoalbument-create</code> contains stubs for implementing a PyTorch dataset (you can read more about creating custom PyTorch datasets here). You need to add implementation for <code>__len__</code> and <code>__getitem__</code> methods (and optionally add the initialization logic if required).</p> <p>A dataset for a classification task should return an image and a class label. A dataset for a segmentation task should return an image and an associated mask.</p>"},{"location":"autoalbument/how_to_use/#c-optional-adjust-search-parameters-in-searchyaml","title":"c. [Optional] Adjust search parameters in <code>search.yaml</code>","text":"<p>You may want to change the parameters that AutoAlbument will use to search for augmentation policies. To do this, you need to edit the <code>search.yaml</code> file created by <code>autoalbument-create</code> at step 1. Each configuration parameter contains a comment that describes the meaning of the setting. Please refer to the  \"Tuning the search parameters\" section that includes a description of the most critical parameters.</p> <p><code>search.yaml</code> is a Hydra config file. You can use all Hydra features inside it.</p>"},{"location":"autoalbument/how_to_use/#step-2-use-autoalbument-to-search-for-augmentation-policies","title":"Step 2. Use AutoAlbument to search for augmentation policies.","text":"<p>To search for augmentation policies, run <code>autoalbument-search --config-dir &lt;/path/to/directory&gt;</code>, e.g. <code>autoalbument-search --config-dir ~/experiments/autoalbument-search-cifar10</code>. The value of <code>--config-dir</code> should be the same value that was passed to <code>autoalbument-create</code> at step 1.</p> <p><code>autoalbument-search</code> will create a directory with output files (by default the path of the directory will be <code>&lt;config_dir&gt;/outputs/&lt;current_date&gt;/&lt;current_time&gt;</code>, but you can customize it in search.yaml).  The <code>policy</code> subdirectory will contain JSON files with policies found at each search phase's epoch.</p> <p><code>autoalbument-search</code> is a command wrapped with the <code>@hydra.main</code> decorator from Hydra. You can use all Hydra features when calling this command.</p> <p>AutoAlbument uses PyTorch to search for augmentation policies. You can speed up the search by using a CUDA-capable GPU.</p>"},{"location":"autoalbument/how_to_use/#step-3-use-albumentations-to-load-augmentation-policies-and-utilize-them-in-your-training-pipeline","title":"Step 3. Use Albumentations to load augmentation policies and utilize them in your training pipeline.","text":"<p>AutoAlbument produces a JSON file that contains a configuration for an augmentation pipeline. You can load that JSON file with Albumentations:</p> Text Only<pre><code>import albumentations as A\ntransform = A.load(\"/path/to/policy.json\")\n</code></pre> <p>Then you can use the created augmentation pipeline to augment the input data.</p> <p>For example, to augment an image for a classification task:</p> Text Only<pre><code>transformed = transform(image=image)\ntransformed_image = transformed[\"image\"]\n</code></pre> <p>To augment an image and a mask for a semantic segmentation task: Text Only<pre><code>transformed = transform(image=image, mask=mask)\ntransformed_image = transformed[\"image\"]\ntransformed_mask = transformed[\"mask\"]\n</code></pre></p>"},{"location":"autoalbument/how_to_use/#additional-resources","title":"Additional resources","text":"<ul> <li> <p>You can read more about the most important configuration parameters for AutoAlbument in Tuning the search parameters.</p> </li> <li> <p>To see examples of configuration files and custom PyTorch Datasets, please refer to Examples</p> </li> <li> <p>You can read more about using Albumentations for augmentation in those articles Image augmentation for classification, Mask augmentation for segmentation.</p> </li> <li> <p>Refer to this section of the documentation to get examples of how to use Albumentations with PyTorch and TensorFlow 2.</p> </li> </ul>"},{"location":"autoalbument/installation/","title":"Installation","text":"<p>AutoAlbument requires Python 3.6 or higher.</p>"},{"location":"autoalbument/installation/#pypi","title":"PyPI","text":"<p>To install the latest stable version from PyPI:</p> <p><code>pip install -U autoalbument</code></p>"},{"location":"autoalbument/installation/#github","title":"GitHub","text":"<p>To install the latest version from GitHub:</p> <p><code>pip install -U git+https://github.com/albumentations-team/autoalbument</code></p>"},{"location":"autoalbument/introduction/","title":"AutoAlbument introduction and core concepts","text":""},{"location":"autoalbument/introduction/#what-is-autoalbument","title":"What is AutoAlbument","text":"<p>AutoAlbument is a tool that automatically searches for the best augmentation policies for your data.</p> <p>Under the hood, it uses the Faster AutoAugment algorithm. Briefly speaking, the idea is to use a GAN-like architecture in which Generator applies augmentation to some input images, and Discriminator must determine whether an image was or wasn't augmented. This process helps to find augmentation policies that will produce images similar to the original images.</p>"},{"location":"autoalbument/introduction/#how-to-use-autoalbument","title":"How to use AutoAlbument","text":"<p>To use AutoAlbument, you need to define two things: a PyTorch Dataset for your data and configuration parameters for AutoAlbument. You can read the detailed instruction in the How to use AutoAlbument article.</p> <p>Internally AutoAlbument uses PyTorch Lightning for training a GAN and Hydra for handling configuration parameters.</p> <p>Here are a few things about AutoAlbument and Hydra.</p>"},{"location":"autoalbument/introduction/#hydra","title":"Hydra","text":"<p>The main internal configuration file is located at autoalbument/cli/conf/config.yaml</p> <p>Here is its content:</p> Text Only<pre><code>defaults:\n - _version\n - task\n - policy_model: default\n - classification_model: default\n - semantic_segmentation_model: default\n - data: default\n - searcher: default\n - trainer: default\n - optim: default\n - callbacks: default\n - logger: default\n - hydra: default\n - seed\n - search\n</code></pre> <p>Basically, it includes a bunch of config files with default values. Those config files are split into sets of closely related parameters such as model parameters or optimizer parameters. All default config files are located in their respective directories inside autoalbument/cli/conf</p> <p>The main config file also includes the <code>search.yaml</code> file, which you will use for overriding default parameters for your specific dataset and task (you can read more about creating the <code>search.yaml</code> file with <code>autoalbument-create</code> in How to use AutoAlbument)</p> <p>To allow great flexibility, AutoAlbument relies heavily on the <code>instantiate</code> function from Hydra. This function allows to define a path to a Python class in a YAML config (using the <code>_target_</code> parameter) along with arguments to that class, and Hydra will create an instance of this class with the provided arguments.</p> <p>As a practice example, if a config contains a definition like this:</p> Text Only<pre><code>_target_: autoalbument.faster_autoaugment.models.ClassificationModel\nnum_classes: 10\narchitecture: resnet18\npretrained: False\n</code></pre> <p>AutoAlbument will translate it approximately to the following call:</p> Text Only<pre><code>from autoalbument.faster_autoaugment.models import ClassificationModel\n\nmodel = ClassificationModel(num_classes=10, architecture='resnet18', pretrained=False)\n</code></pre> <p>By relying on this feature, AutoAlbument allows customizing its behavior without changing the library's internal code.</p>"},{"location":"autoalbument/introduction/#pytorch-lightning","title":"PyTorch Lightning","text":"<p>AutoAlbument relies on PyTorch Lightning to train a GAN. In AutoAlbument configs, you can configure PyTorch Lightning by passing the appropriate arguments to Trainer through the <code>trainer</code> config or defining a list of Callbacks through the <code>callbacks</code> config.</p>"},{"location":"autoalbument/metrics/","title":"Metrics and their meaning","text":"<p>During the search phase, AutoAlbument outputs four metrics: <code>loss</code>, <code>d_loss</code>, <code>a_loss</code>, and <code>Average Parameter Change</code> (at the end of an epoch).</p>"},{"location":"autoalbument/metrics/#a_loss","title":"a_loss","text":"<p><code>a_loss</code> is a loss for the policy network (or Generator in terms of GAN), which applies augmentations to input images.</p>"},{"location":"autoalbument/metrics/#d_loss","title":"d_loss","text":"<p><code>d_loss</code> is a loss for the Discriminator, the network that tries to guess whether the input image is an augmented or non-augmented one.</p>"},{"location":"autoalbument/metrics/#loss","title":"loss","text":"<p><code>loss</code> is a task-specific loss (<code>CrossEntropyLoss</code> for classification, <code>BCEWithLogitsLoss</code> for semantic segmentation) that acts as a regularizer and prevents the policy network from applying such augmentations that will make an object with class A looks like an object with class B.</p>"},{"location":"autoalbument/metrics/#average-parameter-change","title":"Average Parameter Change","text":"<p><code>Average Parameter Change</code> is a difference between magnitudes of augmentation parameters multiplied by their probabilities at the end of an epoch and the same parameters at the beginning of the epoch. The metric is calculated using the following formula:</p> <p></p> <ul> <li><code>m'</code>  and <code>m</code> are magnitude values for the i-th augmentation at the end and the beginning of the epoch, respectively.</li> <li><code>p'</code>  and <code>p</code> are probability values for the i-th augmentation at the end and the beginning of the epoch, respectively.</li> </ul> <p>The intuition behind this metric is that at the beginning, augmentation parameters are initialized at random, so they are now optimal and prone to heavy change at each epoch. After some time, these parameters should begin to converge, and they should change less at each epoch.</p>"},{"location":"autoalbument/metrics/#examples-for-metric-values","title":"Examples for metric values","text":"<p>Below are TensorBoard logs for AutoAlbument on different datasets. The search was performed using AutoAlbument configs from the examples directory.</p> <ul> <li>CIFAR10</li> <li>SVHN</li> <li>ImageNet</li> <li>Pascal VOC</li> <li>Cityscapes</li> </ul> <p>As you see, in all these charts, <code>loss</code> is slightly decreasing at each epoch, and <code>a_loss</code> or <code>d_loss</code> could either decrease or increase. <code>Average Parameter Change</code> is usually large at first epochs, but then it starts to decrease. As a rule of thumb, to decide whether you should stop AutoAlbument search and use the resulting policy, you should check that <code>Average Parameter Change</code> is stopped decreasing and started to oscillate, wait for a few more epochs, and use the found policy from that epoch.</p> <p>In autoalbument-benchmaks, we use AutoAlbument policies produced by the last epoch on these charts.</p>"},{"location":"autoalbument/search_algorithms/","title":"Search algorithms","text":"<p>AutoAlbument uses the following algorithms to search for augmentation policies.</p>"},{"location":"autoalbument/search_algorithms/#faster-autoaugment","title":"Faster AutoAugment","text":"<p>\"Faster AutoAugment: Learning Augmentation Strategies using Backpropagation\" by Ryuichiro Hataya, Jan Zdenek, Kazuki Yoshizoe, and Hideki Nakayama. Paper | Original implementation</p>"},{"location":"autoalbument/tuning_parameters/","title":"Tuning the search parameters","text":"<p>The <code>search.yaml</code> file contains parameters for the search of augmentation policies. Here is an example <code>search.yaml</code> for image classification on the CIFAR-10 dataset, and here is an example <code>search.yaml</code> for semantic segmentation on the Pascal VOC dataset.</p>"},{"location":"autoalbument/tuning_parameters/#task-specific-model","title":"Task-specific model","text":"<p>A task-specific model is a model that classifies images for a classification task or outputs masks for a semantic segmentation task. Settings for a task-specific model are defined by either <code>classification_model</code> or <code>semantic_segmentation_model</code> depending on a selected task. Ideally, you should select the same model (the same architecture and the same pretrained weights) that you will use in an actual task. AutoAlbument uses models from PyTorch Image Models and Segmentation models packages for classification and semantic segmentation respectively.</p>"},{"location":"autoalbument/tuning_parameters/#base-pytorch-parameters","title":"Base PyTorch parameters.","text":"<p>You may want to adjust the following parameters for a PyTorch pipeline:</p> <ul> <li><code>data.dataloader</code> parameters such as batch_size and <code>num_workers</code></li> <li>Number of epochs to search for best augmentation policies in <code>optim.epochs</code>.</li> <li>Learning rate for optimizers in <code>optim.main.lr</code> and <code>optim.policy.lr</code>.</li> </ul>"},{"location":"autoalbument/tuning_parameters/#parameters-for-the-augmentations-search","title":"Parameters for the augmentations search.","text":"<p>Those parameters are defined in <code>policy_model</code>. You may want to tune the following ones:</p> <ul> <li> <p><code>num_sub_policies</code> - number of distinct augmentation sub-policies. A random sub-policy is selected in each iteration, and that sub-policy is applied to input data. The larger number of sub-policies will produce a more diverse set of augmentations. On the other side, the more sub-policies you have, the more time and data you need to tune those sub-policies correctly.</p> </li> <li> <p><code>num_chunks</code> controls the balance between speed and diversity of augmentations in a search phase. Each batch is split-up into <code>num_chunks</code> chunks, and then a random sub-policy is applied to each chunk separately. The larger the value of <code>num_chunks</code> helps to learn augmentation policies better but simultaneously increases the searching time. Authors of FasterAutoAugment used such values for <code>num_chunks</code> that each chunk consisted of 8 to 16 images.</p> </li> <li> <p><code>operation_count</code> - the number of augmentation operations that will be applied to each input data instance. For example, <code>operation_count: 1</code> means that only one operation will be applied to an input image/mask, and <code>operation_count: 4</code> means that four sequential operations will be applied to each input image/mask. The larger number of operations produces a more diverse set of augmentations but simultaneously increases the searching time.</p> </li> </ul>"},{"location":"autoalbument/tuning_parameters/#preprocessing-transforms","title":"Preprocessing transforms","text":"<p>If images have different sizes or you want to train a model on image patches, you could define preprocessing transforms (such as Resizing, Cropping, and Padding) in <code>data.preprocessing</code>. Those transforms will always be applied to all input data. Found augmentation policies will also contain those preprocessing transforms.</p> <p>Note that it is crucial for Policy Model (a model that searches for augmentation parameters) to receive images of the same size that will be used during the training of an actual model. For some augmentations, parameters depend on input data's height and width (for example, hole sizes for the Cutout augmentation).</p>"},{"location":"autoalbument/examples/cifar10/","title":"Image classification on the CIFAR10 dataset","text":"<p>The following files are also available on GitHub - https://github.com/albumentations-team/autoalbument/tree/master/examples/cifar10</p>"},{"location":"autoalbument/examples/cifar10/#datasetpy","title":"dataset.py","text":"Python<pre><code>import cv2\nimport torchvision\n\ncv2.setNumThreads(0)\ncv2.ocl.setUseOpenCL(False)\n\n\nclass Cifar10SearchDataset(torchvision.datasets.CIFAR10):\n    def __init__(self, root=\"~/data/cifar10\", train=True, download=True, transform=None):\n        super().__init__(root=root, train=train, download=download, transform=transform)\n\n    def __getitem__(self, index):\n        image, label = self.data[index], self.targets[index]\n\n        if self.transform is not None:\n            transformed = self.transform(image=image)\n            image = transformed[\"image\"]\n\n        return image, label\n</code></pre>"},{"location":"autoalbument/examples/cifar10/#searchyaml","title":"search.yaml","text":"YAML<pre><code># @package _global_\n\n_version: 2  # An internal value that indicates a version of the config schema. This value is used by\n# `autoalbument-search` and `autoalbument-migrate` to upgrade the config to the latest version if necessary.\n# Please do not change it manually.\n\n\ntask: classification # Deep learning task. Should either be `classification` or `semantic_segmentation`.\n\n\npolicy_model:\n  # Settings for Policy Model that searches augmentation policies.\n\n  task_factor: 0.1\n  # Multiplier for classification loss of a model. Faster AutoAugment uses classification loss to prevent augmentations\n  # from transforming images of a particular class to another class. The authors of Faster AutoAugment use 0.1 as\n  # default value.\n\n  gp_factor: 10\n  # Multiplier for the gradient penalty for WGAN-GP training. 10 is the default value that was proposed in\n  # `Improved Training of Wasserstein GANs`.\n\n  temperature: 0.05\n  # Temperature for Relaxed Bernoulli distribution. The probability of applying a certain augmentation is sampled from\n  # Relaxed Bernoulli distribution (because Bernoulli distribution is not differentiable). With lower values of\n  # `temperature` Relaxed Bernoulli distribution behaves like Bernoulli distribution. In the paper, the authors\n  # of Faster AutoAugment used 0.05 as a default value for `temperature`.\n\n  num_sub_policies: 100\n  # Number of augmentation sub-policies. When an image passes through an augmentation pipeline, Faster AutoAugment\n  # randomly chooses one sub-policy and uses augmentations from that sub-policy to transform an input image. A larger\n  # number of sub-policies leads to a more diverse set of augmentations and better performance of a model trained on\n  # augmented images. However, an increase in the number of sub-policies leads to the exponential growth of a search\n  # space of augmentations, so you need more training data for Policy Model to find good augmentation policies.\n\n  num_chunks: 8\n  # Number of chunks in a batch. Faster AutoAugment splits each batch of images into `num_chunks` chunks. Then it\n  # applies the same sub-policy with the same parameters to each image in a chunk. This parameter controls the tradeoff\n  # between the speed of augmentation search and diversity of augmentations. Larger `num_chunks` values will lead to\n  # faster searching but less diverse set of augmentations. Note that this parameter is used only in the searching\n  # phase. When you train a model with found sub-policies, Albumentations will apply a distinct set of transformations\n  # to each image separately.\n\n  operation_count: 4\n  # Number of consecutive augmentations in each sub-policy. Faster AutoAugment will sequentially apply `operation_count`\n  # augmentations from a sub-policy to an image. Larger values of `operation_count` lead to better performance of\n  # a model trained on augmented images. Simultaneously, larger values of `operation_count` affect the speed of search\n  # and increase the searching time.\n\n\nclassification_model:\n  # Settings for Classification Model that is used for two purposes:\n  # 1. As a model that performs classification of input images.\n  # 2. As a Discriminator for Policy Model.\n\n  _target_: model.Cifar10ClassificationModel\n  # A custom classification model is used. This model is defined inside the `model.py` file which is located\n  # in the same directory with `search.yaml` and `dataset.py`.\n  #  # As an alternative, you could use a built-in AutoAlbument model using the following config:\n  #  #  _target_: autoalbument.faster_autoaugment.models.ClassificationModel\n  #\n  #  # Number of classes in the dataset. The dataset implementation should return an integer in the range\n  #  # [0, num_classes - 1] as a class label of an image.\n  #  num_classes: 10\n  #\n  #  # The architecture of Classification Model. AutoAlbument uses models from\n  #  # https://github.com/rwightman/pytorch-image-models/. Please refer to its documentation to get a list of available\n  #  # models - https://rwightman.github.io/pytorch-image-models/#list-models-with-pretrained-weights.\n  #  architecture: resnet18\n  #\n  #  # Boolean flag that indicates whether the selected model architecture should load pretrained weights or use randomly\n  #  # initialized weights.\n  #  pretrained: False\n\n\ndata:\n  dataset:\n    _target_: dataset.Cifar10SearchDataset\n    root: ~/data/cifar10\n    train: true\n    download: true\n  # Class for the PyTorch Dataset and arguments to it. AutoAlbument will create an object of this class using\n  # the `instantiate` method from Hydra - https://hydra.cc/docs/next/patterns/instantiate_objects/overview/.\n  #\n  # Note that the target class value in the `_target_` argument should be located inside PYTHONPATH so Hydra could\n  # find it. The directory with the config file is automatically added to PYTHONPATH, so the default value\n  # `dataset.SearchDataset` points to the class `SearchDataset` from the `dataset.py` file. This `dataset.py` file is\n  # located along with the `search.yaml` file in the same directory provided by `--config-dir`.\n  #\n  # As an alternative, you could provide a path to a Python file with the dataset using the `dataset_file` parameter\n  # instead of the `dataset` parameter. The Python file should contain the implementation of a PyTorch dataset for\n  # augmentation search. The dataset class should have named `SearchDataset`. The value in `dataset_file` could either\n  # be a relative or an absolute path ; in the case of a relative path, the path should be relative to this config\n  # file's location.\n  #\n  # - Example of a relative path:\n  # dataset_file: dataset.py\n  #\n  # - Example of an absolute path:\n  # dataset_file: /projects/pytorch/dataset.py\n  #\n\n  input_dtype: uint8\n  # The data type of input images. Two values are supported:\n  # - uint8. In that case, all input images should be NumPy arrays with the np.uint8 data type and values in the range\n  #   [0, 255].\n  # - float32. In that case, all input images should be NumPy arrays with the np.float32 data type and values in the\n  #   range [0.0, 1.0].\n\n  preprocessing: null\n  # A list of preprocessing augmentations that will be applied to each image before applying augmentations from\n  # a policy. A preprocessing augmentation should be defined as `key`: `value`, where `key` is the name of augmentation\n  # from Albumentations, and `value` is a dictionary with augmentation parameters. The found policy will also apply\n  # those preprocessing augmentations before applying the main augmentations.\n  #\n  # Here is an example of an augmentation pipeline that first pads an image to the size 512x512 pixels, then resizes\n  # the resulting image to the size 256x256 pixels and finally crops a random patch with the size 224x224 pixels.\n  #\n  #  preprocessing:\n  #    - PadIfNeeded:\n  #        min_height: 512\n  #        min_width: 512\n  #    - Resize:\n  #        height: 256\n  #        width: 256\n  #    - RandomCrop:\n  #        height: 224\n  #        width: 224\n  #\n\n  normalization:\n    mean: [0.4914, 0.4822, 0.4465]\n    std: [0.247, 0.243, 0.261]\n  # Normalization values for images. For each image, the search pipeline will subtract `mean` and divide by `std`.\n  # Normalization is applied after transforms defined in `preprocessing`. Note that regardless of `input_dtype`,\n  # the normalization function will always receive a `float32` input with values in the range [0.0, 1.0], so you should\n  # define `mean` and `std` values accordingly.\n\n  dataloader:\n    _target_: torch.utils.data.DataLoader\n    batch_size: 128\n    shuffle: true\n    num_workers: 8\n    pin_memory: true\n    drop_last: true\n  # Parameters for the PyTorch DataLoader. Please refer to the PyTorch documentation for the description of parameters -\n  # https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader.\n\n\noptim:\n  main:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n  # Optimizer configuration for the main (either Classification or Semantic Segmentation) Model\n\n  policy:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n  # Optimizer configuration for Policy Model\n\n\nseed: 42 # Random seed. If the value is not null, it will be passed to `seed_everything` -\n# https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.utilities.seed.html?highlight=seed_everything\n\n\nhydra:\n  run:\n    dir: ${config_dir:}/outputs/${now:%Y-%m-%d}/${now:%H-%M-%S}\n    # Path to the directory that will contain all outputs produced by the search algorithm. `${config_dir:}` contains\n    # path to the directory with the `search.yaml` config file. Please refer to the Hydra documentation for more\n    # information - https://hydra.cc/docs/configure_hydra/workdir.\n\n\ntrainer:\n  # Configuration for PyTorch Lightning Trainer. You can read more about Trainer and its arguments at\n  # https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html.\n\n  max_epochs: 40\n  # Number of epochs to search for augmentation parameters.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#max-epochs\n\n  benchmark: true\n  # If true enables cudnn.benchmark.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#benchmark\n\n  gpus: 1\n  # Number of GPUs to train on. Set to `0` or None` to use CPU for training.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#gpus\n</code></pre>"},{"location":"autoalbument/examples/cifar10/#modelpy","title":"model.py","text":"Python<pre><code>\"\"\"WideResNet code from https://github.com/xternalz/WideResNet-pytorch\"\"\"\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom autoalbument.faster_autoaugment.models import BaseDiscriminator\n\n\nclass BasicBlock(nn.Module):\n    def __init__(self, in_planes, out_planes, stride):\n        super(BasicBlock, self).__init__()\n        self.bn1 = nn.BatchNorm2d(in_planes)\n        self.relu1 = nn.ReLU(inplace=True)\n        self.conv1 = nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)\n        self.bn2 = nn.BatchNorm2d(out_planes)\n        self.relu2 = nn.ReLU(inplace=True)\n        self.conv2 = nn.Conv2d(out_planes, out_planes, kernel_size=3, stride=1, padding=1, bias=False)\n        self.equal_in_out = in_planes == out_planes\n        self.conv_shortcut = (\n            (not self.equal_in_out)\n            and nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, padding=0, bias=False)\n            or None\n        )\n\n    def forward(self, x):\n        if not self.equal_in_out:\n            x = self.relu1(self.bn1(x))\n        else:\n            out = self.relu1(self.bn1(x))\n        out = self.relu2(self.bn2(self.conv1(out if self.equal_in_out else x)))\n        out = self.conv2(out)\n        return torch.add(x if self.equal_in_out else self.conv_shortcut(x), out)\n\n\nclass NetworkBlock(nn.Module):\n    def __init__(self, nb_layers, in_planes, out_planes, block, stride):\n        super(NetworkBlock, self).__init__()\n        self.layer = self._make_layer(block, in_planes, out_planes, nb_layers, stride)\n\n    def _make_layer(self, block, in_planes, out_planes, nb_layers, stride):\n        layers = []\n        for i in range(int(nb_layers)):\n            layers.append(block(i == 0 and in_planes or out_planes, out_planes, i == 0 and stride or 1))\n        return nn.Sequential(*layers)\n\n    def forward(self, x):\n        return self.layer(x)\n\n\nclass WideResNet(nn.Module):\n    def __init__(self, depth, num_classes, widen_factor=1):\n        super(WideResNet, self).__init__()\n        n_channels = [16, 16 * widen_factor, 32 * widen_factor, 64 * widen_factor]\n        assert (depth - 4) % 6 == 0\n        n = (depth - 4) / 6\n        block = BasicBlock\n        # 1st conv before any network block\n        self.conv1 = nn.Conv2d(3, n_channels[0], kernel_size=3, stride=1, padding=1, bias=False)\n        # 1st block\n        self.block1 = NetworkBlock(n, n_channels[0], n_channels[1], block, 1)\n        # 2nd block\n        self.block2 = NetworkBlock(n, n_channels[1], n_channels[2], block, 2)\n        # 3rd block\n        self.block3 = NetworkBlock(n, n_channels[2], n_channels[3], block, 2)\n        # global average pooling and classifier\n        self.bn1 = nn.BatchNorm2d(n_channels[3])\n        self.relu = nn.ReLU(inplace=True)\n        self.fc = nn.Linear(n_channels[3], num_classes)\n        self.n_channels = n_channels[3]\n\n        for m in self.modules():\n            if isinstance(m, nn.Conv2d):\n                nn.init.kaiming_normal_(m.weight, mode=\"fan_out\", nonlinearity=\"relu\")\n            elif isinstance(m, nn.BatchNorm2d):\n                m.weight.data.fill_(1)\n                m.bias.data.zero_()\n            elif isinstance(m, nn.Linear):\n                m.bias.data.zero_()\n\n    def forward_features(self, x):\n        x = self.conv1(x)\n        x = self.block1(x)\n        x = self.block2(x)\n        x = self.block3(x)\n        x = self.relu(self.bn1(x))\n        x = F.avg_pool2d(x, 8, 1, 0)\n        x = x.view(-1, self.n_channels)\n        return x\n\n    def forward_classifier(self, x):\n        return self.fc(x)\n\n    def forward(self, x):\n        x = self.forward_features(x)\n        x = self.forward_classifier(x)\n        return x\n\n\ndef wide_resnet_28x10(num_classes):\n    return WideResNet(depth=28, widen_factor=10, num_classes=num_classes)\n\n\nclass Cifar10ClassificationModel(BaseDiscriminator):\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n        self.base_model = wide_resnet_28x10(num_classes=10)\n        num_features = self.base_model.fc.in_features\n        self.discriminator = nn.Sequential(\n            nn.Linear(num_features, num_features), nn.ReLU(), nn.Linear(num_features, 1)\n        )\n\n    def forward(self, input):\n        x = self.base_model.forward_features(input)\n        return self.base_model.forward_classifier(x), self.discriminator(x).view(-1)\n</code></pre>"},{"location":"autoalbument/examples/cityscapes/","title":"Semantic segmentation on Cityscapes dataset","text":"<p>The following files are also available on GitHub - https://github.com/albumentations-team/autoalbument/tree/master/examples/cityscapes</p>"},{"location":"autoalbument/examples/cityscapes/#datasetpy","title":"dataset.py","text":"Python<pre><code>import cv2\nimport numpy as np\nimport torchvision\n\ncv2.setNumThreads(0)\ncv2.ocl.setUseOpenCL(False)\n\n\nclass CityscapesSearchDataset(torchvision.datasets.Cityscapes):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs, target_type=\"semantic\")\n        self.semantic_target_type_index = [i for i, t in enumerate(self.target_type) if t == \"semantic\"][0]\n        self.colormap = self._generate_colormap()\n\n    def _generate_colormap(self):\n        colormap = {}\n        for class_ in self.classes:\n            if class_.train_id in (-1, 255):\n                continue\n            colormap[class_.train_id] = class_.id\n        return colormap\n\n    def _convert_to_segmentation_mask(self, mask):\n        height, width = mask.shape[:2]\n        segmentation_mask = np.zeros((height, width, len(self.colormap)), dtype=np.float32)\n        for label_index, label in self.colormap.items():\n            segmentation_mask[:, :, label_index] = (mask == label).astype(float)\n        return segmentation_mask\n\n    def __getitem__(self, index):\n        image = cv2.imread(self.images[index])\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        mask = cv2.imread(self.targets[index][self.semantic_target_type_index], cv2.IMREAD_UNCHANGED)\n\n        mask = self._convert_to_segmentation_mask(mask)\n\n        if self.transform is not None:\n            transformed = self.transform(image=image, mask=mask)\n            image = transformed[\"image\"]\n            mask = transformed[\"mask\"]\n\n        return image, mask\n</code></pre>"},{"location":"autoalbument/examples/cityscapes/#searchyaml","title":"search.yaml","text":"YAML<pre><code># @package _global_\n\n_version: 2  # An internal value that indicates a version of the config schema. This value is used by\n# `autoalbument-search` and `autoalbument-migrate` to upgrade the config to the latest version if necessary.\n# Please do not change it manually.\n\ntask: semantic_segmentation # Deep learning task. Should either be `classification` or `semantic_segmentation`.\n\npolicy_model:\n  # Settings for Policy Model that searches augmentation policies.\n\n  task_factor: 0.1\n  # Multiplier for segmentation loss of a model. Faster AutoAugment uses segmentation loss to prevent augmentations\n  # from transforming images of a particular class to another class.\n\n  gp_factor: 10\n  # Multiplier for the gradient penalty for WGAN-GP training. 10 is the default value that was proposed in\n  # `Improved Training of Wasserstein GANs`.\n\n  temperature: 0.05\n  # Temperature for Relaxed Bernoulli distribution. The probability of applying a certain augmentation is sampled from\n  # Relaxed Bernoulli distribution (because Bernoulli distribution is not differentiable). With lower values of\n  # `temperature` Relaxed Bernoulli distribution behaves like Bernoulli distribution. In the paper, the authors\n  # of Faster AutoAugment used 0.05 as a default value for `temperature`.\n\n  num_sub_policies: 25\n  # Number of augmentation sub-policies. When an image passes through an augmentation pipeline, Faster AutoAugment\n  # randomly chooses one sub-policy and uses augmentations from that sub-policy to transform an input image. A larger\n  # number of sub-policies leads to a more diverse set of augmentations and better performance of a model trained on\n  # augmented images. However, an increase in the number of sub-policies leads to the exponential growth of a search\n  # space of augmentations, so you need more training data for Policy Model to find good augmentation policies.\n\n  num_chunks: 4\n  # Number of chunks in a batch. Faster AutoAugment splits each batch of images into `num_chunks` chunks. Then it\n  # applies the same sub-policy with the same parameters to each image in a chunk. This parameter controls the tradeoff\n  # between the speed of augmentation search and diversity of augmentations. Larger `num_chunks` values will lead to\n  # faster searching but less diverse set of augmentations. Note that this parameter is used only in the searching\n  # phase. When you train a model with found sub-policies, Albumentations will apply a distinct set of transformations\n  # to each image separately.\n\n  operation_count: 4\n  # Number of consecutive augmentations in each sub-policy. Faster AutoAugment will sequentially apply `operation_count`\n  # augmentations from a sub-policy to an image. Larger values of `operation_count` lead to better performance of\n  # a model trained on augmented images. Simultaneously, larger values of `operation_count` affect the speed of search\n  # and increase the searching time.\n\nsemantic_segmentation_model:\n  # Settings for Semantic Segmentation Model that is used for two purposes:\n  # 1. As a model that performs semantic segmentation of input images.\n  # 2. As a Discriminator for Policy Model.\n\n  _target_: autoalbument.faster_autoaugment.models.SemanticSegmentationModel\n  # By default, AutoAlbument uses an instance of `autoalbument.faster_autoaugment.models.SemanticSegmentationModel` as\n  # a semantic segmentation model.\n  # This model takes four parameters: `num_classes`, `architecture`, `encoder_architecture` and `pretrained`.\n\n  num_classes: 19\n  # The number of classes in the dataset. The dataset implementation should return a mask as a NumPy array with\n  # the shape [height, width, num_classes]. In a case of binary segmentation you can set `num_classes` to 1.\n\n  architecture: DeepLabV3Plus\n  # The architecture of Semantic Segmentation Model. AutoAlbument uses models from\n  # https://github.com/qubvel/segmentation_models.pytorch. Please refer to its documentation to get a list of available\n  # models - https://github.com/qubvel/segmentation_models.pytorch#models-.\n\n  encoder_architecture: resnet50\n  # The architecture of encoder in Semantic Segmentation Model. Please refer to Segmentation Models' documentation to\n  # get a list of available encoders - https://github.com/qubvel/segmentation_models.pytorch#encoders-\n\n  pretrained: true\n  # Either boolean flag or string with that indicates whether the selected encoder architecture should load pretrained\n  # weights or use randomly initialized weights.\n  # - In the case of boolean flag `true` means using pretrained weights from ImageNet and `false` means using randomly\n  #   initialized weights.\n  # - In the case of string the value should specify the name of the weights. For the list of available weights please\n  #   refer to https://github.com/qubvel/segmentation_models.pytorch#encoders-\n\ndata:\n  dataset:\n    _target_: dataset.CityscapesSearchDataset\n    root: ~/data/cityscapes/data\n    split: train\n  # Class for the PyTorch Dataset and arguments to it. AutoAlbument will create an object of this class using\n  # the `instantiate` method from Hydra - https://hydra.cc/docs/next/patterns/instantiate_objects/overview/.\n  #\n  # Note that the target class value in the `_target_` argument should be located inside PYTHONPATH so Hydra could\n  # find it. The directory with the config file is automatically added to PYTHONPATH, so the default value\n  # `dataset.SearchDataset` points to the class `SearchDataset` from the `dataset.py` file. This `dataset.py` file is\n  # located along with the `search.yaml` file in the same directory provided by `--config-dir`.\n  #\n  # As an alternative, you could provide a path to a Python file with the dataset using the `dataset_file` parameter\n  # instead of the `dataset` parameter. The Python file should contain the implementation of a PyTorch dataset for\n  # augmentation search. The dataset class should have named `SearchDataset`. The value in `dataset_file` could either\n  # be a relative or an absolute path ; in the case of a relative path, the path should be relative to this config\n  # file's location.\n  #\n  # - Example of a relative path:\n  # dataset_file: dataset.py\n  #\n  # - Example of an absolute path:\n  # dataset_file: /projects/pytorch/dataset.py\n  #\n\n  input_dtype: uint8\n  # The data type of input images. Two values are supported:\n  # - uint8. In that case, all input images should be NumPy arrays with the np.uint8 data type and values in the range\n  #   [0, 255].\n  # - float32. In that case, all input images should be NumPy arrays with the np.float32 data type and values in the\n  #   range [0.0, 1.0].\n\n  preprocessing:\n  - LongestMaxSize:\n      max_size: 256\n  - PadIfNeeded:\n      min_height: 256\n      min_width: 256\n      border_mode: 0\n      value: [0, 0, 0]\n  # A list of preprocessing augmentations that will be applied to each image before applying augmentations from\n  # a policy. A preprocessing augmentation should be defined as `key`: `value`, where `key` is the name of augmentation\n  # from Albumentations, and `value` is a dictionary with augmentation parameters. The found policy will also apply\n  # those preprocessing augmentations before applying the main augmentations.\n  #\n  # Here is an example of an augmentation pipeline that first pads an image to the size 512x512 pixels, then resizes\n  # the resulting image to the size 256x256 pixels and finally crops a random patch with the size 224x224 pixels.\n  #\n  #  preprocessing:\n  #    - PadIfNeeded:\n  #        min_height: 512\n  #        min_width: 512\n  #    - Resize:\n  #        height: 256\n  #        width: 256\n  #    - RandomCrop:\n  #        height: 224\n  #        width: 224\n  #\n\n  normalization:\n    mean: [0.485, 0.456, 0.406]\n    std: [0.229, 0.224, 0.225]\n  # Normalization values for images. For each image, the search pipeline will subtract `mean` and divide by `std`.\n  # Normalization is applied after transforms defined in `preprocessing`. Note that regardless of `input_dtype`,\n  # the normalization function will always receive a `float32` input with values in the range [0.0, 1.0], so you should\n  # define `mean` and `std` values accordingly. ImageNet normalization is used by default.\n\n  dataloader:\n    _target_: torch.utils.data.DataLoader\n    batch_size: 32\n    shuffle: true\n    num_workers: 8\n    pin_memory: true\n    drop_last: true\n  # Parameters for the PyTorch DataLoader. Please refer to the PyTorch documentation for the description of parameters -\n  # https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader.\n\noptim:\n  main:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n  # Optimizer configuration for the main (either Classification or Semantic Segmentation) Model\n\n  policy:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n  # Optimizer configuration for Policy Model\n\nseed: 42 # Random seed. If the value is not null, it will be passed to `seed_everything` -\n# https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.utilities.seed.html?highlight=seed_everything\n\nhydra:\n  run:\n    dir: ${config_dir:}/outputs/${now:%Y-%m-%d}/${now:%H-%M-%S}\n    # Path to the directory that will contain all outputs produced by the search algorithm. `${config_dir:}` contains\n    # path to the directory with the `search.yaml` config file. Please refer to the Hydra documentation for more\n    # information - https://hydra.cc/docs/configure_hydra/workdir.\n\ntrainer:\n  # Configuration for PyTorch Lightning Trainer. You can read more about Trainer and its arguments at\n  # https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html.\n  max_epochs: 50\n  # Number of epochs to search for augmentation parameters.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#max-epochs\n\n  benchmark: true\n  # If true enables cudnn.benchmark.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#benchmark\n\n  gpus: 1\n  # Number of GPUs to train on. Set to `0` or None` to use CPU for training.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#gpus\n</code></pre>"},{"location":"autoalbument/examples/imagenet/","title":"Image classification on the ImageNet dataset","text":"<p>The following files are also available on GitHub - https://github.com/albumentations-team/autoalbument/tree/master/examples/imagenet</p>"},{"location":"autoalbument/examples/imagenet/#datasetpy","title":"dataset.py","text":"Python<pre><code>import cv2\nimport torchvision\n\ncv2.setNumThreads(0)\ncv2.ocl.setUseOpenCL(False)\n\n\nclass ImageNetSearchDataset(torchvision.datasets.ImageNet):\n    def __getitem__(self, index):\n        path, label = self.samples[index]\n        image = cv2.imread(path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        if self.transform is not None:\n            transformed = self.transform(image=image)\n            image = transformed[\"image\"]\n\n        return image, label\n</code></pre>"},{"location":"autoalbument/examples/imagenet/#searchyaml","title":"search.yaml","text":"YAML<pre><code># @package _global_\n\n_version: 2  # An internal value that indicates a version of the config schema. This value is used by\n# `autoalbument-search` and `autoalbument-migrate` to upgrade the config to the latest version if necessary.\n# Please do not change it manually.\n\n\ntask: classification # Deep learning task. Should either be `classification` or `semantic_segmentation`.\n\n\npolicy_model:\n  # Settings for Policy Model that searches augmentation policies.\n\n  task_factor: 0.1\n  # Multiplier for classification loss of a model. Faster AutoAugment uses classification loss to prevent augmentations\n  # from transforming images of a particular class to another class. The authors of Faster AutoAugment use 0.1 as\n  # default value.\n\n  gp_factor: 10\n  # Multiplier for the gradient penalty for WGAN-GP training. 10 is the default value that was proposed in\n  # `Improved Training of Wasserstein GANs`.\n\n  temperature: 0.05\n  # Temperature for Relaxed Bernoulli distribution. The probability of applying a certain augmentation is sampled from\n  # Relaxed Bernoulli distribution (because Bernoulli distribution is not differentiable). With lower values of\n  # `temperature` Relaxed Bernoulli distribution behaves like Bernoulli distribution. In the paper, the authors\n  # of Faster AutoAugment used 0.05 as a default value for `temperature`.\n\n  num_sub_policies: 100\n  # Number of augmentation sub-policies. When an image passes through an augmentation pipeline, Faster AutoAugment\n  # randomly chooses one sub-policy and uses augmentations from that sub-policy to transform an input image. A larger\n  # number of sub-policies leads to a more diverse set of augmentations and better performance of a model trained on\n  # augmented images. However, an increase in the number of sub-policies leads to the exponential growth of a search\n  # space of augmentations, so you need more training data for Policy Model to find good augmentation policies.\n\n  num_chunks: 6\n  # Number of chunks in a batch. Faster AutoAugment splits each batch of images into `num_chunks` chunks. Then it\n  # applies the same sub-policy with the same parameters to each image in a chunk. This parameter controls the tradeoff\n  # between the speed of augmentation search and diversity of augmentations. Larger `num_chunks` values will lead to\n  # faster searching but less diverse set of augmentations. Note that this parameter is used only in the searching\n  # phase. When you train a model with found sub-policies, Albumentations will apply a distinct set of transformations\n  # to each image separately.\n\n  operation_count: 4\n  # Number of consecutive augmentations in each sub-policy. Faster AutoAugment will sequentially apply `operation_count`\n  # augmentations from a sub-policy to an image. Larger values of `operation_count` lead to better performance of\n  # a model trained on augmented images. Simultaneously, larger values of `operation_count` affect the speed of search\n  # and increase the searching time.\n\nclassification_model:\n  # Settings for Classification Model that is used for two purposes:\n  # 1. As a model that performs classification of input images.\n  # 2. As a Discriminator for Policy Model.\n\n  num_classes: 1000\n  # Number of classes in the dataset. The dataset implementation should return an integer in the range\n  # [0, num_classes - 1] as a class label of an image.\n\n  architecture: resnet50\n  # The architecture of Classification Model. AutoAlbument uses models from\n  # https://github.com/rwightman/pytorch-image-models/. Please refer to its documentation to get a list of available\n  # models - https://rwightman.github.io/pytorch-image-models/#list-models-with-pretrained-weights.\n\n  pretrained: false\n  # Boolean flag that indicates whether the selected model architecture should load pretrained weights or use randomly\n  # initialized weights.\n\ndata:\n  dataset:\n    _target_: dataset.ImageNetSearchDataset\n    root: ~/data/imagenet\n    split: train\n  # Class for the PyTorch Dataset and arguments to it. AutoAlbument will create an object of this class using\n  # the `instantiate` method from Hydra - https://hydra.cc/docs/next/patterns/instantiate_objects/overview/.\n  #\n  # Note that the target class value in the `_target_` argument should be located inside PYTHONPATH so Hydra could\n  # find it. The directory with the config file is automatically added to PYTHONPATH, so the default value\n  # `dataset.SearchDataset` points to the class `SearchDataset` from the `dataset.py` file. This `dataset.py` file is\n  # located along with the `search.yaml` file in the same directory provided by `--config-dir`.\n  #\n  # As an alternative, you could provide a path to a Python file with the dataset using the `dataset_file` parameter\n  # instead of the `dataset` parameter. The Python file should contain the implementation of a PyTorch dataset for\n  # augmentation search. The dataset class should have named `SearchDataset`. The value in `dataset_file` could either\n  # be a relative or an absolute path ; in the case of a relative path, the path should be relative to this config\n  # file's location.\n  #\n  # - Example of a relative path:\n  # dataset_file: dataset.py\n  #\n  # - Example of an absolute path:\n  # dataset_file: /projects/pytorch/dataset.py\n  #\n\n  input_dtype: uint8\n  # The data type of input images. Two values are supported:\n  # - uint8. In that case, all input images should be NumPy arrays with the np.uint8 data type and values in the range\n  #   [0, 255].\n  # - float32. In that case, all input images should be NumPy arrays with the np.float32 data type and values in the\n  #   range [0.0, 1.0].\n\n  preprocessing:\n  - Resize:\n      height: 256\n      width: 256\n  - RandomCrop:\n      height: 224\n      width: 224\n  # A list of preprocessing augmentations that will be applied to each image before applying augmentations from\n  # a policy. A preprocessing augmentation should be defined as `key`: `value`, where `key` is the name of augmentation\n  # from Albumentations, and `value` is a dictionary with augmentation parameters. The found policy will also apply\n  # those preprocessing augmentations before applying the main augmentations.\n  #\n  # Here is an example of an augmentation pipeline that first pads an image to the size 512x512 pixels, then resizes\n  # the resulting image to the size 256x256 pixels and finally crops a random patch with the size 224x224 pixels.\n  #\n  #  preprocessing:\n  #    - PadIfNeeded:\n  #        min_height: 512\n  #        min_width: 512\n  #    - Resize:\n  #        height: 256\n  #        width: 256\n  #    - RandomCrop:\n  #        height: 224\n  #        width: 224\n  #\n\n  normalization:\n    mean: [0.485, 0.456, 0.406]\n    std: [0.229, 0.224, 0.225]\n  # Normalization values for images. For each image, the search pipeline will subtract `mean` and divide by `std`.\n  # Normalization is applied after transforms defined in `preprocessing`. Note that regardless of `input_dtype`,\n  # the normalization function will always receive a `float32` input with values in the range [0.0, 1.0], so you should\n  # define `mean` and `std` values accordingly.\n\n  dataloader:\n    _target_: torch.utils.data.DataLoader\n    batch_size: 96\n    shuffle: true\n    num_workers: 8\n    pin_memory: true\n    drop_last: true\n  # Parameters for the PyTorch DataLoader. Please refer to the PyTorch documentation for the description of parameters -\n  # https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader.\n\noptim:\n  main:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n  # Optimizer configuration for the main (either Classification or Semantic Segmentation) Model\n\n\n  policy:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n  # Optimizer configuration for Policy Model\n\n\nseed: 42 # Random seed. If the value is not null, it will be passed to `seed_everything` -\n# https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.utilities.seed.html?highlight=seed_everything\n\nhydra:\n  run:\n    dir: ${config_dir:}/outputs/${now:%Y-%m-%d}/${now:%H-%M-%S}\n    # Path to the directory that will contain all outputs produced by the search algorithm. `${config_dir:}` contains\n    # path to the directory with the `search.yaml` config file. Please refer to the Hydra documentation for more\n    # information - https://hydra.cc/docs/configure_hydra/workdir.\n\ntrainer:\n  # Configuration for PyTorch Lightning Trainer. You can read more about Trainer and its arguments at\n  # https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html.\n  max_epochs: 1\n  # Number of epochs to search for augmentation parameters.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#max-epochs\n\n  benchmark: true\n  # If true enables cudnn.benchmark.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#benchmark\n\n  gpus: 1\n  # Number of GPUs to train on. Set to `0` or None` to use CPU for training.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#gpus\n</code></pre>"},{"location":"autoalbument/examples/list/","title":"List of examples","text":"<ul> <li>Image classification on the CIFAR10 dataset.</li> <li>Image classification on the SVHN dataset.</li> <li>Image classification on the ImageNet dataset.</li> <li>Semantic segmentation on the Pascal VOC dataset.</li> <li>Semantic segmentation on the Cityscapes dataset.</li> </ul> <p>To run the search with an example config:</p> Bash<pre><code>autoalbument-search --config-dir &lt;/path/to/directory_with_dataset.py_and_search.yaml&gt;\n</code></pre>"},{"location":"autoalbument/examples/pascal_voc/","title":"Semantic segmentation on the Pascal VOC dataset","text":"<p>The following files are also available on GitHub - https://github.com/albumentations-team/autoalbument/tree/master/examples/pascal_voc</p>"},{"location":"autoalbument/examples/pascal_voc/#datasetpy","title":"dataset.py","text":"Python<pre><code>import cv2\nimport numpy as np\nfrom torchvision.datasets import VOCSegmentation\n\ncv2.setNumThreads(0)\ncv2.ocl.setUseOpenCL(False)\n\n\nVOC_CLASSES = [\n    \"background\",\n    \"aeroplane\",\n    \"bicycle\",\n    \"bird\",\n    \"boat\",\n    \"bottle\",\n    \"bus\",\n    \"car\",\n    \"cat\",\n    \"chair\",\n    \"cow\",\n    \"diningtable\",\n    \"dog\",\n    \"horse\",\n    \"motorbike\",\n    \"person\",\n    \"potted plant\",\n    \"sheep\",\n    \"sofa\",\n    \"train\",\n    \"tv/monitor\",\n]\n\n\nVOC_COLORMAP = [\n    [0, 0, 0],\n    [128, 0, 0],\n    [0, 128, 0],\n    [128, 128, 0],\n    [0, 0, 128],\n    [128, 0, 128],\n    [0, 128, 128],\n    [128, 128, 128],\n    [64, 0, 0],\n    [192, 0, 0],\n    [64, 128, 0],\n    [192, 128, 0],\n    [64, 0, 128],\n    [192, 0, 128],\n    [64, 128, 128],\n    [192, 128, 128],\n    [0, 64, 0],\n    [128, 64, 0],\n    [0, 192, 0],\n    [128, 192, 0],\n    [0, 64, 128],\n]\n\n\nclass PascalVOCSearchDataset(VOCSegmentation):\n    def __init__(self, root=\"~/data/pascal_voc\", image_set=\"train\", download=True, transform=None):\n        super().__init__(root=root, image_set=image_set, download=download, transform=transform)\n\n    @staticmethod\n    def _convert_to_segmentation_mask(mask):\n        # This function converts a mask from the Pascal VOC format to the format required by AutoAlbument.\n        #\n        # Pascal VOC uses an RGB image to encode the segmentation mask for that image. RGB values of a pixel\n        # encode the pixel's class.\n        #\n        # AutoAlbument requires a segmentation mask to be a NumPy array with the shape [height, width, num_classes].\n        # Each channel in this mask should encode values for a single class. Pixel in a mask channel should have\n        # a value of 1.0 if the pixel of the image belongs to this class and 0.0 otherwise.\n        height, width = mask.shape[:2]\n        segmentation_mask = np.zeros((height, width, len(VOC_COLORMAP)), dtype=np.float32)\n        for label_index, label in enumerate(VOC_COLORMAP):\n            segmentation_mask[:, :, label_index] = np.all(mask == label, axis=-1).astype(float)\n        return segmentation_mask\n\n    def __getitem__(self, index):\n        image = cv2.imread(self.images[index])\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        mask = cv2.imread(self.masks[index])\n        mask = cv2.cvtColor(mask, cv2.COLOR_BGR2RGB)\n        mask = self._convert_to_segmentation_mask(mask)\n        if self.transform is not None:\n            transformed = self.transform(image=image, mask=mask)\n            image = transformed[\"image\"]\n            mask = transformed[\"mask\"]\n        return image, mask\n</code></pre>"},{"location":"autoalbument/examples/pascal_voc/#searchyaml","title":"search.yaml","text":"YAML<pre><code># @package _global_\n\n_version: 2  # An internal value that indicates a version of the config schema. This value is used by\n# `autoalbument-search` and `autoalbument-migrate` to upgrade the config to the latest version if necessary.\n# Please do not change it manually.\n\n\ntask: semantic_segmentation # Deep learning task. Should either be `classification` or `semantic_segmentation`.\n\n\npolicy_model:\n  # Settings for Policy Model that searches augmentation policies.\n\n  task_factor: 0.1\n  # Multiplier for segmentation loss of a model. Faster AutoAugment uses segmentation loss to prevent augmentations\n  # from transforming images of a particular class to another class.\n\n  gp_factor: 10\n  # Multiplier for the gradient penalty for WGAN-GP training. 10 is the default value that was proposed in\n  # `Improved Training of Wasserstein GANs`.\n\n  temperature: 0.05\n  # Temperature for Relaxed Bernoulli distribution. The probability of applying a certain augmentation is sampled from\n  # Relaxed Bernoulli distribution (because Bernoulli distribution is not differentiable). With lower values of\n  # `temperature` Relaxed Bernoulli distribution behaves like Bernoulli distribution. In the paper, the authors\n  # of Faster AutoAugment used 0.05 as a default value for `temperature`.\n\n  num_sub_policies: 25\n  # Number of augmentation sub-policies. When an image passes through an augmentation pipeline, Faster AutoAugment\n  # randomly chooses one sub-policy and uses augmentations from that sub-policy to transform an input image. A larger\n  # number of sub-policies leads to a more diverse set of augmentations and better performance of a model trained on\n  # augmented images. However, an increase in the number of sub-policies leads to the exponential growth of a search\n  # space of augmentations, so you need more training data for Policy Model to find good augmentation policies.\n\n  num_chunks: 4\n  # Number of chunks in a batch. Faster AutoAugment splits each batch of images into `num_chunks` chunks. Then it\n  # applies the same sub-policy with the same parameters to each image in a chunk. This parameter controls the tradeoff\n  # between the speed of augmentation search and diversity of augmentations. Larger `num_chunks` values will lead to\n  # faster searching but less diverse set of augmentations. Note that this parameter is used only in the searching\n  # phase. When you train a model with found sub-policies, Albumentations will apply a distinct set of transformations\n  # to each image separately.\n\n  operation_count: 4\n  # Number of consecutive augmentations in each sub-policy. Faster AutoAugment will sequentially apply `operation_count`\n  # augmentations from a sub-policy to an image. Larger values of `operation_count` lead to better performance of\n  # a model trained on augmented images. Simultaneously, larger values of `operation_count` affect the speed of search\n  # and increase the searching time.\n\nsemantic_segmentation_model:\n  # Settings for Semantic Segmentation Model that is used for two purposes:\n  # 1. As a model that performs semantic segmentation of input images.\n  # 2. As a Discriminator for Policy Model.\n\n  _target_: autoalbument.faster_autoaugment.models.SemanticSegmentationModel\n  # By default, AutoAlbument uses an instance of `autoalbument.faster_autoaugment.models.SemanticSegmentationModel` as\n  # a semantic segmentation model.\n  # This model takes four parameters: `num_classes`, `architecture`, `encoder_architecture` and `pretrained`.\n\n  num_classes: 21\n  # The number of classes in the dataset. The dataset implementation should return a mask as a NumPy array with\n  # the shape [height, width, num_classes]. In a case of binary segmentation you can set `num_classes` to 1.\n\n  architecture: DeepLabV3Plus\n  # The architecture of Semantic Segmentation Model. AutoAlbument uses models from\n  # https://github.com/qubvel/segmentation_models.pytorch. Please refer to its documentation to get a list of available\n  # models - https://github.com/qubvel/segmentation_models.pytorch#models-.\n\n  encoder_architecture: resnet50\n  # The architecture of encoder in Semantic Segmentation Model. Please refer to Segmentation Models' documentation to\n  # get a list of available encoders - https://github.com/qubvel/segmentation_models.pytorch#encoders-\n\n  pretrained: true\n  # Either boolean flag or string with that indicates whether the selected encoder architecture should load pretrained\n  # weights or use randomly initialized weights.\n  # - In the case of boolean flag `true` means using pretrained weights from ImageNet and `false` means using randomly\n  #   initialized weights.\n  # - In the case of string the value should specify the name of the weights. For the list of available weights please\n  #   refer to https://github.com/qubvel/segmentation_models.pytorch#encoders-\n\ndata:\n  dataset:\n    _target_: dataset.PascalVOCSearchDataset\n    root: ~/data/pascal_voc\n    image_set: train\n    download: false\n  # Class for the PyTorch Dataset and arguments to it. AutoAlbument will create an object of this class using\n  # the `instantiate` method from Hydra - https://hydra.cc/docs/next/patterns/instantiate_objects/overview/.\n  #\n  # Note that the target class value in the `_target_` argument should be located inside PYTHONPATH so Hydra could\n  # find it. The directory with the config file is automatically added to PYTHONPATH, so the default value\n  # `dataset.SearchDataset` points to the class `SearchDataset` from the `dataset.py` file. This `dataset.py` file is\n  # located along with the `search.yaml` file in the same directory provided by `--config-dir`.\n  #\n  # As an alternative, you could provide a path to a Python file with the dataset using the `dataset_file` parameter\n  # instead of the `dataset` parameter. The Python file should contain the implementation of a PyTorch dataset for\n  # augmentation search. The dataset class should have named `SearchDataset`. The value in `dataset_file` could either\n  # be a relative or an absolute path ; in the case of a relative path, the path should be relative to this config\n  # file's location.\n  #\n  # - Example of a relative path:\n  # dataset_file: dataset.py\n  #\n  # - Example of an absolute path:\n  # dataset_file: /projects/pytorch/dataset.py\n  #\n\n  input_dtype: uint8\n  # The data type of input images. Two values are supported:\n  # - uint8. In that case, all input images should be NumPy arrays with the np.uint8 data type and values in the range\n  #   [0, 255].\n  # - float32. In that case, all input images should be NumPy arrays with the np.float32 data type and values in the\n  #   range [0.0, 1.0].\n\n  preprocessing:\n  - LongestMaxSize:\n      max_size: 256\n  - PadIfNeeded:\n      min_height: 256\n      min_width: 256\n      border_mode: 0\n      value: [0, 0, 0]\n  # A list of preprocessing augmentations that will be applied to each image before applying augmentations from\n  # a policy. A preprocessing augmentation should be defined as `key`: `value`, where `key` is the name of augmentation\n  # from Albumentations, and `value` is a dictionary with augmentation parameters. The found policy will also apply\n  # those preprocessing augmentations before applying the main augmentations.\n  #\n  # Here is an example of an augmentation pipeline that first pads an image to the size 512x512 pixels, then resizes\n  # the resulting image to the size 256x256 pixels and finally crops a random patch with the size 224x224 pixels.\n  #\n  #  preprocessing:\n  #    - PadIfNeeded:\n  #        min_height: 512\n  #        min_width: 512\n  #    - Resize:\n  #        height: 256\n  #        width: 256\n  #    - RandomCrop:\n  #        height: 224\n  #        width: 224\n  #\n\n  normalization:\n    mean: [0.485, 0.456, 0.406]\n    std: [0.229, 0.224, 0.225]\n  # Normalization values for images. For each image, the search pipeline will subtract `mean` and divide by `std`.\n  # Normalization is applied after transforms defined in `preprocessing`. Note that regardless of `input_dtype`,\n  # the normalization function will always receive a `float32` input with values in the range [0.0, 1.0], so you should\n  # define `mean` and `std` values accordingly. ImageNet normalization is used by default.\n\n  dataloader:\n    _target_: torch.utils.data.DataLoader\n    batch_size: 32\n    shuffle: true\n    num_workers: 8\n    pin_memory: true\n    drop_last: true\n  # Parameters for the PyTorch DataLoader. Please refer to the PyTorch documentation for the description of parameters -\n  # https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader.\n\n\noptim:\n  main:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n  # Optimizer configuration for the main (either Classification or Semantic Segmentation) Model\n\n  policy:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n  # Optimizer configuration for Policy Model\n\n\nseed: 42 # Random seed. If the value is not null, it will be passed to `seed_everything` -\n# https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.utilities.seed.html?highlight=seed_everything\n\n\nhydra:\n  run:\n    dir: ${config_dir:}/outputs/${now:%Y-%m-%d}/${now:%H-%M-%S}\n    # Path to the directory that will contain all outputs produced by the search algorithm. `${config_dir:}` contains\n    # path to the directory with the `search.yaml` config file. Please refer to the Hydra documentation for more\n    # information - https://hydra.cc/docs/configure_hydra/workdir.\n\n\ntrainer:\n  # Configuration for PyTorch Lightning Trainer. You can read more about Trainer and its arguments at\n  # https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html.\n  max_epochs: 50\n  # Number of epochs to search for augmentation parameters.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#max-epochs\n\n  benchmark: true\n  # If true enables cudnn.benchmark.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#benchmark\n\n  gpus: 1\n  # Number of GPUs to train on. Set to `0` or None` to use CPU for training.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#gpus\n</code></pre>"},{"location":"autoalbument/examples/svhn/","title":"Image classification on the SVHN dataset","text":"<p>The following files are also available on GitHub - https://github.com/albumentations-team/autoalbument/tree/master/examples/svhn</p>"},{"location":"autoalbument/examples/svhn/#datasetpy","title":"dataset.py","text":"Python<pre><code>import cv2\nimport numpy as np\nimport torch\nimport torchvision\n\ncv2.setNumThreads(0)\ncv2.ocl.setUseOpenCL(False)\n\n\nclass SVHNSearchDataset(torchvision.datasets.SVHN):\n    def __getitem__(self, index):\n        image, label = self.data[index], int(self.labels[index])\n        image = np.transpose(image, (1, 2, 0))\n\n        if self.transform is not None:\n            transformed = self.transform(image=image)\n            image = transformed[\"image\"]\n\n        return image, label\n\n\nclass ConcatSVHNSearchDataset(torch.utils.data.ConcatDataset):\n    def __init__(self, root, download, transform=None):\n        datasets = [\n            SVHNSearchDataset(root=root, split=\"train\", download=download, transform=transform),\n            SVHNSearchDataset(root=root, split=\"extra\", download=download, transform=transform),\n        ]\n        super().__init__(datasets)\n</code></pre>"},{"location":"autoalbument/examples/svhn/#searchyaml","title":"search.yaml","text":"YAML<pre><code># @package _global_\n\n_version: 2  # An internal value that indicates a version of the config schema. This value is used by\n# `autoalbument-search` and `autoalbument-migrate` to upgrade the config to the latest version if necessary.\n# Please do not change it manually.\n\ntask: classification # Deep learning task. Should either be `classification` or `semantic_segmentation`.\n\n# Settings for Policy Model that searches augmentation policies.\npolicy_model:\n\n  # Multiplier for classification loss of a model. Faster AutoAugment uses classification loss to prevent augmentations\n  # from transforming images of a particular class to another class. The authors of Faster AutoAugment use 0.1 as\n  # default value.\n  task_factor: 0.1\n\n  # Multiplier for the gradient penalty for WGAN-GP training. 10 is the default value that was proposed in\n  # `Improved Training of Wasserstein GANs`.\n  gp_factor: 10\n\n  # Temperature for Relaxed Bernoulli distribution. The probability of applying a certain augmentation is sampled from\n  # Relaxed Bernoulli distribution (because Bernoulli distribution is not differentiable). With lower values of\n  # `temperature` Relaxed Bernoulli distribution behaves like Bernoulli distribution. In the paper, the authors\n  # of Faster AutoAugment used 0.05 as a default value for `temperature`.\n  temperature: 0.05\n\n  # Number of augmentation sub-policies. When an image passes through an augmentation pipeline, Faster AutoAugment\n  # randomly chooses one sub-policy and uses augmentations from that sub-policy to transform an input image. A larger\n  # number of sub-policies leads to a more diverse set of augmentations and better performance of a model trained on\n  # augmented images. However, an increase in the number of sub-policies leads to the exponential growth of a search\n  # space of augmentations, so you need more training data for Policy Model to find good augmentation policies.\n  num_sub_policies: 100\n\n  # Number of chunks in a batch. Faster AutoAugment splits each batch of images into `num_chunks` chunks. Then it\n  # applies the same sub-policy with the same parameters to each image in a chunk. This parameter controls the tradeoff\n  # between the speed of augmentation search and diversity of augmentations. Larger `num_chunks` values will lead to\n  # faster searching but less diverse set of augmentations. Note that this parameter is used only in the searching\n  # phase. When you train a model with found sub-policies, Albumentations will apply a distinct set of transformations\n  # to each image separately.\n  num_chunks: 8\n\n  # Number of consecutive augmentations in each sub-policy. Faster AutoAugment will sequentially apply `operation_count`\n  # augmentations from a sub-policy to an image. Larger values of `operation_count` lead to better performance of\n  # a model trained on augmented images. Simultaneously, larger values of `operation_count` affect the speed of search\n  # and increase the searching time.\n  operation_count: 4\n\n# Settings for Classification Model that is used for two purposes:\n# 1. As a model that performs classification of input images.\n# 2. As a Discriminator for Policy Model.\nclassification_model:\n  # A custom classification model is used. This model is defined inside the `model.py` file which is located\n  # in the same directory with `search.yaml` and `dataset.py`.\n  _target_: model.SVHNClassificationModel\n\n  #  # As an alternative, you could use a built-in AutoAldbument model using the following config:\n  #  #  _target_: autoalbument.faster_autoaugment.models.ClassificationModel\n  #\n  #  # Number of classes in the dataset. The dataset implementation should return an integer in the range\n  #  # [0, num_classes - 1] as a class label of an image.\n  #  num_classes: 10\n  #\n  #  # The architecture of Classification Model. AutoAlbument uses models from\n  #  # https://github.com/rwightman/pytorch-image-models/. Please refer to its documentation to get a list of available\n  #  # models - https://rwightman.github.io/pytorch-image-models/#list-models-with-pretrained-weights.\n  #  architecture: resnet18\n  #\n  #  # Boolean flag that indicates whether the selected model architecture should load pretrained weights or use randomly\n  #  # initialized weights.\n  #  pretrained: False\n\ndata:\n  # Class for the PyTorch Dataset and arguments to it. AutoAlbument will create an object of this class using\n  # the `instantiate` method from Hydra - https://hydra.cc/docs/next/patterns/instantiate_objects/overview/.\n  #\n  # Note that the target class value in the `_target_` argument should be located inside PYTHONPATH so Hydra could\n  # find it. The directory with the config file is automatically added to PYTHONPATH, so the default value\n  # `dataset.SearchDataset` points to the class `SearchDataset` from the `dataset.py` file. This `dataset.py` file is\n  # located along with the `search.yaml` file in the same directory provided by `--config-dir`.\n  #\n  # As an alternative, you could provide a path to a Python file with the dataset using the `dataset_file` parameter\n  # instead of the `dataset` parameter. The Python file should contain the implementation of a PyTorch dataset for\n  # augmentation search. The dataset class should have named `SearchDataset`. The value in `dataset_file` could either\n  # be a relative or an absolute path ; in the case of a relative path, the path should be relative to this config\n  # file's location.\n  #\n  # - Example of a relative path:\n  # dataset_file: dataset.py\n  #\n  # - Example of an absolute path:\n  # dataset_file: /projects/pytorch/dataset.py\n  #\n  dataset:\n    _target_: dataset.ConcatSVHNSearchDataset\n    root: ~/data/svhn\n    download: true\n\n  # The data type of input images. Two values are supported:\n  # - uint8. In that case, all input images should be NumPy arrays with the np.uint8 data type and values in the range\n  #   [0, 255].\n  # - float32. In that case, all input images should be NumPy arrays with the np.float32 data type and values in the\n  #   range [0.0, 1.0].\n  input_dtype: uint8\n\n  # A list of preprocessing augmentations that will be applied to each image before applying augmentations from\n  # a policy. A preprocessing augmentation should be defined as `key`: `value`, where `key` is the name of augmentation\n  # from Albumentations, and `value` is a dictionary with augmentation parameters. The found policy will also apply\n  # those preprocessing augmentations before applying the main augmentations.\n  #\n  # Here is an example of an augmentation pipeline that first pads an image to the size 512x512 pixels, then resizes\n  # the resulting image to the size 256x256 pixels and finally crops a random patch with the size 224x224 pixels.\n  #\n  #  preprocessing:\n  #    - PadIfNeeded:\n  #        min_height: 512\n  #        min_width: 512\n  #    - Resize:\n  #        height: 256\n  #        width: 256\n  #    - RandomCrop:\n  #        height: 224\n  #        width: 224\n  #\n  preprocessing: null\n\n  # Normalization values for images. For each image, the search pipeline will subtract `mean` and divide by `std`.\n  # Normalization is applied after transforms defined in `preprocessing`. Note that regardless of `input_dtype`,\n  # the normalization function will always receive a `float32` input with values in the range [0.0, 1.0], so you should\n  # define `mean` and `std` values accordingly.\n  normalization:\n    mean: [0.4376821, 0.4437697, 0.47280442]\n    std: [0.19803012, 0.20101562, 0.19703614]\n\n  # Parameters for the PyTorch DataLoader. Please refer to the PyTorch documentation for the description of parameters -\n  # https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader.\n  dataloader:\n    _target_: torch.utils.data.DataLoader\n    batch_size: 128\n    shuffle: true\n    num_workers: 8\n    pin_memory: true\n    drop_last: true\n\noptim:\n  # Number of epochs to search parameters of augmentations.\n  main:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n\n  # Optimizer configuration for Policy Model\n  policy:\n    _target_: torch.optim.Adam\n    lr: 1e-3\n    betas: [0, 0.999]\n\nseed: 42 # Random seed. If the value is not null, it will be passed to `seed_everything` -\n# https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.utilities.seed.html?highlight=seed_everything\n\n\nhydra:\n  run:\n    # Path to the directory that will contain all outputs produced by the search algorithm. `${config_dir:}` contains\n    # path to the directory with the `search.yaml` config file. Please refer to the Hydra documentation for more\n    # information - https://hydra.cc/docs/configure_hydra/workdir.\n    dir: ${config_dir:}/outputs/${now:%Y-%m-%d}/${now:%H-%M-%S}\n\ntrainer:\n  # Configuration for PyTorch Lightning Trainer. You can read more about Trainer and its arguments at\n  # https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html.\n  max_epochs: 4\n  # Number of epochs to search for augmentation parameters.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#max-epochs\n\n  benchmark: true\n  # If true enables cudnn.benchmark.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#benchmark\n\n  gpus: 1\n  # Number of GPUs to train on. Set to `0` or None` to use CPU for training.\n  # More detailed description - https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#gpus\n</code></pre>"},{"location":"autoalbument/examples/svhn/#modelpy","title":"model.py","text":"Python<pre><code>\"\"\"WideResNet code from https://github.com/xternalz/WideResNet-pytorch\"\"\"\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom autoalbument.faster_autoaugment.models import BaseDiscriminator\n\n\nclass BasicBlock(nn.Module):\n    def __init__(self, in_planes, out_planes, stride):\n        super(BasicBlock, self).__init__()\n        self.bn1 = nn.BatchNorm2d(in_planes)\n        self.relu1 = nn.ReLU(inplace=True)\n        self.conv1 = nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)\n        self.bn2 = nn.BatchNorm2d(out_planes)\n        self.relu2 = nn.ReLU(inplace=True)\n        self.conv2 = nn.Conv2d(out_planes, out_planes, kernel_size=3, stride=1, padding=1, bias=False)\n        self.equal_in_out = in_planes == out_planes\n        self.conv_shortcut = (\n            (not self.equal_in_out)\n            and nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, padding=0, bias=False)\n            or None\n        )\n\n    def forward(self, x):\n        if not self.equal_in_out:\n            x = self.relu1(self.bn1(x))\n        else:\n            out = self.relu1(self.bn1(x))\n        out = self.relu2(self.bn2(self.conv1(out if self.equal_in_out else x)))\n        out = self.conv2(out)\n        return torch.add(x if self.equal_in_out else self.conv_shortcut(x), out)\n\n\nclass NetworkBlock(nn.Module):\n    def __init__(self, nb_layers, in_planes, out_planes, block, stride):\n        super(NetworkBlock, self).__init__()\n        self.layer = self._make_layer(block, in_planes, out_planes, nb_layers, stride)\n\n    def _make_layer(self, block, in_planes, out_planes, nb_layers, stride):\n        layers = []\n        for i in range(int(nb_layers)):\n            layers.append(block(i == 0 and in_planes or out_planes, out_planes, i == 0 and stride or 1))\n        return nn.Sequential(*layers)\n\n    def forward(self, x):\n        return self.layer(x)\n\n\nclass WideResNet(nn.Module):\n    def __init__(self, depth, num_classes, widen_factor=1):\n        super(WideResNet, self).__init__()\n        n_channels = [16, 16 * widen_factor, 32 * widen_factor, 64 * widen_factor]\n        assert (depth - 4) % 6 == 0\n        n = (depth - 4) / 6\n        block = BasicBlock\n        # 1st conv before any network block\n        self.conv1 = nn.Conv2d(3, n_channels[0], kernel_size=3, stride=1, padding=1, bias=False)\n        # 1st block\n        self.block1 = NetworkBlock(n, n_channels[0], n_channels[1], block, 1)\n        # 2nd block\n        self.block2 = NetworkBlock(n, n_channels[1], n_channels[2], block, 2)\n        # 3rd block\n        self.block3 = NetworkBlock(n, n_channels[2], n_channels[3], block, 2)\n        # global average pooling and classifier\n        self.bn1 = nn.BatchNorm2d(n_channels[3])\n        self.relu = nn.ReLU(inplace=True)\n        self.fc = nn.Linear(n_channels[3], num_classes)\n        self.n_channels = n_channels[3]\n\n        for m in self.modules():\n            if isinstance(m, nn.Conv2d):\n                nn.init.kaiming_normal_(m.weight, mode=\"fan_out\", nonlinearity=\"relu\")\n            elif isinstance(m, nn.BatchNorm2d):\n                m.weight.data.fill_(1)\n                m.bias.data.zero_()\n            elif isinstance(m, nn.Linear):\n                m.bias.data.zero_()\n\n    def forward_features(self, x):\n        x = self.conv1(x)\n        x = self.block1(x)\n        x = self.block2(x)\n        x = self.block3(x)\n        x = self.relu(self.bn1(x))\n        x = F.avg_pool2d(x, 8, 1, 0)\n        x = x.view(-1, self.n_channels)\n        return x\n\n    def forward_classifier(self, x):\n        return self.fc(x)\n\n    def forward(self, x):\n        x = self.forward_features(x)\n        x = self.forward_classifier(x)\n        return x\n\n\ndef wide_resnet_28x10(num_classes):\n    return WideResNet(depth=28, widen_factor=10, num_classes=num_classes)\n\n\nclass SVHNClassificationModel(BaseDiscriminator):\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n        self.base_model = wide_resnet_28x10(num_classes=10)\n        num_features = self.base_model.fc.in_features\n        self.discriminator = nn.Sequential(\n            nn.Linear(num_features, num_features), nn.ReLU(), nn.Linear(num_features, 1)\n        )\n\n    def forward(self, input):\n        x = self.base_model.forward_features(input)\n        return self.base_model.forward_classifier(x), self.discriminator(x).view(-1)\n</code></pre>"},{"location":"examples/","title":"List of examples","text":"<ul> <li>Defining a simple augmentation pipeline for image augmentation</li> <li>Working with non-8-bit images</li> <li>Using Albumentations to augment bounding boxes for object detection tasks</li> <li>How to use Albumentations for detection tasks if you need to keep all bounding boxes</li> <li>Using Albumentations for a semantic segmentation task</li> <li>Using Albumentations to augment keypoints</li> <li>Applying the same augmentation with the same parameters to multiple images, masks, bounding boxes, or keypoints</li> <li>Weather augmentations in Albumentations</li> <li>Example of applying XYMasking transform</li> <li>Example of applying MixUp transform</li> <li>Example of applying ChromaticAberration transform</li> <li>Example of applying Morphological transform</li> <li>Migrating from torchvision to Albumentations</li> <li>Debugging an augmentation pipeline with ReplayCompose</li> <li>How to save and load parameters of an augmentation pipeline</li> <li>Showcase. Cool augmentation examples on diverse set of images from various real-world tasks.</li> </ul>"},{"location":"examples/#examples-of-how-to-use-albumentations-with-different-deep-learning-frameworks","title":"Examples of how to use Albumentations with different deep learning frameworks","text":"<ul> <li>PyTorch</li> <li>PyTorch and Albumentations for image classification</li> <li>PyTorch and Albumentations for semantic segmentation</li> <li>TensorFlow 2</li> <li>Using Albumentations with Tensorflow</li> </ul>"},{"location":"examples/example/","title":"Defining a simple augmentation pipeline for image augmentation","text":"<p>This example shows how you can use Albumentations to define a simple augmentation pipeline.</p> In\u00a0[2]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt  import albumentations as A In\u00a0[3]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(10, 10))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(10, 10))     plt.axis('off')     plt.imshow(image) <p>For historical reasons, OpenCV reads an image in BGR format (so color channels of the image have the following order: Blue, Green, Red). Albumentations uses the most common and popular RGB image format. So when using OpenCV, we need to convert the image format to RGB explicitly.</p> In\u00a0[4]: Copied! <pre>image = cv2.imread('images/image_3.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\nvisualize(image)\n</pre> image = cv2.imread('images/image_3.jpg') image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) visualize(image) <p>We fix the random seed for visualization purposes, so the augmentation will always produce the same result. In a real computer vision pipeline, you shouldn't fix the random seed before applying a transform to the image because, in that case, the pipeline will always output the same image. The purpose of image augmentation is to use different transformations each time.</p> In\u00a0[5]: Copied! <pre>transform = A.HorizontalFlip(p=0.5)\nrandom.seed(7)\naugmented_image = transform(image=image)['image']\nvisualize(augmented_image)\n</pre> transform = A.HorizontalFlip(p=0.5) random.seed(7) augmented_image = transform(image=image)['image'] visualize(augmented_image) In\u00a0[6]: Copied! <pre>transform = A.ShiftScaleRotate(p=0.5)\nrandom.seed(7)\naugmented_image = transform(image=image)['image']\nvisualize(augmented_image)\n</pre> transform = A.ShiftScaleRotate(p=0.5) random.seed(7) augmented_image = transform(image=image)['image'] visualize(augmented_image) In\u00a0[7]: Copied! <pre>transform = A.Compose([\n    A.CLAHE(),\n    A.RandomRotate90(),\n    A.Transpose(),\n    A.ShiftScaleRotate(shift_limit=0.0625, scale_limit=0.50, rotate_limit=45, p=.75),\n    A.Blur(blur_limit=3),\n    A.OpticalDistortion(),\n    A.GridDistortion(),\n    A.HueSaturationValue(),\n])\nrandom.seed(42)\naugmented_image = transform(image=image)['image']\nvisualize(augmented_image)\n</pre> transform = A.Compose([     A.CLAHE(),     A.RandomRotate90(),     A.Transpose(),     A.ShiftScaleRotate(shift_limit=0.0625, scale_limit=0.50, rotate_limit=45, p=.75),     A.Blur(blur_limit=3),     A.OpticalDistortion(),     A.GridDistortion(),     A.HueSaturationValue(), ]) random.seed(42) augmented_image = transform(image=image)['image'] visualize(augmented_image) In\u00a0[9]: Copied! <pre>transform = A.Compose([\n        A.RandomRotate90(),\n        A.Flip(),\n        A.Transpose(),\n        A.GaussNoise(),\n        A.OneOf([\n            A.MotionBlur(p=.2),\n            A.MedianBlur(blur_limit=3, p=0.1),\n            A.Blur(blur_limit=3, p=0.1),\n        ], p=0.2),\n        A.ShiftScaleRotate(shift_limit=0.0625, scale_limit=0.2, rotate_limit=45, p=0.2),\n        A.OneOf([\n            A.OpticalDistortion(p=0.3),\n            A.GridDistortion(p=.1),\n        ], p=0.2),\n        A.OneOf([\n            A.CLAHE(clip_limit=2),\n            A.RandomBrightnessContrast(),\n        ], p=0.3),\n        A.HueSaturationValue(p=0.3),\n    ])\nrandom.seed(42)\naugmented_image = transform(image=image)['image']\nvisualize(augmented_image)\n</pre> transform = A.Compose([         A.RandomRotate90(),         A.Flip(),         A.Transpose(),         A.GaussNoise(),         A.OneOf([             A.MotionBlur(p=.2),             A.MedianBlur(blur_limit=3, p=0.1),             A.Blur(blur_limit=3, p=0.1),         ], p=0.2),         A.ShiftScaleRotate(shift_limit=0.0625, scale_limit=0.2, rotate_limit=45, p=0.2),         A.OneOf([             A.OpticalDistortion(p=0.3),             A.GridDistortion(p=.1),         ], p=0.2),         A.OneOf([             A.CLAHE(clip_limit=2),             A.RandomBrightnessContrast(),         ], p=0.3),         A.HueSaturationValue(p=0.3),     ]) random.seed(42) augmented_image = transform(image=image)['image'] visualize(augmented_image)"},{"location":"examples/example/#defining-a-simple-augmentation-pipeline-for-image-augmentation","title":"Defining a simple augmentation pipeline for image augmentation\u00b6","text":""},{"location":"examples/example/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/example/#define-the-visualization-function","title":"Define the visualization function\u00b6","text":""},{"location":"examples/example/#read-the-image-from-the-disk-and-convert-it-from-the-bgr-color-space-to-the-rgb-color-space","title":"Read the image from the disk and convert it from the BGR color space to the RGB color space\u00b6","text":""},{"location":"examples/example/#define-a-single-augmentation-pass-the-image-to-it-and-receive-the-augmented-image","title":"Define a single augmentation, pass the image to it and receive the augmented image\u00b6","text":""},{"location":"examples/example/#define-an-augmentation-pipeline-using-compose-pass-the-image-to-it-and-receive-the-augmented-image","title":"Define an augmentation pipeline using <code>Compose</code>, pass the image to it and receive the augmented image\u00b6","text":""},{"location":"examples/example_16_bit_tiff/","title":"Working with non-8-bit images","text":"<p>This example shows how you can augment 16-bit TIFF images. 16-bit images are used in satellite imagery. The following technique could also be applied to all non-8-bit images (i.e., 24-bit images, 32-bit images. etc.).</p> In\u00a0[1]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt  import albumentations as A In\u00a0[2]: Copied! <pre>def visualize(image):\n    # Divide all values by 65535 so we can display the image using matplotlib\n    image = image / 65535\n    plt.figure(figsize=(10, 10))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     # Divide all values by 65535 so we can display the image using matplotlib     image = image / 65535     plt.figure(figsize=(10, 10))     plt.axis('off')     plt.imshow(image) In\u00a0[3]: Copied! <pre># The image is taken from http://www.brucelindbloom.com/index.html?ReferenceImages.html\n# \u00a9 Bruce Justin Lindbloom\nimage = cv2.imread('images/DeltaE_16bit_gamma2.2.tif', cv2.IMREAD_UNCHANGED)\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\nvisualize(image)\n</pre> # The image is taken from http://www.brucelindbloom.com/index.html?ReferenceImages.html # \u00a9 Bruce Justin Lindbloom image = cv2.imread('images/DeltaE_16bit_gamma2.2.tif', cv2.IMREAD_UNCHANGED) image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) visualize(image) <p>Note: OpenCV may read incorrectly some TIFF files. Consider using <code>tifffile</code> - https://github.com/blink1073/tifffile</p> <p>Under the hood, Albumentations supports two data types that describe the intensity of pixels:</p> <ul> <li><code>np.uint8</code>, an unsigned 8-bit integer that can define values between 0 and 255.</li> <li><code>np.float32</code>, a floating-point number with single precision. For <code>np.float32</code> input, Albumentations expects that value will lie in the range between 0.0 and 1.0.</li> </ul> <p>Albumentations has a dedicated transformation called <code>ToFloat</code> that takes a NumPy array with data types such as <code>np.uint16</code>, <code>np.uint32</code>, etc. (so any datatype that used values higher than 255 to represent pixel intensity) and converts it to a NumPy array with the <code>np.float32</code> datatype. Additionally, this transformation divides all input values to lie in the range <code>[0.0, 1.0]</code>. By default, if the input data type is <code>np.uint16</code>, all values are divided by 65535, and if the input data type is <code>np.uint32</code>, all values are divided by 4294967295. You can specify your divider in the <code>max_value</code> parameter.</p> <p>The augmentation pipeline for non-8-bit images consists of the following stages:</p> <ul> <li>First, you use the <code>ToFloat</code> transform to convert an input image to float32. All values in the converted image will lie in the range <code>[0.0, 1.0]</code>.</li> <li>Then you use all the necessary image transforms.</li> <li>Optionally you could use the <code>FromFloat</code> transform at the end of the augmentation pipeline to convert the image back to its original data type.</li> </ul> In\u00a0[4]: Copied! <pre>transform = A.Compose([\n    A.ToFloat(max_value=65535.0),\n\n    A.RandomRotate90(),\n    A.Flip(),\n    A.OneOf([\n        A.MotionBlur(p=0.2),\n        A.MedianBlur(blur_limit=3, p=0.1),\n        A.Blur(blur_limit=3, p=0.1),\n    ], p=0.2),\n    A.ShiftScaleRotate(shift_limit=0.0625, scale_limit=0.2, rotate_limit=45, p=0.2),\n    A.OneOf([\n        A.OpticalDistortion(p=0.3),\n        A.GridDistortion(p=0.1),\n    ], p=0.2),\n    A.HueSaturationValue(hue_shift_limit=20, sat_shift_limit=0.1, val_shift_limit=0.1, p=0.3),\n\n    A.FromFloat(max_value=65535.0),\n])\n</pre> transform = A.Compose([     A.ToFloat(max_value=65535.0),      A.RandomRotate90(),     A.Flip(),     A.OneOf([         A.MotionBlur(p=0.2),         A.MedianBlur(blur_limit=3, p=0.1),         A.Blur(blur_limit=3, p=0.1),     ], p=0.2),     A.ShiftScaleRotate(shift_limit=0.0625, scale_limit=0.2, rotate_limit=45, p=0.2),     A.OneOf([         A.OpticalDistortion(p=0.3),         A.GridDistortion(p=0.1),     ], p=0.2),     A.HueSaturationValue(hue_shift_limit=20, sat_shift_limit=0.1, val_shift_limit=0.1, p=0.3),      A.FromFloat(max_value=65535.0), ]) <p>We fix the random seed for visualization purposes, so the augmentation will always produce the same result. In a real computer vision pipeline, you shouldn't fix the random seed before applying a transform to the image because, in that case, the pipeline will always output the same image. The purpose of image augmentation is to use different transformations each time.</p> In\u00a0[5]: Copied! <pre>random.seed(7)\naugmented = transform(image=image)\nvisualize(augmented['image'])\n</pre> random.seed(7) augmented = transform(image=image) visualize(augmented['image'])"},{"location":"examples/example_16_bit_tiff/#working-with-non-8-bit-images","title":"Working with non-8-bit images\u00b6","text":""},{"location":"examples/example_16_bit_tiff/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/example_16_bit_tiff/#define-the-visualization-function","title":"Define the visualization function\u00b6","text":""},{"location":"examples/example_16_bit_tiff/#read-the-16-bit-tiff-image-from-the-disk","title":"Read the 16-bit TIFF image from the disk\u00b6","text":""},{"location":"examples/example_16_bit_tiff/#define-an-augmentation-pipeline-that-works-with-16-bit-tiff-images","title":"Define an augmentation pipeline that works with 16-bit TIFF images\u00b6","text":""},{"location":"examples/example_bboxes/","title":"Using Albumentations to augment bounding boxes for object detection tasks","text":"In\u00a0[1]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[2]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt  import albumentations as A <p>The visualization function is based on https://github.com/facebookresearch/Detectron/blob/master/detectron/utils/vis.py</p> In\u00a0[3]: Copied! <pre>BOX_COLOR = (255, 0, 0) # Red\nTEXT_COLOR = (255, 255, 255) # White\n\n\ndef visualize_bbox(img, bbox, class_name, color=BOX_COLOR, thickness=2):\n    \"\"\"Visualizes a single bounding box on the image\"\"\"\n    x_min, y_min, w, h = bbox\n    x_min, x_max, y_min, y_max = int(x_min), int(x_min + w), int(y_min), int(y_min + h)\n\n    cv2.rectangle(img, (x_min, y_min), (x_max, y_max), color=color, thickness=thickness)\n\n    ((text_width, text_height), _) = cv2.getTextSize(class_name, cv2.FONT_HERSHEY_SIMPLEX, 0.35, 1)\n    cv2.rectangle(img, (x_min, y_min - int(1.3 * text_height)), (x_min + text_width, y_min), BOX_COLOR, -1)\n    cv2.putText(\n        img,\n        text=class_name,\n        org=(x_min, y_min - int(0.3 * text_height)),\n        fontFace=cv2.FONT_HERSHEY_SIMPLEX,\n        fontScale=0.35,\n        color=TEXT_COLOR,\n        lineType=cv2.LINE_AA,\n    )\n    return img\n\n\ndef visualize(image, bboxes, category_ids, category_id_to_name):\n    img = image.copy()\n    for bbox, category_id in zip(bboxes, category_ids):\n        class_name = category_id_to_name[category_id]\n        img = visualize_bbox(img, bbox, class_name)\n    plt.figure(figsize=(12, 12))\n    plt.axis('off')\n    plt.imshow(img)\n</pre> BOX_COLOR = (255, 0, 0) # Red TEXT_COLOR = (255, 255, 255) # White   def visualize_bbox(img, bbox, class_name, color=BOX_COLOR, thickness=2):     \"\"\"Visualizes a single bounding box on the image\"\"\"     x_min, y_min, w, h = bbox     x_min, x_max, y_min, y_max = int(x_min), int(x_min + w), int(y_min), int(y_min + h)      cv2.rectangle(img, (x_min, y_min), (x_max, y_max), color=color, thickness=thickness)      ((text_width, text_height), _) = cv2.getTextSize(class_name, cv2.FONT_HERSHEY_SIMPLEX, 0.35, 1)     cv2.rectangle(img, (x_min, y_min - int(1.3 * text_height)), (x_min + text_width, y_min), BOX_COLOR, -1)     cv2.putText(         img,         text=class_name,         org=(x_min, y_min - int(0.3 * text_height)),         fontFace=cv2.FONT_HERSHEY_SIMPLEX,         fontScale=0.35,         color=TEXT_COLOR,         lineType=cv2.LINE_AA,     )     return img   def visualize(image, bboxes, category_ids, category_id_to_name):     img = image.copy()     for bbox, category_id in zip(bboxes, category_ids):         class_name = category_id_to_name[category_id]         img = visualize_bbox(img, bbox, class_name)     plt.figure(figsize=(12, 12))     plt.axis('off')     plt.imshow(img) <p>For this example we will use an image from the COCO dataset that have two associated bounding boxes. The image is available at http://cocodataset.org/#explore?id=386298</p> In\u00a0[4]: Copied! <pre>image = cv2.imread('images/000000386298.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</pre> image = cv2.imread('images/000000386298.jpg') image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) <p>Coordinates for those bounding boxes are declared using the <code>coco</code> format. Each bounding box is described using four values <code>[x_min, y_min, width, height]</code>. For the detailed description of different formats for bounding boxes coordinates, please refer to the documentation article about bounding boxes - https://albumentations.ai/docs/getting_started/bounding_boxes_augmentation/.</p> In\u00a0[5]: Copied! <pre>bboxes = [[5.66, 138.95, 147.09, 164.88], [366.7, 80.84, 132.8, 181.84]]\ncategory_ids = [17, 18]\n\n# We will use the mapping from category_id to the class name\n# to visualize the class label for the bounding box on the image\ncategory_id_to_name = {17: 'cat', 18: 'dog'}\n</pre> bboxes = [[5.66, 138.95, 147.09, 164.88], [366.7, 80.84, 132.8, 181.84]] category_ids = [17, 18]  # We will use the mapping from category_id to the class name # to visualize the class label for the bounding box on the image category_id_to_name = {17: 'cat', 18: 'dog'} In\u00a0[6]: Copied! <pre>visualize(image, bboxes, category_ids, category_id_to_name)\n</pre> visualize(image, bboxes, category_ids, category_id_to_name) <p>To make an augmentation pipeline that works with bounding boxes, you need to pass an instance of <code>BboxParams</code> to <code>Compose</code>. In <code>BboxParams</code> you need to specify the format of coordinates for bounding boxes and optionally a few other parameters. For the detailed description of <code>BboxParams</code> please refer to the documentation article about bounding boxes - https://albumentations.ai/docs/getting_started/bounding_boxes_augmentation/.</p> In\u00a0[7]: Copied! <pre>transform = A.Compose(\n    [A.HorizontalFlip(p=0.5)],\n    bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']),\n)\n</pre> transform = A.Compose(     [A.HorizontalFlip(p=0.5)],     bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']), ) <p>We fix the random seed for visualization purposes, so the augmentation will always produce the same result. In a real computer vision pipeline, you shouldn't fix the random seed before applying a transform to the image because, in that case, the pipeline will always output the same image. The purpose of image augmentation is to use different transformations each time.</p> In\u00a0[8]: Copied! <pre>random.seed(7)\ntransformed = transform(image=image, bboxes=bboxes, category_ids=category_ids)\nvisualize(\n    transformed['image'],\n    transformed['bboxes'],\n    transformed['category_ids'],\n    category_id_to_name,\n)\n</pre> random.seed(7) transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids) visualize(     transformed['image'],     transformed['bboxes'],     transformed['category_ids'],     category_id_to_name, ) In\u00a0[9]: Copied! <pre>transform = A.Compose(\n    [A.ShiftScaleRotate(p=0.5)],\n    bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']),\n)\n</pre> transform = A.Compose(     [A.ShiftScaleRotate(p=0.5)],     bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']), ) In\u00a0[10]: Copied! <pre>random.seed(7)\ntransformed = transform(image=image, bboxes=bboxes, category_ids=category_ids)\nvisualize(\n    transformed['image'],\n    transformed['bboxes'],\n    transformed['category_ids'],\n    category_id_to_name,\n)\n</pre> random.seed(7) transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids) visualize(     transformed['image'],     transformed['bboxes'],     transformed['category_ids'],     category_id_to_name, ) In\u00a0[11]: Copied! <pre>transform = A.Compose([\n        A.HorizontalFlip(p=0.5),\n        A.ShiftScaleRotate(p=0.5),\n        A.RandomBrightnessContrast(p=0.3),\n        A.RGBShift(r_shift_limit=30, g_shift_limit=30, b_shift_limit=30, p=0.3),\n    ],\n    bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']),\n)\n</pre> transform = A.Compose([         A.HorizontalFlip(p=0.5),         A.ShiftScaleRotate(p=0.5),         A.RandomBrightnessContrast(p=0.3),         A.RGBShift(r_shift_limit=30, g_shift_limit=30, b_shift_limit=30, p=0.3),     ],     bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']), ) In\u00a0[12]: Copied! <pre>random.seed(7)\ntransformed = transform(image=image, bboxes=bboxes, category_ids=category_ids)\nvisualize(\n    transformed['image'],\n    transformed['bboxes'],\n    transformed['category_ids'],\n    category_id_to_name,\n)\n</pre> random.seed(7) transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids) visualize(     transformed['image'],     transformed['bboxes'],     transformed['category_ids'],     category_id_to_name, ) <p>The size of bounding boxes could change if you apply spatial augmentations, for example, when you crop a part of an image or when you resize an image.</p> <p><code>min_area</code> and <code>min_visibility</code> parameters control what Albumentations should do to the augmented bounding boxes if their size has changed after augmentation. The size of bounding boxes could change if you apply spatial augmentations, for example, when you crop a part of an image or when you resize an image.</p> <p><code>min_area</code> is a value in pixels. If the area of a bounding box after augmentation becomes smaller than <code>min_area</code>, Albumentations will drop that box. So the returned list of augmented bounding boxes won't contain that bounding box.</p> <p><code>min_visibility</code> is a value between 0 and 1. If the ratio of the bounding box area after augmentation to <code>the area of the bounding box before augmentation</code> becomes smaller than <code>min_visibility</code>, Albumentations will drop that box. So if the augmentation process cuts the most of the bounding box, that box won't be present in the returned list of the augmented bounding boxes.</p> <p>If you don't pass the <code>min_area</code> and <code>min_visibility</code> parameters, Albumentations will use 0 as a default value for them.</p> In\u00a0[13]: Copied! <pre>transform = A.Compose(\n    [A.CenterCrop(height=280, width=280, p=1)],\n    bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']),\n)\n</pre> transform = A.Compose(     [A.CenterCrop(height=280, width=280, p=1)],     bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']), ) In\u00a0[14]: Copied! <pre>transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids)\nvisualize(\n    transformed['image'],\n    transformed['bboxes'],\n    transformed['category_ids'],\n    category_id_to_name,\n)\n</pre> transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids) visualize(     transformed['image'],     transformed['bboxes'],     transformed['category_ids'],     category_id_to_name, ) <p>As you see the output contains two bounding boxes.</p> <p>Next, we will set the <code>min_area</code> value to 4500 pixels.</p> In\u00a0[15]: Copied! <pre>transform = A.Compose(\n    [A.CenterCrop(height=280, width=280, p=1)],\n    bbox_params=A.BboxParams(format='coco', min_area=4500, label_fields=['category_ids']),\n)\n</pre> transform = A.Compose(     [A.CenterCrop(height=280, width=280, p=1)],     bbox_params=A.BboxParams(format='coco', min_area=4500, label_fields=['category_ids']), ) In\u00a0[16]: Copied! <pre>transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids)\nvisualize(\n    transformed['image'],\n    transformed['bboxes'],\n    transformed['category_ids'],\n    category_id_to_name,\n)\n</pre> transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids) visualize(     transformed['image'],     transformed['bboxes'],     transformed['category_ids'],     category_id_to_name, ) <p>The output contains only one bounding box because the area of the second bounding box became lower than 4500 pixels.</p> <p>Finally, we will set <code>min_visibility</code> to 0.3. So if the area of the output bounding box is less than 30% of the original area, Albumentations won't return that bounding box.</p> In\u00a0[17]: Copied! <pre>transform = A.Compose(\n    [A.CenterCrop(height=280, width=280, p=1)],\n    bbox_params=A.BboxParams(format='coco', min_visibility=0.3, label_fields=['category_ids']),\n)\n</pre> transform = A.Compose(     [A.CenterCrop(height=280, width=280, p=1)],     bbox_params=A.BboxParams(format='coco', min_visibility=0.3, label_fields=['category_ids']), ) In\u00a0[18]: Copied! <pre>transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids)\nvisualize(\n    transformed['image'],\n    transformed['bboxes'],\n    transformed['category_ids'],\n    category_id_to_name,\n)\n</pre> transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids) visualize(     transformed['image'],     transformed['bboxes'],     transformed['category_ids'],     category_id_to_name, ) <p>The output doesn't contain any bounding box.</p> <p>Note that you can declare both the <code>min_area</code> and <code>min_visibility</code> parameters simultaneously in one <code>BboxParams</code> instance.</p>"},{"location":"examples/example_bboxes/#using-albumentations-to-augment-bounding-boxes-for-object-detection-tasks","title":"Using Albumentations to augment bounding boxes for object detection tasks\u00b6","text":""},{"location":"examples/example_bboxes/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/example_bboxes/#define-functions-to-visualize-bounding-boxes-and-class-labels-on-an-image","title":"Define functions to visualize bounding boxes and class labels on an image\u00b6","text":""},{"location":"examples/example_bboxes/#get-an-image-and-annotations-for-it","title":"Get an image and annotations for it\u00b6","text":""},{"location":"examples/example_bboxes/#load-the-image-from-the-disk","title":"Load the image from the disk\u00b6","text":""},{"location":"examples/example_bboxes/#define-two-bounding-boxes-with-coordinates-and-class-labels","title":"Define two bounding boxes with coordinates and class labels\u00b6","text":""},{"location":"examples/example_bboxes/#visuaize-the-original-image-with-bounding-boxes","title":"Visuaize the original image with bounding boxes\u00b6","text":""},{"location":"examples/example_bboxes/#define-an-augmentation-pipeline","title":"Define an augmentation pipeline\u00b6","text":""},{"location":"examples/example_bboxes/#another-example","title":"Another example\u00b6","text":""},{"location":"examples/example_bboxes/#define-a-complex-augmentation-piepline","title":"Define a complex augmentation piepline\u00b6","text":""},{"location":"examples/example_bboxes/#min_area-and-min_visibility-parameters","title":"<code>min_area</code> and <code>min_visibility</code> parameters\u00b6","text":""},{"location":"examples/example_bboxes/#define-an-augmentation-pipeline-with-the-default-values-for-min_area-and-min_visibilty","title":"Define an augmentation pipeline with the default values for <code>min_area</code> and <code>min_visibilty</code>\u00b6","text":""},{"location":"examples/example_bboxes/#define-an-augmentation-pipeline-with-min_area","title":"Define an augmentation pipeline with <code>min_area</code>\u00b6","text":""},{"location":"examples/example_bboxes/#define-an-augmentation-pipeline-with-min_visibility","title":"Define an augmentation pipeline with <code>min_visibility</code>\u00b6","text":""},{"location":"examples/example_bboxes2/","title":"How to use Albumentations for detection tasks if you need to keep all bounding boxes","text":"<p>Some augmentations like <code>RandomCrop</code> and <code>CenterCrop</code> may transform an image so that it won't contain all original bounding boxes. This example shows how you can use the transform named <code>RandomSizedBBoxSafeCrop</code> to crop a part of the image but keep all bounding boxes from the original image.</p> In\u00a0[2]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt  import albumentations as A <p>The visualization function is based on https://github.com/facebookresearch/Detectron/blob/master/detectron/utils/vis.py</p> In\u00a0[3]: Copied! <pre>BOX_COLOR = (255, 0, 0) # Red\nTEXT_COLOR = (255, 255, 255) # White\n\n\ndef visualize_bbox(img, bbox, class_name, color=BOX_COLOR, thickness=2):\n    \"\"\"Visualizes a single bounding box on the image\"\"\"\n    x_min, y_min, w, h = bbox\n    x_min, x_max, y_min, y_max = int(x_min), int(x_min + w), int(y_min), int(y_min + h)\n\n    cv2.rectangle(img, (x_min, y_min), (x_max, y_max), color=color, thickness=thickness)\n\n    ((text_width, text_height), _) = cv2.getTextSize(class_name, cv2.FONT_HERSHEY_SIMPLEX, 0.35, 1)\n    cv2.rectangle(img, (x_min, y_min - int(1.3 * text_height)), (x_min + text_width, y_min), BOX_COLOR, -1)\n    cv2.putText(\n        img,\n        text=class_name,\n        org=(x_min, y_min - int(0.3 * text_height)),\n        fontFace=cv2.FONT_HERSHEY_SIMPLEX,\n        fontScale=0.35,\n        color=TEXT_COLOR,\n        lineType=cv2.LINE_AA,\n    )\n    return img\n\n\ndef visualize(image, bboxes, category_ids, category_id_to_name):\n    img = image.copy()\n    for bbox, category_id in zip(bboxes, category_ids):\n        class_name = category_id_to_name[category_id]\n        img = visualize_bbox(img, bbox, class_name)\n    plt.figure(figsize=(12, 12))\n    plt.axis('off')\n    plt.imshow(img)\n</pre> BOX_COLOR = (255, 0, 0) # Red TEXT_COLOR = (255, 255, 255) # White   def visualize_bbox(img, bbox, class_name, color=BOX_COLOR, thickness=2):     \"\"\"Visualizes a single bounding box on the image\"\"\"     x_min, y_min, w, h = bbox     x_min, x_max, y_min, y_max = int(x_min), int(x_min + w), int(y_min), int(y_min + h)      cv2.rectangle(img, (x_min, y_min), (x_max, y_max), color=color, thickness=thickness)      ((text_width, text_height), _) = cv2.getTextSize(class_name, cv2.FONT_HERSHEY_SIMPLEX, 0.35, 1)     cv2.rectangle(img, (x_min, y_min - int(1.3 * text_height)), (x_min + text_width, y_min), BOX_COLOR, -1)     cv2.putText(         img,         text=class_name,         org=(x_min, y_min - int(0.3 * text_height)),         fontFace=cv2.FONT_HERSHEY_SIMPLEX,         fontScale=0.35,         color=TEXT_COLOR,         lineType=cv2.LINE_AA,     )     return img   def visualize(image, bboxes, category_ids, category_id_to_name):     img = image.copy()     for bbox, category_id in zip(bboxes, category_ids):         class_name = category_id_to_name[category_id]         img = visualize_bbox(img, bbox, class_name)     plt.figure(figsize=(12, 12))     plt.axis('off')     plt.imshow(img) <p>For this example we will use an image from the COCO dataset that have two associated bounding boxes. The image is available at http://cocodataset.org/#explore?id=386298</p> In\u00a0[4]: Copied! <pre>image = cv2.imread('images/000000386298.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</pre> image = cv2.imread('images/000000386298.jpg') image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) <p>Coordinates for those bounding boxes are declared using the <code>coco</code> format. Each bounding box is described using four values <code>[x_min, y_min, width, height]</code>. For the detailed description of different formats for bounding boxes coordinates, please refer to the documentation article about bounding boxes - https://albumentations.ai/docs/getting_started/bounding_boxes_augmentation/.</p> In\u00a0[5]: Copied! <pre>bboxes = [[5.66, 138.95, 147.09, 164.88], [366.7, 80.84, 132.8, 181.84]]\ncategory_ids = [17, 18]\n\n# We will use the mapping from category_id to the class name\n# to visualize the class label for the bounding box on the image\ncategory_id_to_name = {17: 'cat', 18: 'dog'}\n</pre> bboxes = [[5.66, 138.95, 147.09, 164.88], [366.7, 80.84, 132.8, 181.84]] category_ids = [17, 18]  # We will use the mapping from category_id to the class name # to visualize the class label for the bounding box on the image category_id_to_name = {17: 'cat', 18: 'dog'} In\u00a0[6]: Copied! <pre>visualize(image, bboxes, category_ids, category_id_to_name)\n</pre> visualize(image, bboxes, category_ids, category_id_to_name) <p><code>RandomSizedBBoxSafeCrop</code> crops a random part of the image. It ensures that the cropped part will contain all bounding boxes from the original image. Then the transform rescales the crop to height and width specified by the respective parameters. The <code>erosion_rate</code> parameter controls how much area of the original bounding box could be lost after cropping. <code>erosion_rate = 0.2</code> means that the augmented bounding box's area could be up to 20% smaller than the area of the original bounding box.</p> In\u00a0[7]: Copied! <pre>transform = A.Compose(\n    [A.RandomSizedBBoxSafeCrop(width=448, height=336, erosion_rate=0.2)],\n    bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']),\n)\n</pre> transform = A.Compose(     [A.RandomSizedBBoxSafeCrop(width=448, height=336, erosion_rate=0.2)],     bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']), ) <p>We fix the random seed for visualization purposes, so the augmentation will always produce the same result. In a real computer vision pipeline, you shouldn't fix the random seed before applying a transform to the image because, in that case, the pipeline will always output the same image. The purpose of image augmentation is to use different transformations each time.</p> In\u00a0[8]: Copied! <pre>random.seed(7)\ntransformed = transform(image=image, bboxes=bboxes, category_ids=category_ids)\nvisualize(\n    transformed['image'],\n    transformed['bboxes'],\n    transformed['category_ids'],\n    category_id_to_name,\n)\n</pre> random.seed(7) transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids) visualize(     transformed['image'],     transformed['bboxes'],     transformed['category_ids'],     category_id_to_name, ) In\u00a0[9]: Copied! <pre>random.seed(3)\ntransformed = transform(image=image, bboxes=bboxes, category_ids=category_ids)\nvisualize(\n    transformed['image'],\n    transformed['bboxes'],\n    transformed['category_ids'],\n    category_id_to_name,\n)\n</pre> random.seed(3) transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids) visualize(     transformed['image'],     transformed['bboxes'],     transformed['category_ids'],     category_id_to_name, ) In\u00a0[10]: Copied! <pre>random.seed(444)\ntransformed = transform(image=image, bboxes=bboxes, category_ids=category_ids)\nvisualize(\n    transformed['image'],\n    transformed['bboxes'],\n    transformed['category_ids'],\n    category_id_to_name,\n)\n</pre> random.seed(444) transformed = transform(image=image, bboxes=bboxes, category_ids=category_ids) visualize(     transformed['image'],     transformed['bboxes'],     transformed['category_ids'],     category_id_to_name, )"},{"location":"examples/example_bboxes2/#how-to-use-albumentations-for-detection-tasks-if-you-need-to-keep-all-bounding-boxes","title":"How to use Albumentations for detection tasks if you need to keep all bounding boxes\u00b6","text":""},{"location":"examples/example_bboxes2/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/example_bboxes2/#define-functions-to-visualize-bounding-boxes-and-class-labels-on-an-image","title":"Define functions to visualize bounding boxes and class labels on an image\u00b6","text":""},{"location":"examples/example_bboxes2/#get-an-image-and-annotations-for-it","title":"Get an image and annotations for it\u00b6","text":""},{"location":"examples/example_bboxes2/#load-the-image-from-the-disk","title":"Load the image from the disk\u00b6","text":""},{"location":"examples/example_bboxes2/#define-two-bounding-boxes-with-coordinates-and-class-labels","title":"Define two bounding boxes with coordinates and class labels\u00b6","text":""},{"location":"examples/example_bboxes2/#visuaize-the-image-with-bounding-boxes","title":"Visuaize the image with bounding boxes\u00b6","text":""},{"location":"examples/example_bboxes2/#using-randomsizedbboxsafecrop-to-keep-all-bounding-boxes-from-the-original-image","title":"Using <code>RandomSizedBBoxSafeCrop</code> to keep all bounding boxes from the original image\u00b6","text":""},{"location":"examples/example_bboxes2/#define-an-augmentation-pipeline","title":"Define an augmentation pipeline\u00b6","text":""},{"location":"examples/example_bboxes2/#augment-the-input-image-with-bounding-boxes","title":"Augment the input image with bounding boxes\u00b6","text":""},{"location":"examples/example_bboxes2/#a-few-more-examples-with-different-random-seeds","title":"A few more examples with different random seeds\u00b6","text":""},{"location":"examples/example_chromatic_abberation/","title":"Load the image from the disk","text":"In\u00a0[14]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\nfrom pathlib import Path\nimport numpy as np\nimport cv2\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt from pathlib import Path import numpy as np import cv2  import albumentations as A In\u00a0[15]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(10, 5))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(10, 5))     plt.axis('off')     plt.imshow(image) In\u00a0[16]: Copied! <pre>def load_rgb(image_path):\n    image = cv2.imread(image_path)\n    return cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</pre> def load_rgb(image_path):     image = cv2.imread(image_path)     return cv2.cvtColor(image, cv2.COLOR_BGR2RGB) In\u00a0[17]: Copied! <pre>img_path = \"../images/alina_rossoshanska.jpeg\"\nimg = load_rgb(img_path)\n</pre> img_path = \"../images/alina_rossoshanska.jpeg\" img = load_rgb(img_path) In\u00a0[18]: Copied! <pre>visualize(img)\n</pre> visualize(img) In\u00a0[19]: Copied! <pre>transform = A.Compose([A.ChromaticAberration(mode=\"red_blue\", primary_distortion_limit=0.5, secondary_distortion_limit=0.1, p=1)])\n\nplt.figure(figsize=(15, 10))\n\nnum_images = 12\n\n# Loop through the list of images and plot them with subplot\nfor i in range(num_images):\n    transformed_image = transform(image = img)[\"image\"]\n    plt.subplot(4, 3, i + 1)\n    plt.imshow(transformed_image)\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> transform = A.Compose([A.ChromaticAberration(mode=\"red_blue\", primary_distortion_limit=0.5, secondary_distortion_limit=0.1, p=1)])  plt.figure(figsize=(15, 10))  num_images = 12  # Loop through the list of images and plot them with subplot for i in range(num_images):     transformed_image = transform(image = img)[\"image\"]     plt.subplot(4, 3, i + 1)     plt.imshow(transformed_image)     plt.axis('off')  plt.tight_layout() plt.show()"},{"location":"examples/example_chromatic_abberation/#load-the-image-from-the-disk","title":"Load the image from the disk\u00b6","text":""},{"location":"examples/example_chromatic_abberation/#visualize-the-original-image","title":"Visualize the original image\u00b6","text":""},{"location":"examples/example_chromatic_abberation/#red-blue-mode","title":"Red-blue mode\u00b6","text":""},{"location":"examples/example_chromatic_aberration/","title":"Load the image from the disk","text":"In\u00a0[14]: Copied! <pre>import cv2\nfrom matplotlib import pyplot as plt\nimport cv2\n\nimport albumentations as A\n</pre> import cv2 from matplotlib import pyplot as plt import cv2  import albumentations as A In\u00a0[15]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(10, 5))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(10, 5))     plt.axis('off')     plt.imshow(image) In\u00a0[16]: Copied! <pre>def load_rgb(image_path):\n    image = cv2.imread(image_path)\n    return cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</pre> def load_rgb(image_path):     image = cv2.imread(image_path)     return cv2.cvtColor(image, cv2.COLOR_BGR2RGB) In\u00a0[17]: Copied! <pre>img_path = \"../images/alina_rossoshanska.jpeg\"\nimg = load_rgb(img_path)\n</pre> img_path = \"../images/alina_rossoshanska.jpeg\" img = load_rgb(img_path) In\u00a0[18]: Copied! <pre>visualize(img)\n</pre> visualize(img) In\u00a0[19]: Copied! <pre>transform = A.Compose([A.ChromaticAberration(mode=\"red_blue\", primary_distortion_limit=0.5, secondary_distortion_limit=0.1, p=1)])\n\nplt.figure(figsize=(15, 10))\n\nnum_images = 12\n\n# Loop through the list of images and plot them with subplot\nfor i in range(num_images):\n    transformed_image = transform(image = img)[\"image\"]\n    plt.subplot(4, 3, i + 1)\n    plt.imshow(transformed_image)\n    plt.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> transform = A.Compose([A.ChromaticAberration(mode=\"red_blue\", primary_distortion_limit=0.5, secondary_distortion_limit=0.1, p=1)])  plt.figure(figsize=(15, 10))  num_images = 12  # Loop through the list of images and plot them with subplot for i in range(num_images):     transformed_image = transform(image = img)[\"image\"]     plt.subplot(4, 3, i + 1)     plt.imshow(transformed_image)     plt.axis('off')  plt.tight_layout() plt.show()"},{"location":"examples/example_chromatic_aberration/#load-the-image-from-the-disk","title":"Load the image from the disk\u00b6","text":""},{"location":"examples/example_chromatic_aberration/#visualize-the-original-image","title":"Visualize the original image\u00b6","text":""},{"location":"examples/example_chromatic_aberration/#red-blue-mode","title":"Red-blue mode\u00b6","text":""},{"location":"examples/example_documents/","title":"Morphological Transform","text":"In\u00a0[1]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt  import albumentations as A In\u00a0[2]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(10, 5))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(10, 5))     plt.axis('off')     plt.imshow(image) In\u00a0[3]: Copied! <pre>def load_rgb(image_path):\n    image = cv2.imread(image_path)\n    return cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</pre> def load_rgb(image_path):     image = cv2.imread(image_path)     return cv2.cvtColor(image, cv2.COLOR_BGR2RGB) <p>Load the image from the disk</p> In\u00a0[4]: Copied! <pre>img_path = \"../images/scan.jpeg\"\nimg = load_rgb(img_path)\n</pre> img_path = \"../images/scan.jpeg\" img = load_rgb(img_path) In\u00a0[5]: Copied! <pre>visualize(img)\n</pre> visualize(img) <p>Dilation expands the white (foreground) regions in a binary or grayscale image.</p> In\u00a0[6]: Copied! <pre>transform = A.Compose([A.Morphological(p=1, scale=(2, 3), operation='dilation')], p=1)\n</pre> transform = A.Compose([A.Morphological(p=1, scale=(2, 3), operation='dilation')], p=1) In\u00a0[8]: Copied! <pre>transformed = transform(image=img)\nvisualize(transformed[\"image\"])\n</pre> transformed = transform(image=img) visualize(transformed[\"image\"]) <p>Erosion shrinks the white (foreground) regions in a binary or grayscale image.</p> In\u00a0[9]: Copied! <pre>transform = A.Compose([A.Morphological(p=1, scale=(2, 3), operation='erosion')], p=1)\n</pre> transform = A.Compose([A.Morphological(p=1, scale=(2, 3), operation='erosion')], p=1) In\u00a0[10]: Copied! <pre>transformed = transform(image=img)\nvisualize(transformed[\"image\"])\n</pre> transformed = transform(image=img) visualize(transformed[\"image\"])"},{"location":"examples/example_documents/#morphological-transform","title":"Morphological Transform\u00b6","text":""},{"location":"examples/example_documents/#visualize-the-original-image","title":"Visualize the original image\u00b6","text":""},{"location":"examples/example_documents/#dilation","title":"Dilation\u00b6","text":""},{"location":"examples/example_documents/#erosion","title":"Erosion\u00b6","text":""},{"location":"examples/example_kaggle_salt/","title":"Using Albumentations for a semantic segmentation task","text":"<p>We will use images and data from the TGS Salt Identification Challenge.</p> In\u00a0[1]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt  import albumentations as A In\u00a0[2]: Copied! <pre>def visualize(image, mask, original_image=None, original_mask=None):\n    fontsize = 18\n\n    if original_image is None and original_mask is None:\n        f, ax = plt.subplots(2, 1, figsize=(8, 8))\n\n        ax[0].imshow(image)\n        ax[1].imshow(mask)\n    else:\n        f, ax = plt.subplots(2, 2, figsize=(8, 8))\n\n        ax[0, 0].imshow(original_image)\n        ax[0, 0].set_title('Original image', fontsize=fontsize)\n\n        ax[1, 0].imshow(original_mask)\n        ax[1, 0].set_title('Original mask', fontsize=fontsize)\n\n        ax[0, 1].imshow(image)\n        ax[0, 1].set_title('Transformed image', fontsize=fontsize)\n\n        ax[1, 1].imshow(mask)\n        ax[1, 1].set_title('Transformed mask', fontsize=fontsize)\n</pre> def visualize(image, mask, original_image=None, original_mask=None):     fontsize = 18      if original_image is None and original_mask is None:         f, ax = plt.subplots(2, 1, figsize=(8, 8))          ax[0].imshow(image)         ax[1].imshow(mask)     else:         f, ax = plt.subplots(2, 2, figsize=(8, 8))          ax[0, 0].imshow(original_image)         ax[0, 0].set_title('Original image', fontsize=fontsize)          ax[1, 0].imshow(original_mask)         ax[1, 0].set_title('Original mask', fontsize=fontsize)          ax[0, 1].imshow(image)         ax[0, 1].set_title('Transformed image', fontsize=fontsize)          ax[1, 1].imshow(mask)         ax[1, 1].set_title('Transformed mask', fontsize=fontsize) In\u00a0[3]: Copied! <pre>image = cv2.imread('images/kaggle_salt/0fea4b5049_image.png')\nmask = cv2.imread('images/kaggle_salt/0fea4b5049.png', cv2.IMREAD_GRAYSCALE)\n</pre> image = cv2.imread('images/kaggle_salt/0fea4b5049_image.png') mask = cv2.imread('images/kaggle_salt/0fea4b5049.png', cv2.IMREAD_GRAYSCALE) In\u00a0[4]: Copied! <pre>print(image.shape, mask.shape)\n</pre> print(image.shape, mask.shape) <pre>(101, 101, 3) (101, 101)\n</pre> In\u00a0[5]: Copied! <pre>original_height, original_width = image.shape[:2]\n</pre> original_height, original_width = image.shape[:2] In\u00a0[6]: Copied! <pre>visualize(image, mask)\n</pre> visualize(image, mask) <p>UNet type architecture requires input image size be divisible by $2^N$, where $N$ is the number of maxpooling layers. In the vanilla UNet $N=5$  $\\Longrightarrow$, we need to pad input images to the closest divisible by $2^5 = 32$ number, which is 128. This operation may be performed using PadIfNeeded transformation. It pads both the image and the mask on all four sides. Padding type (zero, constant, reflection) may be specified. The default padding is reflection padding.</p> In\u00a0[7]: Copied! <pre>aug = A.PadIfNeeded(min_height=128, min_width=128, p=1)\n\naugmented = aug(image=image, mask=mask)\n\nimage_padded = augmented['image']\nmask_padded = augmented['mask']\n\nprint(image_padded.shape, mask_padded.shape)\n\nvisualize(image_padded, mask_padded, original_image=image, original_mask=mask)\n</pre> aug = A.PadIfNeeded(min_height=128, min_width=128, p=1)  augmented = aug(image=image, mask=mask)  image_padded = augmented['image'] mask_padded = augmented['mask']  print(image_padded.shape, mask_padded.shape)  visualize(image_padded, mask_padded, original_image=image, original_mask=mask) <pre>(128, 128, 3) (128, 128)\n</pre> <p>To get to the original image and mask from the padded version, we may use CenterCrop or Crop transformations.</p> In\u00a0[8]: Copied! <pre>aug = A.CenterCrop(p=1, height=original_height, width=original_width)\n\naugmented = aug(image=image_padded, mask=mask_padded)\n\nimage_center_cropped = augmented['image']\nmask_center_cropped = augmented['mask']\n\nprint(image_center_cropped.shape, mask_center_cropped.shape)\n\nassert (image - image_center_cropped).sum() == 0\nassert (mask - mask_center_cropped).sum() == 0\n\nvisualize(image_padded, mask_padded, original_image=image_center_cropped, original_mask=mask_center_cropped)\n</pre> aug = A.CenterCrop(p=1, height=original_height, width=original_width)  augmented = aug(image=image_padded, mask=mask_padded)  image_center_cropped = augmented['image'] mask_center_cropped = augmented['mask']  print(image_center_cropped.shape, mask_center_cropped.shape)  assert (image - image_center_cropped).sum() == 0 assert (mask - mask_center_cropped).sum() == 0  visualize(image_padded, mask_padded, original_image=image_center_cropped, original_mask=mask_center_cropped) <pre>(101, 101, 3) (101, 101)\n</pre> In\u00a0[9]: Copied! <pre>x_min = (128 - original_width) // 2\ny_min = (128 - original_height) // 2\n\nx_max = x_min + original_width\ny_max = y_min + original_height\n\naug = A.Crop(x_min=x_min, x_max=x_max, y_min=y_min, y_max=y_max, p=1)\n\naugmented = aug(image=image_padded, mask=mask_padded)\n\nimage_cropped = augmented['image']\nmask_cropped = augmented['mask']\n\nprint(image_cropped.shape, mask_cropped.shape)\n\nassert (image - image_cropped).sum() == 0\nassert (mask - mask_cropped).sum() == 0\n\nvisualize(image_cropped, mask_cropped, original_image=image_padded, original_mask=mask_padded)\n</pre> x_min = (128 - original_width) // 2 y_min = (128 - original_height) // 2  x_max = x_min + original_width y_max = y_min + original_height  aug = A.Crop(x_min=x_min, x_max=x_max, y_min=y_min, y_max=y_max, p=1)  augmented = aug(image=image_padded, mask=mask_padded)  image_cropped = augmented['image'] mask_cropped = augmented['mask']  print(image_cropped.shape, mask_cropped.shape)  assert (image - image_cropped).sum() == 0 assert (mask - mask_cropped).sum() == 0  visualize(image_cropped, mask_cropped, original_image=image_padded, original_mask=mask_padded) <pre>(101, 101, 3) (101, 101)\n</pre> <p>For images for which there is no clear notion of top like this one, satellite and aerial imagery or medical imagery is typically a good idea to add transformations that do not add or lose the information.</p> <p>There are eight distinct ways to represent the same square on the plane.</p> <p></p> <p>Combinations of the transformations HorizontalFlip, VerticalFlip, Transpose, RandomRotate90 will be able to get the original image to all eight states.</p> In\u00a0[10]: Copied! <pre>aug = A.HorizontalFlip(p=1)\n\naugmented = aug(image=image, mask=mask)\n\nimage_h_flipped = augmented['image']\nmask_h_flipped = augmented['mask']\n\nvisualize(image_h_flipped, mask_h_flipped, original_image=image, original_mask=mask)\n</pre> aug = A.HorizontalFlip(p=1)  augmented = aug(image=image, mask=mask)  image_h_flipped = augmented['image'] mask_h_flipped = augmented['mask']  visualize(image_h_flipped, mask_h_flipped, original_image=image, original_mask=mask) In\u00a0[11]: Copied! <pre>aug = A.VerticalFlip(p=1)\n\naugmented = aug(image=image, mask=mask)\n\nimage_v_flipped = augmented['image']\nmask_v_flipped = augmented['mask']\n\nvisualize(image_v_flipped, mask_v_flipped, original_image=image, original_mask=mask)\n</pre> aug = A.VerticalFlip(p=1)  augmented = aug(image=image, mask=mask)  image_v_flipped = augmented['image'] mask_v_flipped = augmented['mask']  visualize(image_v_flipped, mask_v_flipped, original_image=image, original_mask=mask) In\u00a0[12]: Copied! <pre>aug = A.RandomRotate90(p=1)\n\naugmented = aug(image=image, mask=mask)\n\nimage_rot90 = augmented['image']\nmask_rot90 = augmented['mask']\n\nvisualize(image_rot90, mask_rot90, original_image=image, original_mask=mask)\n</pre> aug = A.RandomRotate90(p=1)  augmented = aug(image=image, mask=mask)  image_rot90 = augmented['image'] mask_rot90 = augmented['mask']  visualize(image_rot90, mask_rot90, original_image=image, original_mask=mask) In\u00a0[13]: Copied! <pre>aug = A.Transpose(p=1)\n\naugmented = aug(image=image, mask=mask)\n\nimage_transposed = augmented['image']\nmask_transposed = augmented['mask']\n\nvisualize(image_transposed, mask_transposed, original_image=image, original_mask=mask)\n</pre> aug = A.Transpose(p=1)  augmented = aug(image=image, mask=mask)  image_transposed = augmented['image'] mask_transposed = augmented['mask']  visualize(image_transposed, mask_transposed, original_image=image, original_mask=mask) <p>In medical imaging problems, non-rigid transformations help to augment the data. It is unclear if they will help with this problem, but let's look at them. We will consider ElasticTransform, GridDistortion, OpticalDistortion.</p> <p>We fix the random seed for visualization purposes, so the augmentation will always produce the same result. In a real computer vision pipeline, you shouldn't fix the random seed before applying a transform to the image because, in that case, the pipeline will always output the same image. The purpose of image augmentation is to use different transformations each time.</p> In\u00a0[14]: Copied! <pre>aug = A.ElasticTransform(p=1, alpha=120, sigma=120 * 0.05, alpha_affine=120 * 0.03)\n\nrandom.seed(7)\naugmented = aug(image=image, mask=mask)\n\nimage_elastic = augmented['image']\nmask_elastic = augmented['mask']\n\nvisualize(image_elastic, mask_elastic, original_image=image, original_mask=mask)\n</pre> aug = A.ElasticTransform(p=1, alpha=120, sigma=120 * 0.05, alpha_affine=120 * 0.03)  random.seed(7) augmented = aug(image=image, mask=mask)  image_elastic = augmented['image'] mask_elastic = augmented['mask']  visualize(image_elastic, mask_elastic, original_image=image, original_mask=mask) In\u00a0[15]: Copied! <pre>aug = A.GridDistortion(p=1)\n\nrandom.seed(7)\naugmented = aug(image=image, mask=mask)\n\nimage_grid = augmented['image']\nmask_grid = augmented['mask']\n\nvisualize(image_grid, mask_grid, original_image=image, original_mask=mask)\n</pre> aug = A.GridDistortion(p=1)  random.seed(7) augmented = aug(image=image, mask=mask)  image_grid = augmented['image'] mask_grid = augmented['mask']  visualize(image_grid, mask_grid, original_image=image, original_mask=mask) In\u00a0[16]: Copied! <pre>aug = A.OpticalDistortion(distort_limit=2, shift_limit=0.5, p=1)\n\nrandom.seed(7)\naugmented = aug(image=image, mask=mask)\n\nimage_optical = augmented['image']\nmask_optical = augmented['mask']\n\nvisualize(image_optical, mask_optical, original_image=image, original_mask=mask)\n</pre> aug = A.OpticalDistortion(distort_limit=2, shift_limit=0.5, p=1)  random.seed(7) augmented = aug(image=image, mask=mask)  image_optical = augmented['image'] mask_optical = augmented['mask']  visualize(image_optical, mask_optical, original_image=image, original_mask=mask) <p>One may combine RandomCrop and RandomScale but there is a transformation RandomSizedCrop that allows to combine them into one transformation.</p> In\u00a0[17]: Copied! <pre>aug = A.RandomSizedCrop(min_max_height=(50, 101), height=original_height, width=original_width, p=1)\n\nrandom.seed(7)\naugmented = aug(image=image, mask=mask)\n\nimage_scaled = augmented['image']\nmask_scaled = augmented['mask']\n\nvisualize(image_scaled, mask_scaled, original_image=image, original_mask=mask)\n</pre> aug = A.RandomSizedCrop(min_max_height=(50, 101), height=original_height, width=original_width, p=1)  random.seed(7) augmented = aug(image=image, mask=mask)  image_scaled = augmented['image'] mask_scaled = augmented['mask']  visualize(image_scaled, mask_scaled, original_image=image, original_mask=mask) <p>Light non-destructive augmentations.</p> In\u00a0[18]: Copied! <pre>aug = A.Compose([\n    A.VerticalFlip(p=0.5),\n    A.RandomRotate90(p=0.5)]\n)\n\nrandom.seed(7)\naugmented = aug(image=image, mask=mask)\n\nimage_light = augmented['image']\nmask_light = augmented['mask']\n\nvisualize(image_light, mask_light, original_image=image, original_mask=mask)\n</pre> aug = A.Compose([     A.VerticalFlip(p=0.5),     A.RandomRotate90(p=0.5)] )  random.seed(7) augmented = aug(image=image, mask=mask)  image_light = augmented['image'] mask_light = augmented['mask']  visualize(image_light, mask_light, original_image=image, original_mask=mask) In\u00a0[19]: Copied! <pre>aug = A.Compose([\n    A.OneOf([\n        A.RandomSizedCrop(min_max_height=(50, 101), height=original_height, width=original_width, p=0.5),\n        A.PadIfNeeded(min_height=original_height, min_width=original_width, p=0.5)\n    ],p=1),\n    A.VerticalFlip(p=0.5),\n    A.RandomRotate90(p=0.5),\n    A.OneOf([\n        A.ElasticTransform(p=0.5, alpha=120, sigma=120 * 0.05, alpha_affine=120 * 0.03),\n        A.GridDistortion(p=0.5),\n        A.OpticalDistortion(distort_limit=1, shift_limit=0.5, p=1),\n    ], p=0.8)])\n\nrandom.seed(11)\naugmented = aug(image=image, mask=mask)\n\nimage_medium = augmented['image']\nmask_medium = augmented['mask']\n\nvisualize(image_medium, mask_medium, original_image=image, original_mask=mask)\n</pre> aug = A.Compose([     A.OneOf([         A.RandomSizedCrop(min_max_height=(50, 101), height=original_height, width=original_width, p=0.5),         A.PadIfNeeded(min_height=original_height, min_width=original_width, p=0.5)     ],p=1),     A.VerticalFlip(p=0.5),     A.RandomRotate90(p=0.5),     A.OneOf([         A.ElasticTransform(p=0.5, alpha=120, sigma=120 * 0.05, alpha_affine=120 * 0.03),         A.GridDistortion(p=0.5),         A.OpticalDistortion(distort_limit=1, shift_limit=0.5, p=1),     ], p=0.8)])  random.seed(11) augmented = aug(image=image, mask=mask)  image_medium = augmented['image'] mask_medium = augmented['mask']  visualize(image_medium, mask_medium, original_image=image, original_mask=mask) <p>Many non-spatial transformations like CLAHE, RandomBrightness, RandomContrast, RandomGamma can be also added. They will be applied only to the image and not the mask.</p> In\u00a0[20]: Copied! <pre>aug = A.Compose([\n    A.OneOf([\n        A.RandomSizedCrop(min_max_height=(50, 101), height=original_height, width=original_width, p=0.5),\n        A.PadIfNeeded(min_height=original_height, min_width=original_width, p=0.5)\n    ], p=1),\n    A.VerticalFlip(p=0.5),\n    A.RandomRotate90(p=0.5),\n    A.OneOf([\n        A.ElasticTransform(alpha=120, sigma=120 * 0.05, alpha_affine=120 * 0.03, p=0.5),\n        A.GridDistortion(p=0.5),\n        A.OpticalDistortion(distort_limit=2, shift_limit=0.5, p=1)\n        ], p=0.8),\n    A.CLAHE(p=0.8),\n    A.RandomBrightnessContrast(p=0.8),\n    A.RandomGamma(p=0.8)])\n\nrandom.seed(11)\naugmented = aug(image=image, mask=mask)\n\nimage_heavy = augmented['image']\nmask_heavy = augmented['mask']\n\nvisualize(image_heavy, mask_heavy, original_image=image, original_mask=mask)\n</pre> aug = A.Compose([     A.OneOf([         A.RandomSizedCrop(min_max_height=(50, 101), height=original_height, width=original_width, p=0.5),         A.PadIfNeeded(min_height=original_height, min_width=original_width, p=0.5)     ], p=1),     A.VerticalFlip(p=0.5),     A.RandomRotate90(p=0.5),     A.OneOf([         A.ElasticTransform(alpha=120, sigma=120 * 0.05, alpha_affine=120 * 0.03, p=0.5),         A.GridDistortion(p=0.5),         A.OpticalDistortion(distort_limit=2, shift_limit=0.5, p=1)         ], p=0.8),     A.CLAHE(p=0.8),     A.RandomBrightnessContrast(p=0.8),     A.RandomGamma(p=0.8)])  random.seed(11) augmented = aug(image=image, mask=mask)  image_heavy = augmented['image'] mask_heavy = augmented['mask']  visualize(image_heavy, mask_heavy, original_image=image, original_mask=mask)"},{"location":"examples/example_kaggle_salt/#using-albumentations-for-a-semantic-segmentation-task","title":"Using Albumentations for a semantic segmentation task\u00b6","text":""},{"location":"examples/example_kaggle_salt/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/example_kaggle_salt/#define-a-function-to-visualize-images-and-masks","title":"Define a function to visualize images and masks\u00b6","text":""},{"location":"examples/example_kaggle_salt/#read-an-image-and-its-mask-from-the-disk","title":"Read an image and its mask from the disk\u00b6","text":""},{"location":"examples/example_kaggle_salt/#original-image","title":"Original image \u00b6","text":""},{"location":"examples/example_kaggle_salt/#padding","title":"Padding\u00b6","text":""},{"location":"examples/example_kaggle_salt/#centercrop-and-crop","title":"CenterCrop and Crop\u00b6","text":""},{"location":"examples/example_kaggle_salt/#non-destructive-transformations-dehidral-group-d4","title":"Non destructive transformations. Dehidral group D4\u00b6","text":""},{"location":"examples/example_kaggle_salt/#horizontalflip","title":"HorizontalFlip\u00b6","text":""},{"location":"examples/example_kaggle_salt/#verticalflip","title":"VerticalFlip\u00b6","text":""},{"location":"examples/example_kaggle_salt/#randomrotate90-randomly-rotates-by-0-90-180-270-degrees","title":"RandomRotate90 (Randomly rotates by 0, 90, 180, 270 degrees)\u00b6","text":""},{"location":"examples/example_kaggle_salt/#transpose-switch-x-and-y-axis","title":"Transpose (switch X and Y axis)\u00b6","text":""},{"location":"examples/example_kaggle_salt/#non-rigid-transformations-elastictransform-griddistortion-opticaldistortion","title":"Non-rigid transformations: ElasticTransform, GridDistortion, OpticalDistortion\u00b6","text":""},{"location":"examples/example_kaggle_salt/#elastictransform","title":"ElasticTransform\u00b6","text":""},{"location":"examples/example_kaggle_salt/#griddistortion","title":"GridDistortion\u00b6","text":""},{"location":"examples/example_kaggle_salt/#opticaldistortion","title":"OpticalDistortion\u00b6","text":""},{"location":"examples/example_kaggle_salt/#randomsizedcrop","title":"RandomSizedCrop\u00b6","text":""},{"location":"examples/example_kaggle_salt/#lets-try-to-combine-different-transformations","title":"Let's try to combine different transformations\u00b6","text":""},{"location":"examples/example_kaggle_salt/#lets-add-non-rigid-transformations-and-randomsizedcrop","title":"Let's add non rigid transformations and RandomSizedCrop\u00b6","text":""},{"location":"examples/example_kaggle_salt/#medium-augmentations","title":"Medium augmentations\u00b6","text":""},{"location":"examples/example_kaggle_salt/#lets-add-non-spatial-stransformations","title":"Let's add non-spatial stransformations.\u00b6","text":""},{"location":"examples/example_keypoints/","title":"Using Albumentations to augment keypoints","text":"<p>In this notebook we will show how to apply Albumentations to the keypoint augmentation problem. Please refer to A list of transforms and their supported targets to see which spatial-level augmentations support keypoints. You can use any pixel-level augmentation to an image with keypoints because pixel-level augmentations don't affect keypoints.</p> <p>Note: by default, augmentations that work with keypoints don't change keypoints' labels after transformation. If keypoints' labels are side-specific, that may pose a problem. For example, if you have a keypoint named <code>left arm</code> and apply a HorizontalFlip augmentation, you will get a keypoint with the same <code>left arm</code> label, but it will now look like a <code>right arm</code> keypoint. See a picture at the end of this article for a visual example.</p> <p>If you work with such type of keypoints, consider using SymmetricKeypoints augmentations from albumentations-experimental that are created precisely to handle that case.</p> In\u00a0[1]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt  import albumentations as A In\u00a0[2]: Copied! <pre>KEYPOINT_COLOR = (0, 255, 0) # Green\n\ndef vis_keypoints(image, keypoints, color=KEYPOINT_COLOR, diameter=15):\n    image = image.copy()\n\n    for (x, y) in keypoints:\n        cv2.circle(image, (int(x), int(y)), diameter, (0, 255, 0), -1)\n\n    plt.figure(figsize=(8, 8))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> KEYPOINT_COLOR = (0, 255, 0) # Green  def vis_keypoints(image, keypoints, color=KEYPOINT_COLOR, diameter=15):     image = image.copy()      for (x, y) in keypoints:         cv2.circle(image, (int(x), int(y)), diameter, (0, 255, 0), -1)      plt.figure(figsize=(8, 8))     plt.axis('off')     plt.imshow(image) In\u00a0[3]: Copied! <pre>image = cv2.imread('images/keypoints_image.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</pre> image = cv2.imread('images/keypoints_image.jpg') image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) <p>We will use the <code>xy</code> format for keypoints' coordinates. Each keypoint is defined with two coordinates, <code>x</code> is the position on the x-axis, and <code>y</code> is the position on the y-axis. Please refer to this article with the detailed description of formats for keypoints' coordinates - https://albumentations.ai/docs/getting_started/keypoints_augmentation/</p> In\u00a0[4]: Copied! <pre>keypoints = [\n    (100, 100),\n    (720, 410),\n    (1100, 400),\n    (1700, 30),\n    (300, 650),\n    (1570, 590),\n    (560, 800),\n    (1300, 750),\n    (900, 1000),\n    (910, 780),\n    (670, 670),\n    (830, 670),\n    (1000, 670),\n    (1150, 670),\n    (820, 900),\n    (1000, 900),\n]\n</pre> keypoints = [     (100, 100),     (720, 410),     (1100, 400),     (1700, 30),     (300, 650),     (1570, 590),     (560, 800),     (1300, 750),     (900, 1000),     (910, 780),     (670, 670),     (830, 670),     (1000, 670),     (1150, 670),     (820, 900),     (1000, 900), ] In\u00a0[5]: Copied! <pre>vis_keypoints(image, keypoints)\n</pre> vis_keypoints(image, keypoints) In\u00a0[6]: Copied! <pre>transform = A.Compose(\n    [A.HorizontalFlip(p=1)],\n    keypoint_params=A.KeypointParams(format='xy')\n)\ntransformed = transform(image=image, keypoints=keypoints)\nvis_keypoints(transformed['image'], transformed['keypoints'])\n</pre> transform = A.Compose(     [A.HorizontalFlip(p=1)],     keypoint_params=A.KeypointParams(format='xy') ) transformed = transform(image=image, keypoints=keypoints) vis_keypoints(transformed['image'], transformed['keypoints']) In\u00a0[7]: Copied! <pre>transform = A.Compose(\n    [A.VerticalFlip(p=1)],\n    keypoint_params=A.KeypointParams(format='xy')\n)\ntransformed = transform(image=image, keypoints=keypoints)\nvis_keypoints(transformed['image'], transformed['keypoints'])\n</pre> transform = A.Compose(     [A.VerticalFlip(p=1)],     keypoint_params=A.KeypointParams(format='xy') ) transformed = transform(image=image, keypoints=keypoints) vis_keypoints(transformed['image'], transformed['keypoints']) <p>We fix the random seed for visualization purposes, so the augmentation will always produce the same result. In a real computer vision pipeline, you shouldn't fix the random seed before applying a transform to the image because, in that case, the pipeline will always output the same image. The purpose of image augmentation is to use different transformations each time.</p> In\u00a0[8]: Copied! <pre>random.seed(7)\ntransform = A.Compose(\n    [A.RandomCrop(width=768, height=768, p=1)],\n    keypoint_params=A.KeypointParams(format='xy')\n)\ntransformed = transform(image=image, keypoints=keypoints)\nvis_keypoints(transformed['image'], transformed['keypoints'])\n</pre> random.seed(7) transform = A.Compose(     [A.RandomCrop(width=768, height=768, p=1)],     keypoint_params=A.KeypointParams(format='xy') ) transformed = transform(image=image, keypoints=keypoints) vis_keypoints(transformed['image'], transformed['keypoints']) In\u00a0[9]: Copied! <pre>random.seed(7)\ntransform = A.Compose(\n    [A.Rotate(p=0.5)],\n    keypoint_params=A.KeypointParams(format='xy')\n)\ntransformed = transform(image=image, keypoints=keypoints)\nvis_keypoints(transformed['image'], transformed['keypoints'])\n</pre> random.seed(7) transform = A.Compose(     [A.Rotate(p=0.5)],     keypoint_params=A.KeypointParams(format='xy') ) transformed = transform(image=image, keypoints=keypoints) vis_keypoints(transformed['image'], transformed['keypoints']) In\u00a0[10]: Copied! <pre>transform = A.Compose(\n    [A.CenterCrop(height=512, width=512, p=1)],\n    keypoint_params=A.KeypointParams(format='xy')\n)\ntransformed = transform(image=image, keypoints=keypoints)\nvis_keypoints(transformed['image'], transformed['keypoints'])\n</pre> transform = A.Compose(     [A.CenterCrop(height=512, width=512, p=1)],     keypoint_params=A.KeypointParams(format='xy') ) transformed = transform(image=image, keypoints=keypoints) vis_keypoints(transformed['image'], transformed['keypoints']) In\u00a0[11]: Copied! <pre>random.seed(7)\ntransform = A.Compose(\n    [A.ShiftScaleRotate(p=0.5)],\n    keypoint_params=A.KeypointParams(format='xy')\n)\ntransformed = transform(image=image, keypoints=keypoints)\nvis_keypoints(transformed['image'], transformed['keypoints'])\n</pre> random.seed(7) transform = A.Compose(     [A.ShiftScaleRotate(p=0.5)],     keypoint_params=A.KeypointParams(format='xy') ) transformed = transform(image=image, keypoints=keypoints) vis_keypoints(transformed['image'], transformed['keypoints']) In\u00a0[12]: Copied! <pre>random.seed(7)\ntransform = A.Compose([\n        A.RandomSizedCrop(min_max_height=(256, 1025), height=512, width=512, p=0.5),\n        A.HorizontalFlip(p=0.5),\n        A.OneOf([\n            A.HueSaturationValue(p=0.5),\n            A.RGBShift(p=0.7)\n        ], p=1),\n        A.RandomBrightnessContrast(p=0.5)\n    ],\n    keypoint_params=A.KeypointParams(format='xy'),\n)\ntransformed = transform(image=image, keypoints=keypoints)\nvis_keypoints(transformed['image'], transformed['keypoints'])\n</pre> random.seed(7) transform = A.Compose([         A.RandomSizedCrop(min_max_height=(256, 1025), height=512, width=512, p=0.5),         A.HorizontalFlip(p=0.5),         A.OneOf([             A.HueSaturationValue(p=0.5),             A.RGBShift(p=0.7)         ], p=1),         A.RandomBrightnessContrast(p=0.5)     ],     keypoint_params=A.KeypointParams(format='xy'), ) transformed = transform(image=image, keypoints=keypoints) vis_keypoints(transformed['image'], transformed['keypoints'])"},{"location":"examples/example_keypoints/#using-albumentations-to-augment-keypoints","title":"Using Albumentations to augment keypoints\u00b6","text":""},{"location":"examples/example_keypoints/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/example_keypoints/#define-a-function-to-visualize-keypoints-on-an-image","title":"Define a function to visualize keypoints on an image\u00b6","text":""},{"location":"examples/example_keypoints/#get-an-image-and-annotations-for-it","title":"Get an image and annotations for it\u00b6","text":""},{"location":"examples/example_keypoints/#define-keypoints","title":"Define keypoints\u00b6","text":""},{"location":"examples/example_keypoints/#visualize-the-original-image-with-keypoints","title":"Visualize the original image with keypoints\u00b6","text":""},{"location":"examples/example_keypoints/#define-a-simple-augmentation-pipeline","title":"Define a simple augmentation pipeline\u00b6","text":""},{"location":"examples/example_keypoints/#a-few-more-examples-of-augmentation-pipelines","title":"A few more examples of augmentation pipelines\u00b6","text":""},{"location":"examples/example_keypoints/#an-example-of-complex-augmentation-pipeline","title":"An example of complex augmentation pipeline\u00b6","text":""},{"location":"examples/example_mixup/","title":"MixUp transform in Albumentations","text":"In\u00a0[1]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\nfrom pathlib import Path\nimport numpy as np\nimport cv2\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt from pathlib import Path import numpy as np import cv2  import albumentations as A In\u00a0[2]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(10, 5))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(10, 5))     plt.axis('off')     plt.imshow(image) In\u00a0[3]: Copied! <pre>def load_rgb(image_path):\n    image = cv2.imread(image_path)\n    return cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</pre> def load_rgb(image_path):     image = cv2.imread(image_path)     return cv2.cvtColor(image, cv2.COLOR_BGR2RGB) In\u00a0[4]: Copied! <pre>img_path = \"../images/woman.jpeg\"\nimg = load_rgb(img_path)\n</pre> img_path = \"../images/woman.jpeg\" img = load_rgb(img_path) In\u00a0[5]: Copied! <pre>class_id = 0\n</pre> class_id = 0 In\u00a0[6]: Copied! <pre>visualize(img)\n</pre> visualize(img) <p>To use transform we need to define reference data that could be any sequence or generator.</p> <p>We also need to defined <code>read_fn</code> that transforms items from <code>reference_data</code> to dictionaries with keys: <code>image</code>, and optional <code>global_label</code>, <code>mask</code>.</p> In\u00a0[7]: Copied! <pre>reference_data = [{\n    \"image_path\": \"../images/cat1.jpeg\", \n    \"class_id\": 1},\n                  {\"image_path\": \"../images/tiger.jpeg\", \n    \"class_id\": 2}]\n</pre> reference_data = [{     \"image_path\": \"../images/cat1.jpeg\",      \"class_id\": 1},                   {\"image_path\": \"../images/tiger.jpeg\",      \"class_id\": 2}]  In\u00a0[8]: Copied! <pre>def int_to_onehot(value, num_classes):\n    \"\"\"Convert an array of integers to one-hot representation.\n    \n    Args:\n        values (np.ndarray): Array of integers to be converted.\n        num_classes (int): Total number of classes, determines the length of one-hot vectors.\n\n    Returns:\n        np.ndarray: One-hot encoded representation of `values`.\n    \"\"\"\n    # Initialize the one-hot encoded array of shape (num_classes,)\n    one_hot = np.zeros(num_classes, dtype=int)\n    \n    # Set the appropriate index to one\n    one_hot[value] = 1\n    \n    return one_hot\n</pre> def int_to_onehot(value, num_classes):     \"\"\"Convert an array of integers to one-hot representation.          Args:         values (np.ndarray): Array of integers to be converted.         num_classes (int): Total number of classes, determines the length of one-hot vectors.      Returns:         np.ndarray: One-hot encoded representation of `values`.     \"\"\"     # Initialize the one-hot encoded array of shape (num_classes,)     one_hot = np.zeros(num_classes, dtype=int)          # Set the appropriate index to one     one_hot[value] = 1          return one_hot In\u00a0[9]: Copied! <pre>NUM_CLASSES = 5\n</pre> NUM_CLASSES = 5 In\u00a0[10]: Copied! <pre>target_height = 2500\ntarget_width = 1800\n</pre> target_height = 2500 target_width = 1800 In\u00a0[11]: Copied! <pre># We can process data as we want, including application of augmentations transform.\n\nreference_aug = A.Compose([A.RandomCrop(width=target_width, height=target_height, p=1)], p=1)\n</pre> # We can process data as we want, including application of augmentations transform.  reference_aug = A.Compose([A.RandomCrop(width=target_width, height=target_height, p=1)], p=1) In\u00a0[12]: Copied! <pre>def read_fn(item):\n    image = load_rgb(item[\"image_path\"])\n    \n    transformed_image = reference_aug(image=image)[\"image\"]\n    \n    global_label = int_to_onehot(item[\"class_id\"], NUM_CLASSES)\n    return {\n        \"image\": transformed_image,\n        \"global_label\": global_label\n    }\n</pre> def read_fn(item):     image = load_rgb(item[\"image_path\"])          transformed_image = reference_aug(image=image)[\"image\"]          global_label = int_to_onehot(item[\"class_id\"], NUM_CLASSES)     return {         \"image\": transformed_image,         \"global_label\": global_label     } In\u00a0[13]: Copied! <pre>visualize(read_fn(reference_data[0])[\"image\"])\n</pre> visualize(read_fn(reference_data[0])[\"image\"]) In\u00a0[14]: Copied! <pre>visualize(read_fn(reference_data[1])[\"image\"])\n</pre> visualize(read_fn(reference_data[1])[\"image\"]) In\u00a0[15]: Copied! <pre>transform = A.Compose([A.RandomCrop(width=target_width, height=target_height, p=1),\n                                       A.MixUp(reference_data=reference_data,\n                                              read_fn=read_fn, p=1),\n                                      A.HorizontalFlip(p=1)], p=1)\n</pre> transform = A.Compose([A.RandomCrop(width=target_width, height=target_height, p=1),                                        A.MixUp(reference_data=reference_data,                                               read_fn=read_fn, p=1),                                       A.HorizontalFlip(p=1)], p=1) In\u00a0[16]: Copied! <pre>original_global_label = int_to_onehot(class_id, NUM_CLASSES)\n</pre> original_global_label = int_to_onehot(class_id, NUM_CLASSES) In\u00a0[37]: Copied! <pre>transformed = transform(image=img, global_label=original_global_label)\nprint(\"Global label = \", transformed[\"global_label\"])\nprint(\"Mixing coefficient = \", transformed[\"mix_coef\"])\n\nvisualize(transformed[\"image\"])\n</pre> transformed = transform(image=img, global_label=original_global_label) print(\"Global label = \", transformed[\"global_label\"]) print(\"Mixing coefficient = \", transformed[\"mix_coef\"])  visualize(transformed[\"image\"]) <pre>Global label =  [0.62160869 0.37839131 0.         0.         0.        ]\nMixing coefficient =  0.6216086930047383\n</pre> In\u00a0[41]: Copied! <pre>transformed = transform(image=img, global_label=original_global_label)\nprint(\"Global label = \", transformed[\"global_label\"])\nprint(\"Mixing coefficient = \", transformed[\"mix_coef\"])\n\nvisualize(transformed[\"image\"])\n</pre> transformed = transform(image=img, global_label=original_global_label) print(\"Global label = \", transformed[\"global_label\"]) print(\"Mixing coefficient = \", transformed[\"mix_coef\"])  visualize(transformed[\"image\"]) <pre>Global label =  [0.54018375 0.         0.45981625 0.         0.        ]\nMixing coefficient =  0.5401837474762494\n</pre>"},{"location":"examples/example_mixup/#mixup-transform-in-albumentations","title":"MixUp transform in Albumentations\u00b6","text":"<p>In that transform we create weighted average of original and reference images. Transform also supports global_labels and masks</p>"},{"location":"examples/example_mixup/#define-a-function-to-visualize-an-image","title":"Define a function to visualize an image\u00b6","text":""},{"location":"examples/example_mixup/#load-the-image-from-the-disk","title":"Load the image from the disk\u00b6","text":""},{"location":"examples/example_mixup/#visualize-the-original-image","title":"Visualize the original image\u00b6","text":""},{"location":"examples/example_mixup/#mixup-transform","title":"Mixup transform\u00b6","text":""},{"location":"examples/example_mixup/#show-reference-images","title":"Show reference images\u00b6","text":""},{"location":"examples/example_multi_target/","title":"Applying the same augmentation with the same parameters to multiple images, masks, bounding boxes, or keypoints","text":"<p>Sometimes you want to apply the same set of augmentations to multiple input objects of the same type. For example, you might have a set of frames from the video, and you want to augment them in the same way. Or you may have multiple masks for the same image, and you want to apply the same augmentation for all of them.</p> <p>In Albumentations, you can declare additional targets and their types using the <code>additional_targets</code> argument to <code>Compose</code>.</p> <p>For the name of an additional target, you can use any string value that is also a valid argument name in Python. Later, you will use those names to pass additional targets to a transformation pipeline. So you can't use a string that starts with a digit, such as <code>'0image'</code> because it is not a valid Python argument name.</p> <p>The type could be either <code>image</code>, <code>mask</code>, <code>bboxes</code>, or <code>keypoints</code>.</p> <p>An example definition of <code>Compose</code> that supports multiple inputs of the same type may be the following:</p> <pre><code>import albumentations as A\n\ntransform = A.Compose(\n    [HorizontalFlip(p=0.5), ...],\n    additional_targets={\n        'image1': 'image',\n        'image2': 'image',\n        ...\n        'imageN': 'image',\n\n        'bboxes1': 'bboxes',\n        'bboxes1': 'bboxes',\n        ...\n        'bboxesM': 'bboxes',\n\n        'keypoints1': 'keypoints',\n        'keypoints2': 'keypoints',\n        ...\n        'keypointsK': 'keypoints',\n\n        'mask1': 'mask',\n        'mask2': 'mask',\n        ...\n        'maskL': 'mask'\n    })\n)\n</code></pre> <p>Note: there is also an alternative way to apply the same augmentation to multiple inputs such as images, masks, etc.</p> <p><code>ReplayCompose</code> is a tool that could record augmentation parameters applied to one set of inputs (e.g., an image and an associated mask) and then use the recorded values to augment another set of inputs in the same way.</p> <p>You can read more about <code>ReplayCompose</code> here.</p> In\u00a0[2]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt  import albumentations as A In\u00a0[3]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(10, 10))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(10, 10))     plt.axis('off')     plt.imshow(image) In\u00a0[4]: Copied! <pre>image = cv2.imread('images/multi_target_1.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\nimage0 = cv2.imread('images/multi_target_2.jpg')\nimage0 = cv2.cvtColor(image0, cv2.COLOR_BGR2RGB)\nimage1 = cv2.imread('images/multi_target_3.jpg')\nimage1 = cv2.cvtColor(image1, cv2.COLOR_BGR2RGB)\n</pre> image = cv2.imread('images/multi_target_1.jpg') image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) image0 = cv2.imread('images/multi_target_2.jpg') image0 = cv2.cvtColor(image0, cv2.COLOR_BGR2RGB) image1 = cv2.imread('images/multi_target_3.jpg') image1 = cv2.cvtColor(image1, cv2.COLOR_BGR2RGB) In\u00a0[5]: Copied! <pre>visualize(image)\n</pre> visualize(image) In\u00a0[6]: Copied! <pre>visualize(image0)\n</pre> visualize(image0) In\u00a0[7]: Copied! <pre>visualize(image1)\n</pre> visualize(image1) <p>The pipeline expects three images as inputs named <code>image</code>, <code>image0</code>, and <code>image1</code>. Then the pipeline will augment those three images in the same way. So it will apply the same set of transformations with the same parameters.</p> In\u00a0[22]: Copied! <pre>transform = A.Compose(\n    [A.VerticalFlip(p=1)],\n    additional_targets={'image0': 'image', 'image1': 'image'}\n)\n\n# original object and additional targets of the same type should have the same shape\nimage = image[:503, :723]\nimage1 = image[:503, :723]\n</pre> transform = A.Compose(     [A.VerticalFlip(p=1)],     additional_targets={'image0': 'image', 'image1': 'image'} )  # original object and additional targets of the same type should have the same shape image = image[:503, :723] image1 = image[:503, :723]  In\u00a0[14]: Copied! <pre>transformed = transform(image=image, image0=image0, image1=image1)\n</pre> transformed = transform(image=image, image0=image0, image1=image1) In\u00a0[15]: Copied! <pre>visualize(transformed['image'])\n</pre> visualize(transformed['image']) In\u00a0[16]: Copied! <pre>visualize(transformed['image0'])\n</pre> visualize(transformed['image0']) In\u00a0[17]: Copied! <pre>visualize(transformed['image1'])\n</pre> visualize(transformed['image1']) In\u00a0[12]: Copied! <pre>transform = A.Compose(\n    [\n        A.HorizontalFlip(p=0.5),\n        A.ShiftScaleRotate(p=0.5),\n        A.RandomBrightnessContrast(p=0.2),\n        A.RGBShift(p=0.2),\n    ],\n    additional_targets={'image0': 'image', 'image1': 'image'}\n)\n</pre> transform = A.Compose(     [         A.HorizontalFlip(p=0.5),         A.ShiftScaleRotate(p=0.5),         A.RandomBrightnessContrast(p=0.2),         A.RGBShift(p=0.2),     ],     additional_targets={'image0': 'image', 'image1': 'image'} ) In\u00a0[18]: Copied! <pre>random.seed(42)\ntransformed = transform(image=image, image0=image0, image1=image1)\n</pre> random.seed(42) transformed = transform(image=image, image0=image0, image1=image1) In\u00a0[19]: Copied! <pre>visualize(transformed['image'])\n</pre> visualize(transformed['image']) In\u00a0[20]: Copied! <pre>visualize(transformed['image0'])\n</pre> visualize(transformed['image0']) In\u00a0[21]: Copied! <pre>visualize(transformed['image1'])\n</pre> visualize(transformed['image1'])"},{"location":"examples/example_multi_target/#applying-the-same-augmentation-with-the-same-parameters-to-multiple-images-masks-bounding-boxes-or-keypoints","title":"Applying the same augmentation with the same parameters to multiple images, masks, bounding boxes, or keypoints\u00b6","text":""},{"location":"examples/example_multi_target/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/example_multi_target/#define-a-function-to-visualize-an-image","title":"Define a function to visualize an image\u00b6","text":""},{"location":"examples/example_multi_target/#load-images-from-the-disk","title":"Load images from the disk\u00b6","text":""},{"location":"examples/example_multi_target/#show-original-images","title":"Show original images\u00b6","text":""},{"location":"examples/example_multi_target/#define-an-augmentation-pipeline","title":"Define an augmentation pipeline\u00b6","text":""},{"location":"examples/example_multi_target/#an-example-of-more-complex-pipeline","title":"An example of more complex pipeline\u00b6","text":""},{"location":"examples/example_weather_transforms/","title":"Weather augmentations in Albumentations","text":"<p>This notebook demonstrates weather augmentations that are supported by Albumentations.</p> In\u00a0[2]: Copied! <pre>import random\n\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random   import cv2 from matplotlib import pyplot as plt  import albumentations as A In\u00a0[3]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(20, 10))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(20, 10))     plt.axis('off')     plt.imshow(image) In\u00a0[4]: Copied! <pre>image = cv2.imread('images/weather_example.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</pre> image = cv2.imread('images/weather_example.jpg') image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) In\u00a0[5]: Copied! <pre>visualize(image)\n</pre> visualize(image) <p>We fix the random seed for visualization purposes, so the augmentation will always produce the same result. In a real computer vision pipeline, you shouldn't fix the random seed before applying a transform to the image because, in that case, the pipeline will always output the same image. The purpose of image augmentation is to use different transformations each time.</p> In\u00a0[6]: Copied! <pre>transform = A.Compose(\n    [A.RandomRain(brightness_coefficient=0.9, drop_width=1, blur_value=5, p=1)],\n)\nrandom.seed(7)\ntransformed = transform(image=image)\nvisualize(transformed['image'])\n</pre> transform = A.Compose(     [A.RandomRain(brightness_coefficient=0.9, drop_width=1, blur_value=5, p=1)], ) random.seed(7) transformed = transform(image=image) visualize(transformed['image']) In\u00a0[7]: Copied! <pre>transform = A.Compose(\n    [A.RandomSnow(brightness_coeff=2.5, snow_point_lower=0.3, snow_point_upper=0.5, p=1)],\n)\nrandom.seed(7)\ntransformed = transform(image=image)\nvisualize(transformed['image'])\n</pre> transform = A.Compose(     [A.RandomSnow(brightness_coeff=2.5, snow_point_lower=0.3, snow_point_upper=0.5, p=1)], ) random.seed(7) transformed = transform(image=image) visualize(transformed['image']) In\u00a0[8]: Copied! <pre>transform = A.Compose(\n    [A.RandomSunFlare(flare_roi=(0, 0, 1, 0.5), angle_lower=0.5, p=1)],\n)\nrandom.seed(7)\ntransformed = transform(image=image)\nvisualize(transformed['image'])\n</pre> transform = A.Compose(     [A.RandomSunFlare(flare_roi=(0, 0, 1, 0.5), angle_lower=0.5, p=1)], ) random.seed(7) transformed = transform(image=image) visualize(transformed['image']) In\u00a0[9]: Copied! <pre>transform = A.Compose(\n    [A.RandomShadow(num_shadows_lower=1, num_shadows_upper=1, shadow_dimension=5, shadow_roi=(0, 0.5, 1, 1), p=1)],\n)\nrandom.seed(7)\ntransformed = transform(image=image)\nvisualize(transformed['image'])\n</pre> transform = A.Compose(     [A.RandomShadow(num_shadows_lower=1, num_shadows_upper=1, shadow_dimension=5, shadow_roi=(0, 0.5, 1, 1), p=1)], ) random.seed(7) transformed = transform(image=image) visualize(transformed['image']) In\u00a0[10]: Copied! <pre>transform = A.Compose(\n    [A.RandomFog(fog_coef_lower=0.7, fog_coef_upper=0.8, alpha_coef=0.1, p=1)],\n)\nrandom.seed(7)\ntransformed = transform(image=image)\nvisualize(transformed['image'])\n</pre> transform = A.Compose(     [A.RandomFog(fog_coef_lower=0.7, fog_coef_upper=0.8, alpha_coef=0.1, p=1)], ) random.seed(7) transformed = transform(image=image) visualize(transformed['image'])"},{"location":"examples/example_weather_transforms/#weather-augmentations-in-albumentations","title":"Weather augmentations in Albumentations\u00b6","text":""},{"location":"examples/example_weather_transforms/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/example_weather_transforms/#define-a-function-to-visualize-an-image","title":"Define a function to visualize an image\u00b6","text":""},{"location":"examples/example_weather_transforms/#load-the-image-from-the-disk","title":"Load the image from the disk\u00b6","text":""},{"location":"examples/example_weather_transforms/#visualize-the-original-image","title":"Visualize the original image\u00b6","text":""},{"location":"examples/example_weather_transforms/#randomrain","title":"RandomRain\u00b6","text":""},{"location":"examples/example_weather_transforms/#randomsnow","title":"RandomSnow\u00b6","text":""},{"location":"examples/example_weather_transforms/#randomsunflare","title":"RandomSunFlare\u00b6","text":""},{"location":"examples/example_weather_transforms/#randomshadow","title":"RandomShadow\u00b6","text":""},{"location":"examples/example_weather_transforms/#randomfog","title":"RandomFog\u00b6","text":""},{"location":"examples/example_xymasking/","title":"Example xymasking","text":"<p>This transform is a generalization of the TimeMasking and FrequencyMasking from torchaudio.</p> In\u00a0[8]: Copied! <pre>import random\n\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimport albumentations as A\n</pre> import random  import cv2 from matplotlib import pyplot as plt  import albumentations as A In\u00a0[9]: Copied! <pre>import torchaudio\nimport torch\nfrom pathlib import Path\nimport numpy as np\nimport pandas as pd\n</pre> import torchaudio import torch from pathlib import Path import numpy as np import pandas as pd In\u00a0[21]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(10, 5))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(10, 5))     plt.axis('off')     plt.imshow(image) In\u00a0[22]: Copied! <pre>img = np.load('../images/spectrogram.npy')\n</pre> img = np.load('../images/spectrogram.npy') In\u00a0[23]: Copied! <pre>img.shape\n</pre> img.shape Out[23]: <pre>(128, 256, 4)</pre> In\u00a0[24]: Copied! <pre>visualize(img[:, :, 0])\n</pre> visualize(img[:, :, 0]) In\u00a0[25]: Copied! <pre>params1 = {\n    \"num_masks_x\": 1,    \n    \"mask_x_length\": 20,\n    \"fill_value\": 0,    \n\n}\ntransform1 = A.Compose([A.XYMasking(**params1, p=1)])\nvisualize(transform1(image=img[:, :, 0])[\"image\"])\n</pre> params1 = {     \"num_masks_x\": 1,         \"mask_x_length\": 20,     \"fill_value\": 0,      } transform1 = A.Compose([A.XYMasking(**params1, p=1)]) visualize(transform1(image=img[:, :, 0])[\"image\"]) In\u00a0[26]: Copied! <pre>params2 = {\n    \"num_masks_x\": 1,    \n    \"mask_x_length\": (0, 20), # This line changed from fixed  to a range\n    \"fill_value\": 0,\n}\ntransform2 = A.Compose([A.XYMasking(**params2, p=1)])\nvisualize(transform2(image=img[:, :, 0])[\"image\"])\n</pre> params2 = {     \"num_masks_x\": 1,         \"mask_x_length\": (0, 20), # This line changed from fixed  to a range     \"fill_value\": 0, } transform2 = A.Compose([A.XYMasking(**params2, p=1)]) visualize(transform2(image=img[:, :, 0])[\"image\"]) In\u00a0[27]: Copied! <pre>spectrogram = torchaudio.transforms.Spectrogram()\nmasking = torchaudio.transforms.TimeMasking(time_mask_param=20)\nmasked = masking(torch.from_numpy(img[:, :, 0]))\nvisualize(masked.numpy())\n</pre> spectrogram = torchaudio.transforms.Spectrogram() masking = torchaudio.transforms.TimeMasking(time_mask_param=20) masked = masking(torch.from_numpy(img[:, :, 0])) visualize(masked.numpy()) In\u00a0[29]: Copied! <pre>params3 = {    \n    \"num_masks_y\": 1,    \n    \"mask_y_length\": (0, 20),\n    \"fill_value\": 0,    \n\n}\ntransform3 = A.Compose([A.XYMasking(**params3, p=1)])\nvisualize(transform3(image=img[:, :, 0])[\"image\"])\n</pre> params3 = {         \"num_masks_y\": 1,         \"mask_y_length\": (0, 20),     \"fill_value\": 0,      } transform3 = A.Compose([A.XYMasking(**params3, p=1)]) visualize(transform3(image=img[:, :, 0])[\"image\"]) In\u00a0[30]: Copied! <pre>spectrogram = torchaudio.transforms.Spectrogram()\nmasking = torchaudio.transforms.FrequencyMasking(freq_mask_param=20)\nmasked = masking(torch.from_numpy(img[:, :, 0]))\nvisualize(masked)\n</pre> spectrogram = torchaudio.transforms.Spectrogram() masking = torchaudio.transforms.FrequencyMasking(freq_mask_param=20) masked = masking(torch.from_numpy(img[:, :, 0])) visualize(masked) In\u00a0[32]: Copied! <pre>params4 = {    \n    \"num_masks_x\": (2, 4),\n    \"num_masks_y\": 5,    \n    \"mask_y_length\": 8,\n    \"mask_x_length\": (10, 20),\n    \"fill_value\": 0,  \n\n}\ntransform4 = A.Compose([A.XYMasking(**params4, p=1)])\nvisualize(transform4(image=img[:, :, 0])[\"image\"])\n</pre> params4 = {         \"num_masks_x\": (2, 4),     \"num_masks_y\": 5,         \"mask_y_length\": 8,     \"mask_x_length\": (10, 20),     \"fill_value\": 0,    } transform4 = A.Compose([A.XYMasking(**params4, p=1)]) visualize(transform4(image=img[:, :, 0])[\"image\"]) <p>Transform can work with any number of channels supporing image shapes of</p> <ul> <li>Grayscale: (height, width)</li> <li>RGB: (height, width, 3)</li> <li>Multichannel: (heigh, width, num_channels)</li> </ul> <p>For value that is used to fill masking regions you can use:</p> <ul> <li>scalar that will be applied to every channel</li> <li>list of numbers equal to the number of channels, so that every channel will have it's own filling value</li> </ul> In\u00a0[33]: Copied! <pre>params5 = {    \n    \"num_masks_x\": (2, 4),\n    \"num_masks_y\": 5,    \n    \"mask_y_length\": 8,\n    \"mask_x_length\": (20, 30),\n    \"fill_value\": (0, 1, 2, 3),  \n\n}\ntransform5 = A.Compose([A.XYMasking(**params5, p=1)])\ntransformed = transform5(image=img)[\"image\"]\n</pre> params5 = {         \"num_masks_x\": (2, 4),     \"num_masks_y\": 5,         \"mask_y_length\": 8,     \"mask_x_length\": (20, 30),     \"fill_value\": (0, 1, 2, 3),    } transform5 = A.Compose([A.XYMasking(**params5, p=1)]) transformed = transform5(image=img)[\"image\"] In\u00a0[34]: Copied! <pre>fig, axs = plt.subplots(2, 2) \nvmin=0\nvmax=3\n\naxs[0, 0].imshow(transformed[:, :, 0], vmin=vmin, vmax=vmax)\naxs[0, 0].set_title('Channel 0')\naxs[0, 0].axis('off')  # Hide axes for cleaner visualization\n\naxs[0, 1].imshow(transformed[:, :, 1], vmin=vmin, vmax=vmax)\naxs[0, 1].set_title('Channel 1')\naxs[0, 1].axis('off')\n\naxs[1, 0].imshow(transformed[:, :, 2], vmin=vmin, vmax=vmax)\naxs[1, 0].set_title('Channel 2')\naxs[1, 0].axis('off')\n\naxs[1, 1].imshow(transformed[:, :, 3], vmin=vmin, vmax=vmax)\naxs[1, 1].set_title('Channel 3')\naxs[1, 1].axis('off')\n\nplt.tight_layout()\n\nplt.show()\n</pre> fig, axs = plt.subplots(2, 2)  vmin=0 vmax=3  axs[0, 0].imshow(transformed[:, :, 0], vmin=vmin, vmax=vmax) axs[0, 0].set_title('Channel 0') axs[0, 0].axis('off')  # Hide axes for cleaner visualization  axs[0, 1].imshow(transformed[:, :, 1], vmin=vmin, vmax=vmax) axs[0, 1].set_title('Channel 1') axs[0, 1].axis('off')  axs[1, 0].imshow(transformed[:, :, 2], vmin=vmin, vmax=vmax) axs[1, 0].set_title('Channel 2') axs[1, 0].axis('off')  axs[1, 1].imshow(transformed[:, :, 3], vmin=vmin, vmax=vmax) axs[1, 1].set_title('Channel 3') axs[1, 1].axis('off')  plt.tight_layout()  plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/example_xymasking/#xymasking-aug-in-albumentations","title":"XYMasking aug in Albumentations\u00b6","text":""},{"location":"examples/example_xymasking/#one-vertical-stripe-time-masking-with-fixed-width-filled-with-0","title":"One vertical stripe (time masking) with fixed width, filled with 0\u00b6","text":""},{"location":"examples/example_xymasking/#one-vertical-stripe-time-masking-with-randomly-sampled-width-filled-with-0","title":"One vertical stripe (time masking) with randomly sampled width, filled with 0\u00b6","text":""},{"location":"examples/example_xymasking/#analogous-transform-in-torchaudio","title":"Analogous transform in torchaudio\u00b6\u00b6","text":""},{"location":"examples/example_xymasking/#one-horizontal-stripe-frequency-masking-with-randomly-sampled-width-filled-with-0","title":"One horizontal stripe (frequency masking) with randomly sampled width, filled with 0\u00b6","text":""},{"location":"examples/example_xymasking/#analogous-transform-in-torchaudio","title":"Analogous transform in torchaudio\u00b6","text":""},{"location":"examples/example_xymasking/#several-vertical-and-horizontal-stripes","title":"Several vertical and horizontal stripes\u00b6","text":""},{"location":"examples/example_xymasking/#application-to-the-image-with-the-number-of-channels-larger-than-3-and-different-fill-values-for-different-channels","title":"Application to the image with the number of channels larger than 3, and different fill values for different channels\u00b6","text":""},{"location":"examples/migrating_from_torchvision_to_albumentations/","title":"Migrating from torchvision to Albumentations","text":"<p>This notebook shows how you can use Albumentations instead of torchvision to perform data augmentation.</p> In\u00a0[4]: Copied! <pre>from PIL import Image\nimport cv2\nimport numpy as np\nfrom torch.utils.data import Dataset\nfrom torchvision import transforms\n\nimport albumentations as A\nfrom albumentations.pytorch import ToTensorV2\n</pre> from PIL import Image import cv2 import numpy as np from torch.utils.data import Dataset from torchvision import transforms  import albumentations as A from albumentations.pytorch import ToTensorV2 In\u00a0[2]: Copied! <pre>class TorchvisionDataset(Dataset):\n    def __init__(self, file_paths, labels, transform=None):\n        self.file_paths = file_paths\n        self.labels = labels\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.file_paths)\n\n    def __getitem__(self, idx):\n        label = self.labels[idx]\n        file_path = self.file_paths[idx]\n\n        # Read an image with PIL\n        image = Image.open(file_path)\n        if self.transform:\n            image = self.transform(image)\n        return image, label\n\n\ntorchvision_transform = transforms.Compose([\n    transforms.Resize((256, 256)),\n    transforms.RandomCrop(224),\n    transforms.RandomHorizontalFlip(),\n    transforms.ToTensor(),\n    transforms.Normalize(\n        mean=[0.485, 0.456, 0.406],\n        std=[0.229, 0.224, 0.225],\n    )\n])\n\n\ntorchvision_dataset = TorchvisionDataset(\n    file_paths=['./images/image_1.jpg', './images/image_2.jpg', './images/image_3.jpg'],\n    labels=[1, 2, 3],\n    transform=torchvision_transform,\n)\n</pre> class TorchvisionDataset(Dataset):     def __init__(self, file_paths, labels, transform=None):         self.file_paths = file_paths         self.labels = labels         self.transform = transform      def __len__(self):         return len(self.file_paths)      def __getitem__(self, idx):         label = self.labels[idx]         file_path = self.file_paths[idx]          # Read an image with PIL         image = Image.open(file_path)         if self.transform:             image = self.transform(image)         return image, label   torchvision_transform = transforms.Compose([     transforms.Resize((256, 256)),     transforms.RandomCrop(224),     transforms.RandomHorizontalFlip(),     transforms.ToTensor(),     transforms.Normalize(         mean=[0.485, 0.456, 0.406],         std=[0.229, 0.224, 0.225],     ) ])   torchvision_dataset = TorchvisionDataset(     file_paths=['./images/image_1.jpg', './images/image_2.jpg', './images/image_3.jpg'],     labels=[1, 2, 3],     transform=torchvision_transform, ) In\u00a0[3]: Copied! <pre>class AlbumentationsDataset(Dataset):\n    \"\"\"__init__ and __len__ functions are the same as in TorchvisionDataset\"\"\"\n    def __init__(self, file_paths, labels, transform=None):\n        self.file_paths = file_paths\n        self.labels = labels\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.file_paths)\n\n    def __getitem__(self, idx):\n        label = self.labels[idx]\n        file_path = self.file_paths[idx]\n\n        # Read an image with OpenCV\n        image = cv2.imread(file_path)\n\n        # By default OpenCV uses BGR color space for color images,\n        # so we need to convert the image to RGB color space.\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        if self.transform:\n            augmented = self.transform(image=image)\n            image = augmented['image']\n        return image, label\n\n\nalbumentations_transform = A.Compose([\n    A.Resize(256, 256),\n    A.RandomCrop(224, 224),\n    A.HorizontalFlip(),\n    A.Normalize(\n        mean=[0.485, 0.456, 0.406],\n        std=[0.229, 0.224, 0.225],\n    ),\n    ToTensorV2()\n])\n\n\nalbumentations_dataset = AlbumentationsDataset(\n    file_paths=['./images/image_1.jpg', './images/image_2.jpg', './images/image_3.jpg'],\n    labels=[1, 2, 3],\n    transform=albumentations_transform,\n)\n</pre> class AlbumentationsDataset(Dataset):     \"\"\"__init__ and __len__ functions are the same as in TorchvisionDataset\"\"\"     def __init__(self, file_paths, labels, transform=None):         self.file_paths = file_paths         self.labels = labels         self.transform = transform      def __len__(self):         return len(self.file_paths)      def __getitem__(self, idx):         label = self.labels[idx]         file_path = self.file_paths[idx]          # Read an image with OpenCV         image = cv2.imread(file_path)          # By default OpenCV uses BGR color space for color images,         # so we need to convert the image to RGB color space.         image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)         if self.transform:             augmented = self.transform(image=image)             image = augmented['image']         return image, label   albumentations_transform = A.Compose([     A.Resize(256, 256),     A.RandomCrop(224, 224),     A.HorizontalFlip(),     A.Normalize(         mean=[0.485, 0.456, 0.406],         std=[0.229, 0.224, 0.225],     ),     ToTensorV2() ])   albumentations_dataset = AlbumentationsDataset(     file_paths=['./images/image_1.jpg', './images/image_2.jpg', './images/image_3.jpg'],     labels=[1, 2, 3],     transform=albumentations_transform, ) <p>You can use PIL instead of OpenCV while working with Albumentations, but in that case, you need to convert a PIL image to a NumPy array before applying transformations. Them you need to convert the augmented image back from a NumPy array to a PIL image.</p> In\u00a0[4]: Copied! <pre>class AlbumentationsPilDataset(Dataset):\n    \"\"\"__init__ and __len__ functions are the same as in TorchvisionDataset\"\"\"\n    def __init__(self, file_paths, labels, transform=None):\n        self.file_paths = file_paths\n        self.labels = labels\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.file_paths)\n\n    def __getitem__(self, idx):\n        label = self.labels[idx]\n        file_path = self.file_paths[idx]\n\n        image = Image.open(file_path)\n\n        if self.transform:\n            # Convert PIL image to numpy array\n            image_np = np.array(image)\n            # Apply transformations\n            augmented = self.transform(image=image_np)\n            # Convert numpy array to PIL Image\n            image = Image.fromarray(augmented['image'])\n        return image, label\n\n\nalbumentations_pil_transform = A.Compose([\n    A.Resize(256, 256),\n    A.RandomCrop(224, 224),\n    A.HorizontalFlip(),\n])\n\n\n# Note that this dataset will output PIL images and not numpy arrays nor PyTorch tensors\nalbumentations_pil_dataset = AlbumentationsPilDataset(\n    file_paths=['./images/image_1.jpg', './images/image_2.jpg', './images/image_3.jpg'],\n    labels=[1, 2, 3],\n    transform=albumentations_pil_transform,\n)\n</pre> class AlbumentationsPilDataset(Dataset):     \"\"\"__init__ and __len__ functions are the same as in TorchvisionDataset\"\"\"     def __init__(self, file_paths, labels, transform=None):         self.file_paths = file_paths         self.labels = labels         self.transform = transform      def __len__(self):         return len(self.file_paths)      def __getitem__(self, idx):         label = self.labels[idx]         file_path = self.file_paths[idx]          image = Image.open(file_path)          if self.transform:             # Convert PIL image to numpy array             image_np = np.array(image)             # Apply transformations             augmented = self.transform(image=image_np)             # Convert numpy array to PIL Image             image = Image.fromarray(augmented['image'])         return image, label   albumentations_pil_transform = A.Compose([     A.Resize(256, 256),     A.RandomCrop(224, 224),     A.HorizontalFlip(), ])   # Note that this dataset will output PIL images and not numpy arrays nor PyTorch tensors albumentations_pil_dataset = AlbumentationsPilDataset(     file_paths=['./images/image_1.jpg', './images/image_2.jpg', './images/image_3.jpg'],     labels=[1, 2, 3],     transform=albumentations_pil_transform, ) torchvision transform Albumentations transform Albumentations example Compose Compose <code>A.Compose([A.Resize(256, 256), A.RandomCrop(224, 224)])</code> CenterCrop CenterCrop <code>A.CenterCrop(256, 256)</code> ColorJitter HueSaturationValue <code>A.HueSaturationValue(hue_shift_limit=20, sat_shift_limit=30, val_shift_limit=20, p=0.5)</code> Pad PadIfNeeded <code>A.PadIfNeeded(min_height=512, min_width=512)</code> RandomAffine Affine <code>A.Affine(scale=(0.9, 1.1), translate_percent=(0.0, 0.2), rotate=(-45, 45), shear=(-15, 15), mode=cv2.BORDER_REFLECT_101, p=0.5)</code> RandomCrop RandomCrop <code>A.RandomCrop(256, 256)</code> RandomGrayscale ToGray <code>A.ToGray(p=0.5)</code> RandomHorizontalFlip HorizontalFlip <code>A.HorizontalFlip(p=0.5)</code> RandomPerspective Perspective <code>A.Perspective(scale=(0.2, 0.4), fit_output=True, p=0.5)</code> RandomRotation Rotate <code>A.Rotate(limit=45, p=0.5)</code> RandomVerticalFlip VerticalFlip <code>A.VerticalFlip(p=0.5)</code> Resize Resize <code>A.Resize(256, 256)</code> GaussianBlur GaussianBlur <code>A.GaussianBlur(blur_limit=(3, 7), p=0.5)</code> RandomInvert InvertImg <code>A.InvertImg(p=0.5)</code> RandomPosterize Posterize <code>A.Posterize(num_bits=4, p=0.5)</code> RandomSolarize Solarize <code>A.Solarize(threshold=127, p=0.5)</code> RandomAdjustSharpness Sharpen <code>A.Sharpen(alpha=(0.2, 0.5), lightness=(0.5, 1.0), p=0.5)</code> RandomAutocontrast RandomBrightnessContrast <code>A.RandomBrightnessContrast(brightness_limit=0, contrast_limit=0.2, p=0.5)</code> RandomEqualize Equalize <code>A.Equalize(p=0.5)</code> RandomErasing CoarseDropout <code>A.CoarseDropout(min_height=8, max_height=32, min_width=8, max_width=32, p=0.5)</code> Normalize Normalize <code>A.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])</code>"},{"location":"examples/migrating_from_torchvision_to_albumentations/#migrating-from-torchvision-to-albumentations","title":"Migrating from torchvision to Albumentations\u00b6","text":""},{"location":"examples/migrating_from_torchvision_to_albumentations/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/migrating_from_torchvision_to_albumentations/#an-example-pipeline-that-uses-torchvision","title":"An example pipeline that uses torchvision\u00b6","text":""},{"location":"examples/migrating_from_torchvision_to_albumentations/#the-same-pipeline-with-albumentations","title":"The same pipeline with Albumentations\u00b6","text":""},{"location":"examples/migrating_from_torchvision_to_albumentations/#using-albumentations-with-pil","title":"Using albumentations with PIL\u00b6","text":""},{"location":"examples/migrating_from_torchvision_to_albumentations/#albumentations-equivalents-for-torchvision-transforms","title":"Albumentations equivalents for torchvision transforms\u00b6","text":""},{"location":"examples/pytorch_classification/","title":"PyTorch and Albumentations for image classification","text":"<p>This example shows how to use Albumentations for image classification. We will use the <code>Cats vs. Docs</code> dataset. The task will be to detect whether an image contains a cat or a dog.</p> In\u00a0[1]: Copied! <pre>from collections import defaultdict\nimport copy\nimport random\nimport os\nimport shutil\nfrom urllib.request import urlretrieve\n\nimport albumentations as A\nfrom albumentations.pytorch import ToTensorV2\nimport cv2\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\nimport torch\nimport torch.backends.cudnn as cudnn\nimport torch.nn as nn\nimport torch.optim\nfrom torch.utils.data import Dataset, DataLoader\nimport torchvision.models as models\n\ncudnn.benchmark = True\n</pre> from collections import defaultdict import copy import random import os import shutil from urllib.request import urlretrieve  import albumentations as A from albumentations.pytorch import ToTensorV2 import cv2 import matplotlib.pyplot as plt from tqdm import tqdm import torch import torch.backends.cudnn as cudnn import torch.nn as nn import torch.optim from torch.utils.data import Dataset, DataLoader import torchvision.models as models  cudnn.benchmark = True In\u00a0[2]: Copied! <pre>class TqdmUpTo(tqdm):\n    def update_to(self, b=1, bsize=1, tsize=None):\n        if tsize is not None:\n            self.total = tsize\n        self.update(b * bsize - self.n)\n\n\ndef download_url(url, filepath):\n    directory = os.path.dirname(os.path.abspath(filepath))\n    os.makedirs(directory, exist_ok=True)\n    if os.path.exists(filepath):\n        print(\"Filepath already exists. Skipping download.\")\n        return\n\n    with TqdmUpTo(unit=\"B\", unit_scale=True, unit_divisor=1024, miniters=1, desc=os.path.basename(filepath)) as t:\n        urlretrieve(url, filename=filepath, reporthook=t.update_to, data=None)\n        t.total = t.n\n\n\ndef extract_archive(filepath):\n    extract_dir = os.path.dirname(os.path.abspath(filepath))\n    shutil.unpack_archive(filepath, extract_dir)\n</pre> class TqdmUpTo(tqdm):     def update_to(self, b=1, bsize=1, tsize=None):         if tsize is not None:             self.total = tsize         self.update(b * bsize - self.n)   def download_url(url, filepath):     directory = os.path.dirname(os.path.abspath(filepath))     os.makedirs(directory, exist_ok=True)     if os.path.exists(filepath):         print(\"Filepath already exists. Skipping download.\")         return      with TqdmUpTo(unit=\"B\", unit_scale=True, unit_divisor=1024, miniters=1, desc=os.path.basename(filepath)) as t:         urlretrieve(url, filename=filepath, reporthook=t.update_to, data=None)         t.total = t.n   def extract_archive(filepath):     extract_dir = os.path.dirname(os.path.abspath(filepath))     shutil.unpack_archive(filepath, extract_dir) In\u00a0[3]: Copied! <pre>dataset_directory = os.path.join(os.environ[\"HOME\"], \"datasets/cats-vs-dogs\")\n</pre> dataset_directory = os.path.join(os.environ[\"HOME\"], \"datasets/cats-vs-dogs\") In\u00a0[4]: Copied! <pre>filepath = os.path.join(dataset_directory, \"kagglecatsanddogs_3367a.zip\")\ndownload_url(\n    url=\"https://download.microsoft.com/download/3/E/1/3E1C3F21-ECDB-4869-8368-6DEBA77B919F/kagglecatsanddogs_3367a.zip\",\n    filepath=filepath,\n)\nextract_archive(filepath)\n</pre> filepath = os.path.join(dataset_directory, \"kagglecatsanddogs_3367a.zip\") download_url(     url=\"https://download.microsoft.com/download/3/E/1/3E1C3F21-ECDB-4869-8368-6DEBA77B919F/kagglecatsanddogs_3367a.zip\",     filepath=filepath, ) extract_archive(filepath) <pre>Filepath already exists. Skipping download.\n</pre> <p>Some files in the dataset are broken, so we will use only those image files that OpenCV could load correctly. We will use 20000 images for training, 4936 images for validation, and 10 images for testing.</p> In\u00a0[5]: Copied! <pre>root_directory = os.path.join(dataset_directory, \"PetImages\")\n\ncat_directory = os.path.join(root_directory, \"Cat\")\ndog_directory = os.path.join(root_directory, \"Dog\")\n\ncat_images_filepaths = sorted([os.path.join(cat_directory, f) for f in os.listdir(cat_directory)])\ndog_images_filepaths = sorted([os.path.join(dog_directory, f) for f in os.listdir(dog_directory)])\nimages_filepaths = [*cat_images_filepaths, *dog_images_filepaths]\ncorrect_images_filepaths = [i for i in images_filepaths if cv2.imread(i) is not None]\n\nrandom.seed(42)\nrandom.shuffle(correct_images_filepaths)\ntrain_images_filepaths = correct_images_filepaths[:20000]\nval_images_filepaths = correct_images_filepaths[20000:-10]\ntest_images_filepaths = correct_images_filepaths[-10:]\nprint(len(train_images_filepaths), len(val_images_filepaths), len(test_images_filepaths))\n</pre> root_directory = os.path.join(dataset_directory, \"PetImages\")  cat_directory = os.path.join(root_directory, \"Cat\") dog_directory = os.path.join(root_directory, \"Dog\")  cat_images_filepaths = sorted([os.path.join(cat_directory, f) for f in os.listdir(cat_directory)]) dog_images_filepaths = sorted([os.path.join(dog_directory, f) for f in os.listdir(dog_directory)]) images_filepaths = [*cat_images_filepaths, *dog_images_filepaths] correct_images_filepaths = [i for i in images_filepaths if cv2.imread(i) is not None]  random.seed(42) random.shuffle(correct_images_filepaths) train_images_filepaths = correct_images_filepaths[:20000] val_images_filepaths = correct_images_filepaths[20000:-10] test_images_filepaths = correct_images_filepaths[-10:] print(len(train_images_filepaths), len(val_images_filepaths), len(test_images_filepaths)) <pre>20000 4936 10\n</pre> <p>Let's define a function that will take a list of images' file paths and their labels and visualize them in a grid. Correct labels are colored green, and incorrectly predicted labels are colored red.</p> In\u00a0[6]: Copied! <pre>def display_image_grid(images_filepaths, predicted_labels=(), cols=5):\n    rows = len(images_filepaths) // cols\n    figure, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(12, 6))\n    for i, image_filepath in enumerate(images_filepaths):\n        image = cv2.imread(image_filepath)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        true_label = os.path.normpath(image_filepath).split(os.sep)[-2]\n        predicted_label = predicted_labels[i] if predicted_labels else true_label\n        color = \"green\" if true_label == predicted_label else \"red\"\n        ax.ravel()[i].imshow(image)\n        ax.ravel()[i].set_title(predicted_label, color=color)\n        ax.ravel()[i].set_axis_off()\n    plt.tight_layout()\n    plt.show()\n</pre> def display_image_grid(images_filepaths, predicted_labels=(), cols=5):     rows = len(images_filepaths) // cols     figure, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(12, 6))     for i, image_filepath in enumerate(images_filepaths):         image = cv2.imread(image_filepath)         image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)         true_label = os.path.normpath(image_filepath).split(os.sep)[-2]         predicted_label = predicted_labels[i] if predicted_labels else true_label         color = \"green\" if true_label == predicted_label else \"red\"         ax.ravel()[i].imshow(image)         ax.ravel()[i].set_title(predicted_label, color=color)         ax.ravel()[i].set_axis_off()     plt.tight_layout()     plt.show() In\u00a0[7]: Copied! <pre>display_image_grid(test_images_filepaths)\n</pre> display_image_grid(test_images_filepaths) <p>Next, we define a PyTorch dataset. If you are new to PyTorch datasets, please refer to this tutorial - https://pytorch.org/tutorials/beginner/data_loading_tutorial.html.</p> <p>Out task is binary classification - a model needs to predict whether an image contains a cat or a dog. Our labels will mark the probability that an image contains a cat. So the correct label for an image with a cat will be <code>1.0</code>, and the correct label for an image with a dog will be <code>0.0</code>.</p> <p><code>__init__</code> will receive an optional <code>transform</code> argument. It is a transformation function of the Albumentations augmentation pipeline. Then in <code>__getitem__</code>, the Dataset class will use that function to augment an image and return it along with the correct label.</p> In\u00a0[8]: Copied! <pre>class CatsVsDogsDataset(Dataset):\n    def __init__(self, images_filepaths, transform=None):\n        self.images_filepaths = images_filepaths\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.images_filepaths)\n\n    def __getitem__(self, idx):\n        image_filepath = self.images_filepaths[idx]\n        image = cv2.imread(image_filepath)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        if os.path.normpath(image_filepath).split(os.sep)[-2] == \"Cat\":\n            label = 1.0\n        else:\n            label = 0.0\n        if self.transform is not None:\n            image = self.transform(image=image)[\"image\"]\n        return image, label\n</pre> class CatsVsDogsDataset(Dataset):     def __init__(self, images_filepaths, transform=None):         self.images_filepaths = images_filepaths         self.transform = transform      def __len__(self):         return len(self.images_filepaths)      def __getitem__(self, idx):         image_filepath = self.images_filepaths[idx]         image = cv2.imread(image_filepath)         image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)         if os.path.normpath(image_filepath).split(os.sep)[-2] == \"Cat\":             label = 1.0         else:             label = 0.0         if self.transform is not None:             image = self.transform(image=image)[\"image\"]         return image, label <p>We use Albumentations to define augmentation pipelines for training and validation datasets. In both pipelines, we first resize an input image, so its smallest size is 160px, then we take a 128px by 128px crop. For the training dataset, we also apply more augmentations to that crop. Next, we will normalize an image. We first divide all pixel values of an image by 255, so each pixel's value will lie in a range <code>[0.0, 1.0]</code>. Then we will subtract mean pixel values and divide values by the standard deviation. <code>mean</code> and <code>std</code> in augmentation pipelines are taken from the <code>ImageNet</code> dataset. Still, they transfer reasonably well to the <code>Cats vs. Dogs</code> dataset. After that, we will apply <code>ToTensorV2</code> that converts a NumPy array to a PyTorch tensor, which will serve as an input to a neural network.</p> <p>Note that in the validation pipeline we will use <code>A.CenterCrop</code> instead of <code>A.RandomCrop</code> because we want out validation results to be deterministic (so that they will not depend upon a random location of a crop).</p> In\u00a0[9]: Copied! <pre>train_transform = A.Compose(\n    [\n        A.SmallestMaxSize(max_size=160),\n        A.ShiftScaleRotate(shift_limit=0.05, scale_limit=0.05, rotate_limit=15, p=0.5),\n        A.RandomCrop(height=128, width=128),\n        A.RGBShift(r_shift_limit=15, g_shift_limit=15, b_shift_limit=15, p=0.5),\n        A.RandomBrightnessContrast(p=0.5),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\ntrain_dataset = CatsVsDogsDataset(images_filepaths=train_images_filepaths, transform=train_transform)\n</pre> train_transform = A.Compose(     [         A.SmallestMaxSize(max_size=160),         A.ShiftScaleRotate(shift_limit=0.05, scale_limit=0.05, rotate_limit=15, p=0.5),         A.RandomCrop(height=128, width=128),         A.RGBShift(r_shift_limit=15, g_shift_limit=15, b_shift_limit=15, p=0.5),         A.RandomBrightnessContrast(p=0.5),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) train_dataset = CatsVsDogsDataset(images_filepaths=train_images_filepaths, transform=train_transform) In\u00a0[10]: Copied! <pre>val_transform = A.Compose(\n    [\n        A.SmallestMaxSize(max_size=160),\n        A.CenterCrop(height=128, width=128),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\nval_dataset = CatsVsDogsDataset(images_filepaths=val_images_filepaths, transform=val_transform)\n</pre> val_transform = A.Compose(     [         A.SmallestMaxSize(max_size=160),         A.CenterCrop(height=128, width=128),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) val_dataset = CatsVsDogsDataset(images_filepaths=val_images_filepaths, transform=val_transform) <p>Also let's define a function that takes a dataset and visualizes different augmentations applied to the same image.</p> In\u00a0[11]: Copied! <pre>def visualize_augmentations(dataset, idx=0, samples=10, cols=5):\n    dataset = copy.deepcopy(dataset)\n    dataset.transform = A.Compose([t for t in dataset.transform if not isinstance(t, (A.Normalize, ToTensorV2))])\n    rows = samples // cols\n    figure, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(12, 6))\n    for i in range(samples):\n        image, _ = dataset[idx]\n        ax.ravel()[i].imshow(image)\n        ax.ravel()[i].set_axis_off()\n    plt.tight_layout()\n    plt.show()\n</pre> def visualize_augmentations(dataset, idx=0, samples=10, cols=5):     dataset = copy.deepcopy(dataset)     dataset.transform = A.Compose([t for t in dataset.transform if not isinstance(t, (A.Normalize, ToTensorV2))])     rows = samples // cols     figure, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(12, 6))     for i in range(samples):         image, _ = dataset[idx]         ax.ravel()[i].imshow(image)         ax.ravel()[i].set_axis_off()     plt.tight_layout()     plt.show()     In\u00a0[12]: Copied! <pre>random.seed(42)\nvisualize_augmentations(train_dataset)\n</pre> random.seed(42) visualize_augmentations(train_dataset) <p>We define a few helpers for our training pipeline. <code>calculate_accuracy</code> takes model predictions and true labels and will return accuracy for those predictions. <code>MetricMonitor</code> helps to track metrics such as accuracy or loss during training and validation</p> In\u00a0[13]: Copied! <pre>def calculate_accuracy(output, target):\n    output = torch.sigmoid(output) &gt;= 0.5\n    target = target == 1.0\n    return torch.true_divide((target == output).sum(dim=0), output.size(0)).item()\n</pre> def calculate_accuracy(output, target):     output = torch.sigmoid(output) &gt;= 0.5     target = target == 1.0     return torch.true_divide((target == output).sum(dim=0), output.size(0)).item() In\u00a0[14]: Copied! <pre>class MetricMonitor:\n    def __init__(self, float_precision=3):\n        self.float_precision = float_precision\n        self.reset()\n\n    def reset(self):\n        self.metrics = defaultdict(lambda: {\"val\": 0, \"count\": 0, \"avg\": 0})\n\n    def update(self, metric_name, val):\n        metric = self.metrics[metric_name]\n\n        metric[\"val\"] += val\n        metric[\"count\"] += 1\n        metric[\"avg\"] = metric[\"val\"] / metric[\"count\"]\n\n    def __str__(self):\n        return \" | \".join(\n            [\n                \"{metric_name}: {avg:.{float_precision}f}\".format(\n                    metric_name=metric_name, avg=metric[\"avg\"], float_precision=self.float_precision\n                )\n                for (metric_name, metric) in self.metrics.items()\n            ]\n        )\n</pre> class MetricMonitor:     def __init__(self, float_precision=3):         self.float_precision = float_precision         self.reset()      def reset(self):         self.metrics = defaultdict(lambda: {\"val\": 0, \"count\": 0, \"avg\": 0})      def update(self, metric_name, val):         metric = self.metrics[metric_name]          metric[\"val\"] += val         metric[\"count\"] += 1         metric[\"avg\"] = metric[\"val\"] / metric[\"count\"]      def __str__(self):         return \" | \".join(             [                 \"{metric_name}: {avg:.{float_precision}f}\".format(                     metric_name=metric_name, avg=metric[\"avg\"], float_precision=self.float_precision                 )                 for (metric_name, metric) in self.metrics.items()             ]         ) <p>Here we define a few training parameters such as model architecture, learning rate, batch size, epochs, etc</p> In\u00a0[15]: Copied! <pre>params = {\n    \"model\": \"resnet50\",\n    \"device\": \"cuda\",\n    \"lr\": 0.001,\n    \"batch_size\": 64,\n    \"num_workers\": 4,\n    \"epochs\": 10,\n}\n</pre> params = {     \"model\": \"resnet50\",     \"device\": \"cuda\",     \"lr\": 0.001,     \"batch_size\": 64,     \"num_workers\": 4,     \"epochs\": 10, } In\u00a0[16]: Copied! <pre>model = getattr(models, params[\"model\"])(pretrained=False, num_classes=1,)\nmodel = model.to(params[\"device\"])\ncriterion = nn.BCEWithLogitsLoss().to(params[\"device\"])\noptimizer = torch.optim.Adam(model.parameters(), lr=params[\"lr\"])\n</pre> model = getattr(models, params[\"model\"])(pretrained=False, num_classes=1,) model = model.to(params[\"device\"]) criterion = nn.BCEWithLogitsLoss().to(params[\"device\"]) optimizer = torch.optim.Adam(model.parameters(), lr=params[\"lr\"]) In\u00a0[17]: Copied! <pre>train_loader = DataLoader(\n    train_dataset, batch_size=params[\"batch_size\"], shuffle=True, num_workers=params[\"num_workers\"], pin_memory=True,\n)\nval_loader = DataLoader(\n    val_dataset, batch_size=params[\"batch_size\"], shuffle=False, num_workers=params[\"num_workers\"], pin_memory=True,\n)\n</pre> train_loader = DataLoader(     train_dataset, batch_size=params[\"batch_size\"], shuffle=True, num_workers=params[\"num_workers\"], pin_memory=True, ) val_loader = DataLoader(     val_dataset, batch_size=params[\"batch_size\"], shuffle=False, num_workers=params[\"num_workers\"], pin_memory=True, ) In\u00a0[18]: Copied! <pre>def train(train_loader, model, criterion, optimizer, epoch, params):\n    metric_monitor = MetricMonitor()\n    model.train()\n    stream = tqdm(train_loader)\n    for i, (images, target) in enumerate(stream, start=1):\n        images = images.to(params[\"device\"], non_blocking=True)\n        target = target.to(params[\"device\"], non_blocking=True).float().view(-1, 1)\n        output = model(images)\n        loss = criterion(output, target)\n        accuracy = calculate_accuracy(output, target)\n        metric_monitor.update(\"Loss\", loss.item())\n        metric_monitor.update(\"Accuracy\", accuracy)\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        stream.set_description(\n            \"Epoch: {epoch}. Train.      {metric_monitor}\".format(epoch=epoch, metric_monitor=metric_monitor)\n        )\n</pre> def train(train_loader, model, criterion, optimizer, epoch, params):     metric_monitor = MetricMonitor()     model.train()     stream = tqdm(train_loader)     for i, (images, target) in enumerate(stream, start=1):         images = images.to(params[\"device\"], non_blocking=True)         target = target.to(params[\"device\"], non_blocking=True).float().view(-1, 1)         output = model(images)         loss = criterion(output, target)         accuracy = calculate_accuracy(output, target)         metric_monitor.update(\"Loss\", loss.item())         metric_monitor.update(\"Accuracy\", accuracy)         optimizer.zero_grad()         loss.backward()         optimizer.step()         stream.set_description(             \"Epoch: {epoch}. Train.      {metric_monitor}\".format(epoch=epoch, metric_monitor=metric_monitor)         ) In\u00a0[19]: Copied! <pre>def validate(val_loader, model, criterion, epoch, params):\n    metric_monitor = MetricMonitor()\n    model.eval()\n    stream = tqdm(val_loader)\n    with torch.no_grad():\n        for i, (images, target) in enumerate(stream, start=1):\n            images = images.to(params[\"device\"], non_blocking=True)\n            target = target.to(params[\"device\"], non_blocking=True).float().view(-1, 1)\n            output = model(images)\n            loss = criterion(output, target)\n            accuracy = calculate_accuracy(output, target)\n\n            metric_monitor.update(\"Loss\", loss.item())\n            metric_monitor.update(\"Accuracy\", accuracy)\n            stream.set_description(\n                \"Epoch: {epoch}. Validation. {metric_monitor}\".format(epoch=epoch, metric_monitor=metric_monitor)\n            )\n</pre> def validate(val_loader, model, criterion, epoch, params):     metric_monitor = MetricMonitor()     model.eval()     stream = tqdm(val_loader)     with torch.no_grad():         for i, (images, target) in enumerate(stream, start=1):             images = images.to(params[\"device\"], non_blocking=True)             target = target.to(params[\"device\"], non_blocking=True).float().view(-1, 1)             output = model(images)             loss = criterion(output, target)             accuracy = calculate_accuracy(output, target)              metric_monitor.update(\"Loss\", loss.item())             metric_monitor.update(\"Accuracy\", accuracy)             stream.set_description(                 \"Epoch: {epoch}. Validation. {metric_monitor}\".format(epoch=epoch, metric_monitor=metric_monitor)             ) In\u00a0[20]: Copied! <pre>for epoch in range(1, params[\"epochs\"] + 1):\n    train(train_loader, model, criterion, optimizer, epoch, params)\n    validate(val_loader, model, criterion, epoch, params)\n</pre> for epoch in range(1, params[\"epochs\"] + 1):     train(train_loader, model, criterion, optimizer, epoch, params)     validate(val_loader, model, criterion, epoch, params) <pre>Epoch: 1. Train.      Loss: 0.700 | Accuracy: 0.598: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:38&lt;00:00,  8.04it/s]\nEpoch: 1. Validation. Loss: 0.684 | Accuracy: 0.663: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 23.46it/s]\nEpoch: 2. Train.      Loss: 0.611 | Accuracy: 0.675: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:37&lt;00:00,  8.24it/s]\nEpoch: 2. Validation. Loss: 0.581 | Accuracy: 0.689: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 23.25it/s]\nEpoch: 3. Train.      Loss: 0.513 | Accuracy: 0.752: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:38&lt;00:00,  8.22it/s]\nEpoch: 3. Validation. Loss: 0.408 | Accuracy: 0.818: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 23.61it/s]\nEpoch: 4. Train.      Loss: 0.440 | Accuracy: 0.796: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:37&lt;00:00,  8.24it/s]\nEpoch: 4. Validation. Loss: 0.374 | Accuracy: 0.829: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 22.89it/s]\nEpoch: 5. Train.      Loss: 0.391 | Accuracy: 0.821: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:37&lt;00:00,  8.25it/s]\nEpoch: 5. Validation. Loss: 0.345 | Accuracy: 0.853: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 23.03it/s]\nEpoch: 6. Train.      Loss: 0.343 | Accuracy: 0.845: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:38&lt;00:00,  8.22it/s]\nEpoch: 6. Validation. Loss: 0.304 | Accuracy: 0.861: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 23.88it/s]\nEpoch: 7. Train.      Loss: 0.312 | Accuracy: 0.858: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:38&lt;00:00,  8.23it/s]\nEpoch: 7. Validation. Loss: 0.259 | Accuracy: 0.886: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 23.29it/s]\nEpoch: 8. Train.      Loss: 0.284 | Accuracy: 0.875: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:38&lt;00:00,  8.21it/s]\nEpoch: 8. Validation. Loss: 0.304 | Accuracy: 0.882: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 23.81it/s]\nEpoch: 9. Train.      Loss: 0.265 | Accuracy: 0.884: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:38&lt;00:00,  8.18it/s]\nEpoch: 9. Validation. Loss: 0.255 | Accuracy: 0.888: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 23.78it/s]\nEpoch: 10. Train.      Loss: 0.248 | Accuracy: 0.890: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:38&lt;00:00,  8.21it/s]\nEpoch: 10. Validation. Loss: 0.222 | Accuracy: 0.909: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 78/78 [00:03&lt;00:00, 23.90it/s]\n</pre> <p>Now we have a trained model, so let's try to predict labels for some images and see whether those predictions are correct. First we make the <code>CatsVsDogsInferenceDataset</code> PyTorch dataset. Its code is similar to the training and validation datasets, but the inference dataset returns only an image and not an associated label (because in the real world we usually don't have access to the true labels and want to infer them using our trained model).</p> In\u00a0[21]: Copied! <pre>class CatsVsDogsInferenceDataset(Dataset):\n    def __init__(self, images_filepaths, transform=None):\n        self.images_filepaths = images_filepaths\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.images_filepaths)\n\n    def __getitem__(self, idx):\n        image_filepath = self.images_filepaths[idx]\n        image = cv2.imread(image_filepath)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        if self.transform is not None:\n            image = self.transform(image=image)[\"image\"]\n        return image\n\ntest_transform = A.Compose(\n    [\n        A.SmallestMaxSize(max_size=160),\n        A.CenterCrop(height=128, width=128),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\ntest_dataset = CatsVsDogsInferenceDataset(images_filepaths=test_images_filepaths, transform=test_transform)\ntest_loader = DataLoader(\n    test_dataset, batch_size=params[\"batch_size\"], shuffle=False, num_workers=params[\"num_workers\"], pin_memory=True,\n)\n</pre> class CatsVsDogsInferenceDataset(Dataset):     def __init__(self, images_filepaths, transform=None):         self.images_filepaths = images_filepaths         self.transform = transform      def __len__(self):         return len(self.images_filepaths)      def __getitem__(self, idx):         image_filepath = self.images_filepaths[idx]         image = cv2.imread(image_filepath)         image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)         if self.transform is not None:             image = self.transform(image=image)[\"image\"]         return image  test_transform = A.Compose(     [         A.SmallestMaxSize(max_size=160),         A.CenterCrop(height=128, width=128),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) test_dataset = CatsVsDogsInferenceDataset(images_filepaths=test_images_filepaths, transform=test_transform) test_loader = DataLoader(     test_dataset, batch_size=params[\"batch_size\"], shuffle=False, num_workers=params[\"num_workers\"], pin_memory=True, ) In\u00a0[22]: Copied! <pre>model = model.eval()\npredicted_labels = []\nwith torch.no_grad():\n    for images in test_loader:\n        images = images.to(params[\"device\"], non_blocking=True)\n        output = model(images)\n        predictions = (torch.sigmoid(output) &gt;= 0.5)[:, 0].cpu().numpy()\n        predicted_labels += [\"Cat\" if is_cat else \"Dog\" for is_cat in predictions]\n</pre> model = model.eval() predicted_labels = [] with torch.no_grad():     for images in test_loader:         images = images.to(params[\"device\"], non_blocking=True)         output = model(images)         predictions = (torch.sigmoid(output) &gt;= 0.5)[:, 0].cpu().numpy()         predicted_labels += [\"Cat\" if is_cat else \"Dog\" for is_cat in predictions] In\u00a0[23]: Copied! <pre>display_image_grid(test_images_filepaths, predicted_labels)\n</pre> display_image_grid(test_images_filepaths, predicted_labels) <p>As we see our model predicted correct labels for 7 out of 10 images. If you train the model for more epochs, you will obtain better results.</p>"},{"location":"examples/pytorch_classification/#pytorch-and-albumentations-for-image-classification","title":"PyTorch and Albumentations for image classification\u00b6","text":""},{"location":"examples/pytorch_classification/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/pytorch_classification/#define-functions-to-download-an-archived-dataset-and-unpack-it","title":"Define functions to download an archived dataset and unpack it\u00b6","text":""},{"location":"examples/pytorch_classification/#set-the-root-directory-for-the-downloaded-dataset","title":"Set the root directory for the downloaded dataset\u00b6","text":""},{"location":"examples/pytorch_classification/#download-and-extract-the-cats-vs-docs-dataset","title":"Download and extract the <code>Cats vs. Docs</code> dataset\u00b6","text":""},{"location":"examples/pytorch_classification/#split-files-from-the-dataset-into-the-train-and-validation-sets","title":"Split files from the dataset into the train and validation sets\u00b6","text":""},{"location":"examples/pytorch_classification/#define-a-function-to-visualize-images-and-their-labels","title":"Define a function to visualize images and their labels\u00b6","text":""},{"location":"examples/pytorch_classification/#define-a-pytorch-dataset-class","title":"Define a PyTorch dataset class\u00b6","text":""},{"location":"examples/pytorch_classification/#use-albumentations-to-define-transformation-functions-for-the-train-and-validation-datasets","title":"Use Albumentations to define transformation functions for the train and validation datasets\u00b6","text":""},{"location":"examples/pytorch_classification/#define-helpers-for-training","title":"Define helpers for training\u00b6","text":""},{"location":"examples/pytorch_classification/#define-training-parameters","title":"Define training parameters\u00b6","text":""},{"location":"examples/pytorch_classification/#create-all-required-objects-and-functions-for-training-and-validation","title":"Create all required objects and functions for training and validation\u00b6","text":""},{"location":"examples/pytorch_classification/#train-a-model","title":"Train a model\u00b6","text":""},{"location":"examples/pytorch_classification/#predict-labels-for-images-and-visualize-those-predictions","title":"Predict labels for images and visualize those predictions\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/","title":"PyTorch and Albumentations for semantic segmentation","text":"<p>This example shows how to use Albumentations for binary semantic segmentation. We will use the The Oxford-IIIT Pet Dataset . The task will be to classify each pixel of an input image either as <code>pet</code> or <code>background</code>.</p> <p>We will use TernausNet, a library that provides pretrained UNet models for the semantic segmentation task.</p> In\u00a0[1]: Copied! <pre>!pip install ternausnet &gt; /dev/null\n</pre> !pip install ternausnet &gt; /dev/null In\u00a0[2]: Copied! <pre>from collections import defaultdict\nimport copy\nimport random\nimport os\nimport shutil\nfrom urllib.request import urlretrieve\n\nimport albumentations as A\nimport albumentations.augmentations.functional as F\nfrom albumentations.pytorch import ToTensorV2\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport ternausnet.models\nfrom tqdm import tqdm\nimport torch\nimport torch.backends.cudnn as cudnn\nimport torch.nn as nn\nimport torch.optim\nfrom torch.utils.data import Dataset, DataLoader\n\ncudnn.benchmark = True\n</pre> from collections import defaultdict import copy import random import os import shutil from urllib.request import urlretrieve  import albumentations as A import albumentations.augmentations.functional as F from albumentations.pytorch import ToTensorV2 import cv2 import matplotlib.pyplot as plt import numpy as np import ternausnet.models from tqdm import tqdm import torch import torch.backends.cudnn as cudnn import torch.nn as nn import torch.optim from torch.utils.data import Dataset, DataLoader  cudnn.benchmark = True In\u00a0[3]: Copied! <pre>class TqdmUpTo(tqdm):\n    def update_to(self, b=1, bsize=1, tsize=None):\n        if tsize is not None:\n            self.total = tsize\n        self.update(b * bsize - self.n)\n\n\ndef download_url(url, filepath):\n    directory = os.path.dirname(os.path.abspath(filepath))\n    os.makedirs(directory, exist_ok=True)\n    if os.path.exists(filepath):\n        print(\"Dataset already exists on the disk. Skipping download.\")\n        return\n\n    with TqdmUpTo(unit=\"B\", unit_scale=True, unit_divisor=1024, miniters=1, desc=os.path.basename(filepath)) as t:\n        urlretrieve(url, filename=filepath, reporthook=t.update_to, data=None)\n        t.total = t.n\n\n\ndef extract_archive(filepath):\n    extract_dir = os.path.dirname(os.path.abspath(filepath))\n    shutil.unpack_archive(filepath, extract_dir)\n</pre> class TqdmUpTo(tqdm):     def update_to(self, b=1, bsize=1, tsize=None):         if tsize is not None:             self.total = tsize         self.update(b * bsize - self.n)   def download_url(url, filepath):     directory = os.path.dirname(os.path.abspath(filepath))     os.makedirs(directory, exist_ok=True)     if os.path.exists(filepath):         print(\"Dataset already exists on the disk. Skipping download.\")         return      with TqdmUpTo(unit=\"B\", unit_scale=True, unit_divisor=1024, miniters=1, desc=os.path.basename(filepath)) as t:         urlretrieve(url, filename=filepath, reporthook=t.update_to, data=None)         t.total = t.n   def extract_archive(filepath):     extract_dir = os.path.dirname(os.path.abspath(filepath))     shutil.unpack_archive(filepath, extract_dir) In\u00a0[4]: Copied! <pre>dataset_directory = os.path.join(os.environ[\"HOME\"], \"datasets/oxford-iiit-pet\")\n</pre> dataset_directory = os.path.join(os.environ[\"HOME\"], \"datasets/oxford-iiit-pet\") In\u00a0[5]: Copied! <pre>filepath = os.path.join(dataset_directory, \"images.tar.gz\")\ndownload_url(\n    url=\"https://www.robots.ox.ac.uk/~vgg/data/pets/data/images.tar.gz\", filepath=filepath,\n)\nextract_archive(filepath)\n</pre> filepath = os.path.join(dataset_directory, \"images.tar.gz\") download_url(     url=\"https://www.robots.ox.ac.uk/~vgg/data/pets/data/images.tar.gz\", filepath=filepath, ) extract_archive(filepath) <pre>Dataset already exists on the disk. Skipping download.\n</pre> In\u00a0[6]: Copied! <pre>filepath = os.path.join(dataset_directory, \"annotations.tar.gz\")\ndownload_url(\n    url=\"https://www.robots.ox.ac.uk/~vgg/data/pets/data/annotations.tar.gz\", filepath=filepath,\n)\nextract_archive(filepath)\n</pre> filepath = os.path.join(dataset_directory, \"annotations.tar.gz\") download_url(     url=\"https://www.robots.ox.ac.uk/~vgg/data/pets/data/annotations.tar.gz\", filepath=filepath, ) extract_archive(filepath) <pre>Dataset already exists on the disk. Skipping download.\n</pre> <p>Some files in the dataset are broken, so we will use only those image files that OpenCV could load correctly. We will use 6000 images for training, 1374 images for validation, and 10 images for testing.</p> In\u00a0[7]: Copied! <pre>root_directory = os.path.join(dataset_directory)\nimages_directory = os.path.join(root_directory, \"images\")\nmasks_directory = os.path.join(root_directory, \"annotations\", \"trimaps\")\n\nimages_filenames = list(sorted(os.listdir(images_directory)))\ncorrect_images_filenames = [i for i in images_filenames if cv2.imread(os.path.join(images_directory, i)) is not None]\n\nrandom.seed(42)\nrandom.shuffle(correct_images_filenames)\n\ntrain_images_filenames = correct_images_filenames[:6000]\nval_images_filenames = correct_images_filenames[6000:-10]\ntest_images_filenames = images_filenames[-10:]\n\nprint(len(train_images_filenames), len(val_images_filenames), len(test_images_filenames))\n</pre> root_directory = os.path.join(dataset_directory) images_directory = os.path.join(root_directory, \"images\") masks_directory = os.path.join(root_directory, \"annotations\", \"trimaps\")  images_filenames = list(sorted(os.listdir(images_directory))) correct_images_filenames = [i for i in images_filenames if cv2.imread(os.path.join(images_directory, i)) is not None]  random.seed(42) random.shuffle(correct_images_filenames)  train_images_filenames = correct_images_filenames[:6000] val_images_filenames = correct_images_filenames[6000:-10] test_images_filenames = images_filenames[-10:]  print(len(train_images_filenames), len(val_images_filenames), len(test_images_filenames)) <pre>6000 1374 10\n</pre> <p>The dataset contains pixel-level trimap segmentation. For each image, there is an associated PNG file with a mask. The size of a mask equals to the size of the related image. Each pixel in a mask image can take one of three values: <code>1</code>, <code>2</code>, or <code>3</code>. <code>1</code> means that this pixel of an image belongs to the class <code>pet</code>, <code>2</code> - to the class <code>background</code>, <code>3</code> - to the class <code>border</code>. Since this example demonstrates a task of binary segmentation (that is assigning one of two classes to each pixel), we will preprocess the mask, so it will contain only two uniques values: <code>0.0</code> if a pixel is a background and <code>1.0</code> if a pixel is a pet or a border.</p> In\u00a0[8]: Copied! <pre>def preprocess_mask(mask):\n    mask = mask.astype(np.float32)\n    mask[mask == 2.0] = 0.0\n    mask[(mask == 1.0) | (mask == 3.0)] = 1.0\n    return mask\n</pre> def preprocess_mask(mask):     mask = mask.astype(np.float32)     mask[mask == 2.0] = 0.0     mask[(mask == 1.0) | (mask == 3.0)] = 1.0     return mask <p>Let's define a visualization function that will take a list of images' file names, a path to the directory with images, a path to the directory with masks, and an optional argument with predicted masks (we will use this argument later to show predictions of a model).</p> In\u00a0[9]: Copied! <pre>def display_image_grid(images_filenames, images_directory, masks_directory, predicted_masks=None):\n    cols = 3 if predicted_masks else 2\n    rows = len(images_filenames)\n    figure, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(10, 24))\n    for i, image_filename in enumerate(images_filenames):\n        image = cv2.imread(os.path.join(images_directory, image_filename))\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n        mask = cv2.imread(os.path.join(masks_directory, image_filename.replace(\".jpg\", \".png\")), cv2.IMREAD_UNCHANGED,)\n        mask = preprocess_mask(mask)\n        ax[i, 0].imshow(image)\n        ax[i, 1].imshow(mask, interpolation=\"nearest\")\n\n        ax[i, 0].set_title(\"Image\")\n        ax[i, 1].set_title(\"Ground truth mask\")\n\n        ax[i, 0].set_axis_off()\n        ax[i, 1].set_axis_off()\n\n        if predicted_masks:\n            predicted_mask = predicted_masks[i]\n            ax[i, 2].imshow(predicted_mask, interpolation=\"nearest\")\n            ax[i, 2].set_title(\"Predicted mask\")\n            ax[i, 2].set_axis_off()\n    plt.tight_layout()\n    plt.show()\n</pre> def display_image_grid(images_filenames, images_directory, masks_directory, predicted_masks=None):     cols = 3 if predicted_masks else 2     rows = len(images_filenames)     figure, ax = plt.subplots(nrows=rows, ncols=cols, figsize=(10, 24))     for i, image_filename in enumerate(images_filenames):         image = cv2.imread(os.path.join(images_directory, image_filename))         image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)          mask = cv2.imread(os.path.join(masks_directory, image_filename.replace(\".jpg\", \".png\")), cv2.IMREAD_UNCHANGED,)         mask = preprocess_mask(mask)         ax[i, 0].imshow(image)         ax[i, 1].imshow(mask, interpolation=\"nearest\")          ax[i, 0].set_title(\"Image\")         ax[i, 1].set_title(\"Ground truth mask\")          ax[i, 0].set_axis_off()         ax[i, 1].set_axis_off()          if predicted_masks:             predicted_mask = predicted_masks[i]             ax[i, 2].imshow(predicted_mask, interpolation=\"nearest\")             ax[i, 2].set_title(\"Predicted mask\")             ax[i, 2].set_axis_off()     plt.tight_layout()     plt.show() In\u00a0[10]: Copied! <pre>display_image_grid(test_images_filenames, images_directory, masks_directory)\n</pre> display_image_grid(test_images_filenames, images_directory, masks_directory) <p>Often, images that you use for training and inference have different heights and widths and different aspect ratios. That fact brings two challenges to a deep learning pipeline:</p> <ul> <li>PyTorch requires all images in a batch to have the same height and width.</li> <li>If a neural network is not fully convolutional, you have to use the same width and height for all images during training and inference. Fully convolutional architectures, such as UNet, can work with images of any size.</li> </ul> <p>There are three common ways to deal with those challenges:</p> <ol> <li>Resize all images and masks to a fixed size (e.g., 256x256 pixels) during training. After a model predicts a mask with that fixed size during inference, resize the mask to the original image size. This approach is simple, but it has a few drawbacks:</li> </ol> <ul> <li>The predicted mask is smaller than the image, and the mask may lose some context and important details of the original image.</li> <li>This approach may be problematic if images in your dataset have different aspect ratios. For example, suppose you are resizing an image with the size 1024x512 pixels (so an image with an aspect ratio of 2:1) to 256x256 pixels (1:1 aspect ratio). In that case, this transformation will distort the image and may also affect the quality of predictions.</li> </ul> <ol> <li>If you use a fully convolutional neural network, you can train a model with image crops, but use original images for inference. This option usually provides the best tradeoff between quality, speed of training, and hardware requirements.</li> <li>Do not alter the sizes of images and use source images both for training and inference. With this approach, you won't lose any information. However, original images could be quite large, so they may require a lot of GPU memory. Also, this approach requires more training time to obtain good results.</li> </ol> <p>Some architectures, such as UNet, require that an image's size must be divisible by a downsampling factor of a network (usually 32), so you may also need to pad an image with borders. Albumentations provides a particular transformation for that case.</p> <p>The following example shows how different types of images look.</p> In\u00a0[11]: Copied! <pre>example_image_filename = correct_images_filenames[0]\nimage = cv2.imread(os.path.join(images_directory, example_image_filename))\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\nresized_image = F.resize(image, height=256, width=256)\npadded_image = F.pad(image, min_height=512, min_width=512)\npadded_constant_image = F.pad(image, min_height=512, min_width=512, border_mode=cv2.BORDER_CONSTANT)\ncropped_image = F.center_crop(image, crop_height=256, crop_width=256)\n</pre> example_image_filename = correct_images_filenames[0] image = cv2.imread(os.path.join(images_directory, example_image_filename)) image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  resized_image = F.resize(image, height=256, width=256) padded_image = F.pad(image, min_height=512, min_width=512) padded_constant_image = F.pad(image, min_height=512, min_width=512, border_mode=cv2.BORDER_CONSTANT) cropped_image = F.center_crop(image, crop_height=256, crop_width=256) In\u00a0[12]: Copied! <pre>figure, ax = plt.subplots(nrows=1, ncols=5, figsize=(18, 10))\nax.ravel()[0].imshow(image)\nax.ravel()[0].set_title(\"Original image\")\nax.ravel()[1].imshow(resized_image)\nax.ravel()[1].set_title(\"Resized image\")\nax.ravel()[2].imshow(cropped_image)\nax.ravel()[2].set_title(\"Cropped image\")\nax.ravel()[3].imshow(padded_image)\nax.ravel()[3].set_title(\"Image padded with reflection\")\nax.ravel()[4].imshow(padded_constant_image)\nax.ravel()[4].set_title(\"Image padded with constant padding\")\nplt.tight_layout()\nplt.show()\n</pre> figure, ax = plt.subplots(nrows=1, ncols=5, figsize=(18, 10)) ax.ravel()[0].imshow(image) ax.ravel()[0].set_title(\"Original image\") ax.ravel()[1].imshow(resized_image) ax.ravel()[1].set_title(\"Resized image\") ax.ravel()[2].imshow(cropped_image) ax.ravel()[2].set_title(\"Cropped image\") ax.ravel()[3].imshow(padded_image) ax.ravel()[3].set_title(\"Image padded with reflection\") ax.ravel()[4].imshow(padded_constant_image) ax.ravel()[4].set_title(\"Image padded with constant padding\") plt.tight_layout() plt.show() <p>In this tutorial, we will explore all three approaches for dealing with image sizes.</p> <p>Next, we define a PyTorch dataset. If you are new to PyTorch datasets, please refer to this tutorial - https://pytorch.org/tutorials/beginner/data_loading_tutorial.html.</p> <p><code>__init__</code> will receive an optional <code>transform</code> argument. It is a transformation function of the Albumentations augmentation pipeline. Then in <code>__getitem__</code>, the Dataset class will use that function to augment an image and a mask and return their augmented versions.</p> In\u00a0[13]: Copied! <pre>class OxfordPetDataset(Dataset):\n    def __init__(self, images_filenames, images_directory, masks_directory, transform=None):\n        self.images_filenames = images_filenames\n        self.images_directory = images_directory\n        self.masks_directory = masks_directory\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.images_filenames)\n\n    def __getitem__(self, idx):\n        image_filename = self.images_filenames[idx]\n        image = cv2.imread(os.path.join(self.images_directory, image_filename))\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        mask = cv2.imread(\n            os.path.join(self.masks_directory, image_filename.replace(\".jpg\", \".png\")), cv2.IMREAD_UNCHANGED,\n        )\n        mask = preprocess_mask(mask)\n        if self.transform is not None:\n            transformed = self.transform(image=image, mask=mask)\n            image = transformed[\"image\"]\n            mask = transformed[\"mask\"]\n        return image, mask\n</pre> class OxfordPetDataset(Dataset):     def __init__(self, images_filenames, images_directory, masks_directory, transform=None):         self.images_filenames = images_filenames         self.images_directory = images_directory         self.masks_directory = masks_directory         self.transform = transform      def __len__(self):         return len(self.images_filenames)      def __getitem__(self, idx):         image_filename = self.images_filenames[idx]         image = cv2.imread(os.path.join(self.images_directory, image_filename))         image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)         mask = cv2.imread(             os.path.join(self.masks_directory, image_filename.replace(\".jpg\", \".png\")), cv2.IMREAD_UNCHANGED,         )         mask = preprocess_mask(mask)         if self.transform is not None:             transformed = self.transform(image=image, mask=mask)             image = transformed[\"image\"]             mask = transformed[\"mask\"]         return image, mask <p>Next, we create augmentation pipelines for the training and validation datasets. Note that we use <code>A.Resize(256, 256)</code> to resize input images and masks to the size 256x256 pixels.</p> In\u00a0[14]: Copied! <pre>train_transform = A.Compose(\n    [\n        A.Resize(256, 256),\n        A.ShiftScaleRotate(shift_limit=0.2, scale_limit=0.2, rotate_limit=30, p=0.5),\n        A.RGBShift(r_shift_limit=25, g_shift_limit=25, b_shift_limit=25, p=0.5),\n        A.RandomBrightnessContrast(brightness_limit=0.3, contrast_limit=0.3, p=0.5),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\ntrain_dataset = OxfordPetDataset(train_images_filenames, images_directory, masks_directory, transform=train_transform,)\n\nval_transform = A.Compose(\n    [A.Resize(256, 256), A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)), ToTensorV2()]\n)\nval_dataset = OxfordPetDataset(val_images_filenames, images_directory, masks_directory, transform=val_transform,)\n</pre> train_transform = A.Compose(     [         A.Resize(256, 256),         A.ShiftScaleRotate(shift_limit=0.2, scale_limit=0.2, rotate_limit=30, p=0.5),         A.RGBShift(r_shift_limit=25, g_shift_limit=25, b_shift_limit=25, p=0.5),         A.RandomBrightnessContrast(brightness_limit=0.3, contrast_limit=0.3, p=0.5),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) train_dataset = OxfordPetDataset(train_images_filenames, images_directory, masks_directory, transform=train_transform,)  val_transform = A.Compose(     [A.Resize(256, 256), A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)), ToTensorV2()] ) val_dataset = OxfordPetDataset(val_images_filenames, images_directory, masks_directory, transform=val_transform,) <p>Let's define a function that takes a dataset and visualizes different augmentations applied to the same image and the associated mask.</p> In\u00a0[15]: Copied! <pre>def visualize_augmentations(dataset, idx=0, samples=5):\n    dataset = copy.deepcopy(dataset)\n    dataset.transform = A.Compose([t for t in dataset.transform if not isinstance(t, (A.Normalize, ToTensorV2))])\n    figure, ax = plt.subplots(nrows=samples, ncols=2, figsize=(10, 24))\n    for i in range(samples):\n        image, mask = dataset[idx]\n        ax[i, 0].imshow(image)\n        ax[i, 1].imshow(mask, interpolation=\"nearest\")\n        ax[i, 0].set_title(\"Augmented image\")\n        ax[i, 1].set_title(\"Augmented mask\")\n        ax[i, 0].set_axis_off()\n        ax[i, 1].set_axis_off()\n    plt.tight_layout()\n    plt.show()\n</pre> def visualize_augmentations(dataset, idx=0, samples=5):     dataset = copy.deepcopy(dataset)     dataset.transform = A.Compose([t for t in dataset.transform if not isinstance(t, (A.Normalize, ToTensorV2))])     figure, ax = plt.subplots(nrows=samples, ncols=2, figsize=(10, 24))     for i in range(samples):         image, mask = dataset[idx]         ax[i, 0].imshow(image)         ax[i, 1].imshow(mask, interpolation=\"nearest\")         ax[i, 0].set_title(\"Augmented image\")         ax[i, 1].set_title(\"Augmented mask\")         ax[i, 0].set_axis_off()         ax[i, 1].set_axis_off()     plt.tight_layout()     plt.show() In\u00a0[16]: Copied! <pre>random.seed(42)\nvisualize_augmentations(train_dataset, idx=55)\n</pre> random.seed(42) visualize_augmentations(train_dataset, idx=55) <p><code>MetricMonitor</code> helps to track metrics such as accuracy or loss during training and validation.</p> In\u00a0[17]: Copied! <pre>class MetricMonitor:\n    def __init__(self, float_precision=3):\n        self.float_precision = float_precision\n        self.reset()\n\n    def reset(self):\n        self.metrics = defaultdict(lambda: {\"val\": 0, \"count\": 0, \"avg\": 0})\n\n    def update(self, metric_name, val):\n        metric = self.metrics[metric_name]\n\n        metric[\"val\"] += val\n        metric[\"count\"] += 1\n        metric[\"avg\"] = metric[\"val\"] / metric[\"count\"]\n\n    def __str__(self):\n        return \" | \".join(\n            [\n                \"{metric_name}: {avg:.{float_precision}f}\".format(\n                    metric_name=metric_name, avg=metric[\"avg\"], float_precision=self.float_precision\n                )\n                for (metric_name, metric) in self.metrics.items()\n            ]\n        )\n</pre> class MetricMonitor:     def __init__(self, float_precision=3):         self.float_precision = float_precision         self.reset()      def reset(self):         self.metrics = defaultdict(lambda: {\"val\": 0, \"count\": 0, \"avg\": 0})      def update(self, metric_name, val):         metric = self.metrics[metric_name]          metric[\"val\"] += val         metric[\"count\"] += 1         metric[\"avg\"] = metric[\"val\"] / metric[\"count\"]      def __str__(self):         return \" | \".join(             [                 \"{metric_name}: {avg:.{float_precision}f}\".format(                     metric_name=metric_name, avg=metric[\"avg\"], float_precision=self.float_precision                 )                 for (metric_name, metric) in self.metrics.items()             ]         ) In\u00a0[18]: Copied! <pre>def train(train_loader, model, criterion, optimizer, epoch, params):\n    metric_monitor = MetricMonitor()\n    model.train()\n    stream = tqdm(train_loader)\n    for i, (images, target) in enumerate(stream, start=1):\n        images = images.to(params[\"device\"], non_blocking=True)\n        target = target.to(params[\"device\"], non_blocking=True)\n        output = model(images).squeeze(1)\n        loss = criterion(output, target)\n        metric_monitor.update(\"Loss\", loss.item())\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        stream.set_description(\n            \"Epoch: {epoch}. Train.      {metric_monitor}\".format(epoch=epoch, metric_monitor=metric_monitor)\n        )\n</pre> def train(train_loader, model, criterion, optimizer, epoch, params):     metric_monitor = MetricMonitor()     model.train()     stream = tqdm(train_loader)     for i, (images, target) in enumerate(stream, start=1):         images = images.to(params[\"device\"], non_blocking=True)         target = target.to(params[\"device\"], non_blocking=True)         output = model(images).squeeze(1)         loss = criterion(output, target)         metric_monitor.update(\"Loss\", loss.item())         optimizer.zero_grad()         loss.backward()         optimizer.step()         stream.set_description(             \"Epoch: {epoch}. Train.      {metric_monitor}\".format(epoch=epoch, metric_monitor=metric_monitor)         ) In\u00a0[19]: Copied! <pre>def validate(val_loader, model, criterion, epoch, params):\n    metric_monitor = MetricMonitor()\n    model.eval()\n    stream = tqdm(val_loader)\n    with torch.no_grad():\n        for i, (images, target) in enumerate(stream, start=1):\n            images = images.to(params[\"device\"], non_blocking=True)\n            target = target.to(params[\"device\"], non_blocking=True)\n            output = model(images).squeeze(1)\n            loss = criterion(output, target)\n            metric_monitor.update(\"Loss\", loss.item())\n            stream.set_description(\n                \"Epoch: {epoch}. Validation. {metric_monitor}\".format(epoch=epoch, metric_monitor=metric_monitor)\n            )\n</pre> def validate(val_loader, model, criterion, epoch, params):     metric_monitor = MetricMonitor()     model.eval()     stream = tqdm(val_loader)     with torch.no_grad():         for i, (images, target) in enumerate(stream, start=1):             images = images.to(params[\"device\"], non_blocking=True)             target = target.to(params[\"device\"], non_blocking=True)             output = model(images).squeeze(1)             loss = criterion(output, target)             metric_monitor.update(\"Loss\", loss.item())             stream.set_description(                 \"Epoch: {epoch}. Validation. {metric_monitor}\".format(epoch=epoch, metric_monitor=metric_monitor)             ) In\u00a0[20]: Copied! <pre>def create_model(params):\n    model = getattr(ternausnet.models, params[\"model\"])(pretrained=True)\n    model = model.to(params[\"device\"])\n    return model\n</pre> def create_model(params):     model = getattr(ternausnet.models, params[\"model\"])(pretrained=True)     model = model.to(params[\"device\"])     return model In\u00a0[21]: Copied! <pre>def train_and_validate(model, train_dataset, val_dataset, params):\n    train_loader = DataLoader(\n        train_dataset,\n        batch_size=params[\"batch_size\"],\n        shuffle=True,\n        num_workers=params[\"num_workers\"],\n        pin_memory=True,\n    )\n    val_loader = DataLoader(\n        val_dataset,\n        batch_size=params[\"batch_size\"],\n        shuffle=False,\n        num_workers=params[\"num_workers\"],\n        pin_memory=True,\n    )\n    criterion = nn.BCEWithLogitsLoss().to(params[\"device\"])\n    optimizer = torch.optim.Adam(model.parameters(), lr=params[\"lr\"])\n    for epoch in range(1, params[\"epochs\"] + 1):\n        train(train_loader, model, criterion, optimizer, epoch, params)\n        validate(val_loader, model, criterion, epoch, params)\n    return model\n</pre> def train_and_validate(model, train_dataset, val_dataset, params):     train_loader = DataLoader(         train_dataset,         batch_size=params[\"batch_size\"],         shuffle=True,         num_workers=params[\"num_workers\"],         pin_memory=True,     )     val_loader = DataLoader(         val_dataset,         batch_size=params[\"batch_size\"],         shuffle=False,         num_workers=params[\"num_workers\"],         pin_memory=True,     )     criterion = nn.BCEWithLogitsLoss().to(params[\"device\"])     optimizer = torch.optim.Adam(model.parameters(), lr=params[\"lr\"])     for epoch in range(1, params[\"epochs\"] + 1):         train(train_loader, model, criterion, optimizer, epoch, params)         validate(val_loader, model, criterion, epoch, params)     return model In\u00a0[22]: Copied! <pre>def predict(model, params, test_dataset, batch_size):\n    test_loader = DataLoader(\n        test_dataset, batch_size=batch_size, shuffle=False, num_workers=params[\"num_workers\"], pin_memory=True,\n    )\n    model.eval()\n    predictions = []\n    with torch.no_grad():\n        for images, (original_heights, original_widths) in test_loader:\n            images = images.to(params[\"device\"], non_blocking=True)\n            output = model(images)\n            probabilities = torch.sigmoid(output.squeeze(1))\n            predicted_masks = (probabilities &gt;= 0.5).float() * 1\n            predicted_masks = predicted_masks.cpu().numpy()\n            for predicted_mask, original_height, original_width in zip(\n                predicted_masks, original_heights.numpy(), original_widths.numpy()\n            ):\n                predictions.append((predicted_mask, original_height, original_width))\n    return predictions\n</pre> def predict(model, params, test_dataset, batch_size):     test_loader = DataLoader(         test_dataset, batch_size=batch_size, shuffle=False, num_workers=params[\"num_workers\"], pin_memory=True,     )     model.eval()     predictions = []     with torch.no_grad():         for images, (original_heights, original_widths) in test_loader:             images = images.to(params[\"device\"], non_blocking=True)             output = model(images)             probabilities = torch.sigmoid(output.squeeze(1))             predicted_masks = (probabilities &gt;= 0.5).float() * 1             predicted_masks = predicted_masks.cpu().numpy()             for predicted_mask, original_height, original_width in zip(                 predicted_masks, original_heights.numpy(), original_widths.numpy()             ):                 predictions.append((predicted_mask, original_height, original_width))     return predictions <p>Here we define a few training parameters such as model architecture, learning rate, batch size, epochs, etc.</p> In\u00a0[23]: Copied! <pre>params = {\n    \"model\": \"UNet11\",\n    \"device\": \"cuda\",\n    \"lr\": 0.001,\n    \"batch_size\": 16,\n    \"num_workers\": 4,\n    \"epochs\": 10,\n}\n</pre> params = {     \"model\": \"UNet11\",     \"device\": \"cuda\",     \"lr\": 0.001,     \"batch_size\": 16,     \"num_workers\": 4,     \"epochs\": 10, } In\u00a0[24]: Copied! <pre>model = create_model(params)\nmodel = train_and_validate(model, train_dataset, val_dataset, params)\n</pre> model = create_model(params) model = train_and_validate(model, train_dataset, val_dataset, params) <pre>Epoch: 1. Train.      Loss: 0.415: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:42&lt;00:00,  3.66it/s]\nEpoch: 1. Validation. Loss: 0.210: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:09&lt;00:00,  9.55it/s]\nEpoch: 2. Train.      Loss: 0.257: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 2. Validation. Loss: 0.178: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.62it/s]\nEpoch: 3. Train.      Loss: 0.221: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:39&lt;00:00,  3.75it/s]\nEpoch: 3. Validation. Loss: 0.168: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.58it/s]\nEpoch: 4. Train.      Loss: 0.209: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 4. Validation. Loss: 0.156: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.57it/s]\nEpoch: 5. Train.      Loss: 0.190: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 5. Validation. Loss: 0.149: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.57it/s]\nEpoch: 6. Train.      Loss: 0.179: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:39&lt;00:00,  3.75it/s]\nEpoch: 6. Validation. Loss: 0.155: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.55it/s]\nEpoch: 7. Train.      Loss: 0.175: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 7. Validation. Loss: 0.147: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.59it/s]\nEpoch: 8. Train.      Loss: 0.167: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 8. Validation. Loss: 0.146: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.61it/s]\nEpoch: 9. Train.      Loss: 0.165: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 9. Validation. Loss: 0.131: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.56it/s]\nEpoch: 10. Train.      Loss: 0.156: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 10. Validation. Loss: 0.140: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.60it/s]\n</pre> <p>Now we have a trained model, so let's try to predict masks for some images. Note that the <code>__getitem__</code> method returns not only an image but also the original height and width of an image. We will use those values to resize a predicted mask from the size of 256x256 pixels to the original image's size.</p> In\u00a0[25]: Copied! <pre>class OxfordPetInferenceDataset(Dataset):\n    def __init__(self, images_filenames, images_directory, transform=None):\n        self.images_filenames = images_filenames\n        self.images_directory = images_directory\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.images_filenames)\n\n    def __getitem__(self, idx):\n        image_filename = self.images_filenames[idx]\n        image = cv2.imread(os.path.join(self.images_directory, image_filename))\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        original_size = tuple(image.shape[:2])\n        if self.transform is not None:\n            transformed = self.transform(image=image)\n            image = transformed[\"image\"]\n        return image, original_size\n</pre> class OxfordPetInferenceDataset(Dataset):     def __init__(self, images_filenames, images_directory, transform=None):         self.images_filenames = images_filenames         self.images_directory = images_directory         self.transform = transform      def __len__(self):         return len(self.images_filenames)      def __getitem__(self, idx):         image_filename = self.images_filenames[idx]         image = cv2.imread(os.path.join(self.images_directory, image_filename))         image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)         original_size = tuple(image.shape[:2])         if self.transform is not None:             transformed = self.transform(image=image)             image = transformed[\"image\"]         return image, original_size In\u00a0[26]: Copied! <pre>test_transform = A.Compose(\n    [A.Resize(256, 256), A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)), ToTensorV2()]\n)\ntest_dataset = OxfordPetInferenceDataset(test_images_filenames, images_directory, transform=test_transform,)\n</pre> test_transform = A.Compose(     [A.Resize(256, 256), A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)), ToTensorV2()] ) test_dataset = OxfordPetInferenceDataset(test_images_filenames, images_directory, transform=test_transform,) In\u00a0[27]: Copied! <pre>predictions = predict(model, params, test_dataset, batch_size=16)\n</pre> predictions = predict(model, params, test_dataset, batch_size=16) <p>Next, we will resize the predicted masks with the size of 256x256 pixels to the original images' size.</p> In\u00a0[28]: Copied! <pre>predicted_masks = []\nfor predicted_256x256_mask, original_height, original_width in predictions:\n    full_sized_mask = F.resize(\n        predicted_256x256_mask, height=original_height, width=original_width, interpolation=cv2.INTER_NEAREST\n    )\n    predicted_masks.append(full_sized_mask)\n</pre> predicted_masks = [] for predicted_256x256_mask, original_height, original_width in predictions:     full_sized_mask = F.resize(         predicted_256x256_mask, height=original_height, width=original_width, interpolation=cv2.INTER_NEAREST     )     predicted_masks.append(full_sized_mask) In\u00a0[29]: Copied! <pre>display_image_grid(test_images_filenames, images_directory, masks_directory, predicted_masks=predicted_masks)\n</pre> display_image_grid(test_images_filenames, images_directory, masks_directory, predicted_masks=predicted_masks) <p>We will reuse most of the code from the previous example.</p> <p>Heights and widths of the same images in the dataset are less than the crop size (256x256 pixels), so we first apply <code>A.PadIfNeeded(min_height=256, min_width=256)</code> which will pad an image if its height or width is less than 256 pixels.</p> In\u00a0[30]: Copied! <pre>train_transform = A.Compose(\n    [\n        A.PadIfNeeded(min_height=256, min_width=256),\n        A.RandomCrop(256, 256),\n        A.ShiftScaleRotate(shift_limit=0.05, scale_limit=0.05, rotate_limit=15, p=0.5),\n        A.RGBShift(r_shift_limit=15, g_shift_limit=15, b_shift_limit=15, p=0.5),\n        A.RandomBrightnessContrast(p=0.5),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\ntrain_dataset = OxfordPetDataset(train_images_filenames, images_directory, masks_directory, transform=train_transform,)\n</pre> train_transform = A.Compose(     [         A.PadIfNeeded(min_height=256, min_width=256),         A.RandomCrop(256, 256),         A.ShiftScaleRotate(shift_limit=0.05, scale_limit=0.05, rotate_limit=15, p=0.5),         A.RGBShift(r_shift_limit=15, g_shift_limit=15, b_shift_limit=15, p=0.5),         A.RandomBrightnessContrast(p=0.5),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) train_dataset = OxfordPetDataset(train_images_filenames, images_directory, masks_directory, transform=train_transform,) In\u00a0[31]: Copied! <pre>val_transform = A.Compose(\n    [\n        A.PadIfNeeded(min_height=256, min_width=256),\n        A.CenterCrop(256, 256),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\nval_dataset = OxfordPetDataset(val_images_filenames, images_directory, masks_directory, transform=val_transform,)\n</pre> val_transform = A.Compose(     [         A.PadIfNeeded(min_height=256, min_width=256),         A.CenterCrop(256, 256),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) val_dataset = OxfordPetDataset(val_images_filenames, images_directory, masks_directory, transform=val_transform,) In\u00a0[32]: Copied! <pre>params = {\n    \"model\": \"UNet11\",\n    \"device\": \"cuda\",\n    \"lr\": 0.001,\n    \"batch_size\": 16,\n    \"num_workers\": 4,\n    \"epochs\": 10,\n}\n</pre> params = {     \"model\": \"UNet11\",     \"device\": \"cuda\",     \"lr\": 0.001,     \"batch_size\": 16,     \"num_workers\": 4,     \"epochs\": 10, } In\u00a0[33]: Copied! <pre>model = create_model(params)\nmodel = train_and_validate(model, train_dataset, val_dataset, params)\n</pre> model = create_model(params) model = train_and_validate(model, train_dataset, val_dataset, params) <pre>Epoch: 1. Train.      Loss: 0.445: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 1. Validation. Loss: 0.279: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.49it/s]\nEpoch: 2. Train.      Loss: 0.311: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:39&lt;00:00,  3.75it/s]\nEpoch: 2. Validation. Loss: 0.238: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.51it/s]\nEpoch: 3. Train.      Loss: 0.259: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:39&lt;00:00,  3.75it/s]\nEpoch: 3. Validation. Loss: 0.206: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.54it/s]\nEpoch: 4. Train.      Loss: 0.244: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:39&lt;00:00,  3.75it/s]\nEpoch: 4. Validation. Loss: 0.211: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.54it/s]\nEpoch: 5. Train.      Loss: 0.224: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.74it/s]\nEpoch: 5. Validation. Loss: 0.270: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.47it/s]\nEpoch: 6. Train.      Loss: 0.207: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 6. Validation. Loss: 0.169: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.56it/s]\nEpoch: 7. Train.      Loss: 0.212: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 7. Validation. Loss: 0.169: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.56it/s]\nEpoch: 8. Train.      Loss: 0.189: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:40&lt;00:00,  3.75it/s]\nEpoch: 8. Validation. Loss: 0.201: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.52it/s]\nEpoch: 9. Train.      Loss: 0.185: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:39&lt;00:00,  3.75it/s]\nEpoch: 9. Validation. Loss: 0.162: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.54it/s]\nEpoch: 10. Train.      Loss: 0.187: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 375/375 [01:39&lt;00:00,  3.75it/s]\nEpoch: 10. Validation. Loss: 0.159: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 86/86 [00:08&lt;00:00, 10.49it/s]\n</pre> <p>All images in the test dataset have a max side with size 500 pixels. Since PyTorch requires that all images in a batch must have the same dimensions, and also UNet requires that the size of an image will be divisible by 16, we will apply <code>A.PadIfNeeded(min_height=512, min_width=512, border_mode=cv2.BORDER_CONSTANT)</code>. That augmentation will pad image borders with zeros so the image size will become 512x512 pixels.</p> In\u00a0[34]: Copied! <pre>test_transform = A.Compose(\n    [\n        A.PadIfNeeded(min_height=512, min_width=512, border_mode=cv2.BORDER_CONSTANT),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\ntest_dataset = OxfordPetInferenceDataset(test_images_filenames, images_directory, transform=test_transform,)\n</pre> test_transform = A.Compose(     [         A.PadIfNeeded(min_height=512, min_width=512, border_mode=cv2.BORDER_CONSTANT),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) test_dataset = OxfordPetInferenceDataset(test_images_filenames, images_directory, transform=test_transform,) In\u00a0[35]: Copied! <pre>predictions = predict(model, params, test_dataset, batch_size=16)\n</pre> predictions = predict(model, params, test_dataset, batch_size=16) <p>Since we received masks for padded images, we need to crop a part of the original image size from the padded mask.</p> In\u00a0[36]: Copied! <pre>predicted_masks = []\nfor predicted_padded_mask, original_height, original_width in predictions:\n    cropped_mask = F.center_crop(predicted_padded_mask, original_height, original_width)\n    predicted_masks.append(cropped_mask)\n</pre> predicted_masks = [] for predicted_padded_mask, original_height, original_width in predictions:     cropped_mask = F.center_crop(predicted_padded_mask, original_height, original_width)     predicted_masks.append(cropped_mask) In\u00a0[37]: Copied! <pre>display_image_grid(test_images_filenames, images_directory, masks_directory, predicted_masks=predicted_masks)\n</pre> display_image_grid(test_images_filenames, images_directory, masks_directory, predicted_masks=predicted_masks) <p>We could also use original images without resizing or cropping them. However, there is a problem with this dataset. A few images in the dataset are so large that even with <code>batch_size=1</code>, they require more than 11Gb of GPU memory for training. So as a tradeoff, we will first apply the <code>A.LongestMaxSize(512)</code> augmentation that will ensure that an image's largest size is no more than 512 pixels. That augmentation will affect only 137 out of 7384 dataset images.</p> <p>Next will use <code>A.PadIfNeeded(min_height=512, min_width=512)</code> to ensure that all images in a batch will have size 512x512 pixels.</p> In\u00a0[38]: Copied! <pre>train_transform = A.Compose(\n    [\n        A.LongestMaxSize(512),\n        A.PadIfNeeded(min_height=512, min_width=512),\n        A.ShiftScaleRotate(shift_limit=0.05, scale_limit=0.05, rotate_limit=15, p=0.5),\n        A.RGBShift(r_shift_limit=15, g_shift_limit=15, b_shift_limit=15, p=0.5),\n        A.RandomBrightnessContrast(p=0.5),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\ntrain_dataset = OxfordPetDataset(train_images_filenames, images_directory, masks_directory, transform=train_transform,)\n\nval_transform = A.Compose(\n    [\n        A.LongestMaxSize(512),\n        A.PadIfNeeded(min_height=512, min_width=512, border_mode=cv2.BORDER_CONSTANT),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\nval_dataset = OxfordPetDataset(val_images_filenames, images_directory, masks_directory, transform=val_transform,)\n</pre> train_transform = A.Compose(     [         A.LongestMaxSize(512),         A.PadIfNeeded(min_height=512, min_width=512),         A.ShiftScaleRotate(shift_limit=0.05, scale_limit=0.05, rotate_limit=15, p=0.5),         A.RGBShift(r_shift_limit=15, g_shift_limit=15, b_shift_limit=15, p=0.5),         A.RandomBrightnessContrast(p=0.5),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) train_dataset = OxfordPetDataset(train_images_filenames, images_directory, masks_directory, transform=train_transform,)  val_transform = A.Compose(     [         A.LongestMaxSize(512),         A.PadIfNeeded(min_height=512, min_width=512, border_mode=cv2.BORDER_CONSTANT),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) val_dataset = OxfordPetDataset(val_images_filenames, images_directory, masks_directory, transform=val_transform,) In\u00a0[39]: Copied! <pre>params = {\n    \"model\": \"UNet11\",\n    \"device\": \"cuda\",\n    \"lr\": 0.001,\n    \"batch_size\": 8,\n    \"num_workers\": 4,\n    \"epochs\": 10,\n}\n</pre> params = {     \"model\": \"UNet11\",     \"device\": \"cuda\",     \"lr\": 0.001,     \"batch_size\": 8,     \"num_workers\": 4,     \"epochs\": 10, } In\u00a0[40]: Copied! <pre>model = create_model(params)\nmodel = train_and_validate(model, train_dataset, val_dataset, params)\n</pre> model = create_model(params) model = train_and_validate(model, train_dataset, val_dataset, params) <pre>Epoch: 1. Train.      Loss: 0.442: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:58&lt;00:00,  1.79it/s]\nEpoch: 1. Validation. Loss: 0.225: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:35&lt;00:00,  4.80it/s]\nEpoch: 2. Train.      Loss: 0.283: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:54&lt;00:00,  1.81it/s]\nEpoch: 2. Validation. Loss: 0.188: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:34&lt;00:00,  4.99it/s]\nEpoch: 3. Train.      Loss: 0.234: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:53&lt;00:00,  1.81it/s]\nEpoch: 3. Validation. Loss: 0.154: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:34&lt;00:00,  4.96it/s]\nEpoch: 4. Train.      Loss: 0.211: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:53&lt;00:00,  1.81it/s]\nEpoch: 4. Validation. Loss: 0.136: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:34&lt;00:00,  4.99it/s]\nEpoch: 5. Train.      Loss: 0.196: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:53&lt;00:00,  1.81it/s]\nEpoch: 5. Validation. Loss: 0.131: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:34&lt;00:00,  4.96it/s]\nEpoch: 6. Train.      Loss: 0.187: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:53&lt;00:00,  1.81it/s]\nEpoch: 6. Validation. Loss: 0.151: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:34&lt;00:00,  4.98it/s]\nEpoch: 7. Train.      Loss: 0.177: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:53&lt;00:00,  1.81it/s]\nEpoch: 7. Validation. Loss: 0.127: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:34&lt;00:00,  4.98it/s]\nEpoch: 8. Train.      Loss: 0.171: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:53&lt;00:00,  1.81it/s]\nEpoch: 8. Validation. Loss: 0.113: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:34&lt;00:00,  4.99it/s]\nEpoch: 9. Train.      Loss: 0.162: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:54&lt;00:00,  1.81it/s]\nEpoch: 9. Validation. Loss: 0.143: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:34&lt;00:00,  4.94it/s]\nEpoch: 10. Train.      Loss: 0.157: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 750/750 [06:53&lt;00:00,  1.81it/s]\nEpoch: 10. Validation. Loss: 0.115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 172/172 [00:34&lt;00:00,  4.97it/s]\n</pre> <p>Next, we will use the same code that we were using in Approach 2 to make predictions.</p> In\u00a0[41]: Copied! <pre>test_transform = A.Compose(\n    [\n        A.PadIfNeeded(min_height=512, min_width=512, border_mode=cv2.BORDER_CONSTANT),\n        A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),\n        ToTensorV2(),\n    ]\n)\ntest_dataset = OxfordPetInferenceDataset(test_images_filenames, images_directory, transform=test_transform,)\n</pre> test_transform = A.Compose(     [         A.PadIfNeeded(min_height=512, min_width=512, border_mode=cv2.BORDER_CONSTANT),         A.Normalize(mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)),         ToTensorV2(),     ] ) test_dataset = OxfordPetInferenceDataset(test_images_filenames, images_directory, transform=test_transform,) In\u00a0[42]: Copied! <pre>predictions = predict(model, params, test_dataset, batch_size=16)\n</pre> predictions = predict(model, params, test_dataset, batch_size=16) In\u00a0[43]: Copied! <pre>predicted_masks = []\nfor predicted_padded_mask, original_height, original_width in predictions:\n    cropped_mask = F.center_crop(predicted_padded_mask, original_height, original_width)\n    predicted_masks.append(cropped_mask)\n</pre> predicted_masks = [] for predicted_padded_mask, original_height, original_width in predictions:     cropped_mask = F.center_crop(predicted_padded_mask, original_height, original_width)     predicted_masks.append(cropped_mask) In\u00a0[44]: Copied! <pre>display_image_grid(test_images_filenames, images_directory, masks_directory, predicted_masks=predicted_masks)\n</pre> display_image_grid(test_images_filenames, images_directory, masks_directory, predicted_masks=predicted_masks)"},{"location":"examples/pytorch_semantic_segmentation/#pytorch-and-albumentations-for-semantic-segmentation","title":"PyTorch and Albumentations for semantic segmentation\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#install-the-required-libraries","title":"Install the required libraries\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#define-functions-to-download-an-archived-dataset-and-unpack-it","title":"Define functions to download an archived dataset and unpack it\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#set-the-root-directory-for-the-downloaded-dataset","title":"Set the root directory for the downloaded dataset\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#download-and-extract-the-cats-vs-docs-dataset","title":"Download and extract the <code>Cats vs. Docs</code> dataset\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#split-files-from-the-dataset-into-the-train-and-validation-sets","title":"Split files from the dataset into the train and validation sets\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#define-a-function-to-preprocess-a-mask","title":"Define a function to preprocess a mask\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#define-a-function-to-visualize-images-and-their-labels","title":"Define a function to visualize images and their labels\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#image-sizes-for-training-and-prediction","title":"Image sizes for training and prediction\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#approach-1-resize-all-images-and-masks-to-a-fixed-size-eg-256x256-pixels","title":"Approach 1. Resize all images and masks to a fixed size (e.g., 256x256 pixels).\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#define-a-pytorch-dataset-class","title":"Define a PyTorch dataset class\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#define-helpers-for-training","title":"Define helpers for training\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#define-functions-for-training-and-validation","title":"Define functions for training and validation\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#define-training-parameters","title":"Define training parameters\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#train-a-model","title":"Train a model\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#predict-labels-for-images-and-visualize-those-predictions","title":"Predict labels for images and visualize those predictions\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#approach-2-train-on-crops-predict-masks-for-full-sized-images","title":"Approach 2. Train on crops, predict masks for full-sized images\u00b6","text":""},{"location":"examples/pytorch_semantic_segmentation/#approach-3-use-original-images","title":"Approach 3. Use original images.\u00b6","text":""},{"location":"examples/replay/","title":"Debugging an augmentation pipeline with ReplayCompose","text":"<p>An augmentation pipeline has a lot of randomness inside it. It applies augmentations with some probabilities, and it samples parameters for those augmentations (such as a rotation angle or a level of changing brightness) from a random distribution.</p> <p>It could be very useful for debugging purposes to see which augmentations were applied to the image and look at the parameters of those augmentations.</p> <p><code>ReplayCompose</code> tracks augmentation parameters. You can inspect those parameters or reapply them to another image.</p> In\u00a0[2]: Copied! <pre>import random\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport albumentations as A\n</pre> import random  import cv2 import matplotlib.pyplot as plt import albumentations as A In\u00a0[3]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(10, 10))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(10, 10))     plt.axis('off')     plt.imshow(image) In\u00a0[4]: Copied! <pre>image = cv2.imread('images/parrot.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\nvisualize(image)\n</pre> image = cv2.imread('images/parrot.jpg') image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) visualize(image) In\u00a0[5]: Copied! <pre>transform = A.ReplayCompose([\n    A.Resize(512, 512, always_apply=True),\n    A.RandomCrop(200, 200, always_apply=True),\n    A.OneOf([\n        A.RGBShift(),\n        A.HueSaturationValue()\n    ]),\n])\n</pre> transform = A.ReplayCompose([     A.Resize(512, 512, always_apply=True),     A.RandomCrop(200, 200, always_apply=True),     A.OneOf([         A.RGBShift(),         A.HueSaturationValue()     ]), ]) <p>We fix the random seed for visualization purposes, so the augmentation will always produce the same result. In a real computer vision pipeline, you shouldn't fix the random seed before applying a transform to the image because, in that case, the pipeline will always output the same image. The purpose of image augmentation is to use different transformations each time.</p> In\u00a0[6]: Copied! <pre>random.seed(7)\ndata = transform(image=image)\nvisualize(data['image'])\n</pre> random.seed(7) data = transform(image=image) visualize(data['image']) <p><code>data['replay']</code> contains information about augmentations that ere applied to the image. If <code>applied</code> is <code>True</code>, then the augmentation was applied to the image. <code>params</code> contains information about parameters that were used to transform the image.</p> In\u00a0[7]: Copied! <pre>data['replay']\n</pre> data['replay'] Out[7]: <pre>{'__class_fullname__': 'ReplayCompose',\n 'params': None,\n 'transforms': [{'__class_fullname__': 'Resize',\n   'always_apply': True,\n   'p': 1,\n   'height': 512,\n   'width': 512,\n   'interpolation': 1,\n   'params': {},\n   'applied': True},\n  {'__class_fullname__': 'RandomCrop',\n   'always_apply': True,\n   'p': 1.0,\n   'height': 200,\n   'width': 200,\n   'params': {'h_start': 0.07243628666754276, 'w_start': 0.5358820043066892},\n   'applied': True},\n  {'__class_fullname__': 'OneOf',\n   'params': None,\n   'transforms': [{'__class_fullname__': 'RGBShift',\n     'always_apply': False,\n     'p': 0.5,\n     'r_shift_limit': (-20, 20),\n     'g_shift_limit': (-20, 20),\n     'b_shift_limit': (-20, 20),\n     'params': None,\n     'applied': False},\n    {'__class_fullname__': 'HueSaturationValue',\n     'always_apply': False,\n     'p': 0.5,\n     'hue_shift_limit': (-20, 20),\n     'sat_shift_limit': (-30, 30),\n     'val_shift_limit': (-20, 20),\n     'params': {'hue_shift': -2.654172653504567,\n      'sat_shift': -25.808674585522866,\n      'val_shift': -16.371479466245397},\n     'applied': True}],\n   'applied': True}],\n 'bbox_params': None,\n 'keypoint_params': None,\n 'additional_targets': {},\n 'is_check_shapes': True,\n 'applied': True}</pre> <p>To apply the same set of augmentations to a new target, you can use the <code>ReplayCompose.replay</code> function.</p> In\u00a0[8]: Copied! <pre>image2 = cv2.imread('images/image_2.jpg')\nimage2 = cv2.cvtColor(image2, cv2.COLOR_BGR2RGB)\nvisualize(image2)\n</pre> image2 = cv2.imread('images/image_2.jpg') image2 = cv2.cvtColor(image2, cv2.COLOR_BGR2RGB) visualize(image2) In\u00a0[9]: Copied! <pre>image3 = cv2.imread('images/image_3.jpg')\nimage3 = cv2.cvtColor(image3, cv2.COLOR_BGR2RGB)\nvisualize(image3)\n</pre> image3 = cv2.imread('images/image_3.jpg') image3 = cv2.cvtColor(image3, cv2.COLOR_BGR2RGB) visualize(image3) In\u00a0[10]: Copied! <pre>image2_data = A.ReplayCompose.replay(data['replay'], image=image2)\nvisualize(image2_data['image'])\n</pre> image2_data = A.ReplayCompose.replay(data['replay'], image=image2) visualize(image2_data['image']) In\u00a0[11]: Copied! <pre>image3_data = A.ReplayCompose.replay(data['replay'], image=image3)\nvisualize(image3_data['image'])\n</pre> image3_data = A.ReplayCompose.replay(data['replay'], image=image3) visualize(image3_data['image'])"},{"location":"examples/replay/#debugging-an-augmentation-pipeline-with-replaycompose","title":"Debugging an augmentation pipeline with ReplayCompose\u00b6","text":""},{"location":"examples/replay/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/replay/#define-the-visualization-function","title":"Define the visualization function\u00b6","text":""},{"location":"examples/replay/#load-an-image-from-the-disk","title":"Load an image from the disk\u00b6","text":""},{"location":"examples/replay/#declare-an-augmentation-pipeline-using-replaycompose","title":"Declare an augmentation pipeline using <code>ReplayCompose</code>\u00b6","text":""},{"location":"examples/replay/#using-replaycomposereplay-to-apply-the-same-augmentations-to-another-image","title":"Using <code>ReplayCompose.replay</code> to apply the same augmentations to another image\u00b6","text":""},{"location":"examples/replay/#load-new-images","title":"Load new images\u00b6","text":""},{"location":"examples/replay/#apply-augmentations-from-datareplay-to-those-images","title":"Apply augmentations from data['replay'] to those images\u00b6","text":""},{"location":"examples/serialization/","title":"How to save and load parameters of an augmentation pipeline","text":"<p>Reproducibility is very important in deep learning. Data scientists and machine learning engineers need a way to save all parameters of deep learning pipelines such as model, optimizer, input datasets, and augmentation parameters and to be able to recreate the same pipeline using that data. Albumentations has built-in functionality to serialize the augmentation parameters and save them. Then you can use those parameters to recreate an augmentation pipeline.</p> In\u00a0[1]: Copied! <pre>import random\n\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\nimport albumentations as A\n</pre> import random  import numpy as np import cv2 import matplotlib.pyplot as plt import albumentations as A In\u00a0[2]: Copied! <pre>def visualize(image):\n    plt.figure(figsize=(6, 6))\n    plt.axis('off')\n    plt.imshow(image)\n</pre> def visualize(image):     plt.figure(figsize=(6, 6))     plt.axis('off')     plt.imshow(image) In\u00a0[3]: Copied! <pre>image = cv2.imread('images/parrot.jpg')\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\nvisualize(image)\n</pre> image = cv2.imread('images/parrot.jpg') image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) visualize(image) In\u00a0[4]: Copied! <pre>transform = A.Compose([\n    A.Perspective(),\n    A.RandomCrop(768, 768),\n    A.OneOf([\n        A.RGBShift(),\n        A.HueSaturationValue()\n    ]),\n])\n</pre> transform = A.Compose([     A.Perspective(),     A.RandomCrop(768, 768),     A.OneOf([         A.RGBShift(),         A.HueSaturationValue()     ]), ]) <p>We can pass an instance of augmentation to the <code>print</code> function, and it will print the string representation of it.</p> In\u00a0[5]: Copied! <pre>print(transform)\n</pre> print(transform) <pre>Compose([\n  Perspective(always_apply=False, p=0.5, scale=(0.05, 0.1), keep_size=True, pad_mode=0, pad_val=0, mask_pad_val=0, fit_output=False, interpolation=1),\n  RandomCrop(always_apply=False, p=1.0, height=768, width=768),\n  OneOf([\n    RGBShift(always_apply=False, p=0.5, r_shift_limit=(-20, 20), g_shift_limit=(-20, 20), b_shift_limit=(-20, 20)),\n    HueSaturationValue(always_apply=False, p=0.5, hue_shift_limit=(-20, 20), sat_shift_limit=(-30, 30), val_shift_limit=(-20, 20)),\n  ], p=0.5),\n], p=1.0, bbox_params=None, keypoint_params=None, additional_targets={}, is_check_shapes=True)\n</pre> <p>Next, we will fix the random seed to make augmentation reproducible for visualization purposes and augment an example image.</p> In\u00a0[6]: Copied! <pre>random.seed(42)\nnp.random.seed(42)\ntransformed = transform(image=image)\nvisualize(transformed['image'])\n</pre> random.seed(42) np.random.seed(42) transformed = transform(image=image) visualize(transformed['image']) <p>To save the serialized representation of an augmentation pipeline to a JSON file, use the <code>save</code> function from Albumentations.</p> In\u00a0[7]: Copied! <pre>A.save(transform, '/tmp/transform.json')\n</pre> A.save(transform, '/tmp/transform.json') <p>To load a serialized representation from a JSON file, use the <code>load</code> function from Albumentations.</p> In\u00a0[8]: Copied! <pre>loaded_transform = A.load('/tmp/transform.json')\n</pre> loaded_transform = A.load('/tmp/transform.json') In\u00a0[9]: Copied! <pre>print(loaded_transform)\n</pre> print(loaded_transform) <pre>Compose([\n  Perspective(always_apply=False, p=0.5, scale=(0.05, 0.1), keep_size=True, pad_mode=0, pad_val=0, mask_pad_val=0, fit_output=False, interpolation=1),\n  RandomCrop(always_apply=False, p=1.0, height=768, width=768),\n  OneOf([\n    RGBShift(always_apply=False, p=0.5, r_shift_limit=(-20, 20), g_shift_limit=(-20, 20), b_shift_limit=(-20, 20)),\n    HueSaturationValue(always_apply=False, p=0.5, hue_shift_limit=(-20, 20), sat_shift_limit=(-30, 30), val_shift_limit=(-20, 20)),\n  ], p=0.5),\n], p=1.0, bbox_params=None, keypoint_params=None, additional_targets={}, is_check_shapes=True)\n</pre> <p>Next, we will use the same random seed as before and apply the loaded augmentation pipeline to the same image.</p> In\u00a0[10]: Copied! <pre>random.seed(42)\ntransformed_from_loaded_transform = loaded_transform(image=image)\nvisualize(transformed_from_loaded_transform['image'])\n</pre> random.seed(42) transformed_from_loaded_transform = loaded_transform(image=image) visualize(transformed_from_loaded_transform['image']) In\u00a0[11]: Copied! <pre>assert np.array_equal(transformed['image'], transformed_from_loaded_transform['image'])\n</pre> assert np.array_equal(transformed['image'], transformed_from_loaded_transform['image']) <p>As you see, it produced the same result.</p> <p>You can also use YAML instead of JSON for serializing and deserializing of augmentation pipelines. To do that add the <code>data_format='yaml'</code> argument to  the <code>save</code> and <code>load</code> functions.</p> In\u00a0[12]: Copied! <pre>A.save(transform, '/tmp/transform.yml', data_format='yaml')\nloaded_transform = A.load('/tmp/transform.yml', data_format='yaml')\n</pre> A.save(transform, '/tmp/transform.yml', data_format='yaml') loaded_transform = A.load('/tmp/transform.yml', data_format='yaml') In\u00a0[13]: Copied! <pre>print(loaded_transform)\n</pre> print(loaded_transform) <pre>Compose([\n  Perspective(always_apply=False, p=0.5, scale=(0.05, 0.1), keep_size=True, pad_mode=0, pad_val=0, mask_pad_val=0, fit_output=False, interpolation=1),\n  RandomCrop(always_apply=False, p=1.0, height=768, width=768),\n  OneOf([\n    RGBShift(always_apply=False, p=0.5, r_shift_limit=(-20, 20), g_shift_limit=(-20, 20), b_shift_limit=(-20, 20)),\n    HueSaturationValue(always_apply=False, p=0.5, hue_shift_limit=(-20, 20), sat_shift_limit=(-30, 30), val_shift_limit=(-20, 20)),\n  ], p=0.5),\n], p=1.0, bbox_params=None, keypoint_params=None, additional_targets={}, is_check_shapes=True)\n</pre> <p>If you need more control over a serialized pipeline, e.g., you want to save a serialized version to a database or send it to a server you can use the <code>to_dict</code> and <code>from_dict</code> functions. <code>to_dict</code> returns a Python dictionary that describes a pipeline. The dictionary will contain only primitive data types such as dictionaries, lists, strings, integers, and floats. To construct a pipeline from a dictionary, you need to call <code>from_dict</code>.</p> In\u00a0[14]: Copied! <pre>transform_dict = A.to_dict(transform)\nloaded_transform = A.from_dict(transform_dict)\n</pre> transform_dict = A.to_dict(transform) loaded_transform = A.from_dict(transform_dict) In\u00a0[15]: Copied! <pre>print(loaded_transform)\n</pre> print(loaded_transform) <pre>Compose([\n  Perspective(always_apply=False, p=0.5, scale=(0.05, 0.1), keep_size=True, pad_mode=0, pad_val=0, mask_pad_val=0, fit_output=False, interpolation=1),\n  RandomCrop(always_apply=False, p=1.0, height=768, width=768),\n  OneOf([\n    RGBShift(always_apply=False, p=0.5, r_shift_limit=(-20, 20), g_shift_limit=(-20, 20), b_shift_limit=(-20, 20)),\n    HueSaturationValue(always_apply=False, p=0.5, hue_shift_limit=(-20, 20), sat_shift_limit=(-30, 30), val_shift_limit=(-20, 20)),\n  ], p=0.5),\n], p=1.0, bbox_params=None, keypoint_params=None, additional_targets={}, is_check_shapes=True)\n</pre> <p>Lambda transforms use custom transformation functions provided by a user. For those types of transforms, Albumentations saves only the name and the position in the augmentation pipeline. To deserialize an augmentation pipeline with Lambda transforms, you need to manually provide all Lambda transform instances using the <code>lambda_transforms</code> argument.</p> <p>Let's define a function that we will use to transform an image.</p> In\u00a0[16]: Copied! <pre>def hflip_image(image, **kwargs):\n    return cv2.flip(image, 1)\n</pre> def hflip_image(image, **kwargs):     return cv2.flip(image, 1) <p>Next, we create a Lambda transform that will apply the <code>hflip_image</code> function to input images. Note that to make the transform serializable, you need to pass the <code>name</code> argument.</p> In\u00a0[17]: Copied! <pre>hflip = A.Lambda(name='hflip_image', image=hflip_image, p=0.5)\ntransform = A.Compose([hflip])\nprint(transform)\n</pre> hflip = A.Lambda(name='hflip_image', image=hflip_image, p=0.5) transform = A.Compose([hflip]) print(transform) <pre>Compose([\n  Lambda(name='hflip_image', image=&lt;function hflip_image at 0x2a7e34d30&gt;, mask=&lt;function noop at 0x13a7c0d30&gt;, keypoint=&lt;function noop at 0x13a7c0d30&gt;, bbox=&lt;function noop at 0x13a7c0d30&gt;, always_apply=False, p=0.5),\n], p=1.0, bbox_params=None, keypoint_params=None, additional_targets={}, is_check_shapes=True)\n</pre> <p>To check that transform is working, we will apply to an image.</p> In\u00a0[18]: Copied! <pre>random.seed(7)\ntransformed = transform(image=image)\nvisualize(transformed['image'])\n</pre> random.seed(7) transformed = transform(image=image) visualize(transformed['image']) <p>To serialize a pipeline with a Lambda transform, use the <code>save</code> function as before.</p> In\u00a0[19]: Copied! <pre>A.save(transform, '/tmp/lambda_transform.json')\n</pre> A.save(transform, '/tmp/lambda_transform.json') <p>To deserialize a pipeline that contains Lambda transforms, you need to pass names and instances of all Lambda transforms in a pipeline through the <code>lambda_transforms</code> argument.</p> In\u00a0[21]: Copied! <pre>loaded_transform = A.load('/tmp/lambda_transform.json', nonserializable={'hflip_image': hflip})\n</pre> loaded_transform = A.load('/tmp/lambda_transform.json', nonserializable={'hflip_image': hflip}) In\u00a0[22]: Copied! <pre>print(loaded_transform)\n</pre> print(loaded_transform) <pre>Compose([\n  Lambda(name='hflip_image', image=&lt;function hflip_image at 0x2a7e34d30&gt;, mask=&lt;function noop at 0x13a7c0d30&gt;, keypoint=&lt;function noop at 0x13a7c0d30&gt;, bbox=&lt;function noop at 0x13a7c0d30&gt;, always_apply=False, p=0.5),\n], p=1.0, bbox_params=None, keypoint_params=None, additional_targets={}, is_check_shapes=True)\n</pre> <p>Verify that the deserialized pipeline produces the same output.</p> In\u00a0[23]: Copied! <pre>random.seed(7)\ntransformed_from_loaded_transform = loaded_transform(image=image)\nassert np.array_equal(transformed['image'], transformed_from_loaded_transform['image'])\n</pre> random.seed(7) transformed_from_loaded_transform = loaded_transform(image=image) assert np.array_equal(transformed['image'], transformed_from_loaded_transform['image']) <p>To serialize and deserialize Lambda transforms to and from dictionaries use <code>to_dict</code> and <code>from_dict</code>.</p> In\u00a0[24]: Copied! <pre>transform_dict = A.to_dict(transform)\nprint(transform_dict)\n</pre> transform_dict = A.to_dict(transform) print(transform_dict) <pre>{'__version__': '1.4.0', 'transform': {'__class_fullname__': 'Compose', 'p': 1.0, 'transforms': [{'__class_fullname__': 'Lambda', '__name__': 'hflip_image'}], 'bbox_params': None, 'keypoint_params': None, 'additional_targets': {}, 'is_check_shapes': True}}\n</pre> In\u00a0[26]: Copied! <pre>loaded_transform = A.from_dict(transform_dict, nonserializable={'hflip_image': hflip})\n</pre> loaded_transform = A.from_dict(transform_dict, nonserializable={'hflip_image': hflip})"},{"location":"examples/serialization/#how-to-save-and-load-parameters-of-an-augmentation-pipeline","title":"How to save and load parameters of an augmentation pipeline\u00b6","text":""},{"location":"examples/serialization/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/serialization/#define-the-visualization-function","title":"Define the visualization function\u00b6","text":""},{"location":"examples/serialization/#load-an-image-from-the-disk","title":"Load an image from the disk\u00b6","text":""},{"location":"examples/serialization/#define-an-augmentation-pipeline-that-we-want-to-serialize","title":"Define an augmentation pipeline that we want to serialize\u00b6","text":""},{"location":"examples/serialization/#serializing-an-augmentation-pipeline-to-a-json-or-yaml-file","title":"Serializing an augmentation pipeline to a JSON or YAML file\u00b6","text":""},{"location":"examples/serialization/#using-yaml-insted-of-json","title":"Using YAML insted of JSON\u00b6","text":""},{"location":"examples/serialization/#serializing-an-augmentation-pipeline-to-a-python-dictionary","title":"Serializing an augmentation pipeline to a Python dictionary\u00b6","text":""},{"location":"examples/serialization/#serializing-and-deserializing-lambda-transforms","title":"Serializing and deserializing Lambda transforms\u00b6","text":""},{"location":"examples/showcase/","title":"Showcase. Cool augmentation examples on diverse set of images from various real-world tasks.","text":"In\u00a0[1]: Copied! <pre>import os\nimport random\n\nimport albumentations as A\nimport cv2\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom skimage.color import label2rgb\n</pre> import os import random  import albumentations as A import cv2 import numpy as np from matplotlib import pyplot as plt from skimage.color import label2rgb In\u00a0[2]: Copied! <pre>BOX_COLOR = (255, 0, 0) # Red\nTEXT_COLOR = (255, 255, 255) # White\n\n\ndef visualize_bbox(img, bbox, color=BOX_COLOR, thickness=2, **kwargs):\n    x_min, y_min, w, h = bbox\n    x_min, x_max, y_min, y_max = int(x_min), int(x_min + w), int(y_min), int(y_min + h)\n    cv2.rectangle(img, (x_min, y_min), (x_max, y_max), color=color, thickness=thickness)\n    return img\n\ndef visualize_titles(img, bbox, title, font_thickness = 2, font_scale=0.35, **kwargs):\n    x_min, y_min = bbox[:2]\n    x_min = int(x_min)\n    y_min = int(y_min)\n    ((text_width, text_height), _) = cv2.getTextSize(title, cv2.FONT_HERSHEY_SIMPLEX, font_scale, font_thickness)\n    cv2.rectangle(img, (x_min, y_min - int(1.3 * text_height)), (x_min + text_width, y_min), BOX_COLOR, -1)\n    cv2.putText(img, title, (x_min, y_min - int(0.3 * text_height)), cv2.FONT_HERSHEY_SIMPLEX, font_scale, TEXT_COLOR,\n                font_thickness, lineType=cv2.LINE_AA)\n    return img\n\n\ndef augment_and_show(aug, image, mask=None, bboxes=[], categories=[], category_id_to_name=[], filename=None,\n                     font_scale_orig=0.35, font_scale_aug=0.35, show_title=True, **kwargs):\n\n    if mask is None:\n        augmented = aug(image=image, bboxes=bboxes, category_ids=categories                       )\n    else:\n        augmented = aug(image=image, mask=mask, bboxes=bboxes, category_ids=categories)\n\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    image_aug = cv2.cvtColor(augmented['image'], cv2.COLOR_BGR2RGB)\n\n    for bbox in bboxes:\n        visualize_bbox(image, bbox, **kwargs)\n\n    for bbox in augmented['bboxes']:\n        visualize_bbox(image_aug, bbox, **kwargs)\n\n    if show_title:\n        for bbox,cat_id in zip(bboxes, categories):\n            visualize_titles(image, bbox, category_id_to_name[cat_id], font_scale=font_scale_orig, **kwargs)\n        for bbox,cat_id in zip(augmented['bboxes'], augmented['category_ids']):\n            visualize_titles(image_aug, bbox, category_id_to_name[cat_id], font_scale=font_scale_aug, **kwargs)\n\n\n    if mask is None:\n        f, ax = plt.subplots(1, 2, figsize=(16, 8))\n\n        ax[0].imshow(image)\n        ax[0].set_title('Original image')\n\n        ax[1].imshow(image_aug)\n        ax[1].set_title('Augmented image')\n    else:\n        f, ax = plt.subplots(2, 2, figsize=(16, 16))\n\n        if len(mask.shape) != 3:\n            mask = label2rgb(mask, bg_label=0)\n            mask_aug = label2rgb(augmented['mask'], bg_label=0)\n        else:\n            mask = cv2.cvtColor(mask, cv2.COLOR_BGR2RGB)\n            mask_aug = cv2.cvtColor(augmented['mask'], cv2.COLOR_BGR2RGB)\n\n        ax[0, 0].imshow(image)\n        ax[0, 0].set_title('Original image')\n\n        ax[0, 1].imshow(image_aug)\n        ax[0, 1].set_title('Augmented image')\n\n        ax[1, 0].imshow(mask, interpolation='nearest')\n        ax[1, 0].set_title('Original mask')\n\n        ax[1, 1].imshow(mask_aug, interpolation='nearest')\n        ax[1, 1].set_title('Augmented mask')\n\n    f.tight_layout()\n\n    if filename is not None:\n        f.savefig(filename)\n\n    if mask is None:\n        return augmented['image'], None, augmented['bboxes']\n\n    return augmented['image'], augmented['mask'], augmented['bboxes']\n\ndef find_in_dir(dirname):\n    return [os.path.join(dirname, fname) for fname in sorted(os.listdir(dirname))]\n</pre> BOX_COLOR = (255, 0, 0) # Red TEXT_COLOR = (255, 255, 255) # White   def visualize_bbox(img, bbox, color=BOX_COLOR, thickness=2, **kwargs):     x_min, y_min, w, h = bbox     x_min, x_max, y_min, y_max = int(x_min), int(x_min + w), int(y_min), int(y_min + h)     cv2.rectangle(img, (x_min, y_min), (x_max, y_max), color=color, thickness=thickness)     return img  def visualize_titles(img, bbox, title, font_thickness = 2, font_scale=0.35, **kwargs):     x_min, y_min = bbox[:2]     x_min = int(x_min)     y_min = int(y_min)     ((text_width, text_height), _) = cv2.getTextSize(title, cv2.FONT_HERSHEY_SIMPLEX, font_scale, font_thickness)     cv2.rectangle(img, (x_min, y_min - int(1.3 * text_height)), (x_min + text_width, y_min), BOX_COLOR, -1)     cv2.putText(img, title, (x_min, y_min - int(0.3 * text_height)), cv2.FONT_HERSHEY_SIMPLEX, font_scale, TEXT_COLOR,                 font_thickness, lineType=cv2.LINE_AA)     return img   def augment_and_show(aug, image, mask=None, bboxes=[], categories=[], category_id_to_name=[], filename=None,                      font_scale_orig=0.35, font_scale_aug=0.35, show_title=True, **kwargs):      if mask is None:         augmented = aug(image=image, bboxes=bboxes, category_ids=categories                       )     else:         augmented = aug(image=image, mask=mask, bboxes=bboxes, category_ids=categories)      image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)     image_aug = cv2.cvtColor(augmented['image'], cv2.COLOR_BGR2RGB)      for bbox in bboxes:         visualize_bbox(image, bbox, **kwargs)      for bbox in augmented['bboxes']:         visualize_bbox(image_aug, bbox, **kwargs)      if show_title:         for bbox,cat_id in zip(bboxes, categories):             visualize_titles(image, bbox, category_id_to_name[cat_id], font_scale=font_scale_orig, **kwargs)         for bbox,cat_id in zip(augmented['bboxes'], augmented['category_ids']):             visualize_titles(image_aug, bbox, category_id_to_name[cat_id], font_scale=font_scale_aug, **kwargs)       if mask is None:         f, ax = plt.subplots(1, 2, figsize=(16, 8))          ax[0].imshow(image)         ax[0].set_title('Original image')          ax[1].imshow(image_aug)         ax[1].set_title('Augmented image')     else:         f, ax = plt.subplots(2, 2, figsize=(16, 16))          if len(mask.shape) != 3:             mask = label2rgb(mask, bg_label=0)             mask_aug = label2rgb(augmented['mask'], bg_label=0)         else:             mask = cv2.cvtColor(mask, cv2.COLOR_BGR2RGB)             mask_aug = cv2.cvtColor(augmented['mask'], cv2.COLOR_BGR2RGB)          ax[0, 0].imshow(image)         ax[0, 0].set_title('Original image')          ax[0, 1].imshow(image_aug)         ax[0, 1].set_title('Augmented image')          ax[1, 0].imshow(mask, interpolation='nearest')         ax[1, 0].set_title('Original mask')          ax[1, 1].imshow(mask_aug, interpolation='nearest')         ax[1, 1].set_title('Augmented mask')      f.tight_layout()      if filename is not None:         f.savefig(filename)      if mask is None:         return augmented['image'], None, augmented['bboxes']      return augmented['image'], augmented['mask'], augmented['bboxes']  def find_in_dir(dirname):     return [os.path.join(dirname, fname) for fname in sorted(os.listdir(dirname))] In\u00a0[3]: Copied! <pre>image = cv2.imread('images/parrot.jpg')\n</pre> image = cv2.imread('images/parrot.jpg') In\u00a0[4]: Copied! <pre>random.seed(42)\n\nbbox_params = A.BboxParams(format='coco', label_fields=['category_ids'])\n\nlight = A.Compose([\n    A.RandomBrightnessContrast(p=1),\n    A.RandomGamma(p=1),\n    A.CLAHE(p=1),\n], p=1, bbox_params=bbox_params)\n\nmedium = A.Compose([\n    A.CLAHE(p=1),\n    A.HueSaturationValue(hue_shift_limit=20, sat_shift_limit=50, val_shift_limit=50, p=1),\n], p=1, bbox_params=bbox_params)\n\n\nstrong = A.Compose([\n    A.RGBShift(p=1),\n     A.Blur(p=1),\n     A.GaussNoise(p=1),\n     A.ElasticTransform(p=1),\n], p=1, bbox_params=bbox_params)\n</pre> random.seed(42)  bbox_params = A.BboxParams(format='coco', label_fields=['category_ids'])  light = A.Compose([     A.RandomBrightnessContrast(p=1),     A.RandomGamma(p=1),     A.CLAHE(p=1), ], p=1, bbox_params=bbox_params)  medium = A.Compose([     A.CLAHE(p=1),     A.HueSaturationValue(hue_shift_limit=20, sat_shift_limit=50, val_shift_limit=50, p=1), ], p=1, bbox_params=bbox_params)   strong = A.Compose([     A.RGBShift(p=1),      A.Blur(p=1),      A.GaussNoise(p=1),      A.ElasticTransform(p=1), ], p=1, bbox_params=bbox_params) In\u00a0[5]: Copied! <pre>r = augment_and_show(light, image)\n</pre> r = augment_and_show(light, image) In\u00a0[6]: Copied! <pre>r = augment_and_show(medium, image)\n</pre> r = augment_and_show(medium, image) In\u00a0[7]: Copied! <pre>r = augment_and_show(strong, image)\n</pre> r = augment_and_show(strong, image) In\u00a0[8]: Copied! <pre>random.seed(42)\n\nimage, mask = cv2.imread('images/inria/inria_tyrol_w4_image.jpg'), cv2.imread('images/inria/inria_tyrol_w4_mask.tif', cv2.IMREAD_GRAYSCALE)\nimage, mask = image[:1024, :1024], mask[:1024,:1024]\n\nlight = A.Compose([\n     A.RandomSizedCrop((512-100, 512+100), 512, 512),\n     A.ShiftScaleRotate(),\n     A.RGBShift(),\n     A.Blur(),\n     A.GaussNoise(),\n     A.ElasticTransform(),\n     A.MaskDropout((10,15), p=1),\n], p=1, bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']))\n\nr = augment_and_show(light, image, mask)\n</pre> random.seed(42)  image, mask = cv2.imread('images/inria/inria_tyrol_w4_image.jpg'), cv2.imread('images/inria/inria_tyrol_w4_mask.tif', cv2.IMREAD_GRAYSCALE) image, mask = image[:1024, :1024], mask[:1024,:1024]  light = A.Compose([      A.RandomSizedCrop((512-100, 512+100), 512, 512),      A.ShiftScaleRotate(),      A.RGBShift(),      A.Blur(),      A.GaussNoise(),      A.ElasticTransform(),      A.MaskDropout((10,15), p=1), ], p=1, bbox_params=A.BboxParams(format='coco', label_fields=['category_ids']))  r = augment_and_show(light, image, mask) In\u00a0[9]: Copied! <pre>random.seed(42)\n\nimage = cv2.imread(\n    'images/dsb2018/1a11552569160f0b1ea10bedbd628ce6c14f29edec5092034c2309c556df833e/images/1a11552569160f0b1ea10bedbd628ce6c14f29edec5092034c2309c556df833e.png')\nmasks = [cv2.imread(x, cv2.IMREAD_GRAYSCALE) for x in\n         find_in_dir('images/dsb2018/1a11552569160f0b1ea10bedbd628ce6c14f29edec5092034c2309c556df833e/masks')]\nbboxes = [cv2.boundingRect(cv2.findNonZero(mask)) for mask in masks]\nlabel_image = np.zeros_like(masks[0])\nfor i, mask in enumerate(masks):\n    label_image += (mask &gt; 0).astype(np.uint8) * i\n\nlight = A.Compose([\n    A.RGBShift(),\n    A.InvertImg(),\n    A.Blur(),\n    A.GaussNoise(),\n    A.Flip(),\n    A.RandomRotate90(),\n    A.RandomSizedCrop((512 - 100, 512 + 100), 512, 512),\n], bbox_params={'format':'coco', 'min_area': 1, 'min_visibility': 0.5, 'label_fields': ['category_ids']}, p=1)\n\nlabel_ids = [0] * len(bboxes)\nlabel_names = ['Nuclei']\n\nr = augment_and_show(light, image, label_image, bboxes, label_ids, label_names, show_title=False)\n</pre> random.seed(42)  image = cv2.imread(     'images/dsb2018/1a11552569160f0b1ea10bedbd628ce6c14f29edec5092034c2309c556df833e/images/1a11552569160f0b1ea10bedbd628ce6c14f29edec5092034c2309c556df833e.png') masks = [cv2.imread(x, cv2.IMREAD_GRAYSCALE) for x in          find_in_dir('images/dsb2018/1a11552569160f0b1ea10bedbd628ce6c14f29edec5092034c2309c556df833e/masks')] bboxes = [cv2.boundingRect(cv2.findNonZero(mask)) for mask in masks] label_image = np.zeros_like(masks[0]) for i, mask in enumerate(masks):     label_image += (mask &gt; 0).astype(np.uint8) * i  light = A.Compose([     A.RGBShift(),     A.InvertImg(),     A.Blur(),     A.GaussNoise(),     A.Flip(),     A.RandomRotate90(),     A.RandomSizedCrop((512 - 100, 512 + 100), 512, 512), ], bbox_params={'format':'coco', 'min_area': 1, 'min_visibility': 0.5, 'label_fields': ['category_ids']}, p=1)  label_ids = [0] * len(bboxes) label_names = ['Nuclei']  r = augment_and_show(light, image, label_image, bboxes, label_ids, label_names, show_title=False)  In\u00a0[10]: Copied! <pre>from PIL import Image\n\nimage = cv2.imread('images/vistas/_HnWguqEbRCphUquTMrCCA.jpg')\nlabels = cv2.imread('images/vistas/_HnWguqEbRCphUquTMrCCA_labels.png', cv2.IMREAD_COLOR)\ninstances = np.array(Image.open('images/vistas/_HnWguqEbRCphUquTMrCCA_instances.png'),dtype=np.uint16)\nIGNORED = 65 * 256\n\ninstances[(instances//256 != 55) &amp; (instances//256 != 44) &amp; (instances//256 != 50)] = IGNORED\n\nimage = image[1000:2500, 1000:2500]\nlabels = labels[1000:2500, 1000:2500]\ninstances = instances[1000:2500, 1000:2500]\n\nbboxes = [cv2.boundingRect(cv2.findNonZero((instances == instance_id).astype(np.uint8))) for instance_id in np.unique(instances) if instance_id != IGNORED]\ninstance_labels = [instance_id // 256 for instance_id in np.unique(instances) if instance_id != IGNORED]\n\ntitles = [\"Bird\",\n\"Ground Animal\",\n\"Curb\",\n\"Fence\",\n\"Guard Rail\",\n\"Barrier\",\n\"Wall\",\n\"Bike Lane\",\n\"Crosswalk - Plain\",\n\"Curb Cut\",\n\"Parking\",\n\"Pedestrian Area\",\n\"Rail Track\",\n\"Road\",\n\"Service Lane\",\n\"Sidewalk\",\n\"Bridge\",\n\"Building\",\n\"Tunnel\",\n\"Person\",\n\"Bicyclist\",\n\"Motorcyclist\",\n\"Other Rider\",\n\"Lane Marking - Crosswalk\",\n\"Lane Marking - General\",\n\"Mountain\",\n\"Sand\",\n\"Sky\",\n\"Snow\",\n\"Terrain\",\n\"Vegetation\",\n\"Water\",\n\"Banner\",\n\"Bench\",\n\"Bike Rack\",\n\"Billboard\",\n\"Catch Basin\",\n\"CCTV Camera\",\n\"Fire Hydrant\",\n\"Junction Box\",\n\"Mailbox\",\n\"Manhole\",\n\"Phone Booth\",\n\"Pothole\",\n\"Street Light\",\n\"Pole\",\n\"Traffic Sign Frame\",\n\"Utility Pole\",\n\"Traffic Light\",\n\"Traffic Sign (Back)\",\n\"Traffic Sign (Front)\",\n\"Trash Can\",\n\"Bicycle\",\n\"Boat\",\n\"Bus\",\n\"Car\",\n\"Caravan\",\n\"Motorcycle\",\n\"On Rails\",\n\"Other Vehicle\",\n\"Trailer\",\n\"Truck\",\n\"Wheeled Slow\",\n\"Car Mount\",\n\"Ego Vehicle\",\n\"Unlabeled\"]\nbbox_params = A.BboxParams(format='coco', min_area=1, min_visibility=0.5, label_fields=['category_ids'])\n\nlight = A.Compose([\n    A.HorizontalFlip(p=1),\n    A.RandomSizedCrop((800 - 100, 800 + 100), 600, 600),\n    A.GaussNoise(var_limit=(100, 150), p=1),\n], bbox_params=bbox_params,  p=1)\n\nmedium = A.Compose([\n    A.HorizontalFlip(p=1),\n    A.RandomSizedCrop((800 - 100, 800 + 100), 600, 600),\n    A.MotionBlur(blur_limit=17, p=1),\n], bbox_params=bbox_params, p=1)\n\n\nstrong = A.Compose([\n    A.HorizontalFlip(p=1),\n    A.RandomSizedCrop((800 - 100, 800 + 100), 600, 600),\n    A.RGBShift(p=1),\n    A.Blur(blur_limit=11, p=1),\n    A.RandomBrightnessContrast(p=1),\n    A.CLAHE(p=1),\n], bbox_params=bbox_params, p=1)\n</pre> from PIL import Image  image = cv2.imread('images/vistas/_HnWguqEbRCphUquTMrCCA.jpg') labels = cv2.imread('images/vistas/_HnWguqEbRCphUquTMrCCA_labels.png', cv2.IMREAD_COLOR) instances = np.array(Image.open('images/vistas/_HnWguqEbRCphUquTMrCCA_instances.png'),dtype=np.uint16) IGNORED = 65 * 256  instances[(instances//256 != 55) &amp; (instances//256 != 44) &amp; (instances//256 != 50)] = IGNORED  image = image[1000:2500, 1000:2500] labels = labels[1000:2500, 1000:2500] instances = instances[1000:2500, 1000:2500]  bboxes = [cv2.boundingRect(cv2.findNonZero((instances == instance_id).astype(np.uint8))) for instance_id in np.unique(instances) if instance_id != IGNORED] instance_labels = [instance_id // 256 for instance_id in np.unique(instances) if instance_id != IGNORED]  titles = [\"Bird\", \"Ground Animal\", \"Curb\", \"Fence\", \"Guard Rail\", \"Barrier\", \"Wall\", \"Bike Lane\", \"Crosswalk - Plain\", \"Curb Cut\", \"Parking\", \"Pedestrian Area\", \"Rail Track\", \"Road\", \"Service Lane\", \"Sidewalk\", \"Bridge\", \"Building\", \"Tunnel\", \"Person\", \"Bicyclist\", \"Motorcyclist\", \"Other Rider\", \"Lane Marking - Crosswalk\", \"Lane Marking - General\", \"Mountain\", \"Sand\", \"Sky\", \"Snow\", \"Terrain\", \"Vegetation\", \"Water\", \"Banner\", \"Bench\", \"Bike Rack\", \"Billboard\", \"Catch Basin\", \"CCTV Camera\", \"Fire Hydrant\", \"Junction Box\", \"Mailbox\", \"Manhole\", \"Phone Booth\", \"Pothole\", \"Street Light\", \"Pole\", \"Traffic Sign Frame\", \"Utility Pole\", \"Traffic Light\", \"Traffic Sign (Back)\", \"Traffic Sign (Front)\", \"Trash Can\", \"Bicycle\", \"Boat\", \"Bus\", \"Car\", \"Caravan\", \"Motorcycle\", \"On Rails\", \"Other Vehicle\", \"Trailer\", \"Truck\", \"Wheeled Slow\", \"Car Mount\", \"Ego Vehicle\", \"Unlabeled\"] bbox_params = A.BboxParams(format='coco', min_area=1, min_visibility=0.5, label_fields=['category_ids'])  light = A.Compose([     A.HorizontalFlip(p=1),     A.RandomSizedCrop((800 - 100, 800 + 100), 600, 600),     A.GaussNoise(var_limit=(100, 150), p=1), ], bbox_params=bbox_params,  p=1)  medium = A.Compose([     A.HorizontalFlip(p=1),     A.RandomSizedCrop((800 - 100, 800 + 100), 600, 600),     A.MotionBlur(blur_limit=17, p=1), ], bbox_params=bbox_params, p=1)   strong = A.Compose([     A.HorizontalFlip(p=1),     A.RandomSizedCrop((800 - 100, 800 + 100), 600, 600),     A.RGBShift(p=1),     A.Blur(blur_limit=11, p=1),     A.RandomBrightnessContrast(p=1),     A.CLAHE(p=1), ], bbox_params=bbox_params, p=1) In\u00a0[11]: Copied! <pre>random.seed(13)\nr = augment_and_show(light, image, labels, bboxes, instance_labels, titles, thickness=2,\n                     font_scale_orig=2,\n                     font_scale_aug=1)\n</pre> random.seed(13) r = augment_and_show(light, image, labels, bboxes, instance_labels, titles, thickness=2,                      font_scale_orig=2,                      font_scale_aug=1) In\u00a0[12]: Copied! <pre>random.seed(13)\nr = augment_and_show(medium, image, labels, bboxes, instance_labels, titles, thickness=2, font_scale_orig=2, font_scale_aug=1)\n</pre> random.seed(13) r = augment_and_show(medium, image, labels, bboxes, instance_labels, titles, thickness=2, font_scale_orig=2, font_scale_aug=1) In\u00a0[13]: Copied! <pre>random.seed(13)\nr = augment_and_show(strong, image, labels, bboxes, instance_labels, titles, thickness=2, font_scale_orig=2, font_scale_aug=1)\n</pre> random.seed(13) r = augment_and_show(strong, image, labels, bboxes, instance_labels, titles, thickness=2, font_scale_orig=2, font_scale_aug=1)"},{"location":"examples/showcase/#showcase-cool-augmentation-examples-on-diverse-set-of-images-from-various-real-world-tasks","title":"Showcase. Cool augmentation examples on diverse set of images from various real-world tasks.\u00b6","text":""},{"location":"examples/showcase/#import-libraries-and-define-helper-functions","title":"Import libraries and define helper functions\u00b6","text":""},{"location":"examples/showcase/#import-the-required-libraries","title":"Import the required libraries\u00b6","text":""},{"location":"examples/showcase/#define-visualization-functions","title":"Define visualization functions\u00b6","text":""},{"location":"examples/showcase/#color-augmentations","title":"Color augmentations\u00b6","text":""},{"location":"examples/showcase/#inria-aerial-image-labeling-dataset","title":"Inria Aerial Image Labeling Dataset\u00b6","text":""},{"location":"examples/showcase/#2018-data-science-bowl","title":"2018 Data Science Bowl\u00b6","text":""},{"location":"examples/showcase/#mapilary-vistas","title":"Mapilary Vistas\u00b6","text":""},{"location":"examples/tensorflow-example/","title":"Using Albumentations with Tensorflow","text":"<p>Author: Ayushman Buragohain</p> In\u00a0[26]: Copied! <pre>!pip install -q -U albumentations\n!echo \"$(pip freeze | grep albumentations) is successfully installed\"\n</pre> !pip install -q -U albumentations !echo \"$(pip freeze | grep albumentations) is successfully installed\" <pre>albumentations==1.4.0 is successfully installed\n</pre> In\u00a0[27]: Copied! <pre>! pip install --upgrade tensorflow_datasets tensorflow\n</pre> ! pip install --upgrade tensorflow_datasets tensorflow <pre>Requirement already satisfied: tensorflow_datasets in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (4.9.4)\nRequirement already satisfied: tensorflow in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (2.15.0)\nRequirement already satisfied: absl-py in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (1.4.0)\nRequirement already satisfied: click in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (8.1.7)\nRequirement already satisfied: dm-tree in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (0.1.8)\nRequirement already satisfied: etils&gt;=0.9.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from etils[enp,epath,etree]&gt;=0.9.0-&gt;tensorflow_datasets) (1.7.0)\nRequirement already satisfied: numpy in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (1.26.4)\nRequirement already satisfied: promise in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (2.3)\nRequirement already satisfied: protobuf&gt;=3.20 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (3.20.3)\nRequirement already satisfied: psutil in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (5.9.0)\nRequirement already satisfied: requests&gt;=2.19.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (2.31.0)\nRequirement already satisfied: tensorflow-metadata in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (1.14.0)\nRequirement already satisfied: termcolor in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (2.4.0)\nRequirement already satisfied: toml in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (0.10.2)\nRequirement already satisfied: tqdm in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (4.66.2)\nRequirement already satisfied: wrapt in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow_datasets) (1.14.1)\nRequirement already satisfied: tensorflow-macos==2.15.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow) (2.15.0)\nRequirement already satisfied: astunparse&gt;=1.6.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (1.6.3)\nRequirement already satisfied: flatbuffers&gt;=23.5.26 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (23.5.26)\nRequirement already satisfied: gast!=0.5.0,!=0.5.1,!=0.5.2,&gt;=0.2.1 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (0.5.4)\nRequirement already satisfied: google-pasta&gt;=0.1.1 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (0.2.0)\nRequirement already satisfied: h5py&gt;=2.9.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (3.10.0)\nRequirement already satisfied: libclang&gt;=13.0.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (16.0.6)\nRequirement already satisfied: ml-dtypes~=0.2.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (0.2.0)\nRequirement already satisfied: opt-einsum&gt;=2.3.2 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (3.3.0)\nRequirement already satisfied: packaging in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (23.2)\nRequirement already satisfied: setuptools in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (68.2.2)\nRequirement already satisfied: six&gt;=1.12.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (1.16.0)\nRequirement already satisfied: typing-extensions&gt;=3.6.6 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (4.9.0)\nRequirement already satisfied: tensorflow-io-gcs-filesystem&gt;=0.23.1 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (0.36.0)\nRequirement already satisfied: grpcio&lt;2.0,&gt;=1.24.3 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (1.60.1)\nRequirement already satisfied: tensorboard&lt;2.16,&gt;=2.15 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (2.15.2)\nRequirement already satisfied: tensorflow-estimator&lt;2.16,&gt;=2.15.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (2.15.0)\nRequirement already satisfied: keras&lt;2.16,&gt;=2.15.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-macos==2.15.0-&gt;tensorflow) (2.15.0)\nRequirement already satisfied: fsspec in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from etils[enp,epath,etree]&gt;=0.9.0-&gt;tensorflow_datasets) (2024.2.0)\nRequirement already satisfied: importlib_resources in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from etils[enp,epath,etree]&gt;=0.9.0-&gt;tensorflow_datasets) (6.1.1)\nRequirement already satisfied: zipp in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from etils[enp,epath,etree]&gt;=0.9.0-&gt;tensorflow_datasets) (3.17.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from requests&gt;=2.19.0-&gt;tensorflow_datasets) (3.3.2)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from requests&gt;=2.19.0-&gt;tensorflow_datasets) (3.6)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from requests&gt;=2.19.0-&gt;tensorflow_datasets) (2.2.0)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from requests&gt;=2.19.0-&gt;tensorflow_datasets) (2024.2.2)\nRequirement already satisfied: googleapis-common-protos&lt;2,&gt;=1.52.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorflow-metadata-&gt;tensorflow_datasets) (1.62.0)\nRequirement already satisfied: wheel&lt;1.0,&gt;=0.23.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from astunparse&gt;=1.6.0-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (0.41.2)\nRequirement already satisfied: google-auth&lt;3,&gt;=1.6.3 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (2.28.0)\nRequirement already satisfied: google-auth-oauthlib&lt;2,&gt;=0.5 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (1.2.0)\nRequirement already satisfied: markdown&gt;=2.6.8 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (3.5.2)\nRequirement already satisfied: tensorboard-data-server&lt;0.8.0,&gt;=0.7.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (0.7.2)\nRequirement already satisfied: werkzeug&gt;=1.0.1 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (3.0.1)\nRequirement already satisfied: cachetools&lt;6.0,&gt;=2.0.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from google-auth&lt;3,&gt;=1.6.3-&gt;tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (5.3.2)\nRequirement already satisfied: pyasn1-modules&gt;=0.2.1 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from google-auth&lt;3,&gt;=1.6.3-&gt;tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (0.3.0)\nRequirement already satisfied: rsa&lt;5,&gt;=3.1.4 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from google-auth&lt;3,&gt;=1.6.3-&gt;tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (4.9)\nRequirement already satisfied: requests-oauthlib&gt;=0.7.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from google-auth-oauthlib&lt;2,&gt;=0.5-&gt;tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (1.3.1)\nRequirement already satisfied: MarkupSafe&gt;=2.1.1 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from werkzeug&gt;=1.0.1-&gt;tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (2.1.5)\nRequirement already satisfied: pyasn1&lt;0.6.0,&gt;=0.4.6 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from pyasn1-modules&gt;=0.2.1-&gt;google-auth&lt;3,&gt;=1.6.3-&gt;tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (0.5.1)\nRequirement already satisfied: oauthlib&gt;=3.0.0 in /Users/vladimiriglovikov/anaconda3/envs/albumentations_examples/lib/python3.10/site-packages (from requests-oauthlib&gt;=0.7.0-&gt;google-auth-oauthlib&lt;2,&gt;=0.5-&gt;tensorboard&lt;2.16,&gt;=2.15-&gt;tensorflow-macos==2.15.0-&gt;tensorflow) (3.2.2)\n</pre> In\u00a0[28]: Copied! <pre># necessary imports\nimport tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport tensorflow_datasets as tfds\nfrom functools import partial\nimport albumentations as A\n\nAUTOTUNE = tf.data.experimental.AUTOTUNE\n</pre> # necessary imports import tensorflow as tf import numpy as np import matplotlib.pyplot as plt import tensorflow_datasets as tfds from functools import partial import albumentations as A  AUTOTUNE = tf.data.experimental.AUTOTUNE In\u00a0[29]: Copied! <pre>tfds.__version__\n</pre> tfds.__version__ Out[29]: <pre>'4.9.4'</pre> In\u00a0[30]: Copied! <pre># load in the tf_flowers dataset\ndata, info= tfds.load(name=\"tf_flowers\", split=\"train\", as_supervised=True, with_info=True)\ndata\n</pre> # load in the tf_flowers dataset data, info= tfds.load(name=\"tf_flowers\", split=\"train\", as_supervised=True, with_info=True) data Out[30]: <pre>&lt;_PrefetchDataset element_spec=(TensorSpec(shape=(None, None, 3), dtype=tf.uint8, name=None), TensorSpec(shape=(), dtype=tf.int64, name=None))&gt;</pre> In\u00a0[31]: Copied! <pre>info\n</pre> info Out[31]: <pre>tfds.core.DatasetInfo(\n    name='tf_flowers',\n    full_name='tf_flowers/3.0.1',\n    description=\"\"\"\n    A large set of images of flowers\n    \"\"\",\n    homepage='https://www.tensorflow.org/tutorials/load_data/images',\n    data_dir='/Users/vladimiriglovikov/tensorflow_datasets/tf_flowers/3.0.1',\n    file_format=tfrecord,\n    download_size=218.21 MiB,\n    dataset_size=221.83 MiB,\n    features=FeaturesDict({\n        'image': Image(shape=(None, None, 3), dtype=uint8),\n        'label': ClassLabel(shape=(), dtype=int64, num_classes=5),\n    }),\n    supervised_keys=('image', 'label'),\n    disable_shuffling=False,\n    splits={\n        'train': &lt;SplitInfo num_examples=3670, num_shards=2&gt;,\n    },\n    citation=\"\"\"@ONLINE {tfflowers,\n    author = \"The TensorFlow Team\",\n    title = \"Flowers\",\n    month = \"jan\",\n    year = \"2019\",\n    url = \"http://download.tensorflow.org/example_images/flower_photos.tgz\" }\"\"\",\n)</pre> In\u00a0[32]: Copied! <pre>def process_image(image, label, img_size):\n    # cast and normalize image\n    image = tf.image.convert_image_dtype(image, tf.float32)\n    # apply simple augmentations\n    image = tf.image.random_flip_left_right(image)\n    image = tf.image.resize(image,[img_size, img_size])\n    return image, label\n\nds_tf = data.map(partial(process_image, img_size=120), num_parallel_calls=AUTOTUNE).batch(30).prefetch(AUTOTUNE)\nds_tf\n</pre> def process_image(image, label, img_size):     # cast and normalize image     image = tf.image.convert_image_dtype(image, tf.float32)     # apply simple augmentations     image = tf.image.random_flip_left_right(image)     image = tf.image.resize(image,[img_size, img_size])     return image, label  ds_tf = data.map(partial(process_image, img_size=120), num_parallel_calls=AUTOTUNE).batch(30).prefetch(AUTOTUNE) ds_tf Out[32]: <pre>&lt;_PrefetchDataset element_spec=(TensorSpec(shape=(None, 120, 120, 3), dtype=tf.float32, name=None), TensorSpec(shape=(None,), dtype=tf.int64, name=None))&gt;</pre> In\u00a0[33]: Copied! <pre>def view_image(ds):\n    image, label = next(iter(ds)) # extract 1 batch from the dataset\n    image = image.numpy()\n    label = label.numpy()\n\n    fig = plt.figure(figsize=(22, 22))\n    for i in range(20):\n        ax = fig.add_subplot(4, 5, i+1, xticks=[], yticks=[])\n        ax.imshow(image[i])\n        ax.set_title(f\"Label: {label[i]}\")\n</pre> def view_image(ds):     image, label = next(iter(ds)) # extract 1 batch from the dataset     image = image.numpy()     label = label.numpy()      fig = plt.figure(figsize=(22, 22))     for i in range(20):         ax = fig.add_subplot(4, 5, i+1, xticks=[], yticks=[])         ax.imshow(image[i])         ax.set_title(f\"Label: {label[i]}\") In\u00a0[34]: Copied! <pre>view_image(ds_tf)\n</pre> view_image(ds_tf) <pre>2024-02-18 14:57:07.678378: W tensorflow/core/kernels/data/cache_dataset_ops.cc:858] The calling iterator did not fully read the dataset being cached. In order to avoid unexpected truncation of the dataset, the partially cached contents of the dataset  will be discarded. This can happen if you have an input pipeline similar to `dataset.cache().take(k).repeat()`. You should use `dataset.take(k).cache().repeat()` instead.\n</pre> <p>Using <code>tf.image</code> is very efficient to create a pipeline but the disadvantage is that with <code>tf.image</code> we can only apply limited amounts of augmentations to our <code>input data</code>. One way to solve is issue is to use <code>tf.keras</code> <code>ImageDataGenerator</code> class but <code>albumentations</code> is faster.</p> <p>To integrate <code>albumentations</code> into our tensorflow pipeline we can create two functions :</p> <ul> <li>Pipeline to apply <code>augmentation</code>.</li> <li>a function that calls the above function and pass in our data through the pipeline. We can then wrap our 2nd Function under <code>tf.numpy_function</code> .</li> </ul> <p>italicized text## Create Pipeline to Process data</p> In\u00a0[35]: Copied! <pre># Instantiate augments\n# we can apply as many augments we want and adjust the values accordingly\n# here I have chosen the augments and their arguments at random\ntransforms = A.Compose([\n            A.Rotate(limit=40),\n            A.RandomBrightnessContrast(brightness_limit=0.1, contrast_limit=0.1, p=0.5),\n            A.HueSaturationValue(hue_shift_limit=20, sat_shift_limit=30, val_shift_limit=20, p=0.5),\n            A.HorizontalFlip(),\n        ])\n</pre> # Instantiate augments # we can apply as many augments we want and adjust the values accordingly # here I have chosen the augments and their arguments at random transforms = A.Compose([             A.Rotate(limit=40),             A.RandomBrightnessContrast(brightness_limit=0.1, contrast_limit=0.1, p=0.5),             A.HueSaturationValue(hue_shift_limit=20, sat_shift_limit=30, val_shift_limit=20, p=0.5),             A.HorizontalFlip(),         ]) In\u00a0[36]: Copied! <pre>def aug_fn(image, img_size):\n    data = {\"image\":image}\n    aug_data = transforms(**data)\n    aug_img = aug_data[\"image\"]\n    aug_img = tf.cast(aug_img/255.0, tf.float32)\n    return tf.image.resize(aug_img, size=[img_size, img_size])\n</pre> def aug_fn(image, img_size):     data = {\"image\":image}     aug_data = transforms(**data)     aug_img = aug_data[\"image\"]     aug_img = tf.cast(aug_img/255.0, tf.float32)     return tf.image.resize(aug_img, size=[img_size, img_size]) In\u00a0[37]: Copied! <pre>def process_data(image, label, img_size):\n    aug_img = tf.numpy_function(func=aug_fn, inp=[image, img_size], Tout=tf.float32)\n    return aug_img, label\n</pre> def process_data(image, label, img_size):     aug_img = tf.numpy_function(func=aug_fn, inp=[image, img_size], Tout=tf.float32)     return aug_img, label In\u00a0[38]: Copied! <pre># create dataset\nds_alb = data.map(partial(process_data, img_size=120),\n                  num_parallel_calls=AUTOTUNE).prefetch(AUTOTUNE)\nds_alb\n</pre> # create dataset ds_alb = data.map(partial(process_data, img_size=120),                   num_parallel_calls=AUTOTUNE).prefetch(AUTOTUNE) ds_alb Out[38]: <pre>&lt;_PrefetchDataset element_spec=(TensorSpec(shape=&lt;unknown&gt;, dtype=tf.float32, name=None), TensorSpec(shape=(), dtype=tf.int64, name=None))&gt;</pre> In\u00a0[39]: Copied! <pre>def set_shapes(img, label, img_shape=(120,120,3)):\n    img.set_shape(img_shape)\n    label.set_shape([])\n    return img, label\n</pre> def set_shapes(img, label, img_shape=(120,120,3)):     img.set_shape(img_shape)     label.set_shape([])     return img, label In\u00a0[40]: Copied! <pre>ds_alb = ds_alb.map(set_shapes, num_parallel_calls=AUTOTUNE).batch(32).prefetch(AUTOTUNE)\nds_alb\n</pre> ds_alb = ds_alb.map(set_shapes, num_parallel_calls=AUTOTUNE).batch(32).prefetch(AUTOTUNE) ds_alb Out[40]: <pre>&lt;_PrefetchDataset element_spec=(TensorSpec(shape=(None, 120, 120, 3), dtype=tf.float32, name=None), TensorSpec(shape=(None,), dtype=tf.int64, name=None))&gt;</pre> In\u00a0[41]: Copied! <pre>view_image(ds_alb)\n</pre> view_image(ds_alb) <pre>2024-02-18 14:57:09.800432: W tensorflow/core/kernels/data/cache_dataset_ops.cc:858] The calling iterator did not fully read the dataset being cached. In order to avoid unexpected truncation of the dataset, the partially cached contents of the dataset  will be discarded. This can happen if you have an input pipeline similar to `dataset.cache().take(k).repeat()`. You should use `dataset.take(k).cache().repeat()` instead.\n</pre> <p>We can then pass in this dataset to out model and call <code>fit</code> on our model</p> In\u00a0[42]: Copied! <pre>from tensorflow.keras import models, layers\nfrom tensorflow import keras\n\n# Running the Model in eager mode using Sequential API\n\ndef create_model(input_shape):\n    return models.Sequential([\n        layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),\n        layers.MaxPooling2D((2, 2)),\n        layers.Conv2D(64, (3, 3), activation='relu'),\n        layers.MaxPooling2D((2, 2)),\n        layers.Conv2D(64, (3, 3), activation='relu'),\n        layers.Flatten(),\n        layers.Dense(64, activation='relu'),\n        layers.Dense(5, activation='softmax')])\n\nmodel = create_model((120,120,3))\n\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy', run_eagerly=True)\nmodel.fit(ds_alb, epochs=2)\n</pre> from tensorflow.keras import models, layers from tensorflow import keras  # Running the Model in eager mode using Sequential API  def create_model(input_shape):     return models.Sequential([         layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),         layers.MaxPooling2D((2, 2)),         layers.Conv2D(64, (3, 3), activation='relu'),         layers.MaxPooling2D((2, 2)),         layers.Conv2D(64, (3, 3), activation='relu'),         layers.Flatten(),         layers.Dense(64, activation='relu'),         layers.Dense(5, activation='softmax')])  model = create_model((120,120,3))  model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy', run_eagerly=True) model.fit(ds_alb, epochs=2) <pre>Epoch 1/2\n115/115 [==============================] - 22s 190ms/step - loss: 1.3435 - accuracy: 0.4322\nEpoch 2/2\n115/115 [==============================] - 21s 180ms/step - loss: 1.1221 - accuracy: 0.5529\n</pre> Out[42]: <pre>&lt;keras.src.callbacks.History at 0x2d9f3b130&gt;</pre> In\u00a0[43]: Copied! <pre># Functional API\n\ninput = keras.Input(shape=(120, 120, 3))\nx = keras.layers.Conv2D(32, (3, 3), activation=\"relu\")(input)\nx = keras.layers.MaxPooling2D((2, 2))(x)\nx = keras.layers.Conv2D(64, (3, 3), activation='relu')(x)\nx = keras.layers.MaxPooling2D((2, 2))(x)\nx = keras.layers.Conv2D(64, (3, 3), activation='relu')(x)\nx = keras.layers.Flatten()(x)\nx = keras.layers.Dense(64, activation='relu')(x)\nx = keras.layers.Dense(5, activation='softmax')(x)\n\nmodel = keras.Model(inputs=input, outputs=x)\n\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')\nmodel.fit(ds_alb, epochs=2)\n</pre> # Functional API  input = keras.Input(shape=(120, 120, 3)) x = keras.layers.Conv2D(32, (3, 3), activation=\"relu\")(input) x = keras.layers.MaxPooling2D((2, 2))(x) x = keras.layers.Conv2D(64, (3, 3), activation='relu')(x) x = keras.layers.MaxPooling2D((2, 2))(x) x = keras.layers.Conv2D(64, (3, 3), activation='relu')(x) x = keras.layers.Flatten()(x) x = keras.layers.Dense(64, activation='relu')(x) x = keras.layers.Dense(5, activation='softmax')(x)  model = keras.Model(inputs=input, outputs=x)  model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy') model.fit(ds_alb, epochs=2) <pre>Epoch 1/2\n115/115 [==============================] - 12s 102ms/step - loss: 1.4318 - accuracy: 0.3807\nEpoch 2/2\n115/115 [==============================] - 12s 104ms/step - loss: 1.1839 - accuracy: 0.5183\n</pre> Out[43]: <pre>&lt;keras.src.callbacks.History at 0x2d9ee2d40&gt;</pre> In\u00a0[44]: Copied! <pre># Transfer Learning [freeze base model layers]: Sequential API\n\nbase_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\")\nbase_model.trainable = False\n\nmodel = keras.models.Sequential([\n        base_model,\n        keras.layers.Conv2D(32, (1, 1), activation=\"relu\"),\n        keras.layers.Dropout(0.2),\n        keras.layers.Flatten(),\n        keras.layers.Dense(64, activation='relu'),\n        keras.layers.Dense(5, activation='softmax'),\n])\n\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')\nmodel.fit(ds_alb, epochs=2)\n</pre> # Transfer Learning [freeze base model layers]: Sequential API  base_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\") base_model.trainable = False  model = keras.models.Sequential([         base_model,         keras.layers.Conv2D(32, (1, 1), activation=\"relu\"),         keras.layers.Dropout(0.2),         keras.layers.Flatten(),         keras.layers.Dense(64, activation='relu'),         keras.layers.Dense(5, activation='softmax'), ])  model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy') model.fit(ds_alb, epochs=2) <pre>Epoch 1/2\n115/115 [==============================] - 30s 239ms/step - loss: 1.5254 - accuracy: 0.3188\nEpoch 2/2\n115/115 [==============================] - 29s 254ms/step - loss: 1.4476 - accuracy: 0.3768\n</pre> Out[44]: <pre>&lt;keras.src.callbacks.History at 0x2e53a5ed0&gt;</pre> In\u00a0[45]: Copied! <pre># Transfer Learning [unfreeze all layers]: Sequential API\n\nbase_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\")\nbase_model.trainable = True\n\nmodel = keras.models.Sequential([\n        base_model,\n        keras.layers.Conv2D(32, (1, 1), activation=\"relu\"),\n        keras.layers.Flatten(),\n        keras.layers.Dense(64, activation='relu'),\n        keras.layers.Dense(5, activation='softmax'),\n])\n\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')\nmodel.fit(ds_alb, epochs=2)\n</pre> # Transfer Learning [unfreeze all layers]: Sequential API  base_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\") base_model.trainable = True  model = keras.models.Sequential([         base_model,         keras.layers.Conv2D(32, (1, 1), activation=\"relu\"),         keras.layers.Flatten(),         keras.layers.Dense(64, activation='relu'),         keras.layers.Dense(5, activation='softmax'), ])  model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy') model.fit(ds_alb, epochs=2) <pre>Epoch 1/2\n115/115 [==============================] - 133s 1s/step - loss: 1.1360 - accuracy: 0.5924\nEpoch 2/2\n115/115 [==============================] - 143s 1s/step - loss: 0.7753 - accuracy: 0.7278\n</pre> Out[45]: <pre>&lt;keras.src.callbacks.History at 0x2e5be11e0&gt;</pre> In\u00a0[46]: Copied! <pre># Transfer Learning [freeze all layers of feature extractor]: Functional API\n\nbase_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\")\nbase_model.trainable = False\n\ninput = keras.Input(shape=(120, 120, 3))\nx = base_model(input, training=False)\nx = keras.layers.Conv2D(32, (1, 1), activation=\"relu\")(x)\nx = keras.layers.Dropout(0.2)(x)\nx = keras.layers.Flatten()(x)\nx = keras.layers.Dense(64, activation='relu')(x)\nx = keras.layers.Dense(5, activation='softmax')(x)\n\nmodel = keras.Model(inputs=input, outputs=x)\n\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')\nmodel.fit(ds_alb, epochs=2)\n</pre> # Transfer Learning [freeze all layers of feature extractor]: Functional API  base_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\") base_model.trainable = False  input = keras.Input(shape=(120, 120, 3)) x = base_model(input, training=False) x = keras.layers.Conv2D(32, (1, 1), activation=\"relu\")(x) x = keras.layers.Dropout(0.2)(x) x = keras.layers.Flatten()(x) x = keras.layers.Dense(64, activation='relu')(x) x = keras.layers.Dense(5, activation='softmax')(x)  model = keras.Model(inputs=input, outputs=x)  model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy') model.fit(ds_alb, epochs=2) <pre>Epoch 1/2\n115/115 [==============================] - 37s 289ms/step - loss: 1.5292 - accuracy: 0.3240\nEpoch 2/2\n115/115 [==============================] - 29s 251ms/step - loss: 1.4471 - accuracy: 0.3779\n</pre> Out[46]: <pre>&lt;keras.src.callbacks.History at 0x2de238820&gt;</pre> In\u00a0[47]: Copied! <pre># Transfer Learning [freeze all layers of feature extractor]: Subclass API\n\nbase_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\")\nbase_model.trainable = False\n\nclass MyModel(keras.Model):\n    def __init__(self, base_model):\n        super(MyModel, self).__init__()\n        self.base = base_model\n        self.layer_1 = keras.layers.Flatten()\n        self.layer_2 = keras.layers.Dense(64, activation='relu')\n        self.layer_3 = keras.layers.Dense(5, activation='softmax')\n\n    @tf.function\n    def call(self, xb):\n        x = self.base(xb)\n        x = self.layer_1(x)\n        x = self.layer_2(x)\n        return self.layer_3(x)\n\n\n\nmodel = MyModel(base_model=base_model)\n\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')\n\nmodel.fit(ds_alb, epochs=2)\n</pre> # Transfer Learning [freeze all layers of feature extractor]: Subclass API  base_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\") base_model.trainable = False  class MyModel(keras.Model):     def __init__(self, base_model):         super(MyModel, self).__init__()         self.base = base_model         self.layer_1 = keras.layers.Flatten()         self.layer_2 = keras.layers.Dense(64, activation='relu')         self.layer_3 = keras.layers.Dense(5, activation='softmax')      @tf.function     def call(self, xb):         x = self.base(xb)         x = self.layer_1(x)         x = self.layer_2(x)         return self.layer_3(x)    model = MyModel(base_model=base_model)  model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')  model.fit(ds_alb, epochs=2) <pre>Epoch 1/2\n115/115 [==============================] - 34s 266ms/step - loss: 1.6205 - accuracy: 0.2736\nEpoch 2/2\n115/115 [==============================] - 31s 266ms/step - loss: 1.5317 - accuracy: 0.3025\n</pre> Out[47]: <pre>&lt;keras.src.callbacks.History at 0x2de884220&gt;</pre> In\u00a0[48]: Copied! <pre># Transfer Learning using [unfreeze all layers of feature extractor]: Subclass API\n\nbase_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\")\nbase_model.trainable = True\n\nclass MyModel(keras.Model):\n    def __init__(self, base_model):\n        super(MyModel, self).__init__()\n        self.base = base_model\n        self.layer_1 = keras.layers.Flatten()\n        self.layer_2 = keras.layers.Dense(64, activation='relu')\n        self.layer_3 = keras.layers.Dense(5, activation='softmax')\n\n    @tf.function\n    def call(self, xb):\n        x = self.base(xb)\n        x = self.layer_1(x)\n        x = self.layer_2(x)\n        return self.layer_3(x)\n\n\n\nmodel = MyModel(base_model=base_model)\n\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')\n\nmodel.fit(ds_alb, epochs=2)\n</pre> # Transfer Learning using [unfreeze all layers of feature extractor]: Subclass API  base_model = keras.applications.ResNet50(include_top=False, input_shape=(120, 120, 3), weights=\"imagenet\") base_model.trainable = True  class MyModel(keras.Model):     def __init__(self, base_model):         super(MyModel, self).__init__()         self.base = base_model         self.layer_1 = keras.layers.Flatten()         self.layer_2 = keras.layers.Dense(64, activation='relu')         self.layer_3 = keras.layers.Dense(5, activation='softmax')      @tf.function     def call(self, xb):         x = self.base(xb)         x = self.layer_1(x)         x = self.layer_2(x)         return self.layer_3(x)    model = MyModel(base_model=base_model)  model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')  model.fit(ds_alb, epochs=2) <pre>Epoch 1/2\n115/115 [==============================] - 137s 1s/step - loss: 1.7294 - accuracy: 0.5883\nEpoch 2/2\n115/115 [==============================] - 139s 1s/step - loss: 1.6056 - accuracy: 0.5390\n</pre> Out[48]: <pre>&lt;keras.src.callbacks.History at 0x2e09d9c00&gt;</pre> In\u00a0[49]: Copied! <pre># Using Sequential API without transfer learning &amp; Eager Execution\n\ndef create_model(input_shape):\n    return models.Sequential([\n        layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),\n        layers.MaxPooling2D((2, 2)),\n        layers.Conv2D(64, (3, 3), activation='relu'),\n        layers.MaxPooling2D((2, 2)),\n        layers.Conv2D(64, (3, 3), activation='relu'),\n        layers.Flatten(),\n        layers.Dense(64, activation='relu'),\n        layers.Dense(5, activation='softmax')])\n\nmodel = create_model((120,120,3))\n\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')\nmodel.fit(ds_alb, epochs=2)\n</pre> # Using Sequential API without transfer learning &amp; Eager Execution  def create_model(input_shape):     return models.Sequential([         layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),         layers.MaxPooling2D((2, 2)),         layers.Conv2D(64, (3, 3), activation='relu'),         layers.MaxPooling2D((2, 2)),         layers.Conv2D(64, (3, 3), activation='relu'),         layers.Flatten(),         layers.Dense(64, activation='relu'),         layers.Dense(5, activation='softmax')])  model = create_model((120,120,3))  model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy') model.fit(ds_alb, epochs=2) <pre>Epoch 1/2\n115/115 [==============================] - 12s 103ms/step - loss: 1.3967 - accuracy: 0.3831\nEpoch 2/2\n115/115 [==============================] - 12s 100ms/step - loss: 1.1674 - accuracy: 0.5272\n</pre> Out[49]: <pre>&lt;keras.src.callbacks.History at 0x3dc67a4a0&gt;</pre> In\u00a0[50]: Copied! <pre># Using Subclass API without transfer learning &amp; Eager Execution\n\nclass MyModel(keras.Model):\n    def __init__(self):\n        super(MyModel, self).__init__()\n        self.conv1 = keras.layers.Conv2D(32, (3, 3), activation='relu')\n        self.pool1 = keras.layers.MaxPooling2D((2, 2))\n        self.conv2 = keras.layers.Conv2D(64, (3, 3), activation='relu')\n        self.pool2 = keras.layers.MaxPooling2D((2, 2))\n        self.conv3 = keras.layers.Conv2D(64, (3, 3), activation='relu')\n        self.flat = keras.layers.Flatten()\n        self.dense1 = keras.layers.Dense(64, activation='relu')\n        self.dense2 = keras.layers.Dense(5, activation='softmax')\n\n    def call(self, xb):\n        x = self.conv1(xb)\n        x = self.pool1(x)\n        x = self.conv2(x)\n        x = self.pool2(x)\n        x = self.conv3(x)\n        x = self.flat(x)\n        x = self.dense1(x)\n        x = self.dense2(x)\n        return x\n\n\nmodel = MyModel()\n\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')\n\nmodel.fit(ds_alb, epochs=2)\n</pre> # Using Subclass API without transfer learning &amp; Eager Execution  class MyModel(keras.Model):     def __init__(self):         super(MyModel, self).__init__()         self.conv1 = keras.layers.Conv2D(32, (3, 3), activation='relu')         self.pool1 = keras.layers.MaxPooling2D((2, 2))         self.conv2 = keras.layers.Conv2D(64, (3, 3), activation='relu')         self.pool2 = keras.layers.MaxPooling2D((2, 2))         self.conv3 = keras.layers.Conv2D(64, (3, 3), activation='relu')         self.flat = keras.layers.Flatten()         self.dense1 = keras.layers.Dense(64, activation='relu')         self.dense2 = keras.layers.Dense(5, activation='softmax')      def call(self, xb):         x = self.conv1(xb)         x = self.pool1(x)         x = self.conv2(x)         x = self.pool2(x)         x = self.conv3(x)         x = self.flat(x)         x = self.dense1(x)         x = self.dense2(x)         return x   model = MyModel()  model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')  model.fit(ds_alb, epochs=2) <pre>Epoch 1/2\n115/115 [==============================] - 12s 102ms/step - loss: 1.4053 - accuracy: 0.3921\nEpoch 2/2\n115/115 [==============================] - 13s 111ms/step - loss: 1.1591 - accuracy: 0.5360\n</pre> Out[50]: <pre>&lt;keras.src.callbacks.History at 0x3dc67a320&gt;</pre>"},{"location":"examples/tensorflow-example/#using-albumentations-with-tensorflow","title":"Using Albumentations with Tensorflow\u00b6","text":""},{"location":"examples/tensorflow-example/#recommended-update-the-version-of-tensorflow_datasets-if-you-want-to-use-it","title":"[Recommended] Update the version of tensorflow_datasets if you want to use it\u00b6","text":"<ul> <li>We'll we using an example from <code>tensorflow_datasets</code>.</li> </ul>"},{"location":"examples/tensorflow-example/#run-the-example","title":"Run the example\u00b6","text":""},{"location":"examples/tensorflow-example/#an-example-pipeline-using-tfimage","title":"An Example Pipeline Using <code>tf.image</code>\u00b6","text":""},{"location":"examples/tensorflow-example/#process-data","title":"Process Data\u00b6","text":""},{"location":"examples/tensorflow-example/#view-images-from-the-dataset","title":"View images from the dataset\u00b6","text":""},{"location":"examples/tensorflow-example/#an-example-pipeline-using-albumentations","title":"An Example Pipeline using <code>albumentations</code>\u00b6","text":""},{"location":"examples/tensorflow-example/#restoring-dataset-shapes","title":"Restoring dataset shapes.\u00b6","text":"<p>The datasets loses its shape after applying a tf.numpy_function, so this is necessary for the sequential model and when inheriting from the model class.</p>"},{"location":"examples/tensorflow-example/#view-images-from-the-dataset","title":"View images from the dataset\u00b6","text":""},{"location":"examples/tensorflow-example/#note","title":"<code>Note</code>:\u00b6","text":"<p>Some <code>API's</code> of <code>tensorflow.keras.Model</code> might not work, if you dont map the dataset with the set_shapes function.</p>"},{"location":"examples/tensorflow-example/#what-works-without-setting-shapes","title":"What works without setting shapes :\u00b6","text":""},{"location":"examples/tensorflow-example/#what-works-only-if-you-set-the-shapes-of-the-dataset","title":"What works only if you set the shapes of the dataset :\u00b6","text":""},{"location":"external_resources/blog_posts_podcasts_talks/","title":"Blog posts, podcasts, talks, and videos about Albumentations","text":""},{"location":"external_resources/blog_posts_podcasts_talks/#blog-posts","title":"Blog posts","text":"<ul> <li>Custom Image Augmentation with Keras. Solving CIFAR-10 with Albumentations and TPU on Google Colab..</li> <li>Road detection using segmentation models and albumentations libraries on Keras.</li> <li>Image Data Augmentation for TensorFlow 2, Keras and PyTorch with Albumentations in Python</li> <li>Explore image augmentations using a convenient tool</li> <li>Image Augmentation using PyTorch and Albumentations</li> <li>Employing the albumentation library in PyTorch workflows. Bonus: Helper for selecting appropriate values!</li> <li>Overview of Albumentations: Open-source library for advanced image augmentations</li> </ul>"},{"location":"external_resources/blog_posts_podcasts_talks/#podcasts-talks-and-videos","title":"Podcasts, talks, and videos","text":"<ul> <li>PyConBY 2020: Eugene Khvedchenya - Albumentations: Fast and Flexible image augmentations</li> <li>Albumentations Framework: a fast image augmentations library | Interview with Dr. Vladimir Iglovikov</li> <li>Image Data Augmentation for TensorFlow 2, Keras and PyTorch with Albumentations in Python</li> <li>Bengali.AI competition - Ch 5. Image augmentations using albumentations</li> <li>Albumentations Tutorial for Data Augmentation</li> </ul>"},{"location":"external_resources/books/","title":"Books that mention Albumentations","text":"<ul> <li>Deep Learning For Dummies. John Paul Mueller, Luca Massaron. May 2019.</li> <li>Data Science Programming All-in-One For Dummies. John Paul Mueller, Luca Massaron. January 2020.</li> <li>PyTorch Computer Vision Cookbook. Michael Avendi. March 2020.</li> <li>Approaching (Almost) Any Machine Learning Problem. Abhishek Thakur. June 2020.</li> </ul>"},{"location":"external_resources/online_courses/","title":"Online classes that cover Albumentations","text":""},{"location":"external_resources/online_courses/#udemy","title":"Udemy","text":"<ul> <li>Modern Computer Vision &amp; Deep Learning with Python &amp; PyTorch</li> <li>Deep Learning for Image Segmentation with Python &amp; Pytorch</li> <li>Deep Learning Masterclass with TensorFlow 2 Over 20 Projects</li> <li>Master Deep Learning for Computer Vision in TensorFlow</li> <li>Deep Learning : Image Classification with Tensorflow in 2024</li> <li>Deep learning with PyTorch | Medical Imaging Competitions</li> <li>Veri Art\u0131r\u0131m\u0131: Albumentations ile Projelerle Veri Art\u0131r\u0131m\u0131</li> <li>Mastering Advanced Representation Learning (CV)</li> </ul>"},{"location":"external_resources/online_courses/#coursera","title":"Coursera","text":"<ul> <li>Deep Learning with PyTorch : Image Segmentation</li> <li>Facial Keypoint Detection with PyTorch</li> <li>Deep Learning with PyTorch : Object Localization</li> <li>Aerial Image Segmentation with PyTorch</li> </ul>"},{"location":"getting_started/bounding_boxes_augmentation/","title":"Bounding boxes augmentation for object detection","text":""},{"location":"getting_started/bounding_boxes_augmentation/#different-annotations-formats","title":"Different annotations formats","text":"<p>Bounding boxes are rectangles that mark objects on an image. There are multiple formats of bounding boxes annotations. Each format uses its specific representation of bounding boxes coordinates. Albumentations supports four formats: <code>pascal_voc</code>, <code>albumentations</code>, <code>coco</code>, and <code>yolo</code> .</p> <p>Let's take a look at each of those formats and how they represent coordinates of bounding boxes.</p> <p>As an example, we will use an image from the dataset named Common Objects in Context. It contains one bounding box that marks a cat. The image width is 640 pixels, and its height is 480 pixels. The width of the bounding box is 322 pixels, and its height is 117 pixels.</p> <p>The bounding box has the following <code>(x, y)</code> coordinates of its corners: top-left is <code>(x_min, y_min)</code> or <code>(98px, 345px)</code>, top-right is <code>(x_max, y_min)</code> or <code>(420px, 345px)</code>, bottom-left is <code>(x_min, y_max)</code> or <code>(98px, 462px)</code>, bottom-right is <code>(x_max, y_max)</code> or <code>(420px, 462px)</code>. As you see, coordinates of the bounding box's corners are calculated with respect to the top-left corner of the image which has <code>(x, y)</code> coordinates <code>(0, 0)</code>.</p> <p> An example image with a bounding box from the COCO dataset</p>"},{"location":"getting_started/bounding_boxes_augmentation/#pascal_voc","title":"pascal_voc","text":"<p><code>pascal_voc</code> is a format used by the Pascal VOC dataset. Coordinates of a bounding box are encoded with four values in pixels: <code>[x_min, y_min, x_max, y_max]</code>.  <code>x_min</code> and <code>y_min</code> are coordinates of the top-left corner of the bounding box. <code>x_max</code> and <code>y_max</code> are coordinates of bottom-right corner of the bounding box.</p> <p>Coordinates of the example bounding box in this format are <code>[98, 345, 420, 462]</code>.</p>"},{"location":"getting_started/bounding_boxes_augmentation/#albumentations","title":"albumentations","text":"<p><code>albumentations</code> is similar to <code>pascal_voc</code>, because it also uses four values <code>[x_min, y_min, x_max, y_max]</code> to represent a bounding box. But unlike <code>pascal_voc</code>, <code>albumentations</code> uses normalized values. To normalize values, we divide coordinates in pixels for the x- and y-axis by the width and the height of the image.</p> <p>Coordinates of the example bounding box in this format are <code>[98 / 640, 345 / 480, 420 / 640, 462 / 480]</code> which are <code>[0.153125, 0.71875, 0.65625, 0.9625]</code>.</p> <p>Albumentations uses this format internally to work with bounding boxes and augment them.</p>"},{"location":"getting_started/bounding_boxes_augmentation/#coco","title":"coco","text":"<p><code>coco</code> is a format used by the Common Objects in Context COCO dataset.</p> <p>In <code>coco</code>, a bounding box is defined by four values in pixels <code>[x_min, y_min, width, height]</code>. They are coordinates of the top-left corner along with the width and height of the bounding box.</p> <p>Coordinates of the example bounding box in this format are <code>[98, 345, 322, 117]</code>.</p>"},{"location":"getting_started/bounding_boxes_augmentation/#yolo","title":"yolo","text":"<p>In <code>yolo</code>, a bounding box is represented by four values <code>[x_center, y_center, width, height]</code>. <code>x_center</code> and <code>y_center</code> are the normalized coordinates of the center of the bounding box. To make coordinates normalized, we take pixel values of x and y, which marks the center of the bounding box on the x- and y-axis. Then we divide the value of x by the width of the image and value of y by the height of the image. <code>width</code> and <code>height</code> represent the width and the height of the bounding box. They are normalized as well.</p> <p>Coordinates of the example bounding box in this format are <code>[((420 + 98) / 2) / 640, ((462 + 345) / 2) / 480, 322 / 640, 117 / 480]</code> which are <code>[0.4046875, 0.840625, 0.503125, 0.24375]</code>.</p> <p> How different formats represent coordinates of a bounding box</p>"},{"location":"getting_started/bounding_boxes_augmentation/#bounding-boxes-augmentation","title":"Bounding boxes augmentation","text":"<p>Just like with images and masks augmentation, the process of augmenting bounding boxes consists of 4 steps.</p> <ol> <li>You import the required libraries.</li> <li>You define an augmentation pipeline.</li> <li>You read images and bounding boxes from the disk.</li> <li>You pass an image and bounding boxes to the augmentation pipeline and receive augmented images and boxes.</li> </ol> <p>Note</p> <p>Some transforms in Albumentation don't support bounding boxes. If you try to use them you will get an exception. Please refer to this article to check whether a transform can augment bounding boxes.</p>"},{"location":"getting_started/bounding_boxes_augmentation/#step-1-import-the-required-libraries","title":"Step 1. Import the required libraries.","text":"Python<pre><code>import albumentations as A\nimport cv2\n</code></pre>"},{"location":"getting_started/bounding_boxes_augmentation/#step-2-define-an-augmentation-pipeline","title":"Step 2. Define an augmentation pipeline.","text":"<p>Here an example of a minimal declaration of an augmentation pipeline that works with bounding boxes.</p> Python<pre><code>transform = A.Compose([\n    A.RandomCrop(width=450, height=450),\n    A.HorizontalFlip(p=0.5),\n    A.RandomBrightnessContrast(p=0.2),\n], bbox_params=A.BboxParams(format='coco'))\n</code></pre> <p>Note that unlike image and masks augmentation, <code>Compose</code> now has an additional parameter <code>bbox_params</code>. You need to pass an instance of <code>A.BboxParams</code> to that argument. <code>A.BboxParams</code> specifies settings for working with bounding boxes. <code>format</code> sets the format for bounding boxes coordinates.</p> <p>It can either be <code>pascal_voc</code>, <code>albumentations</code>, <code>coco</code> or <code>yolo</code>. This value is required because Albumentation needs to know the coordinates' source format for bounding boxes to apply augmentations correctly.</p> <p>Besides <code>format</code>, <code>A.BboxParams</code> supports a few more settings.</p> <p>Here is an example of <code>Compose</code> that shows all available settings with <code>A.BboxParams</code>:</p> Python<pre><code>transform = A.Compose([\n    A.RandomCrop(width=450, height=450),\n    A.HorizontalFlip(p=0.5),\n    A.RandomBrightnessContrast(p=0.2),\n], bbox_params=A.BboxParams(format='coco', min_area=1024, min_visibility=0.1, label_fields=['class_labels']))\n</code></pre>"},{"location":"getting_started/bounding_boxes_augmentation/#min_area-and-min_visibility","title":"<code>min_area</code> and <code>min_visibility</code>","text":"<p><code>min_area</code> and <code>min_visibility</code> parameters control what Albumentations should do to the augmented bounding boxes if their size has changed after augmentation. The size of bounding boxes could change if you apply spatial augmentations, for example, when you crop a part of an image or when you resize an image.</p> <p><code>min_area</code> is a value in pixels. If the area of a bounding box after augmentation becomes smaller than <code>min_area</code>, Albumentations will drop that box. So the returned list of augmented bounding boxes won't contain that bounding box.</p> <p><code>min_visibility</code> is a value between 0 and 1. If the ratio of the bounding box area after augmentation to <code>the area of the bounding box before augmentation</code> becomes smaller than <code>min_visibility</code>, Albumentations will drop that box. So if the augmentation process cuts the most of the bounding box, that box won't be present in the returned list of the augmented bounding boxes.</p> <p>Here is an example image that contains two bounding boxes. Bounding boxes coordinates are declared using the <code>coco</code> format.</p> <p> An example image with two bounding boxes</p> <p>First, we apply the <code>CenterCrop</code> augmentation without declaring parameters <code>min_area</code> and <code>min_visibility</code>. The augmented image contains two bounding boxes.</p> <p> An example image with two bounding boxes after applying augmentation</p> <p>Next, we apply the same <code>CenterCrop</code> augmentation, but now we also use the <code>min_area</code> parameter. Now, the augmented image contains only one bounding box, because the other bounding box's area after augmentation became smaller than <code>min_area</code>, so Albumentations dropped that bounding box.</p> <p> An example image with one bounding box after applying augmentation with 'min_area'</p> <p>Finally, we apply the <code>CenterCrop</code> augmentation with the <code>min_visibility</code>. After that augmentation, the resulting image doesn't contain any bounding box, because visibility of all bounding boxes after augmentation are below threshold set by <code>min_visibility</code>.</p> <p> An example image with zero bounding boxes after applying augmentation with 'min_visibility'</p>"},{"location":"getting_started/bounding_boxes_augmentation/#class-labels-for-bounding-boxes","title":"Class labels for bounding boxes","text":"<p>Besides coordinates, each bounding box should have an associated class label that tells which object lies inside the bounding box. There are two ways to pass a label for a bounding box.</p> <p>Let's say you have an example image with three objects: <code>dog</code>, <code>cat</code>, and <code>sports ball</code>. Bounding boxes coordinates in the <code>coco</code> format for those objects are <code>[23, 74, 295, 388]</code>, <code>[377, 294, 252, 161]</code>, and <code>[333, 421, 49, 49]</code>.</p> <p> An example image with 3 bounding boxes from the COCO dataset</p>"},{"location":"getting_started/bounding_boxes_augmentation/#1-you-can-pass-labels-along-with-bounding-boxes-coordinates-by-adding-them-as-additional-values-to-the-list-of-coordinates","title":"1. You can pass labels along with bounding boxes coordinates by adding them as additional values to the list of coordinates.","text":"<p>For the image above, bounding boxes with class labels will become <code>[23, 74, 295, 388, 'dog']</code>, <code>[377, 294, 252, 161, 'cat']</code>, and <code>[333, 421, 49, 49, 'sports ball']</code>.</p> <p>Class labels could be of any type: integer, string, or any other Python data type. For example, integer values as class labels will look the following: <code>[23, 74, 295, 388, 18]</code>, <code>[377, 294, 252, 161, 17]</code>, and <code>[333, 421, 49, 49, 37].</code></p> <p>Also, you can use multiple class values for each bounding box, for example <code>[23, 74, 295, 388, 'dog', 'animal']</code>, <code>[377, 294, 252, 161, 'cat', 'animal']</code>, and <code>[333, 421, 49, 49, 'sports ball', 'item']</code>.</p>"},{"location":"getting_started/bounding_boxes_augmentation/#2you-can-pass-labels-for-bounding-boxes-as-a-separate-list-the-preferred-way","title":"2.You can pass labels for bounding boxes as a separate list (the preferred way).","text":"<p>For example, if you have three bounding boxes like <code>[23, 74, 295, 388]</code>, <code>[377, 294, 252, 161]</code>, and <code>[333, 421, 49, 49]</code> you can create a separate list with values like <code>['cat', 'dog', 'sports ball']</code>, or <code>[18, 17, 37]</code> that contains class labels for those bounding boxes. Next, you pass that list with class labels as a separate argument to the <code>transform</code> function. Albumentations needs to know the names of all those lists with class labels to join them with augmented bounding boxes correctly. Then, if a bounding box is dropped after augmentation because it is no longer visible, Albumentations will drop the class label for that box as well. Use <code>label_fields</code> parameter to set names for all arguments in <code>transform</code> that will contain label descriptions for bounding boxes (more on that in Step 4).</p>"},{"location":"getting_started/bounding_boxes_augmentation/#step-3-read-images-and-bounding-boxes-from-the-disk","title":"Step 3. Read images and bounding boxes from the disk.","text":"<p>Read an image from the disk.</p> Python<pre><code>image = cv2.imread(\"/path/to/image.jpg\")\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</code></pre> <p>Bounding boxes can be stored on the disk in different serialization formats: JSON, XML, YAML, CSV, etc. So the code to read bounding boxes depends on the actual format of data on the disk.</p> <p>After you read the data from the disk, you need to prepare bounding boxes for Albumentations.</p> <p>Albumentations expects that bounding boxes will be represented as a list of lists. Each list contains information about a single bounding box. A bounding box definition should have at list four elements that represent the coordinates of that bounding box. The actual meaning of those four values depends on the format of bounding boxes (either <code>pascal_voc</code>, <code>albumentations</code>, <code>coco</code>, or <code>yolo</code>). Besides four coordinates, each definition of a bounding box may contain one or more extra values. You can use those extra values to store additional information about the bounding box, such as a class label of the object inside the box. During augmentation, Albumentations will not process those extra values. The library will return them as is along with the updated coordinates of the augmented bounding box.</p>"},{"location":"getting_started/bounding_boxes_augmentation/#step-4-pass-an-image-and-bounding-boxes-to-the-augmentation-pipeline-and-receive-augmented-images-and-boxes","title":"Step 4. Pass an image and bounding boxes to the augmentation pipeline and receive augmented images and boxes.","text":"<p>As discussed in Step 2, there are two ways of passing class labels along with bounding boxes coordinates:</p>"},{"location":"getting_started/bounding_boxes_augmentation/#1-pass-class-labels-along-with-coordinates","title":"1. Pass class labels along with coordinates","text":"<p>So, if you have coordinates of three bounding boxes that look like this:</p> Python<pre><code>bboxes = [\n    [23, 74, 295, 388],\n    [377, 294, 252, 161],\n    [333, 421, 49, 49],\n]\n</code></pre> <p>you can add a class label for each bounding box as an additional element of the list along with four coordinates. So now a list with bounding boxes and their coordinates will look the following:</p> Python<pre><code>bboxes = [\n    [23, 74, 295, 388, 'dog'],\n    [377, 294, 252, 161, 'cat'],\n    [333, 421, 49, 49, 'sports ball'],\n]\n</code></pre> <p>or with multiple labels per each bounding box: Python<pre><code>bboxes = [\n    [23, 74, 295, 388, 'dog', 'animal'],\n    [377, 294, 252, 161, 'cat', 'animal'],\n    [333, 421, 49, 49, 'sports ball', 'item'],\n]\n</code></pre></p> <p>You can use any data type for declaring class labels. It can be string, integer, or any other Python data type.</p> <p>Next, you pass an image and bounding boxes for it to the <code>transform</code> function and receive the augmented image and bounding boxes.</p> Python<pre><code>transformed = transform(image=image, bboxes=bboxes)\ntransformed_image = transformed['image']\ntransformed_bboxes = transformed['bboxes']\n</code></pre> <p> Example input and output data for bounding boxes augmentation</p>"},{"location":"getting_started/bounding_boxes_augmentation/#2-pass-class-labels-in-a-separate-argument-to-transform-the-preferred-way","title":"2. Pass class labels in a separate argument to <code>transform</code> (the preferred way).","text":"<p>Let's say you have coordinates of three bounding boxes Python<pre><code>bboxes = [\n    [23, 74, 295, 388],\n    [377, 294, 252, 161],\n    [333, 421, 49, 49],\n]\n</code></pre></p> <p>You can create a separate list that contains class labels for those bounding boxes:</p> Python<pre><code>class_labels = ['cat', 'dog', 'parrot']\n</code></pre> <p>Then you pass both bounding boxes and class labels to <code>transform</code>. Note that to pass class labels, you need to use the name of the argument that you declared in <code>label_fields</code> when creating an instance of Compose in step 2. In our case, we set the name of the argument to <code>class_labels</code>.</p> Python<pre><code>transformed = transform(image=image, bboxes=bboxes, class_labels=class_labels)\ntransformed_image = transformed['image']\ntransformed_bboxes = transformed['bboxes']\ntransformed_class_labels = transformed['class_labels']\n</code></pre> <p> Example input and output data for bounding boxes augmentation with a separate argument for class labels</p> <p>Note that <code>label_fields</code> expects a list, so you can set multiple fields that contain labels for your bounding boxes. So if you declare Compose like</p> Python<pre><code>transform = A.Compose([\n    A.RandomCrop(width=450, height=450),\n    A.HorizontalFlip(p=0.5),\n    A.RandomBrightnessContrast(p=0.2),\n], bbox_params=A.BboxParams(format='coco', label_fields=['class_labels', 'class_categories'])))\n</code></pre> <p>you can use those multiple arguments to pass info about class labels, like</p> Python<pre><code>class_labels = ['cat', 'dog', 'parrot']\nclass_categories = ['animal', 'animal', 'item']\n\ntransformed = transform(image=image, bboxes=bboxes, class_labels=class_labels, class_categories=class_categories)\ntransformed_image = transformed['image']\ntransformed_bboxes = transformed['bboxes']\ntransformed_class_labels = transformed['class_labels']\ntransformed_class_categories = transformed['class_categories']\n</code></pre>"},{"location":"getting_started/bounding_boxes_augmentation/#examples","title":"Examples","text":"<ul> <li>Using Albumentations to augment bounding boxes for object detection tasks</li> <li>How to use Albumentations for detection tasks if you need to keep all bounding boxes</li> <li>Showcase. Cool augmentation examples on diverse set of images from various real-world tasks.</li> </ul>"},{"location":"getting_started/image_augmentation/","title":"Image augmentation for classification","text":"<p>We can divide the process of image augmentation into four steps:</p> <ol> <li>Import albumentations and a library to read images from the disk (e.g., OpenCV).</li> <li>Define an augmentation pipeline.</li> <li>Read images from the disk.</li> <li>Pass images to the augmentation pipeline and receive augmented images.</li> </ol>"},{"location":"getting_started/image_augmentation/#step-1-import-the-required-libraries","title":"Step 1. Import the required libraries.","text":"<ul> <li>Import Albumentations</li> </ul> Python<pre><code>import albumentations as A\n</code></pre> <ul> <li>Import a library to read images from the disk. In this example, we will use OpenCV. It is an open-source computer vision library that supports many image formats. Albumentations has OpenCV as a dependency, so you already have OpenCV installed.</li> </ul> Python<pre><code>import cv2\n</code></pre>"},{"location":"getting_started/image_augmentation/#step-2-define-an-augmentation-pipeline","title":"Step 2. Define an augmentation pipeline.","text":"<p>To define an augmentation pipeline, you need to create an instance of the <code>Compose</code> class. As an argument to the <code>Compose</code> class, you need to pass a list of augmentations you want to apply. A call to <code>Compose</code> will return a transform function that will perform image augmentation.</p> <p>Let's look at an example:</p> Python<pre><code>transform = A.Compose([\n    A.RandomCrop(width=256, height=256),\n    A.HorizontalFlip(p=0.5),\n    A.RandomBrightnessContrast(p=0.2),\n])\n</code></pre> <p>In the example, <code>Compose</code> receives a list with three augmentations: <code>A.RandomCrop</code>, <code>A.HorizontalFlip</code>, and <code>A.RandomBrighntessContrast</code>. You can find the full list of all available augmentations in the GitHub repository and in the API Docs. A demo playground that demonstrates how augmentations will transform the input image is available at https://demo.albumentations.ai.</p> <p>To create an augmentation, you create an instance of the required augmentation class and pass augmentation parameters to it. <code>A.RandomCrop</code> receives two parameters, <code>height</code> and <code>width</code>. <code>A.RandomCrop(width=256, height=256)</code> means that <code>A.RandomCrop</code> will take an input image, extract a random patch with size 256 by 256 pixels from it and then pass the result to the next augmentation in the pipeline (in this case to <code>A.HorizontalFlip</code>).</p> <p><code>A.HorizontalFlip</code> in this example has one parameter named <code>p</code>. <code>p</code> is a special parameter that is supported by almost all augmentations. It controls the probability of applying the augmentation. <code>p=0.5</code> means that with a probability of 50%, the transform will flip the image horizontally, and with a probability of 50%, the transform won't modify the input image.</p> <p><code>A.RandomBrighntessContrast</code> in the example also has one parameter, <code>p</code>. With a probability of 20%, this augmentation will change the brightness and contrast of the image received from <code>A.HorizontalFlip</code>. And with a probability of 80%, it will keep the received image unchanged.</p> <p> A visualized version of the augmentation pipeline. You pass an image to it, the image goes through all transformations, and then you receive an augmented image from the pipeline.</p>"},{"location":"getting_started/image_augmentation/#step-3-read-images-from-the-disk","title":"Step 3. Read images from the disk.","text":"<p>To pass an image to the augmentation pipeline, you need to read it from the disk. The pipeline expects to receive an image in the form of a NumPy array. If it is a color image, it should have three channels in the following order: Red, Green, Blue (so a regular RGB image).</p> <p>To read images from the disk, you can use OpenCV - a popular library for image processing. It supports a lot of input formats and is installed along with Albumentations since Albumentations utilizes that library under the hood for a lot of augmentations.</p> <p>To import OpenCV</p> Python<pre><code>import cv2\n</code></pre> <p>To read an image with OpenCV</p> <p>Python<pre><code>image = cv2.imread(\"/path/to/image.jpg\")\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</code></pre> Note the usage of <code>cv2.cvtColor</code>. For historical reasons, OpenCV reads an image in BGR format (so color channels of the image have the following order: Blue, Green, Red). Albumentations uses the most common and popular RGB image format. So when using OpenCV, we need to convert the image format to RGB explicitly.</p> <p>Besides OpenCV, you can use other image processing libraries.</p>"},{"location":"getting_started/image_augmentation/#pillow","title":"Pillow","text":"<p>Pillow is a popular Python image processing library.</p> <ul> <li>Install Pillow</li> </ul> Bash<pre><code>    pip install pillow\n</code></pre> <ul> <li>Import Pillow and NumPy (we need NumPy to convert a Pillow image to a NumPy array. NumPy is already installed along with Albumentations).</li> </ul> Python<pre><code>from PIL import Image\nimport numpy as np\n</code></pre> <ul> <li>Read an image with Pillow and convert it to a NumPy array. Python<pre><code>pillow_image = Image.open(\"image.jpg\")\nimage = np.array(pillow_image)\n</code></pre></li> </ul>"},{"location":"getting_started/image_augmentation/#step-4-pass-images-to-the-augmentation-pipeline-and-receive-augmented-images","title":"Step 4. Pass images to the augmentation pipeline and receive augmented images.","text":"<p>To pass an image to the augmentation pipeline you need to call the <code>transform</code> function created by a call to <code>A.Compose</code> at Step 2. In the <code>image</code> argument to that function, you need to pass an image that you want to augment.</p> Python<pre><code>transformed = transform(image=image)\n</code></pre> <p><code>transform</code> will return a dictionary with a single key <code>image</code>. Value at that key will contain an augmented image.</p> Python<pre><code>transformed_image = transformed[\"image\"]\n</code></pre> <p>To augment the next image, you need to call <code>transform</code> again and pass a new image as the <code>image</code> argument:</p> Python<pre><code>another_transformed_image = transform(image=another_image)[\"image\"]\n</code></pre> <p>Each augmentation will change the input image with the probability set by the parameter <code>p</code>. Also, many augmentations have parameters that control the magnitude of changes that will be applied to an image. For example, <code>A.RandomBrightnessContrast</code> has two parameters: <code>brightness_limit</code> that controls the magnitude of adjusting brightness and <code>contrast_limit</code> that controls the magnitude of adjusting contrast. The bigger the value, the more the augmentation will change an image. During augmentation, a magnitude of the transformation is sampled from a uniform distribution limited by <code>brightness_limit</code> and <code>contrast_limit</code>. That means that if you make multiple calls to <code>transform</code> with the same input image, you will get a different output image each time.</p> Python<pre><code>transform = A.Compose([\n    A.RandomBrightnessContrast(brightness_limit=1, contrast_limit=1, p=1.0),\n])\ntransformed_image_1 = transform(image=image)['image']\ntransformed_image_2 = transform(image=image)['image']\ntransformed_image_3 = transform(image=image)['image']\n</code></pre> <p></p>"},{"location":"getting_started/image_augmentation/#examples","title":"Examples","text":"<ul> <li>Defining a simple augmentation pipeline for image augmentation</li> <li>Working with non-8-bit images</li> <li>Weather augmentations in Albumentations</li> <li>Showcase. Cool augmentation examples on diverse set of images from various real-world tasks.</li> </ul>"},{"location":"getting_started/installation/","title":"Installation","text":"<p>Albumentations requires Python 3.8 or higher.</p>"},{"location":"getting_started/installation/#install-the-latest-stable-version-from-pypi","title":"Install the latest stable version from PyPI","text":"Bash<pre><code>pip install -U albumentations\n</code></pre>"},{"location":"getting_started/installation/#install-the-latest-version-from-the-master-branch-on-github","title":"Install the latest version from the master branch on GitHub","text":"Bash<pre><code>pip install -U git+https://github.com/albumentations-team/albumentations\n</code></pre>"},{"location":"getting_started/installation/#note-on-opencv-dependencies","title":"Note on OpenCV dependencies","text":"<p>By default, pip downloads a wheel distribution of Albumentations. This distribution has <code>opencv-python-headless</code> as its dependency.</p> <p>If you already have some OpenCV distribution (such as <code>opencv-python-headless</code>, <code>opencv-python</code>, <code>opencv-contrib-python</code> or <code>opencv-contrib-python-headless</code>) installed in your Python environment, you can force Albumentations to use it by providing the <code>--no-binary qudida,albumentations</code> argument to pip, e.g.</p> Bash<pre><code>pip install -U albumentations\n</code></pre> <p>pip will use the following logic to determine the required OpenCV distribution:</p> <ol> <li>If your Python environment already contains <code>opencv-python</code>, <code>opencv-contrib-python</code>, <code>opencv-contrib-python-headless</code> or <code>opencv-python-headless</code> pip will use it.</li> <li>If your Python environment doesn't contain any OpenCV distribution from step 1, pip will download <code>opencv-python-headless</code>.</li> </ol>"},{"location":"getting_started/installation/#install-the-latest-stable-version-from-conda-forge","title":"Install the latest stable version from conda-forge","text":"<p>If you are using Anaconda or Miniconda you can install Albumentations from conda-forge:</p> Bash<pre><code>conda install -c conda-forge albumentations\n</code></pre>"},{"location":"getting_started/keypoints_augmentation/","title":"Keypoints augmentation","text":"<p>Computer vision tasks such as human pose estimation, face detection, and emotion recognition usually work with keypoints on the image.</p> <p>In the case of pose estimation, keypoints mark human joints such as shoulder, elbow, wrist, knee, etc.</p> <p> Keypoints annotations along with visualized edges between keypoints. Images are from the COCO dataset.</p> <p>In the case of face detection, keypoints mark important areas of the face such as eyes, nose, corners of the mouth, etc.</p> <p> Facial keypoints. Source: the \"Facial Keypoints Detection\" competition on Kaggle.</p> <p>To define a keypoint, you usually need two values, x and y coordinates of the keypoint. Coordinates of the keypoint are calculated with respect to the top-left corner of the image which has <code>(x, y)</code> coordinates <code>(0, 0)</code>. Often keypoints have associated labels such as <code>right_elbow</code>, <code>left_wrist</code>, etc.</p> <p> An example image with five keypoints from the COCO dataset</p> <p>Some classical computer vision algorithms, such as SIFT, may use four values to describe a keypoint. In addition to the x and y coordinates, there are keypoint scale and keypoint angle. Albumentations support those values as well.</p> <p> A keypoint may also has associated scale and angle values</p> <p>Keypoint angles are counter-clockwise. For example, in the following image, the angle value is 65\u00b0. You can read more about angle of rotation in the Wikipedia article. </p>"},{"location":"getting_started/keypoints_augmentation/#supported-formats-for-keypoints-coordinates","title":"Supported formats for keypoints' coordinates.","text":"<ul> <li> <p><code>xy</code>. A keypoint is defined by x and y coordinates in pixels.</p> </li> <li> <p><code>yx</code>. A keypoint is defined by y and x coordinates in pixels.</p> </li> <li> <p><code>xya</code>. A keypoint is defined by x and y coordinates in pixels and the angle.</p> </li> <li> <p><code>xys</code>. A keypoint is defined by x and y coordinates in pixels, and the scale.</p> </li> <li> <p><code>xyas</code>. A keypoint is defined by x and y coordinates in pixels, the angle, and the scale.</p> </li> <li> <p><code>xysa</code>. A keypoint is defined by x and y coordinates in pixels, the scale, and the angle.</p> </li> </ul>"},{"location":"getting_started/keypoints_augmentation/#augmenting-keypoints","title":"Augmenting keypoints","text":"<p>The process of augmenting keypoints looks very similar to the bounding boxes augmentation. It consists of 4 steps.</p> <ol> <li>You import the required libraries.</li> <li>You define an augmentation pipeline.</li> <li>You read images and keypoints from the disk.</li> <li>You pass an image and keypoints to the augmentation pipeline and receive augmented images and keypoints.</li> </ol> <p>Note</p> <p>Some transforms in Albumentation don't support keypoints. If you try to use them you will get an exception. Please refer to this article to check whether a transform can augment keypoints.</p>"},{"location":"getting_started/keypoints_augmentation/#step-1-import-the-required-libraries","title":"Step 1. Import the required libraries.","text":"Python<pre><code>import albumentations as A\nimport cv2\n</code></pre>"},{"location":"getting_started/keypoints_augmentation/#step-2-define-an-augmentation-pipeline","title":"Step 2. Define an augmentation pipeline.","text":"<p>Here an example of a minimal declaration of an augmentation pipeline that works with keypoints.</p> Python<pre><code>transform = A.Compose([\n    A.RandomCrop(width=330, height=330),\n    A.RandomBrightnessContrast(p=0.2),\n], keypoint_params=A.KeypointParams(format='xy'))\n</code></pre> <p>Note that just like with bounding boxes, <code>Compose</code> has an additional parameter that defines the format for keypoints' coordinates. In the case of keypoints, it is called <code>keypoint_params</code>. Here we pass an instance of <code>A.KeypointParams</code> that says that <code>xy</code> coordinates format should be used.</p> <p>Besides <code>format</code>, <code>A.KeypointParams</code> supports a few more settings.</p> <p>Here is an example of <code>Compose</code> that shows all available settings with <code>A.KeypointParams</code></p> Python<pre><code>transform = A.Compose([\n    A.RandomCrop(width=330, height=330),\n    A.RandomBrightnessContrast(p=0.2),\n], keypoint_params=A.KeypointParams(format='xy', label_fields=['class_labels'], remove_invisible=True, angle_in_degrees=True))\n</code></pre>"},{"location":"getting_started/keypoints_augmentation/#label_fields","title":"<code>label_fields</code>","text":"<p>In some computer vision tasks, keypoints have not only coordinates but associated labels as well. For example, in pose estimation, each keypoint has a label such as <code>elbow</code>, <code>knee</code> or <code>wrist</code>. You need to pass those labels in a separate argument (or arguments, because you can use multiple fields) to the <code>transform</code> function that will augment keypoints. <code>label_fields</code> defines names of those fields. Step 4 describes how you need to use the <code>transform</code> function.</p>"},{"location":"getting_started/keypoints_augmentation/#remove_invisible","title":"<code>remove_invisible</code>","text":"<p>After the augmentation, some keypoints may become invisible because they will be located outside of the augmented image's visible area. For example, if you crop a part of the image, all the keypoints outside of the cropped area will become invisible. If <code>remove_invisible</code> is set to <code>True</code>, Albumentations won't return invisible keypoints. <code>remove_invisible</code> is set to <code>True</code> by default, so if you don't pass that argument, Albumentations won't return invisible keypoints.</p>"},{"location":"getting_started/keypoints_augmentation/#angle_in_degrees","title":"<code>angle_in_degrees</code>","text":"<p>If <code>angle_in_degrees</code> is set to <code>True</code> (this is the default value), then Albumentations expects that the angle value in formats <code>xya</code>, <code>xyas</code>, and <code>xysa</code> is defined in angles. If <code>angle_in_degrees</code> is set to <code>False</code>, Albumentations expects that the angle value is specified in radians.</p> <p>This setting doesn't affect <code>xy</code> and <code>yx</code> formats, because those formats don't use angles.</p>"},{"location":"getting_started/keypoints_augmentation/#3-read-images-and-keypoints-from-the-disk","title":"3. Read images and keypoints from the disk.","text":"<p>Read an image from the disk.</p> <p>Python<pre><code>image = cv2.imread(\"/path/to/image.jpg\")\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</code></pre> Keypoints can be stored on the disk in different serialization formats: JSON, XML, YAML, CSV, etc. So the code to read keypoints depends on the actual format of data on the disk.</p> <p>After you read the data from the disk, you need to prepare keypoints for Albumentations.</p> <p>Albumentations expects that keypoint will be represented as a list of lists. Each list contains information about a single keypoint. A definition of keypoint should have two to four elements depending on the selected format of keypoints. The first two elements are x and y coordinates of a keypoint in pixels (or y and x coordinates in the <code>yx</code> format). The third and fourth elements may be the angle and the scale of keypoint if you select a format that uses those values.</p>"},{"location":"getting_started/keypoints_augmentation/#step-4-pass-an-image-and-keypoints-to-the-augmentation-pipeline-and-receive-augmented-images-and-boxes","title":"Step 4. Pass an image and keypoints to the augmentation pipeline and receive augmented images and boxes.","text":"<p>Let's say you have an example image with five keypoints.</p> <p>A list with those five keypoints' coordinates in the <code>xy</code> format will look the following:</p> Python<pre><code>keypoints = [\n    (264, 203),\n    (86, 88),\n    (254, 160),\n    (193, 103),\n    (65, 341),\n]\n</code></pre> <p>Then you pass those keypoints to the <code>transform</code> function along with the image and receive the augmented versions of image and keypoints.</p> Python<pre><code>transformed = transform(image=image, keypoints=keypoints)\ntransformed_image = transformed['image']\ntransformed_keypoints = transformed['keypoints']\n</code></pre> <p> The augmented image with augmented keypoints</p> <p>If you set <code>remove_invisible</code> to <code>False</code> in <code>keypoint_params</code>, then Albumentations will return all keypoints, even if they lie outside the visible area. In the example image below, you can see that the keypoint for the right hip is located outside the image, but Albumentations still returned it. The area outside the image is highlighted in yellow.</p> <p> When <code>remove_invisible</code> is set to <code>False</code> Albumentations will return all keypoints, even those located outside the image</p> <p>If keypoints have associated class labels, you need to create a list that contains those labels:</p> Python<pre><code>class_labels = [\n    'left_elbow',\n    'right_elbow',\n    'left_wrist',\n    'right_wrist',\n    'right_hip',\n]\n</code></pre> <p>Also, you need to declare the name of the argument to <code>transform</code> that will contain those labels. For declaration, you need to use the <code>label_fields</code> parameters of <code>A.KeypointParams</code>.</p> <p>For example, we could use the <code>class_labels</code> name for the argument with labels.</p> Python<pre><code>transform = A.Compose([\n    A.RandomCrop(width=330, height=330),\n    A.RandomBrightnessContrast(p=0.2),\n], keypoint_params=A.KeypointParams(format='xy', label_fields=['class_labels']))\n</code></pre> <p>Next, you pass both keypoints' coordinates and class labels to <code>transform</code>.</p> Python<pre><code>transformed = transform(image=image, keypoints=keypoints, class_labels=class_labels)\ntransformed_image = transformed['image']\ntransformed_keypoints = transformed['keypoints']\ntransformed_class_labels = transformed['class_labels']\n</code></pre> <p>Note that <code>label_fields</code> expects a list, so you can set multiple fields that contain labels for your keypoints. So if you declare Compose like</p> Python<pre><code>transform = A.Compose([\n    A.RandomCrop(width=330, height=330),\n    A.RandomBrightnessContrast(p=0.2),\n], keypoint_params=A.KeypointParams(format='xy', label_fields=['class_labels', 'class_sides']))\n</code></pre> <p>you can use those multiple arguments to pass info about class labels, like</p> Python<pre><code>class_labels = [\n    'left_elbow',\n    'right_elbow',\n    'left_wrist',\n    'right_wrist',\n    'right_hip',\n]\n\nclass_sides = ['left', 'right', 'left', 'right', 'right']\n\ntransformed = transform(image=image, keypoints=keypoints, class_labels=class_labels, class_sides=class_sides)\ntransformed_class_sides = transformed['class_sides']\ntransformed_class_labels = transformed['class_labels']\ntransformed_keypoints = transformed['keypoints']\ntransformed_image = transformed['image']\n</code></pre> <p> Example input and output data for keypoints augmentation with two separate arguments for class labels</p> <p>Note</p> <p>Some augmentations may affect class labels and make them incorrect. For example, the <code>HorizontalFlip</code> augmentation mirrors the input image. When you apply that augmentation to keypoints that mark the side of body parts (left or right), those keypoints will point to the wrong side (since <code>left</code> on the mirrored image becomes <code>right</code>). So when you are creating an augmentation pipeline look carefully which augmentations could be applied to the input data.</p> <p> <code>HorizontalFlip</code> may make keypoints' labels incorrect</p>"},{"location":"getting_started/keypoints_augmentation/#examples","title":"Examples","text":"<ul> <li>Using Albumentations to augment keypoints</li> </ul>"},{"location":"getting_started/mask_augmentation/","title":"Mask augmentation for segmentation","text":"<p>For instance and semantic segmentation tasks, you need to augment both the input image and one or more output masks.</p> <p>Albumentations ensures that the input image and the output mask will receive the same set of augmentations with the same parameters.</p> <p>The process of augmenting images and masks looks very similar to the regular image-only augmentation.</p> <ol> <li>You import the required libraries.</li> <li>You define an augmentation pipeline.</li> <li>You read images and masks from the disk.</li> <li>You pass an image and one or more masks to the augmentation pipeline and receive augmented images and masks.</li> </ol>"},{"location":"getting_started/mask_augmentation/#steps-1-and-2-import-the-required-libraries-and-define-an-augmentation-pipeline","title":"Steps 1 and 2. Import the required libraries and define an augmentation pipeline.","text":"<p>Image augmentation for classification described Steps 1 and 2 in great detail. These are the same steps for the simultaneous augmentation of images and masks.</p> Python<pre><code>import albumentations as A\nimport cv2\n\ntransform = A.Compose([\n    A.RandomCrop(width=256, height=256),\n    A.HorizontalFlip(p=0.5),\n    A.RandomBrightnessContrast(p=0.2),\n])\n</code></pre>"},{"location":"getting_started/mask_augmentation/#step-3-read-images-and-masks-from-the-disk","title":"Step 3. Read images and masks from the disk.","text":"<ul> <li>Reading an image</li> </ul> Python<pre><code>image = cv2.imread(\"/path/to/image.jpg\")\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n</code></pre> <ul> <li>For semantic segmentation, you usually read one mask per image. Albumentations expects the mask to be a NumPy array. The height and width of the mask should have the same values as the height and width of the image.</li> </ul> Python<pre><code>mask = cv2.imread(\"/path/to/mask.png\")\n</code></pre> <ul> <li>For instance segmentation, you sometimes need to read multiple masks per image. Then you create a list that contains all the masks.</li> </ul> Python<pre><code>mask_1 = cv2.imread(\"/path/to/mask_1.png\")\nmask_2 = cv2.imread(\"/path/to/mask_2.png\")\nmask_3 = cv2.imread(\"/path/to/mask_3.png\")\nmasks = [mask_1, mask_2, mask_3]\n</code></pre> <p>Some datasets use other formats to store masks. For example, they can use Run-Length Encoding or Polygon coordinates. In that case, you need to convert a mask to a NumPy before augmenting it with Albumentations. Often dataset authors provide special libraries and tools to simplify the conversion.</p>"},{"location":"getting_started/mask_augmentation/#step-4-pass-image-and-masks-to-the-augmentation-pipeline-and-receive-augmented-images-and-masks","title":"Step 4. Pass image and masks to the augmentation pipeline and receive augmented images and masks.","text":"<p>If the image has one associated mask, you need to call <code>transform</code> with two arguments: <code>image</code> and <code>mask</code>. In <code>image</code> you should pass the input image, in <code>mask</code> you should pass the output mask. <code>transform</code> will return a dictionary with two keys: <code>image</code> will contain the augmented image, and <code>mask</code> will contain the augmented mask.</p> Python<pre><code>transformed = transform(image=image, mask=mask)\ntransformed_image = transformed['image']\ntransformed_mask = transformed['mask']\n</code></pre> <p></p> <p>An image and a mask before and after augmentation. Inria Aerial Image Labeling dataset contains aerial photos as well as their segmentation masks. Each pixel of the mask is marked as 1 if the pixel belongs to the class <code>building</code> and 0 otherwise.</p> <p>If the image has multiple associated masks, you should use the <code>masks</code> argument instead of <code>mask</code>. In <code>masks</code> you should pass a list of masks.</p> Python<pre><code>transformed = transform(image=image, masks=masks)\ntransformed_image = transformed['image']\ntransformed_masks = transformed['masks']\n</code></pre>"},{"location":"getting_started/mask_augmentation/#examples","title":"Examples","text":"<ul> <li>Using Albumentations for a semantic segmentation task</li> <li>Showcase. Cool augmentation examples on diverse set of images from various real-world tasks.</li> </ul>"},{"location":"getting_started/setting_probabilities/","title":"Setting probabilities for transforms in an augmentation pipeline","text":"<p>Each augmentation in Albumentations has a parameter named <code>p</code> that sets the probability of applying that augmentation to input data.</p> <p>The following augmentations have the default value of <code>p</code> set 1 (which means that by default they will be applied to each instance of input data): <code>Compose</code>, <code>ReplayCompose</code>, <code>CenterCrop</code>, <code>Crop</code>, <code>CropNonEmptyMaskIfExists</code>, <code>FromFloat</code>, <code>CenterCrop</code>, <code>Crop</code>, <code>CropNonEmptyMaskIfExists</code>, <code>FromFloat</code>, <code>IAACropAndPad</code>, <code>Lambda</code>, <code>LongestMaxSize</code>, <code>Normalize</code>, <code>PadIfNeeded</code>, <code>RandomCrop</code>, <code>RandomCropNearBBox</code>, <code>RandomResizedCrop</code>, <code>RandomSizedBBoxSafeCrop</code>, <code>RandomSizedCrop</code>, <code>Resize</code>, <code>SmallestMaxSize</code>, <code>ToFloat</code>.</p> <p>All other augmentations have the default value of <code>p</code> set 0.5, which means that by default, they will be applied to 50% of instances of input data.</p> <p>Let's take a look at the example:</p> Python<pre><code>import albumentations as A\nimport cv2\n\np1 = 0.95\np2 = 0.85\np3 = 0.75\n\n\ntransform = A.Compose([\n    A.RandomRotate90(p=p2),\n    A.OneOf([\n        A.IAAAdditiveGaussianNoise(p=0.9),\n        A.GaussNoise(p=0.6),\n    ], p=p3)\n], p=p1)\n\nimage = cv2.imread('some/image.jpg')\nimage = cv2.cvtColor(cv2.COLOR_BGR2RGB)\n\ntransformed = transform(image=image)\ntransformed_image = transformed['image']\n</code></pre> <p>We declare an augmentation pipeline. In this pipeline, we use three placeholder values to set probabilities: <code>p1</code>, <code>p2</code>, and <code>p3</code>. Let's take a closer look at them.</p>"},{"location":"getting_started/setting_probabilities/#p1","title":"<code>p1</code>","text":"<p><code>p1</code> sets the probability that the augmentation pipeline will apply augmentations at all.</p> <p>If <code>p1</code> is set to 0, then augmentations inside <code>Compose</code> will never be applied to the input image, so the augmentation pipeline will always return the input image unchanged.</p> <p>If <code>p1</code> is set to 1, then all augmentations inside <code>Compose</code> will have a chance to be applied. The example above contains two augmentations inside <code>Compose</code>: <code>RandomRotate90</code> and the <code>OneOf</code> block with two child augmentations (more on their probabilities later). Any value of <code>p1</code> between 0 and 1 means that augmentations inside <code>Compose</code> could be applied with the probability between 0 and 100%.</p> <p>If <code>p1</code> equals to 1 or <code>p1</code> is less than 1, but the random generator decides to apply augmentations inside Compose probabilities <code>p2</code> and <code>p3</code> come into play.</p>"},{"location":"getting_started/setting_probabilities/#p2","title":"<code>p2</code>","text":"<p>Each augmentation inside <code>Compose</code> has a probability of being applied. <code>p2</code> sets the probability of applying <code>RandomRotate90</code>. In the example above, <code>p2</code> equals 0.85, so <code>RandomRotate90</code> has an 85% chance to be applied to the input image.</p>"},{"location":"getting_started/setting_probabilities/#p3","title":"<code>p3</code>","text":"<p><code>p3</code> sets the probability of applying the <code>OneOf</code> block. If the random generator decided to apply <code>RandomRotate90</code> at the previous step, then <code>OneOf</code> will receive data augmented by it. If the random generator decided not to apply <code>RandomRotate90</code> then <code>OneOf</code> will receive the input data (that was passed to <code>Compose</code>) since <code>RandomRotate90</code> is skipped.</p> <p>The <code>OneOf</code>block applies one of the augmentations inside it. That means that if the random generator chooses to apply <code>OneOf</code> then one child augmentation from it will be applied to the input data.</p> <p>To decide which augmentation within the <code>OneOf</code> block is used, Albumentations uses the following rule:</p> <p>The <code>OneOf</code> block normalizes the probabilities of all augmentations inside it, so their probabilities sum up to 1. Next, <code>OneOf</code> chooses one of the augmentations inside it with a chance defined by its normalized probability and applies it to the input data. In the example above <code>IAAAdditiveGaussianNoise</code> has probability 0.9 and <code>GaussNoise</code> probability 0.6. After normalization, they become 0.6 and 0.4. Which means that <code>OneOf</code> will decide that it should use <code>IAAAdditiveGaussianNoise</code> with probability 0.6 and <code>GaussNoise</code> otherwise.</p>"},{"location":"getting_started/setting_probabilities/#example-calculations","title":"Example calculations","text":"<p>Thus, each augmentation in the example above will be applied with the probability:</p> <ul> <li><code>RandomRotate90</code>: <code>p1</code> * <code>p2</code></li> <li><code>IAAAdditiveGaussianNoise</code>: <code>p1</code> * <code>p3</code> * (0.9 / (0.9 + 0.6))</li> <li><code>GaussianNoise</code>: <code>p1</code> * <code>p3</code> * (0.6 / (0.9 + 0.6))</li> </ul>"},{"location":"getting_started/simultaneous_augmentation/","title":"Simultaneous augmentation of multiple targets: masks, bounding boxes, keypoints","text":"<p>Albumentations can apply the same set of transformations to the input images and all the targets that are passed to <code>transform</code>: masks, bounding boxes, and keypoints.</p> <p>Please refer to articles Image augmentation for classification, Mask augmentation for segmentation, Bounding boxes augmentation for object detection, and Keypoints augmentation for the detailed description of each data type.</p> <p>Note</p> <p>Some transforms in Albumentation don't support bounding boxes or keypoints. If you try to use them you will get an exception. Please refer to this article to check whether a transform can augment bounding boxes and keypoints.</p> <p>Below is an example, how you can simultaneously augment the input image, mask, bounding boxes with their labels, and keypoints with their labels. Note that the only required argument to <code>transform</code> is <code>image</code>; all other arguments are optional, and you can combine them in any way.</p>"},{"location":"getting_started/simultaneous_augmentation/#step-1-define-compose-with-parameters-that-specify-formats-for-bounding-boxes-and-keypoints","title":"Step 1. Define <code>Compose</code> with parameters that specify formats for bounding boxes and keypoints.","text":"Python<pre><code>transform = A.Compose(\n  [A.RandomCrop(width=330, height=330), A.RandomBrightnessContrast(p=0.2)],\n  bbox_params=A.BboxParams(format=\"coco\", label_fields=[\"bbox_classes\"]),\n  keypoint_params=A.KeypointParams(format=\"xy\", label_fields=[\"keypoints_classes\"]),\n)\n</code></pre>"},{"location":"getting_started/simultaneous_augmentation/#step-2-load-all-required-data-from-the-disk","title":"Step 2. Load all required data from the disk","text":"<p>Please refer to articles Image augmentation for classification, Mask augmentation for segmentation, Bounding boxes augmentation for object detection, and Keypoints augmentation for more information about loading the input data.</p> <p>For example, here is an image from the COCO dataset. that has one associated mask, one bounding box with the class label <code>person</code>, and five keypoints that define body parts.</p> <p> An example image with mask, bounding boxes and keypoints</p>"},{"location":"getting_started/simultaneous_augmentation/#step-3-pass-all-targets-to-transform-and-receive-their-augmented-versions","title":"Step 3. Pass all targets to <code>transform</code> and receive their augmented versions","text":"Python<pre><code>transformed = transform(\n  image=img,\n  mask=mask,\n  bboxes=bboxes,\n  bbox_classes=bbox_classes,\n  keypoints=keypoints,\n  keypoints_classes=keypoints_classes,\n)\ntransformed_image = transformed[\"image\"]\ntransformed_mask = transformed[\"mask\"]\ntransformed_bboxes = transformed[\"bboxes\"]\ntransformed_bbox_classes = transformed[\"bbox_classes\"]\ntransformed_keypoints = transformed[\"keypoints\"]\ntransformed_keypoints_classes = transformed[\"keypoints_classes\"]\n</code></pre> <p> The augmented version of the image and its targets</p>"},{"location":"getting_started/simultaneous_augmentation/#examples","title":"Examples","text":"<ul> <li>Showcase. Cool augmentation examples on diverse set of images from various real-world tasks.</li> </ul>"},{"location":"getting_started/transforms_and_targets/","title":"A list of transforms and their supported targets","text":"<p>We can split all transforms into two groups: pixel-level transforms, and spatial-level transforms. Pixel-level transforms will change just an input image and will leave any additional targets such as masks, bounding boxes, and keypoints unchanged. Spatial-level transforms will simultaneously change both an input image as well as additional targets such as masks, bounding boxes, and keypoints. For the additional information, please refer to this section of \"Why you need a dedicated library for image augmentation\".</p>"},{"location":"getting_started/transforms_and_targets/#pixel-level-transforms","title":"Pixel-level transforms","text":"<p>Here is a list of all available pixel-level transforms. You can apply a pixel-level transform to any target, and under the hood, the transform will change only the input image and return any other input targets such as masks, bounding boxes, or keypoints unchanged.</p> <ul> <li>AdvancedBlur</li> <li>Blur</li> <li>CLAHE</li> <li>ChannelDropout</li> <li>ChannelShuffle</li> <li>ChromaticAberration</li> <li>ColorJitter</li> <li>Defocus</li> <li>Downscale</li> <li>Emboss</li> <li>Equalize</li> <li>FDA</li> <li>FancyPCA</li> <li>FromFloat</li> <li>GaussNoise</li> <li>GaussianBlur</li> <li>GlassBlur</li> <li>HistogramMatching</li> <li>HueSaturationValue</li> <li>ISONoise</li> <li>ImageCompression</li> <li>InvertImg</li> <li>MedianBlur</li> <li>MotionBlur</li> <li>MultiplicativeNoise</li> <li>Normalize</li> <li>PixelDistributionAdaptation</li> <li>Posterize</li> <li>RGBShift</li> <li>RandomBrightnessContrast</li> <li>RandomFog</li> <li>RandomGamma</li> <li>RandomGravel</li> <li>RandomRain</li> <li>RandomShadow</li> <li>RandomSnow</li> <li>RandomSunFlare</li> <li>RandomToneCurve</li> <li>RingingOvershoot</li> <li>Sharpen</li> <li>Solarize</li> <li>Spatter</li> <li>Superpixels</li> <li>TemplateTransform</li> <li>ToFloat</li> <li>ToGray</li> <li>ToRGB</li> <li>ToSepia</li> <li>UnsharpMask</li> <li>ZoomBlur</li> </ul>"},{"location":"getting_started/transforms_and_targets/#spatial-level-transforms","title":"Spatial-level transforms","text":"<p>Here is a table with spatial-level transforms and targets they support. If you try to apply a spatial-level transform to an unsupported target, Albumentations will raise an error.</p> Transform Image Mask BBoxes Keypoints Global Label Affine \u2713 \u2713 \u2713 \u2713 BBoxSafeRandomCrop \u2713 \u2713 \u2713 CenterCrop \u2713 \u2713 \u2713 \u2713 CoarseDropout \u2713 \u2713 \u2713 Crop \u2713 \u2713 \u2713 \u2713 CropAndPad \u2713 \u2713 \u2713 \u2713 CropNonEmptyMaskIfExists \u2713 \u2713 \u2713 \u2713 ElasticTransform \u2713 \u2713 \u2713 Flip \u2713 \u2713 \u2713 \u2713 GridDistortion \u2713 \u2713 \u2713 GridDropout \u2713 \u2713 HorizontalFlip \u2713 \u2713 \u2713 \u2713 Lambda \u2713 \u2713 \u2713 \u2713 \u2713 LongestMaxSize \u2713 \u2713 \u2713 \u2713 MaskDropout \u2713 \u2713 MixUp \u2713 \u2713 \u2713 Morphological \u2713 \u2713 NoOp \u2713 \u2713 \u2713 \u2713 \u2713 OpticalDistortion \u2713 \u2713 \u2713 PadIfNeeded \u2713 \u2713 \u2713 \u2713 Perspective \u2713 \u2713 \u2713 \u2713 PiecewiseAffine \u2713 \u2713 \u2713 \u2713 PixelDropout \u2713 \u2713 RandomCrop \u2713 \u2713 \u2713 \u2713 RandomCropFromBorders \u2713 \u2713 \u2713 \u2713 RandomGridShuffle \u2713 \u2713 \u2713 RandomResizedCrop \u2713 \u2713 \u2713 \u2713 RandomRotate90 \u2713 \u2713 \u2713 \u2713 RandomScale \u2713 \u2713 \u2713 \u2713 RandomSizedBBoxSafeCrop \u2713 \u2713 \u2713 RandomSizedCrop \u2713 \u2713 \u2713 \u2713 Resize \u2713 \u2713 \u2713 \u2713 Rotate \u2713 \u2713 \u2713 \u2713 SafeRotate \u2713 \u2713 \u2713 \u2713 ShiftScaleRotate \u2713 \u2713 \u2713 \u2713 SmallestMaxSize \u2713 \u2713 \u2713 \u2713 Transpose \u2713 \u2713 \u2713 \u2713 VerticalFlip \u2713 \u2713 \u2713 \u2713 XYMasking \u2713 \u2713 \u2713"},{"location":"introduction/image_augmentation/","title":"What is image augmentation and how it can improve the performance of deep neural networks","text":"<p>Deep neural networks require a lot of training data to obtain good results and prevent overfitting. However, it is often very difficult to get enough training samples. Multiple reasons could make it very hard or even impossible to gather enough data:</p> <ul> <li> <p>To make a training dataset, you need to obtain images and then label them. For example, you need to assign correct class labels if you have an image classification task. For an object detection task, you need to draw bounding boxes around objects.  For a semantic segmentation task, you need to assign a correct class to each input image pixel. This process requires manual labor, and sometimes it could be very costly to label the training data. For example, to correctly label medical images, you need expensive domain experts.</p> </li> <li> <p>Sometimes even collecting training images could be hard. There are many legal restrictions for working with healthcare data, and obtaining it requires a lot of effort. Sometimes getting the training images is more feasible, but it will cost a lot of money. For example, to get satellite images, you need to pay a satellite operator to take those photos. To get images for road scene recognition, you need an operator that will drive a car and collect the required data.</p> </li> </ul>"},{"location":"introduction/image_augmentation/#image-augmentation-to-the-rescue","title":"Image augmentation to the rescue","text":"<p>Image augmentation is a process of creating new training examples from the existing ones. To make a new sample, you slightly change the original image. For instance, you could make a new image a little brighter; you could cut a piece from the original image; you could make a new image by mirroring the original one, etc.</p> <p>Here are some examples of transformations of the original image that will create a new training sample.</p> <p></p> <p>By applying those transformations to the original training dataset, you could create an almost infinite amount of new training samples.</p>"},{"location":"introduction/image_augmentation/#how-much-does-image-augmentation-improves-the-quality-and-performance-of-deep-neural-networks","title":"How much does image augmentation improves the quality and performance of deep neural networks","text":"<p>Basic augmentations techniques were used almost in all papers that describe the state-of-the-art models for image recognition.</p> <p>AlexNet was the first model that demonstrated exceptional capabilities of using deep neural networks for image recognition. For training, the authors used a set of basic image augmentation techniques. They resized original images to the fixed size of 256 by 256 pixels, and then they cropped patches of size 224 by 224 pixels as well as their horizontal reflections from those resized images. Also, they altered the intensities of the RGB channels in images.</p> <p>Successive state-of-the-art models such as Inception, ResNet, and EfficientNet also used image augmentation techniques for training.</p> <p>In 2018 Google published a paper about AutoAugment - an algorithm that automatically discovers the best set of augmentations for the dataset. They showed that a custom set of augmentations improves the performance of the model.</p> <p>Here is a comparison between a model that used only the base set of augmentations and a model that used a specific set of augmentations discovered by AutoAugment. The table shows Top-1 accuracy (%) on the ImageNet validation set; higher is better.</p> Model Base augmentations AutoAugment augmentations ResNet-50 76.3 77.6 ResNet-200 78.5 80.0 AmoebaNet-B (6,190) 82.2 82.8 AmoebaNet-C (6,228) 83.1 83.5 <p>The table demonstrates that a diverse set of image augmentations improves the performance of neural networks compared to a base set with only a few most popular transformation techniques.</p> <p>Augmentations help to fight overfitting and improve the performance of deep neural networks for computer vision tasks such as classification, segmentation, and object detection. The best part is that image augmentations libraries such as Albumentations make it possible to add image augmentations to any computer vision pipeline with minimal effort.</p>"},{"location":"introduction/why_albumentations/","title":"Why Albumentations","text":""},{"location":"introduction/why_albumentations/#a-single-interface-to-work-with-images-masks-bounding-boxes-and-key-points","title":"A single interface to work with images, masks, bounding boxes, and key points.","text":"<p>Albumentations provides a single interface to work with different computer vision tasks such as classification, semantic segmentation, instance segmentation, object detection, pose estimation, etc.</p>"},{"location":"introduction/why_albumentations/#battle-tested","title":"Battle-tested","text":"<p>The library is widely used in industry, deep learning research, machine learning competitions, and open source projects.</p>"},{"location":"introduction/why_albumentations/#high-performance","title":"High performance","text":"<p>Albumentations optimized for maximum speed and performance. Under the hood, the library uses highly optimized functions from OpenCV and NumPy for data processing. We have a regularly updated benchmark that compares the speed of popular image augmentations libraries for the most common image transformations. Albumentations demonstrates the best performance in most cases.</p>"},{"location":"introduction/why_albumentations/#diverse-set-of-supported-augmentations","title":"Diverse set of supported augmentations","text":"<p>Albumentations supports more than 60 different image augmentations.</p>"},{"location":"introduction/why_albumentations/#extensibility","title":"Extensibility","text":"<p>Albumentations allows to easily add new augmentations and use them in computer vision pipelines through a single interface along with built-in transformations.</p>"},{"location":"introduction/why_albumentations/#rigorous-testing","title":"Rigorous testing","text":"<p>Bugs in the augmentation pipeline could silently corrupt the input data. They can easily go unnoticed, but the performance of the models trained with incorrect data will degrade. Albumentations has an extensive test suite that helps to discover bugs during development.</p>"},{"location":"introduction/why_albumentations/#it-is-open-source-and-mit-licensed","title":"It is open source and MIT licensed","text":"<p>You can find the source code on GitHub.</p>"},{"location":"introduction/why_you_need_a_dedicated_library_for_image_augmentation/","title":"Why you need a dedicated library for image augmentation","text":"<p>At first glance, image augmentations look very simple; you apply basic transformations to an image: mirroring, cropping, changing brightness and contrast, etc.</p> <p>There are a lot of libraries that could do such image transformations. Here is an example of how you could use Pillow, a popular image processing library for Python, to make simple augmentations.</p> Python<pre><code>from PIL import Image, ImageEnhance\n\nimage = Image.open(\"parrot.jpg\")\n\nmirrored_image = image.transpose(Image.FLIP_LEFT_RIGHT)\n\nrotated_image = image.rotate(45)\n\nbrightness_enhancer = ImageEnhance.Brightness(image)\nbrighter_image = brightness_enhancer.enhance(factor=1.5)\n</code></pre> <p></p> <p>However, this approach has many limitations, and it doesn't handle all cases with image augmentation. An image augmentation library such as Albumentations gives you a lot of advantages.</p> <p>Here is a list of few pitfalls that augmentation libraries can handle very well.</p>"},{"location":"introduction/why_you_need_a_dedicated_library_for_image_augmentation/#the-need-to-apply-the-same-transform-to-an-image-and-for-labels-for-segmentation-object-detection-and-keypoint-detection-tasks","title":"The need to apply the same transform to an image and for labels for segmentation, object detection, and keypoint detection tasks.","text":"<p>For image classification, you need to modify only an input image and keep output labels intact because output labels are invariant to image modifications.</p> <p></p> <p>Note</p> <p>There are some exceptions to this rule. For example, an image could contain a cat and have an assigned label <code>cat</code>. During image augmentation, if you crop a part of an image that doesn't have a cat on it, then the output label <code>cat</code> becomes wrong and misleading. Usually, you deal with those situations by deciding which augmentations you could apply to a dataset without risking to have problems with incorrect labels.</p> <p></p> <p>For segmentation, you need to apply some transformations both to an input image and an output mask. You also have to use the same parameters both for the image transformation and the mask transformation.</p> <p>Let's look at an example of a semantic segmentation task from Inria Aerial Image Labeling Dataset. The dataset contains aerial photos as well as masks for those photos. Each pixel of the mask is marked either as 1 if the pixel belongs to the class <code>building</code> and 0 otherwise.</p> <p>There are two types of image augmentations: pixel-level augmentations and spatial-level augmentations.</p> <p>Pixel-level augmentations change the values of pixels of the original image, but they don't change the output mask. Image transformations such as changing brightness or contrast of adjusting values of the RGB-palette of the image are pixel-level augmentations.</p> <p> We modify the input image by adjusting its brightness, but we keep the output mask intact.</p> <p>On the contrary, spatial-level augmentations change both the image and the mask. When you apply image transformations such as mirroring or rotation or cropping a part of the input image, you also need to apply the same transformation to the output label to preserve its correctness.</p> <p> We rotate both the input image and the output mask. We use the same set of transformations with the same parameters, both for the image and the mask.</p> <p>The same is true for object detection tasks. For pixel-level augmentations, you only need to change the input image. With spatial-level augmentations, you need to apply the same transformation not only to the image but for bounding boxes coordinates as well. After applying spatial-level augmentations, you need to update coordinates of bounding boxes to represent the correct locations of objects on the augmented image.</p> <p> Pixel-level augmentations such as brightness adjustment change only the input image but not the coordinates of bounding boxes. Spatial-level augmentations such as mirroring and cropping a part of the image change both the input image and the bounding boxes' coordinates.</p> <p>Albumentations knows how to correctly apply transformation both to the input data as well as the output labels.</p>"},{"location":"introduction/why_you_need_a_dedicated_library_for_image_augmentation/#working-with-probabilities","title":"Working with probabilities","text":"<p>During training, you usually want to apply augmentations with a probability of less than 100% since you also need to have the original images in your training pipeline. Also, it is beneficial to be able to control the magnitude of image augmentation, how much does the augmentation change the original image. If the original dataset is large, you could apply only the basic augmentations with probability around 10-30% and with a small magnitude of changes. If the dataset is small, you need to act more aggressively with augmentations to prevent overfitting of neural networks, so you usually need to increase the probability of applying each augmentation to 40-50% and increase the magnitude of changes the augmentation makes to the image.</p> <p>Image augmentation libraries allow you to set the required probabilities and the magnitude of values for each transformation.</p>"},{"location":"introduction/why_you_need_a_dedicated_library_for_image_augmentation/#declarative-definition-of-the-augmentation-pipeline-and-unified-interface","title":"Declarative definition of the augmentation pipeline and unified interface","text":"<p>Usually, you want to apply not a single augmentation, but a set of augmentations with specific parameters such as probability and magnitude of changes. Augmentation libraries allow you to declare such a pipeline in a single place and then use it for image transformation through a unified interface. Some libraries can store and load transformation parameters to formats such as JSON, YAML, etc.</p> <p>Here is an example definition of an augmentation pipeline. This pipeline will first crop a random 512px x 512px part of the input image. Then with probability 30%, it will randomly change brightness and contrast of that crop. Finally, with probability 50%, it will horizontally flip the resulting image.</p> Python<pre><code>import albumentations as A\n\ntransform = A.Compose([\n    A.RandomCrop(512, 512),\n    A.RandomBrightnessContrast(p=0.3),\n    A.HorizontalFlip(p=0.5),\n])\n</code></pre>"},{"location":"introduction/why_you_need_a_dedicated_library_for_image_augmentation/#rigorous-testing","title":"Rigorous testing","text":"<p>A bug in the augmentation pipeline could easily go unnoticed. A buggy pipeline could silently corrupt input data. There won't be any exceptions and code failures, but the performance of trained neural networks will degrade because they received a garbage input during training. Augmentation libraries usually have large test suites that capture regressions during development. Also large user base helps to find unnoticed bugs and report them to developers.</p>"}]}